<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>理解c/c++ Volatile关键字</title>
    <url>/2022/11/15/Volatile/</url>
    <content><![CDATA[<p>网络上对于volatile的解读众说纷纭，而且其中较多的是java内存模型。</p>
<p>本篇文章将基于自己的学习和实验，针对C/C++语言嵌入式开发场景进行volatile关键字的分析</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>volatile 关键字是 C /C++ 编程语言的一部分，作为一种类型修饰符。我将其作用总结为<em><strong>告诉编译器禁止优化其所修饰对象的读写访存操作及指令顺序，保证变量的可见性</strong></em></p>
<blockquote>
<p>可见性：当一个线程修改了共享变量后，其他线程能够立即得知这个修改。</p>
<p>有序性：程序执行的顺序按照代码的先后顺序执行。</p>
<p>原子性：一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行。</p>
</blockquote>
<p>在《程序员的自我修养》这本书中讲到，volatile基本可以做到两个事情：</p>
<ol>
<li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回</li>
<li>阻止编译器调整操作volatile变量的指令顺序</li>
</ol>
<p>对于第一个作用volatile是可以很好的做到，而对于第二个作用编译器层面可以保证指令有序但是我们无法阻止cpu动态调整顺序。真正保证有序性是需要通过内存屏障完成的，而volatile并没有内存屏障的功能，gcc 提供了一个内联函数 <em><strong>asm volatile (“” : : : “memory”</strong>)</em> 编译器屏障，具体平台相关内存屏障需要到具体的结构平台去参考</p>
<h1 id="理解volatile"><a href="#理解volatile" class="headerlink" title="理解volatile"></a>理解volatile</h1><blockquote>
<p>Collins对于Volatile释义：A situation that is volatile is <strong>likely</strong> to change <strong>suddenly</strong> and <strong>unexpectedly</strong>.</p>
</blockquote>
<p><strong>volatile</strong> 本身释义为 <strong>易失的、易变的</strong></p>
<p>对于用volatile所修饰的对象，在其自身的含义基础上，有三个副词可以很好的对其性质进行诠释：</p>
<ul>
<li><p>likely   可能地，指对象的状态可能变化、也可能不变保持状态，强调结果；</p>
</li>
<li><p>suddenly:   突然地，指对象状态的瞬时变化，强调过程；</p>
</li>
<li><p>unexpectedly:  不可预期地，指对象变化的时间结果都不可预期；</p>
</li>
</ul>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>根据含义性质，在嵌入式开发中以下三种场景是一定要考虑使用volatile关键字的（大多数情况一定使用！！！）</p>
<ol>
<li>多线程任务读写同一全局变量，</li>
<li>中断服务程序修改的全局变量</li>
<li>内存映射外设寄存器</li>
</ol>
<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h2 id="中断场景"><a href="#中断场景" class="headerlink" title="中断场景"></a>中断场景</h2><p>下面一段代码，我们所期待的结果是主程序运行，直到crtl+c按键按下程序退出，代码编译执行之后并不是我们所预期的样子。如果sig_done变量不通过volatile修饰程序将永远不会退出，而volatile关键字很好的解决了这一个问题</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> sig_done = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//static volatile bool sig_done = false;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(sig == SIGINT)</span><br><span class="line">    ┆   sig_done = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main start, press ctrl+c go on\n"</span>);</span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line">    <span class="keyword">while</span>(!sig_done) {</span><br><span class="line">    }   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main exit\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令</span></span><br><span class="line">gcc main.c <span class="number">-02</span></span><br><span class="line">objdump -d a.out &gt; a.s</span><br></pre></td></tr></tbody></table></figure>

<p>通过反汇编比较两个程序的异同（左侧volatile，右侧无volatile）</p>
<p><img src="/images/coding/meld.png" alt="image"></p>
<p>没有voaltile的while实现方式为：</p>
<ol>
<li>比较rip寄存器+0x2f65地址处的值（sig_done）与 0 是否相等</li>
<li>不相等跳转到main+0x30即上一条指令处</li>
<li>跳转</li>
</ol>
<p>有volatile的while实现方式：</p>
<ol>
<li><p>nopl (%rax) 编译器开启优化后使指令按字对齐,减少取指令的时钟周期。</p>
</li>
<li><p>将 rip寄存器+0x2f65地址处的值放到eax寄存器中</p>
<blockquote>
<p>movzbl指令负责拷贝一个字节，并用0填充其目的操作数中的其余各位，这种扩展方式叫“零扩展”。</p>
<p>movsbl指令负责拷贝一个字节，并用源操作数的最高位填充其目的操作数中的其余各位，这种扩展方式叫“符号扩展”。</p>
</blockquote>
</li>
<li><p>test   %al,%al 对eax寄存器低位逻辑与</p>
<blockquote>
<p>Test命令：将两个操作数进行逻辑与运算，并根据运算结果设置相关的标志位（ze: zero flag）。但是，Test命令的两个操作数不会被改变。运算结果在设置过相关标记位后会被丢弃。</p>
</blockquote>
</li>
<li><p>je   如果ZF（零标志位）=1，零标志位为1（真值）说明结果为0，则转到label所指的指令语句；否则跳过这条语句，执行下条语句</p>
</li>
</ol>
<h2 id="多线程场景"><a href="#多线程场景" class="headerlink" title="多线程场景"></a>多线程场景</h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> mstop = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//static volatile bool mstop = true;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">first_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s start\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">while</span>(mstop) {</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s exit\n"</span>, __func__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">second_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s start\n"</span>, __func__);</span><br><span class="line">    mstop = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s exit\n"</span>, __func__);</span><br><span class="line">}                                                                                                                                                                     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::thread fthread{first_thread};</span><br><span class="line">    std::thread sthread{second_thread};</span><br><span class="line">    fthread.<span class="built_in">join</span>();</span><br><span class="line">	sthread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="外设寄存器"><a href="#外设寄存器" class="headerlink" title="外设寄存器"></a>外设寄存器</h2><p>对于外设通常设置有状态寄存器，我们可以通过循环读取状态寄存器的值来查看对应外设的状态。对于如下示例，如果没有使用volatile关键字，编译器可能生成的代码是读取一个固定地址的值而不会每次都从主存中读取新的值（或者读取n次状态，生成的代码只读取了一次，然后使用n次相同的值）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//设置寄存器</span></span><br><span class="line">*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *) STATUS_BASE_ADDR = <span class="number">1</span> &lt;&lt; <span class="number">24</span>; </span><br><span class="line"><span class="comment">//读寄存器</span></span><br><span class="line"><span class="keyword">while</span>(!(*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *) STATUS_BASE_ADDR)) {</span><br><span class="line">    <span class="comment">// do action</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h1><p>该部分不是volatile的使用，而是对内屏屏障的理解</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mp3decoder.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mp3decoder</span> :</span> public decoderImp </span><br><span class="line">{</span><br><span class="line">    public:</span><br><span class="line">    	<span class="type">static</span> mp3decoder* <span class="title function_">getInstance</span><span class="params">()</span>;</span><br><span class="line">    private:</span><br><span class="line">    	mp3decoder();</span><br><span class="line">    	~mp3decoder();</span><br><span class="line">    	<span class="type">static</span> mp3decoder* mdecoder;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//mp3decoder.cpp</span></span><br><span class="line"><span class="comment">//线程不安全，适用于单线程</span></span><br><span class="line">mp3decoder* mp3decoder::mdecoder = <span class="literal">NULL</span>;</span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全，但锁的代价太高</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全，锁的代价太高</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">    unlock();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Double-Checked Locking Pattern (DCLP 双检查锁)，指令重排序reorder不安全</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">        lock();</span><br><span class="line">    	<span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">       		mdecoder = new mp3decoder();</span><br><span class="line">         unlock();</span><br><span class="line">    	<span class="keyword">return</span> mdecoder;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存屏障</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">    	<span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">            mp3decoder *tmp = new mp3decoder();</span><br><span class="line">            MemoryBarrier();</span><br><span class="line">            mdecoder = tmp;</span><br><span class="line">        }</span><br><span class="line">    	<span class="keyword">return</span> mdecoder;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// mdecoder = new mp3decoder()在cpu层面动作：</span></span><br><span class="line"><span class="comment">// 1. 分配内存</span></span><br><span class="line"><span class="comment">// 2. 调用构造函数</span></span><br><span class="line"><span class="comment">// 3. 将内存地址赋值给mdecoder指针</span></span><br><span class="line"><span class="comment">// 由于2、3对于编译器来讲是有可能进行优化的，即先将指针赋值再调用构造函数，导致线程不安全！！</span></span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>参考文章：</p>
<ul>
<li><a href="https://barrgroup.com/embedded-systems/how-to/c-volatile-keyword">How to Use C’s volatile Keyword</a></li>
<li><a href="https://barrgroup.com/tech-talks/volatile-c">Pro Tips for Using C’s volatile Keyword</a></li>
<li><a href="https://liam.page/2018/01/18/volatile-in-C-and-Cpp/">谈谈 c / c++ 中的volatile</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello New World</title>
    <url>/2022/08/22/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Be all you can be!</p>
</blockquote>
<p>Hello World 是程序员进入编程世界后看到的第一道风景，我也十分乐意这作为第一篇博文的标题，对我来讲可能是：你好新世界！</p>
<p>笔者是一名嵌入式软件工程师，未来更多的内容将会是关于Linux、Android等相关内容，编程语言方面将会是以C / C++为主。做这个博客有三个目的：</p>
<ol>
<li>记录自己在工作中遇到的问题及相关解决办法。帮助自己积累调试经验同时帮助其他可能遇到同样问题的朋友，避免踩很多坑；</li>
<li>总结自己近期学到的新的知识和内容。这部分不一定是最全面的但对于处于相同阶段的我们一定是最实用的，后面再不断的完善更新；</li>
<li>最后可能就是简单的记录并安利一些实用的工具或者比较好的文章，能够以通俗的语言帮助我们理解某一个点或者看清楚某一个面。</li>
</ol>
<p>目前我只搭建了主页基础模块，后面随着文章的不断输出也会添砖加瓦的。我也希望后续能写一些读书笔记或者生活经验来做记录做分享！博客更新频率暂定1~2周至少一篇内容也一定是和工作生活相关的。如果有错误还请指正共同进步呀<span class="github-emoji" style="display:inline;vertical-align:middle"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>!</p>
<p align="right">2022-8-22/23.38</p>

<p align="right">Lee</p>

]]></content>
      <categories>
        <category>Personal</category>
      </categories>
      <tags>
        <tag>开篇</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Ubuntu虚拟机</title>
    <url>/2022/10/22/ubuntu-create/</url>
    <content><![CDATA[<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><p>linus自传《只是为了好玩》中这样定义：</p>
<ul>
<li><p>类Unix操作系统</p>
</li>
<li><p>开放源代码方式协作开发</p>
</li>
<li><p>采用GPL通用许可证维权</p>
</li>
<li><p>主要用于超级电脑、企业级服务器、嵌入式设备等</p>
</li>
</ul>
<h1 id="Ubuntu-简介"><a href="#Ubuntu-简介" class="headerlink" title="Ubuntu 简介"></a>Ubuntu 简介</h1><ul>
<li>桌面应用为主的Linux操作系统</li>
<li>操作简单、方便使用</li>
<li>系统安全性高，默认user权限登录</li>
<li>Ubuntu中文网站：<a href="http://www.wubantu.co/">http://www.wubantu.co</a></li>
<li>Ubuntu中文社区：<a href="http://www.ubuntu.org.cn/">http://www.ubuntu.org.cn</a></li>
<li>Ubuntu技术：<a href="http://wiki.ubuntu.org.cn/">http://wiki.ubuntu.org.cn</a></li>
</ul>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul>
<li>物理主机</li>
<li>iso镜像</li>
<li>vmware / VirtualBox</li>
</ul>
<p>网盘中我准备了ubuntu20.04.4-iso、ubuntu16.04.7-iso、Vmware-16.2.3安装包及密钥和一份linux命令大全！</p>
<p>密钥对于不同版本可能有差异可以都进行尝试，其只是对于个人学习使用，建议购买正版！</p>
<p>同时附上相关官网链接：</p>
<ul>
<li>ubuntu各版本镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/</a></li>
<li>vmware官网：<a href="https://www.vmware.com/cn/products/workstation-pro.html">https://www.vmware.com/cn/products/workstation-pro.html</a></li>
<li>VirtualBox：<a href="https://www.virtualbox.org/">https://www.virtualbox.org</a></li>
<li>资源网盘链接：<a href="https://pan.baidu.com/s/18vxScuvFp2Vf4g28nRSC5w">https://pan.baidu.com/s/18vxScuvFp2Vf4g28nRSC5w</a><br>提取码：f8uo</li>
</ul>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>参考视频：<a href="https://www.bilibili.com/video/BV1hd4y127HY">https://www.bilibili.com/video/BV1hd4y127HY</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>搭建虚拟机</category>
      </categories>
  </entry>
  <entry>
    <title>init.rc语法及解析</title>
    <url>/2022/11/16/init.rc/</url>
    <content><![CDATA[<p>在linux设备上输入“pstree”命令我们便会看到一棵进程树，不同状态不同设备树上进程名字进程号可能不完全一致，但进程号pid=1的进程一定是init进程！对于Android系统来讲，其实际是运行于Linux内核之上的一系列“服务进程”，而这些服务进程的“老祖宗”就是init，它是Android中第一个被启动的进程，所有服务都是通过解析init.rc文件得到的（部分可以执行程序通过init.d/文件夹下的脚本启动）</p>
<p>本篇文章将对init.rc文件语法进行解析</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>查看andriod源码：<a href="http://androidxref.com/">http://androidxref.com/</a></p>
</blockquote>
<p>init.rc是系统启动的第一个程序所加载的语法文件。init.rc文件是以“块”(section)为单位服务的，一个“块”(section)可以包含多行，而一行中包含多个tokens(符号)。“块”(section)分成两大类：一类称为”动作(action)”，另一类称为“服务(service)”。而一个init.rc脚本由四个类型的声明组成：</p>
<ol>
<li>动作 ：Actions，以关键字“on”开始</li>
<li>命令 ：Commands，以关键字“start”“restart”“stop”开始</li>
<li>服务 ：Services</li>
<li>选项 ：Options</li>
</ol>
<h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><p>Actions就是响应某个事件的过程。如下所示当满足trigger触发条件时依次执行Commands命令。源码会依次将这些命令添加到“命令执行队列尾部”，系统对这些命令顺序执行。所以服务启动的根本就是on类型的section被执行的过程</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">on &lt;trigger&gt;        //触发条件</span><br><span class="line">    &lt;command1&gt;      //命令1</span><br><span class="line">    &lt;command2&gt;      //命令2</span><br><span class="line">    &lt;command3&gt;      //命令3</span><br></pre></td></tr></tbody></table></figure>

<p>对于trigger（触发器）来讲，常见的有两种形式：</p>
<ol>
<li>单纯的字符串。例如：on boot</li>
<li>键值匹配，格式为“ on property <key> = <value> ”。例如：on property:init.svc.wifi = stopped</value></key></li>
</ol>
<p>此外还有两种形式：</p>
<ol>
<li>device-added/removed-<patch> 当设备节点添加/删除时触发此事件</patch></li>
<li>sevice-exited-<name> 当指定服务<name> 存在时触发</name></name></li>
</ol>
<h2 id="Actions解析后执行顺序"><a href="#Actions解析后执行顺序" class="headerlink" title="Actions解析后执行顺序"></a>Actions解析后执行顺序</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">on early-init           #在初始化早期阶段触发</span><br><span class="line">on init                 #初始化阶段触发。这里会执行完属性服务，接下来就可以设置属性了</span><br><span class="line">on late-init            #在初始化晚期触发。在这里会通过trigger来执行其他的action,以下均是</span><br><span class="line">on early-fs</span><br><span class="line">on fs</span><br><span class="line">on post-fs</span><br><span class="line">on post-fs-data</span><br><span class="line">on firmware_mounts_complete</span><br><span class="line">on early-boot</span><br><span class="line">on boot`</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>start <service></service></td>
<td>启动一个服务，如果它没有处于运行状态的话</td>
</tr>
<tr>
<td>stop <service></service></td>
<td>停止一个服务，如果当前它处于运行状态的话</td>
</tr>
<tr>
<td>restart <service></service></td>
<td></td>
</tr>
<tr>
<td>setprop <name> <value></value></name></td>
<td>设置<name>的属性值为<value></value></name></td>
</tr>
<tr>
<td>trigger <event></event></td>
<td>触发一个事件</td>
</tr>
<tr>
<td>export <name> <value></value></name></td>
<td>设置<name>环境变量的值为<value>，全局有效</value></name></td>
</tr>
<tr>
<td>mount <type> <device> <dir> [<mountoption>]*</mountoption></dir></device></type></td>
<td>尝试在指定路径上挂载一个设备</td>
</tr>
</tbody></table>
<h1 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h1><p>实际上每一个service就是一个可执行程序，它们在特定选项的约束下是被init程序运行或者重启(service可以在配置中指定是否需要退出重启，这样当service出现异常crash时就可以有机会复原)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">        &lt;option&gt;</span><br><span class="line">        &lt;option&gt;</span><br><span class="line">        ...</span><br><span class="line"># &lt;name&gt;       service服务的名字</span><br><span class="line"># &lt;pathname&gt;   service路径，一般对应可执行程序或者脚本</span><br><span class="line"># &lt;argument&gt;   启动pathname下的service所需要的参数</span><br><span class="line"># &lt;option&gt;     service的约束项</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h1><table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>disable</td>
<td>隐式声明，默认不会自动启动该服务，需要显式调用</td>
</tr>
<tr>
<td>oneshot</td>
<td>字面意思一次性，即服务退出时，不要主动重启该服务</td>
</tr>
<tr>
<td>onrestart</td>
<td>当服务重启时，执行某些命令（需要理解）</td>
</tr>
<tr>
<td>class <name></name></td>
<td>指定该服务属于<name>class类，默认class名为default（注：同一个class所有服务必须是同时启动或停止）</name></td>
</tr>
<tr>
<td>socket <name> <type> <perm> [<user> [<group>] ]</group></user></perm></type></name></td>
<td>创建一个名为dev/socket/<name>的 socket，然后将它的fd值传给启动它的进，有效的<type>值包括dgram,stream 和seqpacket。ueser 和group 的默认值为0。</type></name></td>
</tr>
<tr>
<td>critical</td>
<td>表明这是对设备至关重要的服务；如果它在四分钟内退出超过四次，则设备将进入Recovery 模式</td>
</tr>
<tr>
<td>group <groupname> [<groupname>]*</groupname></groupname></td>
<td>在启动服务前将用户组切换至<groupname></groupname></td>
</tr>
<tr>
<td>setenv <name> <value></value></name></td>
<td>设置环境变量<name> 为值<value></value></name></td>
</tr>
</tbody></table>
<h1 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h1><ol>
<li>service和Actions都是有唯一的名字的。如果有重名的情况会作为错误忽略。</li>
<li>无论是动作还是服务，并不是按照文件的编排顺序执行的。</li>
<li>该文件中注释以“#”开始；反斜杠“\”在行尾表示下面一行是同一行</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * copy from http://androidxref.com/6.0.0_r5/xref/bootable/recovery/etc/init.rc</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import /init.recovery.${ro.hardware}.rc</span><br><span class="line"></span><br><span class="line">on early-init</span><br><span class="line">    start ueventd</span><br><span class="line">    start healthd</span><br><span class="line"></span><br><span class="line">on init</span><br><span class="line">    export PATH /sbin:/system/bin</span><br><span class="line">    export ANDROID_ROOT /system</span><br><span class="line">    export ANDROID_DATA /data</span><br><span class="line">    export EXTERNAL_STORAGE /sdcard</span><br><span class="line"></span><br><span class="line">    symlink /system/etc /etc</span><br><span class="line"></span><br><span class="line">    mkdir /sdcard</span><br><span class="line">    mkdir /system</span><br><span class="line">    mkdir /data</span><br><span class="line">    mkdir /cache</span><br><span class="line">    mkdir /sideload</span><br><span class="line">    mount tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line">    chown root shell /tmp</span><br><span class="line">    chmod 0775 /tmp</span><br><span class="line"></span><br><span class="line">    write /proc/sys/kernel/panic_on_oops 1</span><br><span class="line">    write /proc/sys/vm/max_map_count 1000000</span><br><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    mkdir /dev/usb-ffs 0770 shell shell</span><br><span class="line">    mkdir /dev/usb-ffs/adb 0770 shell shell</span><br><span class="line">    mount functionfs adb /dev/usb-ffs/adb uid=2000,gid=2000</span><br><span class="line"></span><br><span class="line">    write /sys/class/android_usb/android0/enable 0</span><br><span class="line">    write /sys/class/android_usb/android0/idVendor 18D1</span><br><span class="line">    write /sys/class/android_usb/android0/idProduct D001</span><br><span class="line">    write /sys/class/android_usb/android0/f_ffs/aliases adb</span><br><span class="line">    write /sys/class/android_usb/android0/functions adb</span><br><span class="line">    write /sys/class/android_usb/android0/iManufacturer ${ro.product.manufacturer}</span><br><span class="line">    write /sys/class/android_usb/android0/iProduct ${ro.product.model}</span><br><span class="line">    write /sys/class/android_usb/android0/iSerial ${ro.serialno}</span><br><span class="line"></span><br><span class="line">on boot</span><br><span class="line">    ifup lo</span><br><span class="line">    hostname localhost</span><br><span class="line">    domainname localdomain</span><br><span class="line"></span><br><span class="line">    class_start default</span><br><span class="line"></span><br><span class="line"># Load properties from /system/ + /factory after fs mount.</span><br><span class="line">on load_all_props_action</span><br><span class="line">    load_all_props</span><br><span class="line"></span><br><span class="line">on firmware_mounts_complete</span><br><span class="line">   rm /dev/.booting</span><br><span class="line"></span><br><span class="line"># Mount filesystems and start core system services.</span><br><span class="line">on late-init</span><br><span class="line">    trigger early-fs</span><br><span class="line">    trigger fs</span><br><span class="line">    trigger post-fs</span><br><span class="line">    trigger post-fs-data</span><br><span class="line"></span><br><span class="line">    # Load properties from /system/ + /factory after fs mount. Place</span><br><span class="line">    # this in another action so that the load will be scheduled after the prior</span><br><span class="line">    # issued fs triggers have completed.</span><br><span class="line">    trigger load_all_props_action</span><br><span class="line"></span><br><span class="line">    # Remove a file to wake up anything waiting for firmware</span><br><span class="line">    trigger firmware_mounts_complete</span><br><span class="line"></span><br><span class="line">    trigger early-boot</span><br><span class="line">    trigger boot</span><br><span class="line"></span><br><span class="line">on property:sys.powerctl=*</span><br><span class="line">   powerctl ${sys.powerctl}</span><br><span class="line"></span><br><span class="line">service ueventd /sbin/ueventd</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:ueventd:s0</span><br><span class="line"></span><br><span class="line">service healthd /sbin/healthd -r</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:healthd:s0</span><br><span class="line"></span><br><span class="line">service recovery /sbin/recovery</span><br><span class="line">    seclabel u:r:recovery:s0</span><br><span class="line"></span><br><span class="line">service adbd /sbin/adbd --root_seclabel=u:r:su:s0 --device_banner=recovery</span><br><span class="line">    disabled</span><br><span class="line">    socket adbd stream 660 system system</span><br><span class="line">    seclabel u:r:adbd:s0</span><br><span class="line"></span><br><span class="line"># Always start adbd on userdebug and eng builds</span><br><span class="line">on property:ro.debuggable=1</span><br><span class="line">    write /sys/class/android_usb/android0/enable 1</span><br><span class="line">    start adbd</span><br><span class="line"></span><br><span class="line"># Restart adbd so it can run as root</span><br><span class="line">on property:service.adb.root=1</span><br><span class="line">    write /sys/class/android_usb/android0/enable 0</span><br><span class="line">    restart adbd</span><br><span class="line">    write /sys/class/android_usb/android0/enable 1</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>Andriod</category>
      </categories>
  </entry>
  <entry>
    <title>ALSA</title>
    <url>/2023/04/11/Audio/Audio-Alsa/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>官网：<a href="https://www.alsa-project.org/wiki/Main_Page">https://www.alsa-project.org/wiki/Main_Page</a></p>
</blockquote>
<p>ALSA：Advanced Linux Sound Architecture，高级linux声音体系，它在Linux操作系统上提供了音频和MIDI（Musical Instrument Digital Interface，音乐设备数字化接口）的支持。</p>
<h1 id="ALSA设备文件结构"><a href="#ALSA设备文件结构" class="headerlink" title="ALSA设备文件结构"></a>ALSA设备文件结构</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># cd /dev/snd; ls -l;</span></span><br><span class="line"></span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">8</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">38</span> controlC0	 用于声卡的控制,例如通道选择,混音,麦克风的控制等 </span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">4</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">38</span> midiC0D0	 用于播放midi音频 </span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">7</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">39</span> pcmC0D0c	 用于录音的pcm设备 </span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">6</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">56</span> pcmC0D0p	 用于播放的pcm设备 </span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">3</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">38</span> seq		 音序器 </span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">2</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">38</span> timer	     定时器</span><br></pre></td></tr></tbody></table></figure>

<p>其中,C0D0代表的是声卡0中的设备0 ; pcmC0D0c最后一个c代表capture ; pcmC0D0p最后一个p代表playback。</p>
<h2 id="alsa相关函数及文件"><a href="#alsa相关函数及文件" class="headerlink" title="alsa相关函数及文件"></a>alsa相关函数及文件</h2><h3 id="函数及结构体"><a href="#函数及结构体" class="headerlink" title="函数及结构体"></a>函数及结构体</h3><ul>
<li>AVFrame    iFrame           存储非压缩的数据，输入</li>
<li>AVFrame    swapFrame   存储非压缩的数据，重采样</li>
<li>AVPack       oPacket          压缩即编码后的输入，输出</li>
</ul>
<ol>
<li><p>snd_pcm_hw_params_get_rate( )</p>
</li>
<li><p>snd_pcm_open( )</p>
<ul>
<li><p>snd_config_update_ref</p>
<p>这个函数作用是检查alsa配置文件是否发生了变化，包括文件名字和各个配置文件的内容是否修改，如果有修改，就重新加载配置文件树，刷新全局变量snd_config并增加一个snd_config的引用计数，调用snd_config_update_ref传入的top就是指向snd_config的指针，这个top当作参数传入snd_pcm_open_noupdate函数中。snd_config_unref接下来会减去snd_config的引用计数。</p>
<p>首先创建顶层配置节点，然后打开/usr/share/alsa/alsa.conf，加载文件内容到顶层配置节点上，然后遍历所有的hooks，调用snd_config_hooks加载所有hooks，并调用相关的hooks函数打开对应的plugin动态库</p>
</li>
<li><p>snd_pcm_open_noupdate</p>
</li>
</ul>
</li>
<li><p>avcodec_open2( )</p>
<ul>
<li><p>检测指定的codec和context里面的codec是否匹配。</p>
</li>
<li><p>分配空间。</p>
</li>
<li><p>检测codec各个参数合法性，并给某些字段赋初值。</p>
</li>
<li><p>调用codec的init初始化codec。</p>
</li>
<li><p>释放资源，返回。</p>
</li>
</ul>
</li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ol>
<li><p>参考网址 : <a href="https://www.cnblogs.com/lihaiping/p/alsaconfig.html">https://www.cnblogs.com/lihaiping/p/alsaconfig.html</a></p>
</li>
<li><p>配置文件的调用过程</p>
<p>alsa-lib库  :  alsa-lib-1.2.1.2/src/pcm/pcm.c</p>
<p>snd_pcm_open( ) 函数作为打开一个pcm的接口.  具体的调用过程是 :  static snd_pcm_open_noupdate —-&gt;  static snd_pcm_open_conf( )</p>
<p>解析asound.conf过程 : <a href="https://www.xuebuyuan.com/1043778.html">https://www.xuebuyuan.com/1043778.html</a></p>
</li>
<li><p>snd_pcm_open内部直接解析的是usr/share/alsa/alsa.conf, 在这个文件中决定了etc/asound.conf和/.asoundrc这两个文件要不要调用</p>
</li>
</ol>
<h3 id="3-3-音频设备的定义"><a href="#3-3-音频设备的定义" class="headerlink" title="3.3 音频设备的定义"></a>3.3 音频设备的定义</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#  文件定义位置 : /system/core/include/system/audio.h</span><br><span class="line">enum {</span><br><span class="line">    AUDIO_DEVICE_NONE                          = 0x0,</span><br><span class="line">    /* reserved bits */</span><br><span class="line">    AUDIO_DEVICE_BIT_IN                        = 0x80000000,</span><br><span class="line">    AUDIO_DEVICE_BIT_DEFAULT                   = 0x40000000,</span><br><span class="line">    /* output devices */</span><br><span class="line">    AUDIO_DEVICE_OUT_EARPIECE                  = 0x1,    // 听筒</span><br><span class="line">    AUDIO_DEVICE_OUT_SPEAKER                   = 0x2,    // 扬声器</span><br><span class="line">    AUDIO_DEVICE_OUT_WIRED_HEADSET             = 0x4,    // 线控耳机，可以通过耳机控制远端播放、暂停、音量调节等功能的耳机</span><br><span class="line">    AUDIO_DEVICE_OUT_WIRED_HEADPHONE           = 0x8,    // 普通耳机，只能听，不能操控播放</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_SCO             = 0x10,   // 单声道蓝牙耳机，十进制32</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET     = 0x20,   // 车载免提蓝牙设备，十进制64</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT      = 0x40,   // 立体声蓝牙耳机</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP            = 0x80,   // 十进制128</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES = 0x100,  // 十进制256</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER    = 0x200,  // 十进制512</span><br><span class="line">    AUDIO_DEVICE_OUT_AUX_DIGITAL               = 0x400,  // 十进制1024</span><br><span class="line">    AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET         = 0x800,  // 十进制2048</span><br><span class="line">    AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET         = 0x1000, // 十进制4096</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="alsa插件"><a href="#alsa插件" class="headerlink" title="alsa插件"></a>alsa插件</h1><blockquote>
<p>asound.conf配置 <a href="https://www.alsa-project.org/main/index.php/Asoundrc">https://www.alsa-project.org/main/index.php/Asoundrc</a></p>
<p>插件详解官网  <a href="https://www.alsa-project.org/alsa-doc/alsa-lib/pcm_plugins.html">https://www.alsa-project.org/alsa-doc/alsa-lib/pcm_plugins.html</a></p>
</blockquote>
<ol>
<li>生成alsa配置文件 : alsactl store -f a.conf</li>
<li>对于耳机的controls需要指定-c 1,默认走的是card 0</li>
<li>播放音频的命令 arecord -D usbheadsetC -d 5 -f cd -r 48000 -c 2 -t wav test.wav</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//查看控件</span></span><br><span class="line"><span class="meta"># amixer -c 1 controls </span></span><br><span class="line">numid=<span class="number">3</span>,iface=MIXER,name=<span class="string">'PCM Playback Switch'</span></span><br><span class="line">numid=<span class="number">4</span>,iface=MIXER,name=<span class="string">'PCM Playback Volume'</span></span><br><span class="line">numid=<span class="number">6</span>,iface=MIXER,name=<span class="string">'usbCapture_vol'</span></span><br><span class="line">numid=<span class="number">5</span>,iface=MIXER,name=<span class="string">'usbPlay_vol'</span></span><br><span class="line">numid=<span class="number">1</span>,iface=PCM,name=<span class="string">'Capture Channel Map'</span></span><br><span class="line">numid=<span class="number">2</span>,iface=PCM,name=<span class="string">'Playback Channel Map'</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//对控件进行配置</span></span><br><span class="line"><span class="meta"># amixer -c 1 sget usbCapture_vol </span></span><br><span class="line">Simple mixer control <span class="string">'usbCapture_vol'</span>,<span class="number">0</span></span><br><span class="line">  Capabilities: volume</span><br><span class="line">  Playback channels: Front Left - Front Right</span><br><span class="line">  Capture channels: Front Left - Front Right</span><br><span class="line">  Limits: <span class="number">0</span> - <span class="number">255</span></span><br><span class="line">  Front Left: <span class="number">100</span> [<span class="number">39</span>%]</span><br><span class="line">  Front Right: <span class="number">100</span> [<span class="number">39</span>%]</span><br><span class="line"><span class="meta"># amixer -c 1 cget numid=5,iface=MIXER,name=<span class="string">'usbCapture_vol'</span></span></span><br><span class="line">numid=<span class="number">5</span>,iface=MIXER,name=<span class="string">'usbCapture_vol'</span></span><br><span class="line">  ; type=INTEGER,access=rw---RW-,values=<span class="number">2</span>,min=<span class="number">0</span>,max=<span class="number">255</span>,step=<span class="number">0</span></span><br><span class="line">  : values=<span class="number">100</span>,<span class="number">100</span></span><br><span class="line">  | dBscale-min=<span class="number">-20.00</span>dB,step=<span class="number">0.20</span>dB,mute=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># arecord -l</span></span><br><span class="line">**** List of CAPTURE Hardware Devices ****</span><br><span class="line">card <span class="number">0</span>: smartpenknot [smartpen_knot], device <span class="number">0</span>: i2s-ecodec nau8822-hifi<span class="number">-0</span> []</span><br><span class="line">  Subdevices: <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line">card <span class="number">0</span>: smartpenknot [smartpen_knot], device <span class="number">1</span>: dmic dmic-codec-hifi<span class="number">-1</span> []</span><br><span class="line">  Subdevices: <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line">card <span class="number">0</span>: smartpenknot [smartpen_knot], device <span class="number">2</span>: i2s-tloop pcm-dump<span class="number">-2</span> []</span><br><span class="line">  Subdevices: <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line">card <span class="number">1</span>: EP3C [Meizu EP3C], device <span class="number">0</span>: USB Audio [USB Audio]</span><br><span class="line">  Subdevices: <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line"># </span><br><span class="line"><span class="meta"># aplay -l</span></span><br><span class="line">**** List of PLAYBACK Hardware Devices ****</span><br><span class="line">card <span class="number">0</span>: smartpenknot [smartpen_knot], device <span class="number">0</span>: i2s-ecodec nau8822-hifi<span class="number">-0</span> []</span><br><span class="line">  Subdevices: <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line">card <span class="number">1</span>: EP3C [Meizu EP3C], device <span class="number">0</span>: USB Audio [USB Audio]</span><br><span class="line">  Subdevices: <span class="number">0</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h1 id="ALSA音频工具"><a href="#ALSA音频工具" class="headerlink" title="ALSA音频工具"></a>ALSA音频工具</h1><p>对于以下工具的使用，都可以直接输入“工具名”或“工具名 –help” 获得详细使用方法</p>
<h2 id="arecode-录音"><a href="#arecode-录音" class="headerlink" title="arecode 录音"></a>arecode 录音</h2><ol>
<li>查看录音设备 : arecode -l</li>
<li>命令实例 :  arecord -D hw:0,1 -d 10 -f cd -r 44100 -c 2 -t wav test.wav</li>
<li>参数解析 : <ul>
<li>-D 指定了录音设备，0,1 是card 0 device 1</li>
<li>-d 指定录音的时长，单位 : 秒</li>
<li>-f 指定采样格式，通过上面的信息知道只支持 cd cdr dat </li>
<li>-r 指定了采样率，单位 : Hz</li>
<li>-c 指定channel 个数</li>
<li>-t 指定生成的文件格式</li>
</ul>
</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">lee@lee-virtual-machine:~$ arecord -l</span><br><span class="line">**** CAPTURE 硬體裝置清單 ****</span><br><span class="line">card 0: AudioPCI [Ensoniq AudioPCI], device 0: ES1371/1 [ES1371 DAC2/ADC]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 #0: subdevice #0</span><br><span class="line">lee@lee-virtual-machine:~$ arecord -D hw:0,0 -d 10 -f cd -r 44100 -c 2 -t wav test.wav</span><br><span class="line">正在录音 WAVE 'test.wav' : Signed 16 bit Little Endian, 频率44100Hz， Stereo</span><br><span class="line">lee@lee-virtual-machine:~$ </span><br></pre></td></tr></tbody></table></figure>



<h2 id="aplay-放音"><a href="#aplay-放音" class="headerlink" title="aplay 放音"></a>aplay 放音</h2><ol>
<li><p>查看放音设备 : aplay -l</p>
</li>
<li><p>命令实例 : aplay test.wav</p>
<blockquote>
<p>如果是直接播放pcm数据，则需要指定pcm格式 、采样率、channel个数等。</p>
</blockquote>
</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">lee@lee-virtual-machine:~$ aplay -l</span><br><span class="line">**** PLAYBACK 硬體裝置清單 ****</span><br><span class="line">card 0: AudioPCI [Ensoniq AudioPCI], device 0: ES1371/1 [ES1371 DAC2/ADC]</span><br><span class="line">  子设备: 0/1</span><br><span class="line">  子设备 #0: subdevice #0</span><br><span class="line">card 0: AudioPCI [Ensoniq AudioPCI], device 1: ES1371/2 [ES1371 DAC1]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 #0: subdevice #0</span><br><span class="line">lee@lee-virtual-machine:~$ aplay test.wav </span><br><span class="line">正在播放 WAVE 'test.wav' : Signed 16 bit Little Endian, 频率44100Hz， Stereo</span><br><span class="line">lee@lee-virtual-machine:~$ </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h2 id="amixer-配参"><a href="#amixer-配参" class="headerlink" title="amixer 配参"></a>amixer 配参</h2><p>amixer，是alsamixer的文本模式（命令行模式）用于配置音频的各个参数</p>
<ol>
<li><p>使用方法 :</p>
<ol>
<li><p>用 # amixer controls 列出所有控制项。( 显示接口函数 )</p>
</li>
<li><p>如果对控制项不熟悉或者想查看当前的所有配置可以使用 # amixer contents 命令。(显示当前配置)</p>
</li>
<li><p>查看获取某个设置项的值用 # amixer cget + 控制参数 命令。 这里控制参数直接复制 # amixer controls 打印出来的数据就可以</p>
</li>
<li><p>根据控制参数类型设置控制参数使用 # amixer cset + 控制参数 + 设置参数 命令。</p>
</li>
<li><p>values 表示数值对于 volume 之类的是具体的数字，在上下文菜单中有显示数值的范围，对于 switch 之类的表示开关一般是 on 或 off。</p>
<p>另外一sget/sset系列的命令, 与cget/cset的使用相同</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//使用例子:</span></span><br><span class="line"><span class="comment">//给的参数看value需要几个 需要什么类型进行相应的配置即可</span></span><br><span class="line">/ <span class="meta"># amixer cget numid=43,iface=MIXER,name=<span class="string">'Speaker Playback Volum'</span></span></span><br><span class="line">numid=<span class="number">43</span>,iface=MIXER,name=<span class="string">'Speaker Playback Volume'</span></span><br><span class="line">  ; type=INTEGER,access=rw---R--,values=<span class="number">2</span>,min=<span class="number">0</span>,max=<span class="number">63</span>,step=<span class="number">0</span></span><br><span class="line">  : values=<span class="number">63</span>,<span class="number">63</span></span><br><span class="line">  | dBscale-min=<span class="number">-57.00</span>dB,step=<span class="number">1.00</span>dB,mute=<span class="number">0</span></span><br><span class="line">/ # </span><br><span class="line">/ # </span><br><span class="line">/ # </span><br><span class="line">/ <span class="meta"># amixer cset numid=43,iface=MIXER,name=<span class="string">'Speaker Playback Volum'</span> 30 30 </span></span><br><span class="line">numid=<span class="number">43</span>,iface=MIXER,name=<span class="string">'Speaker Playback Volume'</span></span><br><span class="line">  ; type=INTEGER,access=rw---R--,values=<span class="number">2</span>,min=<span class="number">0</span>,max=<span class="number">63</span>,step=<span class="number">0</span></span><br><span class="line">  : values=<span class="number">30</span>,<span class="number">30</span></span><br><span class="line">  | dBscale-min=<span class="number">-57.00</span>dB,step=<span class="number">1.00</span>dB,mute=<span class="number">0</span></span><br><span class="line">/ # </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><p>保存及恢复方法</p>
<p>对声卡信息状态进行保存 : alsactl store -f /var/lib/alsa/asound.state </p>
<p>声卡状态恢复命令 : alsactl restore -f /var/lib/alsa/asound.state</p>
</li>
</ol>
<h2 id="Linux音频分析工具"><a href="#Linux音频分析工具" class="headerlink" title="Linux音频分析工具"></a>Linux音频分析工具</h2><ol>
<li><p>audacity</p>
<ul>
<li><p>功能：查看各种格式音频的波形，并有裁剪、转换格式、生成特定音频数据等诸多功能</p>
</li>
<li><p>下载方法 : sudo apt install audacity -o Acquire::http::proxy=”<a href="http://192.168.4.15:8080/&quot;">http://192.168.4.15:8080/"</a>( -o 参数指定代理)</p>
</li>
<li><p>使用方法：命令行输入audacity，添加音频文件即可</p>
</li>
</ul>
</li>
<li><p>play</p>
<ul>
<li>由于aplay播放数据格式有限，play对于音频数据格式进行了较多的支持</li>
<li>play播放裸数据命令 : play -t raw -r 16000 -e signed-integer -b 16 -c 1 test.wav</li>
</ul>
</li>
</ol>
<h1 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h1><p>代码链接：<a href="https://github.com/yangLieee/audioplayer">https://github.com/yangLieee/audioplayer</a></p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：数据存储出来只有78字节，但是写函数已经执行完毕？</p>
<p>A：这只是写了一个文件头，而最终文件没有写入。原因是：avio_open之后没有关闭，调用closep函数之后数据正常写入;</p>
<p>​		调试流程：首先定位问题位置。在alsa录音完成之后将数据写入buffer中存储来看是否是alsa部分的录音问题。之后根据流程进行检查。一定要注意open close / new delete / 等配套的使用</p>
</li>
<li><p>数据已经写结束 但是还是会再次执行一次其上面的程序</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fmtContext)                                                                    </span><br><span class="line">       av_write_trailer(fmtContext);</span><br><span class="line"><span class="keyword">if</span>(fmtContext != <span class="literal">NULL</span>){   </span><br><span class="line">   <span class="keyword">if</span>( avio_closep(&amp;fmtContext-&gt;pb) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"avio_closep error!"</span>);</span><br><span class="line">   avformat_free_context(fmtContext);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">av_write_trailer的作用</span></span><br><span class="line"><span class="comment">	1. 循环调用interleave_packet()以及write_packet()，将还未输出的AVPacket输出出来。</span></span><br><span class="line"><span class="comment">	2. 调用AVOutputFormat的write_trailer()，输出文件尾。</span></span><br><span class="line"><span class="comment">avio_closep的作用</span></span><br><span class="line"><span class="comment">	关闭输出文件的上下文,与avio_open相对应使用</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">这两个的使用需要保证av_write_trailer函数调用早于avio_closep</span></span><br><span class="line"><span class="comment">如果不调用这两个函数会导致最终文件不能写出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>Q：重采样时 channel 可以正常转换, sample_rate采样率变化不能转换?</p>
<p>A：在做采样率的重采样时, 对输出的context配置需要将采样点也做一下转换,否则已经转换成功但是生成的文件大小还是按照以前的输出进行.<br>  采样点转换函数 : av_rescale_rnd(iFrame-&gt;nb_samples, oSampleRate, iSampleRate, AV_ROUND_UP);</p>
</li>
<li><p>Q : 录音之后声音太小, 甚至有时候听不到, 需要如何调整? </p>
<p>A : 通过amixer参数进行相应的配置</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">/storage/recode <span class="meta"># amixer cset numid=53,iface=MIXER,name=<span class="string">'DMIC GAIN'</span> 15</span></span><br><span class="line">numid=<span class="number">53</span>,iface=MIXER,name=<span class="string">'DMIC GAIN'</span></span><br><span class="line">  ; type=INTEGER,access=rw---R--,values=<span class="number">1</span>,min=<span class="number">0</span>,max=<span class="number">31</span>,step=<span class="number">0</span></span><br><span class="line">  : values=<span class="number">15</span></span><br><span class="line">  | dBscale-min=<span class="number">0.00</span>dB,step=<span class="number">3.00</span>dB,mute=<span class="number">0</span></span><br><span class="line"><span class="comment">//这个步骤的作用是, 将dmic的增益调整为15 </span></span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>Q:  耳机音量小但是amixer没有相关可以配置的参数?</p>
<p>A : 通过asound.conf配置新的插件, </p>
<p><a href="https://alsa.opensrc.org/How_to_use_softvol_to_control_the_master_volume">https://alsa.opensrc.org/How_to_use_softvol_to_control_the_master_volume</a></p>
</li>
</ol>
<h1 id="参考资料（包含FFmpeg）"><a href="#参考资料（包含FFmpeg）" class="headerlink" title="参考资料（包含FFmpeg）"></a>参考资料（包含FFmpeg）</h1><blockquote>
<p>注：如果后续如涉及到FFmpeg文章，再将该部分内容移除，以下文章是在工作的开发中有帮助到自己</p>
</blockquote>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/1TJQc3Ktdw_Qz576iLjB1Q">ALSA（高级Linux声音架构）浅析</a></p>
</li>
<li><p><a href="https://wenku.baidu.com/view/dacb0922af45b307e87197a2.html">ALSA框架介绍——音频通路</a></p>
</li>
<li><p><a href="https://magodo.github.io/alsa-pcm/#0-pcm">ALSA - PCM接口</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/jason-lu/archive/2013/06/07/3123750.html">Linux ALSA框架之三:PCM设备的创建 </a></p>
</li>
<li><p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44116215">FFmpeg源代码简单分析</a></p>
</li>
<li><p><a href="https://blog.csdn.net/BrookIcv/article/details/53490799">FFmpeg 中AVPacket的使用</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
      <tags>
        <tag>ALSA</tag>
      </tags>
  </entry>
  <entry>
    <title>Libmad详解</title>
    <url>/2022/11/05/Audio/Audio-libmad/</url>
    <content><![CDATA[<p>简单来讲，libmad就是一个MP3文件的解码库。如果想要深入理解其中的实现需要对MP3文件格式有详细的了解，关于MP3文件格式的内容在这里我不赘述，之前的文章当中有过详细的讲解 <a href="https://yanglieee.com/2022/09/05/Audio-meet-1/">click here</a></p>
<h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><blockquote>
<p>Libmad 详解：<a href="https://www.underbit.com/products/mad/">https://www.underbit.com/products/mad/</a></p>
</blockquote>
<p> libmad 是一个高质量的 MPEG 音频解码器。目前支持  MPEG-1 和 MPEG-2 对较低采样频率的扩展，以及所谓的 MPEG 2.5 格式，三个音频层都在代码上做了实现。优势：</p>
<ul>
<li>24 位 PCM 输出</li>
<li>100% 定点（整数）计算</li>
<li>基于 ISO/IEC 标准的全新实施</li>
<li>根据 GNU 通用公共许可证 (GPL) 的条款分发</li>
</ul>
<h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p><a href="https://sourceforge.net/projects/mad/files/">https://sourceforge.net/projects/mad/files/</a></p>
<p><a href="https://www.linuxfromscratch.org/blfs/view/svn/multimedia/libmad.html">https://www.linuxfromscratch.org/blfs/view/svn/multimedia/libmad.html</a></p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>&lt; 基于 libmad-0.15.1b 版本&gt;</p>
<table>
<thead>
<tr>
<th>源文件</th>
<th>bit.c</th>
<th>decoder.c</th>
<th>fixed.c</th>
<th>frame.c</th>
<th>huffman.c</th>
<th>layer12.c</th>
<th>layer3.c</th>
<th>stream.c</th>
<th>synth.c</th>
<th>timer.c</th>
<th>version.c</th>
<th>minimad.c(demo)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>头文件</td>
<td>bit.h</td>
<td>decoder.h</td>
<td>fixed.h</td>
<td>frame.h</td>
<td>huffman.h</td>
<td>layer12.h</td>
<td>layer3.h</td>
<td>stream.h</td>
<td>synth.h</td>
<td>timer.h</td>
<td>version.h</td>
<td>global.h</td>
<td>mad.h（API）</td>
</tr>
<tr>
<td>dat文件</td>
<td>sf_table.dat</td>
<td>imdct_s.dat</td>
<td>qc_table.dat</td>
<td>D.dat</td>
<td>rq_table.dat</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>其他文件</td>
<td>Makefile</td>
<td>config</td>
<td>……</td>
<td></td>
<td>大部分内容不参与编译</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>具体使用方法可以参考minimad.c文件，这里面对api的使用有进一步的说明</p>
<p>同时也可以参考我基于Linux libmad写出来的一个音频播放器，源码链接 <a href="https://github.com/yangLieee/audioplayer">click here</a></p>
<h1 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h1><p>&lt; 仅介绍linux环境下编译方法 &gt; </p>
<ol>
<li>手写Makefile / CMakeLists.txt</li>
<li>系统提供的config<ul>
<li>执行 <strong>sed -i ‘/-fforce-mem/d’ configure</strong> ， 这条命令是为了适配高版本的gcc，因为高版本的gcc已经将-fforce-mem去除了</li>
<li>执行 <strong>./configure ,</strong> 文件夹下会生成Makefile</li>
<li>执行 <strong>sudo make; sudo install;</strong> </li>
<li>至此静态库和动态库已经生成，目录在/usr/local/lib</li>
</ul>
</li>
</ol>
<h1 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h1><ol>
<li><p>mad_decoder_init( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mad_decoder_init</span><span class="params">(<span class="keyword">struct</span> mad_decoder *, <span class="type">void</span> *,   </span></span><br><span class="line"><span class="params">           <span class="comment">/* input func  */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* header func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_header <span class="type">const</span> *),                   </span></span><br><span class="line"><span class="params">           <span class="comment">/* filter func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream <span class="type">const</span> *, <span class="keyword">struct</span> mad_frame *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* output func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_header <span class="type">const</span> *, <span class="keyword">struct</span> mad_pcm *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* error func  */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream *, <span class="keyword">struct</span> mad_frame *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* message func*/</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="type">void</span> *, <span class="type">unsigned</span> <span class="type">int</span> *))</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>mad_decoder_init( )是libmad中最终重要的函数之一，其作用是将line3~line8的六个回调函数注册到mad_decoder实例出来的decoder中。</p>
<ul>
<li><p><strong>必须自定义的参数：</strong>参数1：用户自己实例的一个解码器结构体；参数2：用户自定义的结构体指针，这个指针将用于整个解码的过程在回调函数之间进行数据的传输；参数3：输入的回调函数，该回调用于用户自定义将数据输入编码器的逻辑；参数6：输出的回调函数，同input callback func。自定义输出的分辨率吧：24bit / 16bit，可以存成文件亦可以直接通过pcm接口播放。Output回调函数在madlib每解码完成一个帧后被调用，直到全部解码完成或出错。参数8（异步工作模式下必选）：输出信息。</p>
</li>
<li><p><strong>选择性定义参数：</strong>其他参数属于自定义参数比如进行头解析、过滤筛选的回调函数等等，如果自己没有需求置0即可。</p>
</li>
</ul>
</li>
<li><p>mad_decoder_run( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mad_decoder_run</span><span class="params">(<span class="keyword">struct</span> mad_decoder *, <span class="keyword">enum</span> mad_decoder_mode)</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>该函数是解码的主流程函数，即解码器的入口函数，如果要追代码可以从此处开始进行剖析。</p>
<ul>
<li>参数1：用户自定义实例化并初始化的解码器decoder；</li>
<li>参数2：选择解码模式（SYNC / ASYNC）深入代码可以发现这个选择使得解码器进入不同的函数进行工作。</li>
</ul>
<p>所谓同步方式是指解码函数在解码完一帧后才返回并带回出错信息，异步方式是指解码函数在调用后立即返回，通过消息传递解码状态信息。(故异步方式必须定义message回调函数)</p>
</li>
<li><p>mad_decoder_finish( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mad_decoder_finish</span><span class="params">(<span class="keyword">struct</span> mad_decoder *)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>解码结束，用于清理工作，释放与流相关的任何动态内存。</p>
</li>
<li><p>mad_stream_buffer( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mad_stream_buffer</span><span class="params">(<span class="keyword">struct</span> mad_stream *, <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *, <span class="type">unsigned</span> <span class="type">long</span>)</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>该函数是input回调函数中最重要的函数，其作用是按照参数2、参数3即MP3文件在内存映像的起始地址和本次要传递的文件长度与mad_stream进行关联，形成libmad可识别的stream流</p>
<p>需要注意，这里传递多少数据完全是自定义的。如果一次性送入则整个解码过程调用一次input；如果一次性传递若干，output根据传递的数据进行解码，如果没有数据可解继续调用input。所以自己定义好输入逻辑即可。</p>
</li>
</ol>
<h1 id="重点数据结构"><a href="#重点数据结构" class="headerlink" title="重点数据结构"></a>重点数据结构</h1><ol>
<li><p>mad_stream</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h &amp;&amp; stream.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_stream</span> {</span>           </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *buffer;          <span class="comment">/* input bitstream buffer */</span>                                       <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *bufend;          <span class="comment">/* end of buffer */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> skiplen;                <span class="comment">/* bytes to skip before next frame */</span></span><br><span class="line">  <span class="type">int</span> sync;                             <span class="comment">/* stream sync found */</span>        </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> freerate;               <span class="comment">/* free bitrate (fixed) */</span>     </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *this_frame;      <span class="comment">/* start of current frame */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *next_frame;      <span class="comment">/* start of next frame */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mad_bitptr</span> <span class="title">ptr</span>;</span>                <span class="comment">/* current processing bit pointer */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mad_bitptr</span> <span class="title">anc_ptr</span>;</span>            <span class="comment">/* ancillary bits pointer */</span>   </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> anc_bitlen;              <span class="comment">/* number of ancillary bits */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="title function_">char</span> <span class="params">(*main_data)</span>[MAD_BUFFER_MDLEN];                  <span class="comment">/* Layer III main_data() */</span>    </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> md_len;                  <span class="comment">/* bytes in main_data */</span>  </span><br><span class="line">  <span class="type">int</span> options;                          <span class="comment">/* decoding options (see below) */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_error</span> <span class="title">error</span>;</span>                 <span class="comment">/* error code (see above) */</span>   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>该结构体记录了文件的地址、当前所处理的位置和解码前的Bitstream数据</p>
<p>mad_stream.bufend – mad_stream.next_frame就是剩余的未被解码的 MPEG 帧的数据的字节数量（假设此帧在缓冲区中不完整)</p>
</li>
<li><p>mad_header</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_header</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_layer</span> <span class="title">layer</span>;</span>             <span class="comment">/* audio layer (1, 2, or 3) */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_mode</span> <span class="title">mode</span>;</span>               <span class="comment">/* channel mode (see above) */</span></span><br><span class="line">  <span class="type">int</span> mode_extension;               <span class="comment">/* additional mode info */</span>                                             <span class="class"><span class="keyword">enum</span> <span class="title">mad_emphasis</span> <span class="title">emphasis</span>;</span>       <span class="comment">/* de-emphasis to use (see above) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bitrate;            <span class="comment">/* stream bitrate (bps) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> samplerate;          <span class="comment">/* sampling frequency (Hz) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> crc_check;         <span class="comment">/* frame CRC accumulator */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> crc_target;        <span class="comment">/* final target CRC checksum */</span></span><br><span class="line">  <span class="type">int</span> flags;                        <span class="comment">/* flags (see below) */</span></span><br><span class="line">  <span class="type">int</span> private_bits;                 <span class="comment">/* private bits (see below) */</span></span><br><span class="line">  <span class="type">mad_timer_t</span> duration;             <span class="comment">/* audio playing time of frame */</span></span><br><span class="line">};    </span><br></pre></td></tr></tbody></table></figure>

<p>通过注释很容易看出，该结构体记录了MPEG 帧的基本信息，比如MPEG 层数、声道模式、流比特率、采样率、比特率以及某些校验位等等。</p>
<blockquote>
<p>Tips：（bitrate % 32） 如果是整数说明该文件格式是CBR（constant bitrate，恒定比特率），否则是VBR（variable bitrate，可变比特率），这对文件播放时长是有影响的。</p>
</blockquote>
</li>
<li><p>mad_pcm</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_pcm</span> {</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> samplerate;          <span class="comment">/* sampling frequency (Hz) */</span>                                           <span class="type">unsigned</span> <span class="type">short</span> channels;          <span class="comment">/* number of channels */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> length;            <span class="comment">/* number of samples per channel */</span></span><br><span class="line">  <span class="type">mad_fixed_t</span> samples[<span class="number">2</span>][<span class="number">1152</span>];     <span class="comment">/* PCM output samples [ch][sample] */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>madlib解码器是以帧为单位进行解码的，mad_pcm每次最多解码出（1152 * channels）个PCM数据，每个采样点用int（32bit）表征但是只用了其中的24bit，至此可以直接输出数据保存文件或者直接调用音频播放的API进行播放。但目前大多数codec支持的是16bit量化分辨率，所以在输出时将数据饱和到16bit进行输出。</p>
</li>
<li><p>mad_flow</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">mad_flow</span> {</span></span><br><span class="line">  MAD_FLOW_CONTINUE = <span class="number">0x0000</span>,   <span class="comment">/* continue normally */</span>                                                     MAD_FLOW_STOP     = <span class="number">0x0010</span>,   <span class="comment">/* stop decoding normally */</span></span><br><span class="line">  MAD_FLOW_BREAK    = <span class="number">0x0011</span>,   <span class="comment">/* stop decoding and signal an error */</span></span><br><span class="line">  MAD_FLOW_IGNORE   = <span class="number">0x0020</span>    <span class="comment">/* ignore the current frame */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>所有回调函数的返回值均为该枚举类型，在解码的主流程中会通过不断判断解码器所调用的回调函数的状态来确认下一步的动作</p>
</li>
</ol>
<h1 id="相关调试经验"><a href="#相关调试经验" class="headerlink" title="相关调试经验"></a>相关调试经验</h1><ol>
<li><p>配置参数未选择</p>
<p>Q：编译正常通过，流程正确，但是输出的声音能听出是所需要的音频但是整体数据并不正确？</p>
<p>A：在mad.h中有若干的函数是根据平台的不同有不同的实现，由于编译过程中没有注意警告直接将其注释导致没有选择正确函数实现，导致最终的数据都是错误的。编译时添加相应的平台的参数即可，如果手动写cmake，参考给出的Makefile做参数选择！</p>
</li>
<li><p>线程栈空间大小分配不足</p>
<p>Q：在PC上测试正常播放，但是移植到小系统中经常出现stack overflow？</p>
<p>A：由于MP3一帧数据的采样点数为1152，使用 int 类型进行存储，所以核心函数 “ Ⅲ_decode” 至少需要6k的栈空间，如果是单独一个线程的话再加上其他的局部变量、函数跳转等等可能就超过8k。</p>
<p>​	  当时使用c++ 的thread进行的线程创建并不能配置栈空间大小，经过两天左右的debug查到是核心函数栈空间的溢出，最终使用pthread加大栈空间的大小运行即可。</p>
</li>
<li><p>动态解码的实现</p>
<p>Q：刚开始百度libmad的库，很多博客说只能调用一次input回调函数即一次加载所有的源数据，这对于实时控制造成不便？</p>
<p>A： 深入源码可以看出输入的的数据解码完成只要不返回STOP是可以继续填充数据的，这样临时的buffer就小一些并且可以试试控制完成播放器的功能。（需要注意如果一次输入的数据是几帧多一点，而多出来的需要放保存下次再此进行解码）</p>
</li>
<li><p>获得音频参数</p>
<p>Q：能够很快的获得音频信息？</p>
<p>A： 对于wav头很容易的可以找到音频的参数，但是MP3文件的信息保存在帧头中，所以可以进行一步预解码。即读入若干（512即可）byte数据解一帧的头就可以获得全部信息，包括：采样率、比特率、声道、音频时长等等。</p>
</li>
<li><p>获得播放进度 / 时长出现异常</p>
<p>Q：使用公式：当前文件位置 / 文件大小 × 文件总时长，获得当前播放时间出现异常？</p>
<p>A： 对于duration 和 fpos是用int的数据类型进行保存的，但是对于wav文件一般比较大在计算的时候超出了数据类型所能存储的最大长度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
      <tags>
        <tag>libmad</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio-再遇</title>
    <url>/2022/09/05/Audio/Audio-meet-1/</url>
    <content><![CDATA[<p>本篇内容对一节提到的编码进行扩展，将重点对PCM格式、WAVE格式、MP3格式进行详细解析。</p>
<h1 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h1><p>PCM : Pulse-Code Modulation 脉冲调制编码</p>
<p>PCM 本是一种调制方法的名称，进而通过该方法得到的音频数据也称作PCM数据，即裸数据。该数据是我们通过codec得到的最原始的数据！</p>
<p>​    <img src="/images/linux/Audio/Audio-remeet-1.png" alt="pic"></p>
<h1 id="WAVE"><a href="#WAVE" class="headerlink" title="WAVE"></a>WAVE</h1><p>WAVE : Waveform Audio File Format 波形音频文件格式, 即我们平时所说的wave文件</p>
<p>很简单，WAV文件格式结构体通常是用来保存PCM格式的原始数据，基于此添加一个文件头构成了WAV文件，即wave = wave头 + PCM数据。因此它通常也被称为无损音频，但是严格意义上来讲，WAV也可以存储其它压缩格式的音频数据。</p>
<h2 id="wav头"><a href="#wav头" class="headerlink" title="wav头"></a>wav头</h2><table>
<thead>
<tr>
<th><strong>偏移地址</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>大小</strong></th>
<th><strong>名称</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>00H~03H</td>
<td>char</td>
<td>4</td>
<td>资源交换文件标志 ( RIFF )</td>
<td>52 49 46 46 固定写法</td>
</tr>
<tr>
<td>04H~07H</td>
<td>long int （4）</td>
<td>1</td>
<td>文件大小size</td>
<td>从下个地址 (08) 开始到 WAV 文件结尾的总字节数整个 WAV 文件的大小就是该数值 + 8</td>
</tr>
<tr>
<td>08H~0BH</td>
<td>char</td>
<td>4</td>
<td>WAV文件标志 WAVE</td>
<td>57 41 56 45 , 是 WAVE 四个字母的 ASCII 码，固定写法</td>
</tr>
<tr>
<td>0CH~0FH</td>
<td>char</td>
<td>4</td>
<td>波形格式标志（fmt ）</td>
<td>最后一位0x20 对应的字符是空格</td>
</tr>
<tr>
<td>10H~13H</td>
<td>int</td>
<td>1</td>
<td>过滤字节</td>
<td>一般为00000010H</td>
</tr>
<tr>
<td>14H~15H</td>
<td>short int （2）</td>
<td>1</td>
<td><strong>格式种类audioformat</strong></td>
<td>值为1时，表示数据为线性PCM编码</td>
</tr>
<tr>
<td>16H~17H</td>
<td>short int</td>
<td>1</td>
<td><strong>通道数 channnels</strong></td>
<td>1 表示单声道 , 2 表示立体声</td>
</tr>
<tr>
<td>18H~1BH</td>
<td>long int</td>
<td>1</td>
<td><strong>采样频率 sampleRate</strong></td>
<td>80 BB 00 00 – &gt; 48000 Hz ;</td>
</tr>
<tr>
<td>1CH~1FH</td>
<td>long int</td>
<td>1</td>
<td>波形数据传输速率（每秒平均字节数）</td>
<td>采样率×通道数×采样位数 / 8</td>
</tr>
<tr>
<td>20H~21H</td>
<td>short int</td>
<td>1</td>
<td>DATA数据块调整长度，字节。</td>
<td>通道数×样本数据位数 / 8</td>
</tr>
<tr>
<td>22H~23H</td>
<td>short int</td>
<td>1</td>
<td>PCM位宽</td>
<td>10 00 —-&gt; 16 位, 2 字节</td>
</tr>
<tr>
<td>24H~27H</td>
<td>char</td>
<td>4</td>
<td>数据标记</td>
<td>64 61 74 61 data的ASCII的值</td>
</tr>
<tr>
<td>28H~2BH</td>
<td>long int</td>
<td>1</td>
<td>PCM 数据总长度</td>
<td></td>
</tr>
</tbody></table>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>Q：wave文件的文件头一定是44Bytes吗？</p>
<p>A：不一定！以上格式只是wave文件的标准，属于通用标准。但是将其他格式文件通过ffmpeg转码之后的wav文件头会大于44个字节（115Bytes），在文件头和数据块之间添加了一些ffmpeg的信息，部分表征的意义不同！网上很多格式转换工具都是调用的ffmpeg转码的，导致文件头大小不完全相同。</p>
<blockquote>
<p>​     -map_metadata -1 -fflags +bitexact 可以去除标注信息，使文件头符合标准</p>
<p>​     ffmpeg -y -i music.mp3 -map_metadata -1 -fflags +bitexact -f wav -ac 1 -ar 16000 -ab 16k music.wav</p>
</blockquote>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Ffmpeg不去标准信息转码wave之后的文件格式：</p>
<table>
<thead>
<tr>
<th>偏移地址</th>
<th>字节数</th>
<th>数据类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>00H ~ 23H</td>
<td>36</td>
<td>同上表的00H~23H一致</td>
<td></td>
</tr>
<tr>
<td>24H ~ 27H</td>
<td>4</td>
<td>char</td>
<td>“LIST”, LIST块标志，固定不变</td>
</tr>
<tr>
<td>28H ~ 2BH</td>
<td>4</td>
<td>long</td>
<td>LIST块占用的字节数，在这里为26字节</td>
</tr>
<tr>
<td>2CH ~ 45H</td>
<td>26</td>
<td>char</td>
<td>LIST块内容</td>
</tr>
<tr>
<td>46H ~ 49H</td>
<td>4</td>
<td>char</td>
<td>“data”, data数据块标志，固定不变</td>
</tr>
<tr>
<td>4AH ~ 4DH</td>
<td>4</td>
<td>long</td>
<td>wav文件音频数据所占大小</td>
</tr>
</tbody></table>
<h1 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MP3：Moving Picture Experts Group Audio Layer III, 动态影像专家压缩标准音频层面3</p>
<p>首先科普下部分概念：MPEG（Moving Pictures Experts Group ，动态图像专家组），简单理解就是一些研究音视频的专家发布的相关标准，其命名为MPEG-*（其中*代表数字或字母），例如MPEG-1、MPEG-2.5、MPEG-E等等。</p>
<p>可能有人会想MPEG-3是不是就是MP3呢？MPEG是针对音视频及系统测试的一整套的标准规范，其中对于MPEG1来讲，其part3音频部分规定了3个独立分层的音频编码格式，分别为layer Ⅰ、layer Ⅱ、layer Ⅲ，而layer Ⅲ也就是我们所说的MP3（MEPEG1 Layer Ⅲ），这三层的区别主要在于编码的算法及输出速率的区别。同样纵向来看，MPEG2、MPEG2.5同样有三个独立的layer，区别在于它们所使用的采样率更低了。</p>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>目前大多数标准MP3文件都支持ID3V2标准。具体组成格式为：ID3V2.3标签帧（1个）+ 数据帧（若干）+ ID3V1帧（1个），其中ID3V2.3 = 标签头（1个，必须） + 标签帧（若干，不必须） + 扩展标签头（不必须）</p>
<p>组成部分我画了一张示意图可以参考，每一部分下面将做详细解析</p>
<p>​    <img src="/images/linux/Audio/Audio-remeet-2.png" alt="pic"></p>
<h2 id="ID3标准"><a href="#ID3标准" class="headerlink" title="ID3标准"></a>ID3标准</h2><p>MP3帧头中除了存储一些象private、copyright、original的简单音乐说明信息以外，没有考虑存放歌名、作者、专辑名、年份 等复杂信息，而这些信息在MP3应用中非常必要。1996年，FricKemp在“Studio 3”项目中提出了在MP3文件尾增加一块用于存放歌曲的说明信息，形成了ID3标准</p>
<h2 id="标签头"><a href="#标签头" class="headerlink" title="标签头"></a>标签头</h2><p>标签头是由10Byte组成的，具体含义如下</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char Header[3];</td>
<td>必须为”ID3”否则认为标签不存在，如上图地址00—02部分为”49 44 33”，文本为“ID3”</td>
</tr>
<tr>
<td>char Ver;</td>
<td>版本号 ID3V2.3 就记录 3，如上图地址03处记录为”03”</td>
</tr>
<tr>
<td>char Revision;</td>
<td>副版本号此版本记录为 0</td>
</tr>
<tr>
<td>char Flag;</td>
<td>放标志的字节，一般为00abc00000a – 表示是否使用 Unsynchronisationb – 表示是否有扩展头部,一般没有(至少 Winamp 没有记录),所以一般也不设置c – 表示是否为测试标签(99.99%的标签都不是测试用的，所以一般也不设置)</td>
</tr>
<tr>
<td>char Size[4];</td>
<td>标签大小,包括标签头的 10 个字节和所有的标签帧的大小</td>
</tr>
</tbody></table>
<p>整个标签大小 :</p>
<p>ID3V2_frame_size = (int)(Size[0] &amp; 0x7F) &lt;&lt; 21 | (int)(Size[1] &amp; 0x7F) &lt;&lt; 14 | (int)(Size[2] &amp; 0x7F) &lt;&lt; 7 | (int)(Size[3] &amp; 0x7F) + 10;</p>
<h2 id="标签帧"><a href="#标签帧" class="headerlink" title="标签帧"></a>标签帧</h2><p>每个标签帧都有一个 10 个字节的帧头（虽然都是10字节，但是与标签头不是一个东西。标签头有且只有一个，而标签头每一个标签帧都有一个帧头）和至少一个字节的不固定长度的内容组成。</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char FrameID[4]</td>
<td>用四个字符标识一个帧，说明其内容</td>
</tr>
<tr>
<td>char Size[4]</td>
<td>帧内容的大小，不包括帧头，不得小于1</td>
</tr>
<tr>
<td>char Flags[2]</td>
<td>存放标志，只定义了6 位，此处不再说明</td>
</tr>
</tbody></table>
<p>常用帧标识：</p>
<p>TIT2：标题<br>TPE1：作者<br>TALB：专辑<br>TRCK： 音轨，格式：N/M，N表示专辑中第几首，M为专辑中歌曲总数<br>TYER：年份<br>TCON：类型<br>COMM：备注，格式：“eng\0备注内容”，其中eng表示所使用的语言<br>帧大小为四个字节所表示的整数大小。</p>
<h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p>数据帧由帧头和数据帧组成，对于每一帧数据都有一个帧头。</p>
<p>帧头长4字节，对于固定位率的MP3文件，所有帧的帧头格式一样其数据结构如下</p>
<p>typedef struct frameHeader<br>{<br>unsigned int sync1:8; //同步信息 1<br>unsigned int error_protection:1; //CRC 校验<br>unsigned int layer:2; //层<br>unsigned int version:2; //版本<br>unsigned int sync2:3; //同步信息 2<br>unsigned int extension:1; //版权<br>unsigned int padding:1; //填充空白字<br>unsigned int sample_rate_index:2; //采样率索引<br>unsigned int bit_rate_index:4; //位率索引<br>unsigned int emphasis:2; //强调方式<br>unsigned int original:1; //原始媒体<br>unsigned int copyright:1; //版权标志<br>unsigned int mode_extension:2; //扩展模式,仅用于联合立体声<br>unsigned int channel_mode:2; //声道模式<br>}FHEADER;</p>
<p>比特率为32的整数倍一般就是恒定编码，否则就是可变编码；可变编码帧头一般会有不同</p>
<h2 id="ID3V1标签帧"><a href="#ID3V1标签帧" class="headerlink" title="ID3V1标签帧"></a>ID3V1标签帧</h2><p>标签头是由128Byte组成的，具体含义如下</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char Header[3]</td>
<td>标签头必须是”TAG”否则认为没有标签</td>
</tr>
<tr>
<td>char Title[30]</td>
<td>标题</td>
</tr>
<tr>
<td>char Artist[30]</td>
<td>作者</td>
</tr>
<tr>
<td>char Album[30]</td>
<td>专集</td>
</tr>
<tr>
<td>char Year[4]</td>
<td>出品年代</td>
</tr>
<tr>
<td>char Comment[28]</td>
<td>备注</td>
</tr>
<tr>
<td>char reserve</td>
<td>保留</td>
</tr>
<tr>
<td>char track</td>
<td>音轨</td>
</tr>
<tr>
<td>char Genre;</td>
<td>类型</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
  </entry>
  <entry>
    <title>《Google工作法》</title>
    <url>/2023/02/06/Reading/Google%E5%B7%A5%E4%BD%9C%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/images/reading/GoogleWork.jpg" alt="img"></p>
<p>《google工作法》作者是彼得·费利克斯·格日瓦奇，针对google的一些工作方法论和个人经验的进行著书。我认为对于这类书籍的正确使用是通读全篇，二次阅读针对部分内容自己进行场景的带入，此类工具书籍可以经常来进行翻看对自己日常生活工作方式的判断</p>
<p>针对每个细分章节，总结并进行自己的思考</p>
<h1 id="Faster（※）"><a href="#Faster（※）" class="headerlink" title="Faster（※）"></a>Faster（※）</h1><h2 id="一次结束，当场做完"><a href="#一次结束，当场做完" class="headerlink" title="一次结束，当场做完"></a>一次结束，当场做完</h2><p>作者认为决定工作效率的关键在于对 现在 的使用方法。对于一件事情如果能够当场做完就不要推迟到以后，对于一项决定如果当场确定就不要推迟到未来。如果当时没有进行就解决或决定就需要做出相应的计划：要想解决这个问题，需要收集哪些必要的资源。具体策略如下：</p>
<p><img src="/images/reading/google-0.jpg" alt="img"></p>
<p>对自己来讲，我曾经负责某个项目，客户在问我一个技术相关的问题的时候，我当时的做法可能就没有很恰当。现在来看我认为正确的流程应该是：将我自己已知的内容对客户进行反馈；将自己不知道的内容如实告诉客户并询问他目前是否有空我去找一下相关负责人来解答他这个问题（<strong>如果现在有必要的话，现在就联系；如果现在应该决定的话，现在就决定</strong>），如果中途遇到其它问题不知道谁是负责人或者负责人不在，也必须做到相关解决方案做到有切实进展（活用身边的人/回来之后第一时间反馈等等），在第一时间内将问题进行解决，不拖延！！！</p>
<h2 id="设置deadline"><a href="#设置deadline" class="headerlink" title="设置deadline"></a>设置deadline</h2><p>能当场解决的问题一定要一次解决，而不能解决的问题一定要设置deadline，要有一种 如果现在不做那要什么时候做 的观念。对于纷杂的工作需要明确优先级、精细程度等因素。将自己的期限提前是提高效率的有效方法。</p>
<p>对于自己来讲，如果领导要求一项工作周五之前完成。那自己的deadline要设置在周三周四做好一个demo给领导查看。在工作进行之前需要明确事情的紧急程度、完成验收的标准、是否有其它注意事项等等</p>
<h2 id="集中精力于此时此刻"><a href="#集中精力于此时此刻" class="headerlink" title="集中精力于此时此刻"></a>集中精力于此时此刻</h2><p>正念（Mindfulness）的意思就是将意识集中于此时此刻，这一词同样被谷歌所采用。大脑就像是一个CPU应尽可能的减少大脑资源的浪费，对于任何一件事情尽可能要提前做准备。比如：前一天晚上就准备好第二天需要穿的衣服；会议前梳理会议的目的成员组织等等；任何一件事情可能发生的后果及相应的解决办法</p>
<p>分析眼前任务的正确方式：搞清楚”为什么需要解决这个问题“，”在什么时间之前必须得出答案“，设定好”目的与目标“之后全力以赴。比如会议之前的准备列表：</p>
<ul>
<li>为什么将大家召集到一起</li>
<li>要做出什么决定</li>
<li>要取得什么成果</li>
<li>通过会议后要得到什么收获</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li><p>增加现在的密度</p>
<p>针对自己来讲可以体现在：通勤路上进行书籍的阅读英语的学习等等，并行一些任务</p>
</li>
<li><p>减少邮件的使用，直接见面最有效率</p>
</li>
<li><p>合理使用工具</p>
<p>时间/时间管理工具（对于notion的使用没有持续）；整理的文档传至云端，随时查看修改</p>
</li>
<li><p>学习英语</p>
<p>目前很多第一手资料都是英文的，为了提高效率必须学会英文。否则内容的准确性排除在外，也是时间和成本的二次浪费</p>
</li>
</ol>
<h1 id="Sense-VS-sensibility"><a href="#Sense-VS-sensibility" class="headerlink" title="Sense VS sensibility"></a>Sense VS sensibility</h1><h2 id="创意思维的产生"><a href="#创意思维的产生" class="headerlink" title="创意思维的产生"></a>创意思维的产生</h2><p>与逻辑和分析相比“ 灵感（创意思维） ”更重要</p>
<p>通过人为地制造混乱，可以使潜意识活性化，从而更容易创造出新的创意。具体方案：准备几个透明文件袋，将各种图片、杂志、报纸剪下来的内容或写在纸上的关键词放在里面，通过任意物品的组合产生新的创意。为了引发这种“突然出现的创意瞬间”，最好的办法就是多准备一些能够激发灵感的资料</p>
<h2 id="直觉-x2F-逻辑场景"><a href="#直觉-x2F-逻辑场景" class="headerlink" title="直觉/逻辑场景"></a>直觉/逻辑场景</h2><p>经验的直觉和逻辑思考本身之间并没有孰优孰劣，两者各自适用于不同的情况，具有不同的作用。对于更重视感性的领域来说，直觉比逻辑更能够发挥作用。</p>
<h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><ol>
<li><p>与逻辑和分析相比”灵感“更重要</p>
</li>
<li><p>一味的模仿不可能实现差异化。</p>
<p>只对竞争对手的商品进行分析无法实现差异化。要想做出与众不同的商品，必须做到其它公司没有做到的事情。</p>
</li>
<li><p>企划会议不需要总结式报告。只确定一个会议议题，然后大家当场讨论</p>
</li>
<li><p>积极听取其它部门或者其它领域的人的意见</p>
</li>
</ol>
<h1 id="Efficiently"><a href="#Efficiently" class="headerlink" title="Efficiently"></a>Efficiently</h1><h2 id="将目标定为原来的10倍"><a href="#将目标定为原来的10倍" class="headerlink" title="将目标定为原来的10倍"></a>将目标定为原来的10倍</h2><p>工作生活中我们对于自己的要求往往是完成任务即可，但是最终的效果往往不尽如人意，可能只完成了七八成。因此在我们设置目标的时候不妨将目标设置的更大一点，既定目标的10倍。这个目标会倒逼自己打破束缚自己的条条框框和固有观念 ，另一方面，要想改变工作方法，必须敢于承担风险、打破规则。最终即使完成七八成也是一个很好的结果了</p>
<h2 id="Think-like-an-owner"><a href="#Think-like-an-owner" class="headerlink" title="Think like an owner"></a>Think like an owner</h2><p>像公司所有者一样思考。针对自己的工作岗位，以我的年收入应该取得多少的成果，想要取得这些成果需要做哪些工作，而每项工作应该有怎样的结果。这个过程中势必要优化自己的工作，着眼于重点工作内容减少工作中的无用功，吸取他人的经验寻求他人的帮助。同样也可以假设自己即将失业，如果没有工作没有了怎么办？想到这里自己的紧迫感油然而生</p>
<h2 id="活用20-原则"><a href="#活用20-原则" class="headerlink" title="活用20%原则"></a>活用20%原则</h2><p>在思考工作的有限顺序的时候，应该优先将时间放在 <strong>能学到很多东西而且影响力比较大</strong>的工作上。而其它类型的工作可以进行分配等等。可以进一步对二八定律进行了解学习</p>
<h2 id="必要的工作素养（※）"><a href="#必要的工作素养（※）" class="headerlink" title="必要的工作素养（※）"></a>必要的工作素养（※）</h2><ol>
<li><p>拥有预见性</p>
<ul>
<li>预见机会与威胁</li>
<li>寻找周期、趋势以及规律</li>
<li>短期、中期与长期思考。考虑<strong>“5/5/5规则”</strong>，即5周以后、5个月以后、5年以后会发生什么事情进行思考</li>
</ul>
</li>
<li><p>换位思考</p>
</li>
<li><p>敢于提出自己的见解</p>
</li>
<li><p>敢说真话（个人认为这一点还是具体情况具体分析）</p>
</li>
<li><p>主动承担责任</p>
</li>
<li><p>积极参与交流</p>
</li>
<li><p>打破常规</p>
</li>
<li><p>不害怕失败</p>
</li>
<li><p>勤于思考、保持质疑</p>
<p>遇到不明白的事情多问一个为什么</p>
</li>
<li><p>改变视角</p>
<p>整体视角；局部视角；反面视角；未来视角；顾客视角；竞争对手视角；特殊视角</p>
</li>
</ol>
<h1 id="Interpersonal-relationship"><a href="#Interpersonal-relationship" class="headerlink" title="Interpersonal relationship"></a>Interpersonal relationship</h1><h2 id="具象化思考"><a href="#具象化思考" class="headerlink" title="具象化思考"></a>具象化思考</h2><p>实物思考我将其总结为具象化思考。工作生活中别人有某项需求时，可以通过某种类比或实物来与对方确认表达是否一致。具体方案：可以是在一张草图上画出来向别人确认“您说的是这种类型吗？”；或者在讨论问题之前将讨论的内容总结到A4纸上，将比较抽象的事情具象化可以实操。这样是可以大幅度的减少交流的成本降低后期的无用功</p>
<h2 id="提升心理安全"><a href="#提升心理安全" class="headerlink" title="提升心理安全"></a>提升心理安全</h2><ul>
<li>心理安全：面对 我可以信赖你吗 或者 我能尊重你吗 这样的问题的时候能够给出肯定的答案</li>
</ul>
<p>得到他人的信赖和尊重也会使自己产生安全感。一旦构筑起信赖关系，交流双方就会像朋友一样，更容易的互相提出意见或建议，工作现场的气氛也会更加活跃。</p>
<h2 id="倾听（※）"><a href="#倾听（※）" class="headerlink" title="倾听（※）"></a>倾听（※）</h2><p>交流Tips：建立信赖关系最重要的一点就是倾听，最好的办法就是让自己对对方产生兴趣并将这种情绪传递给对方。另外，好不容易让对方说出自己的意见，绝对不能将对方的意见完全否定，不能让对方觉得“我说了也没用”的想法！！！</p>
<p>艾米·埃德蒙顿教授指出：不要将问题单纯地看成“需要解决的问题”，而是要将其看作“需要学习的问题”来进行讨论，这样不清楚的部分就会自然而然的浮现，也更容易让团队成员积极思考</p>
<h2 id="建立良好人际关系"><a href="#建立良好人际关系" class="headerlink" title="建立良好人际关系"></a>建立良好人际关系</h2><p>良好的人际关系是快速解决问题的基石</p>
<p>社会各行各业哪怕只要有一点点交集都足可以让对方和自己产生联系。而见到关键的人的时候正确的方式应该是：提前了解设想对方的课题，然后开门见山的根据课题内容进行提问，交流过程中表现出热情、平等的态度就可以心情舒畅的进行交流。在交流过程中还要需要注意 <strong>不要take而要give</strong>，要让别人看到自己的价值</p>
<p><strong>人际关系的优先顺序</strong>：新认识的人 &gt; 熟识的人；新认识并且不断改变自己的人 &gt; 新认识但变化不多的人</p>
<h1 id="Skill"><a href="#Skill" class="headerlink" title="Skill"></a>Skill</h1><h2 id="学习的正确方法"><a href="#学习的正确方法" class="headerlink" title="学习的正确方法"></a>学习的正确方法</h2><p>检索 + 询问专业人士·询问他人·询问同事</p>
<ul>
<li>检索：询问互联网这个老师</li>
<li>询问他人：<ol>
<li>找最擅长这项工作的人询问</li>
<li>询问之前要有自己的思考。带着假设带着思考去提问。具体可以有四要素：具体来说；要在什么地方；改变什么；怎么做才能让工作更顺利</li>
</ol>
</li>
</ul>
<h2 id="前馈与反馈"><a href="#前馈与反馈" class="headerlink" title="前馈与反馈"></a>前馈与反馈</h2><ul>
<li>前馈：找别人询问“我想解决这个问题，应该怎么办才好呢？”</li>
<li>反馈：事后的反思与经验总结</li>
</ul>
<p>要想获取有用的信息，提问的</p>
<p><img src="/images/reading/google-1.jpg" alt="img"></p>
<h2 id="多参加交流会"><a href="#多参加交流会" class="headerlink" title="多参加交流会"></a>多参加交流会</h2><p>为了保证自己的生存，最好多参加交流，不论是非正式聚会、公司外部会议等等，给自己多创造几个立足点。</p>
<p>同行业、同年龄的人呆在一起，谈论的事情都是相似的话题，无法从中获取到跟多有用的信息。在交流过程中，也要时刻思考“我应该给对方提供什么样的信息”，输出自己的价值</p>
<h1 id="Relax-Work"><a href="#Relax-Work" class="headerlink" title="Relax Work"></a>Relax Work</h1><h2 id="一分钟冥想"><a href="#一分钟冥想" class="headerlink" title="一分钟冥想"></a>一分钟冥想</h2><p>关闭电脑，将所有注意力都集中在自己的呼吸上，安静的坐在座位上</p>
<h2 id="并行任务与串行任务分类"><a href="#并行任务与串行任务分类" class="headerlink" title="并行任务与串行任务分类"></a>并行任务与串行任务分类</h2><p>比如通勤过程中进行书籍的阅读、听音频等等</p>
<p>而一旦专注于某项工作就尽可能排除外部的干扰，可以尝试将手机静音、放远一点等等操作</p>
<h2 id="睡午觉、吃零食、放松是自己的责任"><a href="#睡午觉、吃零食、放松是自己的责任" class="headerlink" title="睡午觉、吃零食、放松是自己的责任"></a>睡午觉、吃零食、放松是自己的责任</h2><h1 id="Final-Innovation"><a href="#Final-Innovation" class="headerlink" title="Final Innovation"></a>Final Innovation</h1><ol>
<li>思考如何使用AI替代自己的工作</li>
<li>站在革新一侧不袖手旁观，改变自己坚持但不好的习惯，合理使用现代化工具</li>
<li>就算对技术细节不了解，也要跟上趋势</li>
<li>工作不能和昨天一样</li>
</ol>
<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><ol>
<li><p>不要认为“公司就是自己的办公室”，而要时刻记住“自己在哪哪里就是办公室”</p>
</li>
<li><p>会议的目的不是将所有人召集到一起，而是取得结果，所以只需要召集对取得结果有帮助的成员即可</p>
</li>
<li><p>邮件是“等待文化”，即时通信是“实时文化”</p>
</li>
<li><p>工程项目的冲刺阶段一般都会采用“规定期限，集中精神”的工作方法</p>
</li>
<li><p>明确工作的优先顺序和品质要求是专业人士的基本素养</p>
</li>
<li><p>工作的目的并不是“从早9点到晚6点坐在同一个地方“，而是取得令人满意的成果（舒适的工作环境至关重要）</p>
</li>
<li><p>没有结论的分析毫无意义</p>
</li>
<li><p>创意思维需要的是灵感以及丰富经验的直觉</p>
</li>
<li><p>只有敢于走出舒适区才能取得更大的成果</p>
</li>
<li><p>公司之所以给你高额薪水，是因为你能做到别人无法做到的困难工作</p>
</li>
<li><p>交流最大的目的是构筑信赖关系 </p>
</li>
<li><p>当人感觉到自己受到了尊重或者别人很重视我的时候，就会将自己的内心从防备中解放出来</p>
</li>
<li><p>在好奇心驱使下不断的追求自己感兴趣的东西，这将成为你职场中的通行证</p>
</li>
<li><p>应该学习的不是知识而是经验</p>
</li>
<li><p>人的成长就像斐波那契数列，昨天的自己加上前天的自己才是今天的自己</p>
</li>
<li><p>多次实践不但有助于提高自信，更能加快掌握速度</p>
</li>
<li><p>拥有的“选项”越多，在竞争中生存的可能性就越大</p>
</li>
<li><p>究竟是选择站在革新的一侧还是选择袖手旁观，不同的选择带来的结果可谓是天壤之别 </p>
</li>
<li><p>找到在巨变洪流中发挥自己能力并且赚取利润的方法</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Opus Ogg详解</title>
    <url>/2023/01/04/Audio/Audio-opus/</url>
    <content><![CDATA[<h1 id="opus是什么"><a href="#opus是什么" class="headerlink" title="opus是什么"></a>opus是什么</h1><blockquote>
<p>以下内容取自opus官网：<a href="https://www.opus-codec.org/">https://www.opus-codec.org</a></p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Opus 是一种完全开放、免版税、用途广泛的音频编解码器。 Opus 在 Internet 上的交互式语音和音乐传输方面无与伦比，但也适用于存储和流媒体应用。它被互联网工程任务组 (IETF) 标准化为 RFC 6716，它结合了 Skype 的 SILK 编解码器和 Xiph.Org 的 CELT 编解码器的技术。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Opus 可以处理范围广泛的音频应用，包括 IP 语音、视频会议、游戏内聊天，甚至远程现场音乐表演。它可以从低比特率窄带语音扩展到非常高质量的立体声音乐。支持的功能有：</p>
<ul>
<li>比特率从 6 kb/s 到 510 kb/s</li>
<li>采样率从 8 kHz（窄带）到 48 kHz（全带）</li>
<li>帧大小从 2.5 ms 到 60 ms</li>
<li>支持恒定比特率 (CBR) 和可变比特率 (VBR)</li>
<li>从窄带到全带的音频带宽</li>
<li>支持语音和音乐</li>
<li>支持单声道和立体声</li>
<li>支持多达 255 个通道（多流帧）</li>
<li>动态可调比特率、音频带宽和帧大小</li>
<li>良好的丢包鲁棒性和丢包隐藏 (PLC)</li>
<li>浮点和定点实现</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>音频带宽。Opus编码器覆盖了低频段到高频段的全带音频</p>
</li>
<li><p>低延迟。延迟依赖于帧规格，Opus最低帧规格2.5ms，非常适合实时音视频场景</p>
</li>
</ul>
<h1 id="opus库"><a href="#opus库" class="headerlink" title="opus库"></a>opus库</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>编解码器libopus: <a href="https://www.opus-codec.org/docs/opus_api-1.2/index.html">https://www.opus-codec.org/docs/opus_api-1.2/index.html</a></p>
<p>封装器opusfile：<a href="https://www.opus-codec.org/docs/opusfile_api-0.7/index.html">https://www.opus-codec.org/docs/opusfile_api-0.7/index.html</a></p>
</blockquote>
<p>opus库包括三部分：libopus、opus-tools、opusfile</p>
<ul>
<li>libopus：opus编解码的源码和可执行文件（注意：这里编码出来的opus文件是播放不了的，并且解码也必须用那种播放不了的opus文件,后面解释为什么）</li>
<li>opus-tools：工具包，其中包含了libogg（.wav2.opus  /  .opus2.wav）</li>
<li>opusfile：将可播放的opus文件解码成wav的工具，可分析出这个可播放的opus文件的信息，其中包含了libogg</li>
</ul>
<h2 id="可播放opus与不可播放opus文件"><a href="#可播放opus与不可播放opus文件" class="headerlink" title="可播放opus与不可播放opus文件"></a>可播放opus与不可播放opus文件</h2><p>ogg文件里面包含了opus编码的音频，相当于MP4文件中包含了aac</p>
<ul>
<li>不可播放opus：只有编码层opus数据的音频（没有ogg的封装只经过libopus编码），后缀名是.opus</li>
<li>可播放的opus：opus编码的音频外部套用了一层ogg的封装（经过ogg的封装，opus-tools编码的文件），后缀名可以是.opus也可以是.ogg</li>
</ul>
<h1 id="opus结构"><a href="#opus结构" class="headerlink" title="opus结构"></a>opus结构</h1><p>每个 Opus 包以一个 TOC （Table of Contents）字节开头</p>
<table>
<thead>
<tr>
<th>配置数（config）</th>
<th>编码模式</th>
<th>音频带宽</th>
<th>帧长度</th>
</tr>
</thead>
<tbody><tr>
<td>0…3</td>
<td>SILK-only</td>
<td>NB</td>
<td>10, 20, 40, 60 ms</td>
</tr>
<tr>
<td>4…7</td>
<td>SILK-only</td>
<td>MB</td>
<td>10, 20, 40, 60 ms</td>
</tr>
<tr>
<td>8…11</td>
<td>SILK-only</td>
<td>WB</td>
<td>10, 20, 40, 60 ms</td>
</tr>
<tr>
<td>12…13</td>
<td>Hybrid</td>
<td>SWB</td>
<td>10, 20 ms</td>
</tr>
<tr>
<td>14…15</td>
<td>Hybrid</td>
<td>FB</td>
<td>10, 20 ms</td>
</tr>
<tr>
<td>16…19</td>
<td>CELT-only</td>
<td>NB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
<tr>
<td>20…23</td>
<td>CELT-only</td>
<td>WB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
<tr>
<td>24…27</td>
<td>CELT-only</td>
<td>SWB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
<tr>
<td>28…31</td>
<td>CELT-only</td>
<td>FB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
</tbody></table>
<p>立体声标志位（s）取值 0 表示单声道，1 表示多声道立体声。</p>
<p>TOC 中最后两位（c）表示：</p>
<ul>
<li>0：一个包中只有一帧音频。</li>
<li>1：一个包中有两帧音频，并且大小相同。</li>
<li>2：一个包中有两帧音频，但是大小不同。</li>
</ul>
<h1 id="opusfile-API"><a href="#opusfile-API" class="headerlink" title="opusfile API"></a>opusfile API</h1><blockquote>
<p>opusfile高级API官方文档：<a href="https://opus-codec.org/docs/opusfile_api-0.12/">https://opus-codec.org/docs/opusfile_api-0.12/</a></p>
<p>参考文档：</p>
<p>​	<a href="https://juejin.cn/post/6844903998831460360">https://juejin.cn/post/6844903998831460360</a></p>
<p>​	<a href="https://chenliang.org/2020/04/17/ogg-encapsulation-for-opus/">https://chenliang.org/2020/04/17/ogg-encapsulation-for-opus/</a></p>
</blockquote>
<ol>
<li><p><strong>op_open_file() / op_free()</strong></p>
<p>打开/关闭一个解码器</p>
</li>
<li><p><strong>op_head() / op_tags()</strong></p>
</li>
</ol>
<ul>
<li><p>op_head函数可用于获取channels、samplerate等参数</p>
</li>
<li><p>op_tags函数可获得用户自定义参数，例如：标题、歌手、编码方式标准等等，其中tags-&gt;user_comments[i]可获取用户自定义的信息</p>
</li>
</ul>
<ol start="3">
<li><strong>op_pcm_total() / op_pcm_tell() / op_pcm_seek()</strong></li>
</ol>
<ul>
<li>op_pcm_total 可以返回该opus文件转换成pcm文件后的总的pcm长度</li>
<li>op_pcm_tell 可以放回目前文件已经播放的pcm的长度</li>
<li>op_pcm_seek 可以通过参数指定让音频进行跳转播放</li>
</ul>
<ol start="4">
<li><strong>op_pcm_read()</strong></li>
</ol>
<p>   从op_open_file打开的文件流中读取pcm数据进行播放。注意解码的数量并不等于传入buffer的大小，需要使用到该函数的返回值</p>
<h1 id="Ogg"><a href="#Ogg" class="headerlink" title="Ogg"></a>Ogg</h1><blockquote>
<p> 参考 : <a href="https://juejin.cn/post/6844904016254599175">https://juejin.cn/post/6844904016254599175</a></p>
</blockquote>
<p>全称：OGGVobis(oggVorbis) 一个自由且开放标准的容器格式，“.ogg”结尾命名</p>
<p>OGG是以页（page）为单位将逻辑流组织链接起来，每个页都有pageheader和pagedata。</p>
<ol>
<li>capture_pattern页标识：ASCII字符，0x4f ‘O’ 0x67 ‘g’ 0x67 ‘g’ 0x53 ‘S’，4个字节大小，它标识着一个页的开始。</li>
<li>stream_structure_version版本id：一般当前版本默认为0，1个字节。</li>
<li>header_type_flag类型标识：标识当前的页的类型，1个字节， - 0x01：本页媒体编码数据与前一页属于同一个逻辑流的同一个packet，若此位没有设，表示本页是以一个新的packet开始的； - 0x02：表示该页为逻辑流的第一页，bos标识，如果此位未设置，那表示不是第一页； - 0x04：表示该页位逻辑流的最后一页，eos标识，如果此位未设置，那表示本页不是最后一页。</li>
<li>granule_position：媒体编码相关的参数信息，8个字节，对于音频流来说，它存储着到本页为止逻辑流在PCM输出中采样码的数目，可以由它来算得时间戳。对于视频流来说，它存储着到本页为止视频帧编码的数目。若此值为-1，那表示截止到本页，逻辑流的packet未结束。(小端)</li>
<li>serial_number：当前页中的流的id，4个字节，它是区分本页所属逻辑流与其他逻辑流的序号，我们可以通过这个值来划分流。(小端)</li>
<li>page_seguence_number：本页在逻辑流的序号，4个字节。</li>
<li>CRC_cbecksum：循环冗余效验码效验，4个字节，用来效验每页的有效性。</li>
<li>number_page_segments：给定本页在segment_table域中出现的segement个数，1个字节。</li>
<li>segment_table：从字面看它就是一个表，表示着每个segment的长度，取值范围是0~255。由segment（1个segment就是1个字节）可以得到packet的值，每个packet的大小是以最后一个不等于255的segment结束的，从页头中的segment_table可以得到每个packet长度，举例：如果一组segment依次顺序为FF 45 FF FF FF 40FF 05FF FF FF 66（共4个packet，含12个segment，每个packet的长度是：FF 45【324】；FF FF FF 40【829】；FF 05【260】；FF FF FF 66【847】），那么第一个packet的长度为255+69 = 324,第二个packet大小829，同理。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
      <tags>
        <tag>opus</tag>
      </tags>
  </entry>
  <entry>
    <title>《人类群星闪耀时》</title>
    <url>/2023/03/18/Reading/%E4%BA%BA%E7%B1%BB%E7%BE%A4%E6%98%9F%E9%97%AA%E8%80%80%E6%97%B6/</url>
    <content><![CDATA[<p><img src="/images/reading/RenLeiQunXing.jpg" alt="img"></p>
<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>和这本书的渊源应该还是在通勤路上使用得到APP听到的对该书的解读。贾行家老师的解读风格一直是我所喜欢的，通过他的语言我大致了解到这本书讲述的是14个历史的决定性瞬间，当然一定是针对世界的，而其实作者默认将西方世界等同于世界。我自己其实对于西方历史的了解程度一直停留在初中历史书的层面。当听到这十四个历史的决定性瞬间包含了滑铁卢战役、马赛曲、拜占庭帝国等等相关内容，我一下子便提起了兴趣，这些耳熟能详的故事后面究竟有什么故事，带着好奇开始了这本书的阅读。</p>
<p>小注：由于这本书的中文译本高达几十种，我在买书的时候也没有看好，买的书只包含十个瞬间。其它缺失的应该包含：列夫托尔斯泰、菲尔德（建立第一条跨洋电缆）、威尔逊（美国第二十八任总统）、巴塞罗。有机会的话这几个也要补回来。</p>
<h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>这本书的作者是斯蒂芬·茨威格，被誉为”历史上最好的传记作家“。茨威格1881年出生在奥地利犹太的富商家庭，这个时间和身份注定他的命运不平凡。二战时期，茨威格因为反战纳粹被驱逐，随后流亡英国、美国、巴西，他的代表作包括&lt;&lt;象棋的故事&gt;&gt;、《昨日的世界》、《三大师传》等等</p>
<h1 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h1><p>能够读完整本书就已经说明足够吸引人了。整体上这本书的跨度很大，包括时间跨度、人物类型跨度等等，最远的讲到公元前1实际的古罗马政治危机（穆罕默德二世），近的可以到一战后的巴黎和会（威尔逊）；而在类型上有历史上伟大的政治家拿破仑、伟大的音乐家亨德尔、甚至包括我们可能完全不熟悉的马赛曲的作者鲁热……</p>
<p>在语言风格上，用贾行家的老师话可以说是，茨威格高贵的气质、优雅的文风和理想主义的笔调尽显无疑。除此之外，这本书给我的另一个感受就是细节刻画非常到位，但是呢这些细节更像是作者本人设身处地的理解人物在某个时刻某个场景下的心理活动。这对于历史纪实可能并不友好但是我觉得对于我们读者理解人物的形象可以说非常到位了！</p>
<p>例子：</p>
<ol>
<li>人民也许永远不会知道，那扇因为疏忽敞开的凯尔卡门在那次命运攸关的时刻，为人类带来了多么大的灾难</li>
<li>也许格鲁希自己根本没有想到的是在他思考的这一秒钟，却决定了拿破仑和他自己的命运，甚至世界命运的一秒钟</li>
<li>刽子手铡刀一闪，这个人类第一双同时见过两大海洋的眼睛，永远熄灭了神采（巴尔沃亚）</li>
</ol>
<h1 id="记忆点及感受"><a href="#记忆点及感受" class="headerlink" title="记忆点及感受"></a>记忆点及感受</h1><p>我在阅读西方历史的时候的我首先关注的变量就是时间节点，在什么时刻发生了这个事件，而接下来我要了解的就是在这个时间节点上我们自己的这片土地处于哪个朝代发生着什么样的故事。古代的中国各方面还是处于先进水平，但是到了明清时期很明显的感受到西方各种科技、灿烂文化涌现，而我们自己的国家始终在一个内忧外患的阶段，科技文化的积累也在这个时期落后于世界</p>
<p>我自己并对于文学没有可以说没啥天赋对于尼采啊、巴尔沃亚等人故事也没有提起很大的兴趣，相反对于拿破仑、鲁热等人还是蛮感兴趣的。对于不明白滑铁卢战役全过程的人来讲（之前的我）大多数都会归咎于拿破仑，但是究竟如何失败哪里失败却说不出所以然。读完这一部分我反倒觉得没有任何人该承担这一责任，但按照书籍的理论，由于格鲁希将军的不会变通导致了滑铁卢战役的最终胜利。历史是由胜利者来书写的，失败者却连狡辩的机会都没有。我们现在知道结果是这个样子，假设当时战争的细节是另外一种样子而格鲁希将军选择驰援滑铁卢我们可能又会认为是他的主动性太强导致了最终的失败。所以终究还是战争的残酷性和不确定性导致了最终的结果。尽人事听天命，大概说的就是这个含义吧，把握我们所能把握的，剩下的就看天意。</p>
<h1 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h1><p>穆罕默德二世—-拜占庭的沦陷</p>
<ul>
<li>历史上所有以理智换来的和平都是转瞬即逝的</li>
<li>出奇制胜往往是所有伟大军事行动中取得胜利的关键</li>
<li>人世间空前团结的场面总是在最危急的关头才会出现</li>
<li>人类的历史和一个人的一生是一样的，一失足成千古恨</li>
</ul>
<p>巴尔沃亚—-在不朽的事业里寻求保护</p>
<ul>
<li>能够在生命的中途，也就是年轻力壮的时候找到自己肩负的使命，这真的是人生最美好的事情</li>
</ul>
<p>鲁热—-一个流星般的天才</p>
<ul>
<li>在这个世界上，从来就不会有哪一部蕴含强大能量的作品被埋没或者长久的被封存，也不会有哪一件优秀的艺术品随着时间的流逝而被遗忘，虽然有暂时被禁锢或者埋没的可能，但终究还是生命力的，他会冲破所有阻碍，脱颖而出</li>
</ul>
<p>拿破仑—-决定命运的一分钟</p>
<ul>
<li>命运只愿意成就那些勇敢者。当重任降临到平庸之辈身上时，他们不是感到庆幸，而是害怕。他们把这个成为命运主人的机会，哆哆嗦嗦地失掉了</li>
<li>命运——这掌管世间世界的另一个神，他强有力的双臂只愿高高举起勇敢者，将他们送上英雄的殿堂</li>
</ul>
<p>尼采—-向宇宙高峰走去</p>
<ul>
<li>无法将我置之死地的，更令我坚强</li>
</ul>
<p>斯科特—-争夺南极之战</p>
<ul>
<li>相较于作品中的悲剧，生活本身创造出的悲剧要多一千倍</li>
<li>悲壮的失败依然光荣，这样的失败能够激起人们继续挑战险境的勇气，因为只有雄心壮志才能将满怀的激情点燃，去完成那历经千难万险才能完成的事</li>
</ul>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio-初识</title>
    <url>/2022/08/31/Audio/Audio-meet/</url>
    <content><![CDATA[<p>跳动的音符，婉转的节奏，悠扬的歌声……</p>
<p>音乐无疑是最能愉悦身心的方式之一，那么歌手的音调、音色是如何存储到手机中，又是如何通过喇叭播放出来的呢？</p>
<p>下面我将通过几篇博客阐述我对音频的理解及部分调试经验，本章主要介绍音频的的基础知识</p>
<h1 id="信号分类"><a href="#信号分类" class="headerlink" title="信号分类"></a>信号分类</h1><p>声音严格意义来讲应该被叫做声音信号，而在维基百科中对于<strong>信号</strong>的定义是<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E9%87%8F/9984692">表示消息的物理量</a>，这样就很好理解了声音信号就是以声音为载体的一个物理量。而自然界中信号可以有如下的分类</p>
<p><img src="/images/linux/Audio/Audio-meet-1.png" alt="signal"></p>
<p>因此，按照信号变化分类声音信号属于随机信号；按照信号特征分类声音信号属于模拟信号</p>
<h1 id="模数转换"><a href="#模数转换" class="headerlink" title="模数转换"></a>模数转换</h1><p>上一部分了解到声音是模拟信号，而对于计算机来讲其只能处理数字信号即0和1，所以必须需要将声音模拟信号转换成数字信号，而这个过程叫做模数转换（Analog Digital Conversion），相应的完成该功能的硬件单元就叫做模数转换器(ADC)</p>
<p>完成该过程需要三部曲分别是：采样、量化、编码，整体过程如下图：</p>
<p><img src="/images/linux/Audio/Audio-meet-2.png" alt="ADC"></p>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p><em>重要参数：采样率</em></p>
<ul>
<li>定义：在时间轴上对信号进行离散化</li>
<li>原理：按照一定的频率对模拟信号的瞬时时刻进行样本采集</li>
</ul>
<p>其实采样作用通俗理解就是是采集样本。由于模拟信号是连续的，理论上我们需要采集无数个点才能完整的还原该信号，但是一来无穷的概念是不可能满足的，二来我们其实并不需要这么高的采样率。我们听觉是有延迟的就和视频帧不停的刷新欺骗我们的眼睛是画面连续的是一个道理。</p>
<p>所以采样率越高，声音的还原就越真实越自然，人对频率的识别范围是 20HZ - 22000HZ, 如果每秒钟能对声音做 22000 个采样, 回放时就足可以满足人耳的需求. 所以 22050 的采样频率是常用的, 44100已是CD音质, 超过48000的采样对人耳已经没有意义。这和电影的每秒 24 帧图片的道理差不多。</p>
<h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p><em>相关参数：采样位数</em></p>
<ul>
<li><p>定义：在幅度轴上对信号进行数字化</p>
</li>
<li><p>原理：对采样点的幅度赋予具体的数值，该数值由n位二进制表征（n = 8 / 16 / 32）</p>
</li>
</ul>
<p>采样位数越高说明划分的等级越精细。较低的采样位数损失精度，较高的采样位数可能造成软硬件资源的浪费</p>
<blockquote>
<p>小常识：标准CD音乐的质量就是16bit、44.1KHz采样</p>
</blockquote>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>定义：按照一定的格式记录 采样 和 量化 后的数据。后续会对部分格式的存储格式进行分析</p>
<h3 id="编码分类"><a href="#编码分类" class="headerlink" title="编码分类"></a>编码分类</h3><blockquote>
<p> 该部分内容转自 <a href="https://www.jianshu.com/p/28d3f108ef63">https://www.jianshu.com/p/28d3f108ef63</a></p>
</blockquote>
<h4 id="波形编码"><a href="#波形编码" class="headerlink" title="波形编码"></a>波形编码</h4><ul>
<li>定义：不利用生成音频信号的任何参数，直接将 <strong>时间域信号</strong> 变换为 <strong>数字代码</strong>，使重构的语音波形尽可能地与原始语音信号的 波形形状 保持一致。</li>
<li>原理：在 <strong>时间轴</strong> 上对模拟语音信号按一定的速率抽样，然后将幅度样本分层量化，并用代码表示。</li>
</ul>
<h4 id="参数编码"><a href="#参数编码" class="headerlink" title="参数编码"></a>参数编码</h4><p>从语音 <strong>波形信号</strong> 中提取生成语音的参数，使用这些参数通过语音生成模型重构出语音，使重构的语音信号尽可能地保持原始语音信号的语意。也就是说，参数编码是把语音信号产生的数字模型作为基础，然后求出数字模型的模型参数，再按照这些参数还原数字模型，进而合成语音。</p>
<h4 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h4><p>混合编码是指同时使用两种或两种以上的编码方法进行编码。这种编码方法克服了波形编码和参数编码的弱点，并结合了波形编码高质量和参数编码的低编码率，能够取得比较好的效果。</p>
<ul>
<li><p>WAV编码（波形编码）</p>
<p>WAV是编码的一种实现方式（其实它有非常多实现方式，但都是不会进行压缩操作）。就是在源 <strong>PCM</strong> 数据格式的前面加上44个字节。分别用来描述 <strong>PCM</strong> 的采样率、声道数、数据格式等信息。</p>
</li>
<li><p>MP3编码</p>
<p>MP3编码具有不错的压缩比，而且听感也接近于WAV文件，当然在不同的环境下，应该调整合适的参数来达到更好的效果。</p>
</li>
<li><p>AAC编码</p>
</li>
</ul>
<p>  AAC是目前比较热门的有损压缩编码技术，并且衍生了LC-AAC、HE-AAC、HE-AAC v2 三种主要编码格式。</p>
<p>  <strong>LC-AAC：</strong>是比较传统的AAC,主要应用于中高码率的场景编码(&gt;= 80Kbit/s)<br>   <strong>HE-AAC：</strong> 主要应用于低码率场景的编码(&lt;= 48Kbit/s)</p>
<ul>
<li><p>Ogg编码（有损）</p>
<p>Ogg编码是一种非常有潜力的编码，在各种码率下都有比较优秀的表现。尤其在低码率场景下。Ogg除了音质好之外，Ogg的编码算法也是非常出色。可以用更小的码率达到更好的音质。128Kbit/s的Ogg比192Kbit/s甚至更高码率的MP3更优质.但目前由软件还是硬件支持问题,都没法达到与MP3的使用广度.</p>
</li>
</ul>
<h1 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h1><p>一段悠扬的音乐经过采样、量化、编码就保存数字信号文件，而我们最终的目的一定不是只存成文件而是通过文件形式传播让更多人听到该音乐，因此一定存在DA转换，即还原数字信号为模拟信号的过程。那么在整个过程中有哪些参数表征了音频重要的信息呢？</p>
<p>不仅限于webrtc、ffmpeg、libmad等等音频编解码库，对于所有编解码器和codec来讲，音频源数据的三个参数至关重要：<strong>声道channel、采样率sampleRate、采样位数sampleBit</strong>。这三个参数之所以重要是因为有这几个参数就可以准确的知道一个裸的音频数据（PCM）的全部信息了。</p>
<h2 id="声道"><a href="#声道" class="headerlink" title="声道"></a>声道</h2><p>声道是指音频文件在录制时音源的数量位置和播放时相应的扬声器的数量（百度百科）。所以可想而知，其他参数相同的情况下，声道数越多定位越精准，同样所需扬声器和功放组件越多。</p>
<ul>
<li>单声道（mono）</li>
<li>双声道（stereo 立体声）：左声道 + 右声道，低音不分离，应用于音乐播放较多</li>
<li>2.1声道 ：左声道 + 右声道， 低音分离</li>
<li>5.1声道 ：左声道 + 右声道 + 低音声道 + 中央声道 + 左环绕 + 右环绕，应用于类传统影院和家庭影院中</li>
<li>7.1声道 ：左声道 + 右声道 + 低音声道 + 中央声道 + 左环绕 + 右环绕 + 左后环 + 右后环，常见的包括：Dolby Surround 7.1杜比7.1环绕声</li>
</ul>
<h2 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h2><p>采样率可以理解为采集样本的速率（故也可以称为采样速度或者采样频率），它定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。</p>
<p>例如：采样率为44100，意味着每秒钟对连续的声音信号采集44100次，同样对应得到的数字信号每秒的样本数量（具体可以参考采样过程）</p>
<h2 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h2><p>采样位数就是指某一瞬时时刻，量化声音大小（精细程度）的计量单位</p>
<ul>
<li>8bit ( 1Byte ) 对应0~255，将振幅划分为256个等级</li>
<li>16bit (2Byte) 对应0~65535，将振幅划分为65536个等级</li>
</ul>
<h2 id="样本格式"><a href="#样本格式" class="headerlink" title="样本格式"></a>样本格式</h2><h3 id="样本组合形式"><a href="#样本组合形式" class="headerlink" title="样本组合形式"></a>样本组合形式</h3><ul>
<li>交错模式：每个声道的样本数据交错存储排布</li>
<li>平面模式：每个声道的样本数据分开存储</li>
</ul>
<p>下面以stereo模式进行图示解释（C代表Channel）：</p>
<p>​    <img src="/images/linux/Audio/Audio-meet-3.png" alt="sample"></p>
<h3 id="FFmpeg-样本组织形式介绍"><a href="#FFmpeg-样本组织形式介绍" class="headerlink" title="FFmpeg 样本组织形式介绍"></a>FFmpeg 样本组织形式介绍</h3><ul>
<li>Packed格式，frame.data[0]包含所有的音频数据。</li>
<li>Planar格式，frame.data[i]表示第i个声道的数据（假设声道0是第一个）</li>
</ul>
<h3 id="FFmpeg-主要样本格式"><a href="#FFmpeg-主要样本格式" class="headerlink" title="FFmpeg 主要样本格式"></a>FFmpeg 主要样本格式</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AVSampleFormat</span> {</span></span><br><span class="line">    AV_SAMPLE_FMT_NONE = <span class="number">-1</span>,</span><br><span class="line">    AV_SAMPLE_FMT_U8,          <span class="comment">///&lt; unsigned 8 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S16,         <span class="comment">///&lt; signed 16 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S32,         <span class="comment">///&lt; signed 32 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_FLT,         <span class="comment">///&lt; float</span></span><br><span class="line">    AV_SAMPLE_FMT_DBL,         <span class="comment">///&lt; double</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_U8P,         <span class="comment">///&lt; unsigned 8 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S16P,        <span class="comment">///&lt; signed 16 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S32P,        <span class="comment">///&lt; signed 32 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_FLTP,        <span class="comment">///&lt; float, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_DBLP,        <span class="comment">///&lt; double, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S64,         <span class="comment">///&lt; signed 64 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S64P,        <span class="comment">///&lt; signed 64 bits, planar</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_NB           <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>说明：以P为结尾的是planar结构；Planar模式是FFmpeg内部存储模式，我们实际使用的音频文件都是Packed模式的。</p>
<h2 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h2><p>比特率指的是单位时间播放连续的媒体如压缩后的音频或视频的比特数量，在这个意义上讲，它相当于术语数字带宽消耗量，或吞吐量。单位bps / Kbps（bit per second）这里是bit而不是Byte（1Byte = 8bit）</p>
<p>虽然经常作为“速度”的参考，比特率并不测量“‘距离’/时间”，而是被传输或者被处理的“‘二进制码数量’/时间”，所以应该把它和传播速度区分开来，传播速度依赖于传输的介质并且有通常的物理意义。（来自维基百科）</p>
<h2 id="参数关系"><a href="#参数关系" class="headerlink" title="参数关系"></a>参数关系</h2><p>对于PCM裸数据： 文件时长 ≈（文件总大小 - 头信息）/ (采样率 * 采样位数 * 通道数 / 8) [也就是比特率]</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
  </entry>
  <entry>
    <title>《嵌入式C语言自我修养》笔记</title>
    <url>/2023/03/13/Reading/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<p><img src="/images/reading/QianRuShiC.jpg" alt="img"></p>
<h1 id="GNU-C编译器扩展语法精讲（六）"><a href="#GNU-C编译器扩展语法精讲（六）" class="headerlink" title="GNU C编译器扩展语法精讲（六）"></a>GNU C编译器扩展语法精讲（六）</h1><p>github Demo：<a href="https://github.com/yangLieee/codebackup/blob/master/book_%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/gnuc.c">click here</a></p>
<h2 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 数组初始化</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">100</span>] = { [<span class="number">10</span>] = <span class="number">1</span>, [<span class="number">20</span>] = <span class="number">3</span> };</span><br><span class="line"></span><br><span class="line"># ... 前后都需要空格，并且该特性也可以用在<span class="keyword">switch</span>-<span class="keyword">case</span>语句中</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">100</span>] = { [<span class="number">10</span> ... <span class="number">20</span>] = <span class="number">1</span>, [<span class="number">40</span> ... <span class="number">50</span>] = <span class="number">2</span> };</span><br><span class="line"><span class="keyword">switch</span>(i) {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> ... <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 结构体成员初始化  (通过结构域名)</span><br><span class="line">例如linux内核：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">const</span> <span class="title">file_opt</span> <span class="title">codec_opt</span> =</span> {</span><br><span class="line">    .open = codec_open,</span><br><span class="line">    .read = codec_read,</span><br><span class="line">    .write = codec_write,</span><br><span class="line">} </span><br><span class="line">好处：灵活，代码易于维护</span><br></pre></td></tr></tbody></table></figure>

<h2 id="语句表达式"><a href="#语句表达式" class="headerlink" title="语句表达式"></a>语句表达式</h2><ul>
<li>目的：构造复杂宏</li>
<li>结构：（ {  表达式1; 表达式2;  表达式3  } ） 语句表达式用（）小括号括起来，代码块用 { } 大括号括起来，语句表达式的值等于最后一个表达式的值</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol>
<li><p>求和</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">sum = ( {</span><br><span class="line">     <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&gt;) </span><br><span class="line">        s = s +i;</span><br><span class="line">     s;</span><br><span class="line">} )</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>定义一个宏，求两个数的最大值？</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> my_max(x,y)   ({    \</span></span><br><span class="line"><span class="meta">    typeof(x) _x = (x);     \</span></span><br><span class="line"><span class="meta">    typeof(y) _y = (y);     \</span></span><br><span class="line"><span class="meta">    (void) (&amp;_x == &amp;_y);    \</span></span><br><span class="line"><span class="meta">    _x &gt; _y ? _x : _y;      \</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"><span class="comment">// 第六行的作用：不同类型的指针比较会给出警告，加void消除没有用到比较结果带来的警告</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="container-of宏"><a href="#container-of宏" class="headerlink" title="container_of宏"></a>container_of宏</h2><ul>
<li><p>作用：根据结构体某一成员地址，获取这个结构体的首地址</p>
</li>
<li><p>场景：传给某个函数的参数是某个结构体的成员变量，在这个函数中还可能用到这个结构体其它变量</p>
</li>
<li><p>基础：常量指针的值即为常量本身的值。0强转为结构体指针，结构体的首地址为0，每个成员变量都是首地址的相对偏移</p>
</li>
<li><p>实现</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offset( TYPE , MEMBER ) ((size_t) &amp; (((TYPE*)0)-&gt;MEMBER))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) ({                    \                    </span></span><br><span class="line">            <span class="type">const</span> <span class="title function_">typeof</span><span class="params">(((type*)<span class="number">0</span>)-&gt;member)</span>* _ptr = (ptr);   \</span><br><span class="line">            (type*) ((<span class="type">char</span>*)_ptr - offset(type, member));     \                              </span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="零长数组"><a href="#零长数组" class="headerlink" title="零长数组"></a>零长数组</h2><ul>
<li>定义：长度为0的数组</li>
<li>优点：不占用内存存储空间</li>
<li>其它：C99支持变长数组，即长度编译时期是不能确定，在运行时才可以确定</li>
<li>应用：变长结构体</li>
<li>数组与指针区别：数组名用来表征一块连续的内存地址空间，仅仅是符号不分配空间；指针是一个变量，编译器需要单独给它分配一个内存空间，用来存放他指向的变量的地址。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> {</span></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> ptr[<span class="number">0</span>];  <span class="comment">// 不占大小</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span>* <span class="title">buf</span>;</span></span><br><span class="line">buf = (<span class="keyword">struct</span> buffer*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> buffer) + <span class="number">100</span>);</span><br><span class="line">buf-&gt;len = <span class="number">100</span>;</span><br></pre></td></tr></tbody></table></figure>



<h2 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>__attribute__</p>
<ul>
<li>作用：指导编译器在编译程序的时候进行特定方面优化或代码检查</li>
<li>格式：<strong>attribute</strong>(( ))，后面需要写两对小括号，多个属性之间逗号隔开</li>
<li>支持的属性声明：section、aligned、packed、format、weak、alias、noinline、always_inilne</li>
</ul>
<h3 id="section"><a href="#section" class="headerlink" title="section"></a>section</h3><ul>
<li><p>作用：将一个函数或变量放到指定的段，即放到指定的section</p>
</li>
<li><p>使用：<strong>attribute</strong>(( section(“.data”) ))</p>
</li>
<li><p>可选项：</p>
<ul>
<li><p>.text：函数定义、程序语句</p>
</li>
<li><p>.data：初始化的全局变量、初始化的静态局部变量</p>
</li>
<li><p>.bss：未初始化的全局变量、未初始化的静态局部变量</p>
</li>
</ul>
</li>
</ul>
<h3 id="aligned"><a href="#aligned" class="headerlink" title="aligned"></a>aligned</h3><ul>
<li>作用：地址对齐，在给变量分配存储空间的时候，需要按照制定的地址对齐方式给变量分配地址</li>
<li>注意：地址对齐的字节数必须是2的幂次方</li>
<li>使用：<strong>attribute</strong>(( (aligned(4) ))</li>
<li>对齐的好处：简化CPU与RAM之间的接口和硬件设计。cpu访存硬件设计可能只支持4字节或4字节整数倍对齐的地址访问，对齐后cpu可以一次读完</li>
<li>注意：这个属性声明只是建议编译器按照这种方式对齐，当超过编译器允许的最大值只能按照最大对齐字节数进行地址分配</li>
</ul>
<h3 id="packed"><a href="#packed" class="headerlink" title="packed"></a>packed</h3><ul>
<li>作用：减少地址对齐</li>
<li>使用： <strong>attribute</strong>(( packed ))</li>
<li>通常aligned与packed一起使用，这样既避免了结构体各个成员变量地址对齐产生的内存空洞又指定了整个结构体对齐方式：<strong>attribute</strong>(( packed, aligned(8) ))</li>
</ul>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><ul>
<li>作用：指定变参函数的参数格式检查</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LOG</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span>* fmt, ...)</span> __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>,<span class="number">2</span>,<span class="number">3</span>)))</span>)</span><br><span class="line"><span class="comment">// LOG函数的参数，个数字符串的位置在所有参数列表的索引是2,即前两个参数；要编辑器帮忙检查的参数在所有参数列表里的索引是3</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><ul>
<li>作用：可以将一个强符号转换为弱符号</li>
<li>使用：void _<em>attribute</em>(( weak )) func(void);</li>
<li>好处：当一个函数被声明为一个弱符号之后，链接阶段找不到函数定义不会报错会将这个弱符号设置为0或者特殊值。当程序运行时，调用这个这个函数跳转到零地址或特殊地址才会产生一个内存错误</li>
</ul>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><ul>
<li>作用：给函数定义一个别名</li>
<li>使用：void f() <strong>attribute</strong>((alias(“_f “)));</li>
<li>通常在linux内核中weak和alias一起使用，随着版本升级可以封装旧名字起一个新名字</li>
</ul>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul>
<li><p>特征：用inline修饰的函数被称为内联函数，通常用static 或 extern 修饰</p>
</li>
<li><p>内联函数特征：</p>
</li>
<li><ul>
<li>函数体积小</li>
<li>函数体内无指针赋值、递归、循环等语句</li>
<li>调用频繁</li>
</ul>
</li>
<li><p>与宏相比，内联函数的优点：</p>
</li>
<li><ul>
<li>参数类型检查，本质仍然是函数</li>
<li>便于调试。可以单步、断点调试</li>
<li>有返回值（宏也可以，语句表达式结构）</li>
<li>接口封装</li>
</ul>
</li>
<li><p>使用：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 显式告诉编译器不要展开</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __attribute((noinline)) <span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 显式告诉编译器要内联展开</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __attribute((always_inline)) <span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 否则编译器的行为不固定，考虑诸多因素决定是否展开</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><ul>
<li>含义：编译器内部实现的函数</li>
<li>特征：通常以 __builtin 开头</li>
<li>说明：没有文档，变动频繁，不建议应用程序工程师使用</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//  __builtin_return_address（LEVEL）    返回当前函数或者调用者的返回地址</span></span><br><span class="line"><span class="comment">// LEVEL 0: 获取当前函数返回地址</span></span><br><span class="line"><span class="comment">// LEVEL 1: 获取上一级函数返回地址</span></span><br><span class="line"><span class="comment">// LEVEL 2: 获取上两级函数返回地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// __builtin_frame_address(LEVEL)        查看函数的栈帧地址</span></span><br><span class="line"><span class="comment">// LEVEL 0: 获取当前函数栈帧地址</span></span><br><span class="line"><span class="comment">// LEVEL 1: 获取上一级函数栈帧地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __builtin_constant_p(n)               判断参数n在编译时是否是常量，是常量返回1,否则0</span></span><br><span class="line"><span class="comment">// 内核中判断宏的参数是否是常数，则有更优化的实现方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __builtin_expect(exp,c)        </span></span><br><span class="line"><span class="comment">// 告诉编译器参数exp的值为c的可能性很大，用于分支预测，参数c与返回值无关，返回值一定是exp</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> likely(x) __builtin_expect(!!(x),1)) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> unlikely(x) __builtin_expect(!!(x),0)</span></span><br><span class="line"><span class="comment">// 告诉编译器某一个分支发生的概率很高，自己做优化</span></span><br><span class="line"><span class="comment">// 两次取非是为了将参数x转换为bool类型，与1/0比较</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h2><ul>
<li>用 … 表示变参列表，变参列表由不确定的参数组成，用  <strong>VA_ARGS</strong>  标识符表示变参函数列表</li>
<li>C99规定，可以使用 args…  表示变参列表，用 args 代表变参列表即可</li>
<li>宏连接符  ##  的作用是连接两个字符串</li>
<li>在定义宏的时候通常使用 do { } while(0);的结构，这样是为了防止宏在选择、条等分支语句中展开后，产生宏歧义</li>
</ul>
<p>两种方法实现自定义等级宏打印：<a href="https://github.com/yangLieee/codebackup/blob/master/book_%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/mlog.h">click here</a></p>
<h2 id="Uboot镜像自复制"><a href="#Uboot镜像自复制" class="headerlink" title="Uboot镜像自复制"></a>Uboot镜像自复制</h2><ul>
<li>作用：加载linux内核镜像到内存，给内核传递启动参数，然后引导linux操作系统启动</li>
<li>过程：通过定义两个零长度数组，分别表示要复制自身镜像的起始地址和结束地址，并放在特定的section上，而这两个section分别放在代码段前和数据段后。数组名本身就代表一个地址，通过arm ldr伪指令直接获取要复制的镜像首地址保存在某个寄存器中，从flash复制自身镜像到内存中，然后重定位，最终跳转到内存中执行。（自举）</li>
</ul>
<h1 id="C语言面向对象编程思想（八）"><a href="#C语言面向对象编程思想（八）" class="headerlink" title="C语言面向对象编程思想（八）"></a>C语言面向对象编程思想（八）</h1><h2 id="代码复用与分层"><a href="#代码复用与分层" class="headerlink" title="代码复用与分层"></a>代码复用与分层</h2><p>复用：</p>
<ul>
<li>函数级复用</li>
<li>库级复用</li>
<li>框架级复用</li>
<li>操作系统级复用</li>
</ul>
<p>分层：</p>
<ul>
<li>应用层</li>
<li>Framework层</li>
<li>库</li>
<li>Linux内核</li>
</ul>
<h2 id="面向对象主要特征"><a href="#面向对象主要特征" class="headerlink" title="面向对象主要特征"></a>面向对象主要特征</h2><p>继承、多态、纯虚函数特征（抽象类）</p>
<h1 id="模块化（九）"><a href="#模块化（九）" class="headerlink" title="模块化（九）"></a>模块化（九）</h1><p>模块化的思想内核是分而治之，重点在于抽象的对象之间的关联，而不是内容</p>
<p>面向对象的编程思想主要是为了代码复用，重点在于内容的实现</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《曾国藩传》</title>
    <url>/2022/12/11/Reading/%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BC%A0/</url>
    <content><![CDATA[<p><img src="/images/reading/zengGuoFan.jpg" alt="img"></p>
<p>近几年，曾国藩倍受成功学的推崇，关于他的书也是铺天盖地。偶然间看到老俞（俞敏洪）在推荐这本书，带着浓厚的兴趣开始对这本书的探索。《曾国藩传》是中国知名历史学家张宏杰先生的作品，除了这本《曾国藩传》他还著有《曾国藩的正面与侧面》《饥饿的盛世》《大明王朝的七张面孔》等等。整本书通读下来，作者按照时间顺序，以曾国藩日记及各种历史参考文献为史实基础进行了深度解读，将曾国藩国之重臣的形象立体的展现在了我们的眼前。</p>
<p>本篇也无所谓是读书笔记、读后感亦或者是书评了，便想到哪里写到哪里吧。</p>
<h1 id="故事自述"><a href="#故事自述" class="headerlink" title="故事自述"></a>故事自述</h1><p>曾国藩历任晚清四朝，生于嘉庆、文于道光、武于咸丰、卒于同治，我这里的文、武分别指其京官时代和领导湘军阶段。</p>
<p>老曾家本是一个殷实的小地主家庭，奈何祖坟一直没冒青烟，祖辈上没有一个读书人。在爷爷曾玉屏的影响下，小小的曾子城（该时期曾国藩未改名）开启了他的读书生涯。屡战屡败、屡败屡战，落榜六次之后，院试中秀才、乡试中举人、会试中进士，也就是在此正式更名为曾国藩，寄以“国之藩篱“之意，此时他才二十八岁。在此之后在京十年中，曾国藩立下学做圣人的宏愿并坚韧不拔地沿着这条仕途之道前进，步步升迁到二品官位。十年七迁，连跃十级。直至1852年充任江西乡试正考官才结束了他的京官生涯。</p>
<p>在曾国藩春风得意之际，却突然收到母亲去世的噩耗，致使他不得不改变自己的行程回家守孝。此时太平天国运动轰轰烈烈席卷半个中国，而清军主力八旗和绿营早已腐败不堪，咸丰皇帝不得不颁布兴办团练的诏书。曾国藩起初内心是拒绝的，但是心系国家的他最终还是决定应诏，以团为表，以军为里组建起了湘军，殊不知这支军队成了日后抵抗太平军的主力。没有任何军事经验、初来乍到再加上曾国藩此时直率的性格特征，组建一支像样且有战斗力的军队的难度可想而知，克服重重困难湘军算是建立起来了。抱着首战必胜的心理曾国藩决定出兵靖港，未曾可知迎来一场大败，这也让他的信心跌落谷底一度跳江自杀，幸被救下。随后大大小小战斗经历无数，湘潭大捷、九江大败…… 1857年父亲去世，他向皇帝请求回家奔丧三个月，未曾想再想复出却被皇帝解除了兵权。</p>
<p>塞翁失马焉知非福？也正是接下来两年的蛰伏让曾国藩完成了脱胎换骨的变化，他开始变得通人情世故，适应晚清官场的环境，但面对自己时仍然选择做圣人。趁着太平军内讧石达开的出走，好兄弟胡林翼给曾国藩争取来了再度出山的机会，之后两人联手攻克了安庆，期间何桂清弃城逃跑也成就了曾国藩得到了梦寐以求的两江总督的职位。水到渠成地1864年正月，攻破天京，结束叛乱。</p>
<p>此时曾国藩任两江总督，后面应该就是被大众所熟知的部分——主办洋务。首先他和自己的接班人李鸿章联手剿灭了北方黄淮一带的捻军起义，随后便是兴办洋务，建立安庆军械所、江南制造总局，翻译大量外文书籍等等。1868年升任直隶总督处理完天津教案事件因备受指责再次担任两江总督，四年后中国传统文化最后一个偶像曾国藩去世。</p>
<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><h2 id="越努力越幸运"><a href="#越努力越幸运" class="headerlink" title="越努力越幸运"></a>越努力越幸运</h2><p>曾国藩不能说是天资卓越的人，从他读书、治军经历不难看出这一点。关于这一点还有一个广为流传的小故事，一日黄昏，他在书桌前背诵《岳阳楼记》，一个小偷偷偷潜入他家爬到房梁上，等待这一家人都入睡后偷东西。奈何小偷睡了好几觉，曾国藩还没有背下来，小偷气急败坏跳下房梁说：就你这个笨样读什么书？随后他完完整整背了一遍，甩门而去，留下的曾国藩目瞪口呆一人凌乱。真实性无从考证，但是由此可见他是真挺笨的，而他未来的成就更多来自于努力。他的人生哲学便是”尚拙“，崇尚笨拙。曾国藩曾说：“天下之至拙，能胜天下之之巧”。一味的追求高效率而不择手段、投机取巧终不能成大才。天赋不够，努力来凑，而越努力才会越幸运。</p>
<h2 id="历史总是有迹可循"><a href="#历史总是有迹可循" class="headerlink" title="历史总是有迹可循"></a>历史总是有迹可循</h2><p>在本书中曾有过这样两个片段。</p>
<p>其一，在曾国藩守制期间大彻大悟完成蜕变，他突然意识到所谓”天下之至柔，驰骋天下之志坚“、”大柔非柔，至刚无刚“真正的含义。行事过于方刚者，表面似乎是强者，实际上确是弱者。而他之前看不起的麻木、圆滑、机诈有时候才是解决问题的最好方法。</p>
<p>其二，在攻打安庆期间，胡林翼创造出”围城打援“的战术，给在湖北作战的湘军统帅多隆阿的信中说道，战争的目的不在于一城一池的得失，而在于消灭对方的有生力量。</p>
<p>读到第一个片段，脑海中不由得浮现出老子”以柔克刚“的思想，而曾国藩大彻大悟后的思想何尝不是对先贤思想的进一步阐述和升华。而读到第二个片段时，脑海里浮现的是解放战争期间，毛主席在延安面对胡宗南二十五万大军主动撤离，决定”拿一个延安换取一个全中国“。当时便提出：存地失人，人地皆失；存人失地，人地皆存。这与胡林翼讲述的战争目的可谓是如出一辙。</p>
<h2 id="尽人事，听天命"><a href="#尽人事，听天命" class="headerlink" title="尽人事，听天命"></a>尽人事，听天命</h2><p>在曾国藩赋闲在家为父亲治丧三个月期满之时，他向皇帝申请继续守制三年，太平天国未灭皇帝当然不会批准这个请求。于是曾国藩说出了实情：哭诉了一番自己的委屈和困难，并对皇帝说如果你不给我督抚大权，我就只能在籍终制。这明显是赤裸裸的要挟，出乎曾国藩的预料，咸丰皇帝居然答应了他的守制请求，彻彻底底没收了军权。而在与太平天国的决战当中，何桂清弃城逃跑，曾国藩没有索要皇帝便把何桂清两江总督职位给到了他。</p>
<p>一旦在做一件事情时有了极强的功利心，实现的过程可能将不择手段，目标也可能会背道而驰，最终一定不会达到最完美的状态。而最好的方式则是做到”尽人事听天命“，尽心尽力的去做事情，而能否成功，则需要顺其自然。</p>
<h2 id="脚踏实地，常于反思"><a href="#脚踏实地，常于反思" class="headerlink" title="脚踏实地，常于反思"></a>脚踏实地，常于反思</h2><p>在八旗兵和绿营兵战斗力如此低下的情况下，一介书生曾国藩为什么创建出战斗力满满的湘军呢？答案就是反思的力量，他追根溯源找到八旗绿营真正症结所在并在湘军中及时调整完成功业。而建立起来的湘军在战斗时奉行的时曾国藩”结硬寨，打呆仗“的战术，具体来讲就是”以静制动，反客为主“，把自己的营寨盘结实等待敌人前来进攻，等待他们露出马脚湘军再反攻，这便是整个逻辑。</p>
<p>细细看下来曾国藩的战术一定不是最先进的但一定是最稳妥的。不论走多远的路，但一定要确保走过的每一步路都有自己的脚印。</p>
<h2 id="保持忧患意识"><a href="#保持忧患意识" class="headerlink" title="保持忧患意识"></a>保持忧患意识</h2><p>在太平天国运动被平定之后，湘军无疑成了整个清王朝最强大的战斗力。曾国藩熟读史书，《易传》中讲：日中则昃，月盈则亏。越是辉煌的时候越应该保持清醒的头脑，懂得趋福避祸。他怎么能不明白朝廷的心思呢，为了不让朝廷猜忌决定自剪羽毛裁撤湘军。与此同时，他默默的将部分主力交给李鸿章的淮军当中。这一手”裁湘留淮“的操作可谓真的是粗中有细，这也保证了它后面官场生涯的延续。</p>
<h2 id="读书永远可以保持竞争力"><a href="#读书永远可以保持竞争力" class="headerlink" title="读书永远可以保持竞争力"></a>读书永远可以保持竞争力</h2><p>选士人，领山农。湘军大部分人都是山农即农民出身。但是湘军重视政治教育，罗泽南部则索性白天打仗，晚上把部下召集到一起，教他们读书，学习理学。流氓不可怕，就怕流氓有文化，这句话可能不是很恰当，但是有了知识的农民部队战斗力、战斗素养提升了可不是一个等级。</p>
<h2 id="桃李满天下"><a href="#桃李满天下" class="headerlink" title="桃李满天下"></a>桃李满天下</h2><p>这一项不能算作是感悟，称得上是曾国藩的成就。晚清大多数重臣都多多少少都受到过曾国藩的提点，李鸿章、左宗棠、沈葆桢、彭玉麟、胡林翼等等，尤其是李鸿章可谓是一手提拔起来的。英国一位历史学家说：曾国藩是中国最有势力的人，但他死去的时候，所有的总督（类似于现在的省委书记）都曾做过他的部下，并且都是由他提名的。如果他希冀，他可能已经成为皇帝。真实性无从考证，但由此也可看出他的影响力之大</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>曾国藩这一生是失败的。为天地立心、为生民立命、为往圣继绝学、为万世开太平。曾国藩用他的一生来践行张载的横渠四句，但可惜生不逢时终究是没有完成全部的理想，无奈成为追日的夸父、填海的精卫。在这里引用一下杨耀在”得到“APP解读李鸿章一书中提到的：时势能够造英雄，而英雄也可以改变时势。而显然传统保守的思想让曾国藩注定只能成为时势造的英雄，而不能成为改变时势的英雄。这不是他一个人的失败，而是整个腐朽政权的失败！</p>
<p>曾国藩这一生又是成功的。立功、立德、立言三不朽的境界他全部做到了。立功而言，他从一介书生起家，创建军队，挽狂澜于既倒，扶大厦之将倾，使中国传统文化免遭毁灭之灾，让清朝又可以在历史上浓墨重彩的多写几笔；立德而言，他以圣贤为标准要求自己，道德修养近乎纯粹；立言而言，我一个普通人能在这里写这篇文章感受曾国藩的风采，其影响力便不言而喻，洋洋洒洒数百万字全集让人受益匪浅。</p>
<p>一万个人有一万个哈姆雷特，同样也会有一万个曾国藩，每个人切入角度不同读出的人物自然不同，但带给我们每个人的力量却是永恒且相同的！</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机存储体系</title>
    <url>/2023/02/07/computerSystem/%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>作为计算机五大核心功能（运算、存储、控制、输入、输出）之一的存储，无疑在整个计算机体系结构中有着举足轻重的地位。</p>
<p>存储器属于计算机的记忆装置，用于存放程序和数据。在我看来程序是作为计算机的灵魂而存在的，它指导了计算机的一切行为，而数据则是这一切行为的基石。</p>
<p>本文将基于存储器对计算机的存储系统做简要介绍</p>
<h1 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h1><p><img src="/images/computerSystem/storage/storage-0.png" alt="image"></p>
<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="/images/computerSystem/storage/storage-1.png" alt="image"></p>
<h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>通过存储器分类图不难看出存储器的种类繁多，而如何合理的使用每一种存储器组成庞大的存储体系结构无不体现着工程师们的智慧。</p>
<p>存储系统设计的核心问题在于：<strong>成本（存储1bit）、容量、速度三者平衡</strong>。恰好这三者之间又是相互矛盾的，主要体现在：容量越高，成本越低，而速度越慢；速度越块，成本就越高（其它情况可根据 2.2金字塔章节 理解），因此平衡成了关键。因此存储体系结构设计目的可总结为：将各种不同的器件组合成一个体系，让各种器件扬长避短，从而形成一种快速、大容量、低成本的内存系统</p>
<p>通过优化存储系统的组织来使得针对典型应用平均访存时间最短</p>
<h2 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h2><p><img src="/images/computerSystem/storage/storage-2.png" alt="image"></p>
<p>越靠近金字塔顶，距离处理器越近，访问速度就越快，造价也就越高，同时容量也会更小</p>
<table>
<thead>
<tr>
<th></th>
<th>存储器种类</th>
<th>硬件（存储1bit）</th>
<th>速度</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>触发器</td>
<td>十几个晶体管</td>
<td>300ps</td>
</tr>
<tr>
<td>缓存</td>
<td>sram</td>
<td>6个晶体管</td>
<td>L1-1ns；L2-10ns</td>
</tr>
<tr>
<td>内存</td>
<td>dram</td>
<td>1个mos管+1个电容</td>
<td>100ns</td>
</tr>
<tr>
<td>硬盘</td>
<td>flash/磁性存储…</td>
<td>/</td>
<td>SSD-25us；HDD-5ms</td>
</tr>
</tbody></table>
<p>通过表格可以发现内存的组成有电容的存在，因此不再是单纯的逻辑电路更不能用CMOS工艺制造，而SRAM却可以。这也就是为什么缓存可以集成到芯片内部，而内存是和芯片分开制造的。</p>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>storage system</tag>
      </tags>
  </entry>
  <entry>
    <title>《格局》</title>
    <url>/2023/01/04/Reading/%E6%A0%BC%E5%B1%80/</url>
    <content><![CDATA[<p><img src="/images/reading/GeJu.jpg" alt="img"></p>
<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>《格局》一书是吴军博士2019年出版的。吴军博士头衔可谓众多，“文津图书奖”得主、硅谷投资人、约翰·霍普金斯大学工学院董事、原腾讯副总裁，出版过《数学之美》《浪潮之巅》《文明之光》《硅谷之谜》等等不同品类的书籍。</p>
<p>我自己对于”格局“一词的理解是一个人对于世界认知的边界以及对事物认知的范围。整书通读下来给我的感觉更像是吴军博士对于自己生活经验及基于某些历史事件的规律总结，甚至有些章节的内容前后都没有很关联，对于本书大部分内容无感的本质原因我认为是自己的经历没有那么丰富无法做到感同身受亦或者是自己对于这本书没有完全读懂。那便写下自己感兴趣的部分的心得吧</p>
<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><h2 id="技术是手段-不是目的"><a href="#技术是手段-不是目的" class="headerlink" title="技术是手段 不是目的"></a>技术是手段 不是目的</h2><p>互联网飞速发展，新的技术理论得到迅速且广泛的传播。对于一名技术从业者来讲，要想在职场行业内始终保持竞争力，需要不断的去学习新的内容来保证自己不会被时代所淘汰。但实际上，技术从来都是手段而不是目的，如果搞不清楚这一点，就会为了技术而研发技术。2022年AI、IOT可能是时代的潮流，但10年后一切都未曾可知而可以肯定的是计算机的底层原理及知识仍然不会落伍。可见洞察一件事情的本质并去学习探索才是真正的硬道理。</p>
<h2 id="未来的特征"><a href="#未来的特征" class="headerlink" title="未来的特征"></a>未来的特征</h2><ul>
<li>不对称性。新技术的产生，最早掌握新技术的少数人可以利用新技术颠覆过去在相关领域中占据统治地位的组织或机构；</li>
<li>复杂性。当下的知识体系非常复杂，通常都是跨学科的而不是单一维度的；</li>
<li>不确定性。没有人能够预测未来</li>
</ul>
<ol>
<li>不过度依赖过去的权威</li>
<li>拉力由于推力（主动获取而不是被动接收）</li>
<li>指南针优于地图（改变一直存在，掌握本质，求渔不求鱼）</li>
<li>拥抱风险</li>
<li>叛逆精神（打破规则）</li>
<li>通才胜于专才（前提一定是已经在某一方面已经是专才）</li>
<li>韧性优于力量</li>
<li>强调整体性</li>
</ol>
<h2 id="以正和，以奇胜"><a href="#以正和，以奇胜" class="headerlink" title="以正和，以奇胜"></a>以正和，以奇胜</h2><p>面对不断变化的未来，把握好常态是关键，而正是常态，奇是非常态。《孙子兵法 兵势篇》中写到：凡战者，以正和，以奇胜。这句话的意思是：作战，要先把正面的兵排好，排的不偏斜合乎法则，此为正；如果这时候还有多余的兵力你就赢了，在现代汉语字典中也可以理解为：出奇制胜。”以正和，以奇胜”更应该是一个人做事的准则，在做好正的基础上出奇制胜，不要相信所谓的弯道超车，这一定是不稳定的。</p>
<h2 id="被信息放大的悲观"><a href="#被信息放大的悲观" class="headerlink" title="被信息放大的悲观"></a>被信息放大的悲观</h2><p>我们明显能够感觉到现在的年轻人普遍会更焦虑，他们仿佛对这个世界充满悲观情绪。xxx飞机失事、xxx公司大规模裁员、xxx地区洪水或火山爆发，这些新闻在现在真的是屡见不鲜，也正是这些新闻的广泛传播给我们造成了很大的焦虑情绪。但实际上飞机其实是比汽车更安全、在大范围内就业形式是向好的、火山喷发地正是处于板块交界地带。可以发现真正广泛传播的言论实际上大多是悲观的，从信息论的角度来讲，越是与众不同的说法信息量越大。相反宣传乐观主义的观点论文不仅没有人看甚至是无法发表的。因为没有人会关心一篇”今年经济持续向好“的文章，大家都知道也自然就不会过多关注。面对各种各样的新闻，适当保持忧患意识是必要的，但请不应过度的悲观！</p>
<h2 id="人立于天地之间必有出路"><a href="#人立于天地之间必有出路" class="headerlink" title="人立于天地之间必有出路"></a>人立于天地之间必有出路</h2><p>面对生活、工作、家庭的压力，我们总是使自己处于一个很忙碌的状态之中，面对未来可能发生的问题我们也常说：车到山前必有路、船到桥头自然直。确实，对于未来的不确定性，我们始终要坚信人立与天地之前必有出路。</p>
<h1 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h1><p>自己花了精力做的事情要尽可能的对自己未来有帮助。</p>
<p>过分追求物质可能会成为生活的负担。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件随机数测试方法</title>
    <url>/2022/11/26/third-party/DTRNG_Test/</url>
    <content><![CDATA[<h1 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h1><p>配置芯片DTRNG硬件单元寄存器生成一定数量的数据，保存成二进制文件，使用NIST测试套件进行验证得到是否随机的结论。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol>
<li>DTRNG：Digital True Random Number Generator，数字真随机数发生器</li>
<li>NIST：National Institude of Standards and Technology，国家标准技术研究所</li>
<li>NIST-sts (Statistical Test Suite)，统计测试套件：</li>
</ol>
<ul>
<li><p>源码链接：<a href="https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software%EF%BC%88Download%E5%8D%B3%E5%8F%AF%EF%BC%89">https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software（Download即可）</a></p>
</li>
<li><p>文档链接：<a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf">https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf</a></p>
</li>
<li><p>windows安装</p>
<p>官网的软件包是Linux系统下开发的，Windows系统需要先下一个<a href="https://cygwin.com/install.html">cygwin软件</a>来辅助使用</p>
<p>可以参考博客：<a href="https://blog.csdn.net/weixin_39928192/article/details/89256576">https://blog.csdn.net/weixin_39928192/article/details/89256576</a>?</p>
</li>
<li><p>Linux安装</p>
<p>进入工程文件夹sts-2.1.2直接make即可，得到 assess 可执行程序</p>
</li>
</ul>
<h1 id="随机测试项"><a href="#随机测试项" class="headerlink" title="随机测试项"></a><strong>随机测试项</strong></h1><p>每一个测试项的解读：<a href="https://blog.csdn.net/lafu5137/article/details/79593845">https://blog.csdn.net/lafu5137/article/details/79593845</a></p>
<ol>
<li>The Frequency (Monobit) Test，频率检测。该检验主要是看0和1在整个序列中所占的比例（基础检测）</li>
<li>Frequency Test within a Block，块内频率检测</li>
<li>The Runs Test，游程检测。游程指的是一个没有间断的相同数序列</li>
<li>Tests for the Longest-Run-of-Ones in a Block，块内最长游程检测</li>
<li>The Binary Matrix Rank Test，二元矩阵秩检测</li>
<li>The Discrete Fourier Transform (Spectral) Test，离散傅立叶变换检测</li>
<li>The Non-overlapping Template Matching Test，非重叠模块匹配检测</li>
<li>The Overlapping Template Matching Test，重叠模块匹配检测</li>
<li>Maurer’s “Universal Statistical” Test，Maurer的通用检测统计</li>
<li>The Linear Complexity Test，线性复杂度检测</li>
<li>The Serial Test，序列检测</li>
<li>The Approximate Entropy Test，近似熵检测</li>
<li>The Cumulative Sums (Cusums) Test，累加和检验</li>
<li>The Random Excursions Test，随机游动检测</li>
<li>The Random Excursions Variant Test.，随机游动状态频率检测</li>
</ol>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h1><p>该流程是基于Linux系统进行操作的，使用的数据：sts-2.1.2/data/data.pi</p>
<ol>
<li>启动程序。**./assess ，**stream length译为流的长度。</li>
<li>输入待测文件路径。根据菜单，键入0并输入文件的路径（相对路径和绝对路径都可以）</li>
<li>选择测试项。键入1表示应用全部测试项；输入0表示部分测试项，随后输入一个16位二进制序列选择测试项。</li>
<li>参数调整。可以根据菜单及选项微调部分参数的值，基本选择默认即可。</li>
<li>输入比特流的个数。表示有多少个stream</li>
<li>选择输入文件类型。该类型对应于第二步输入文件的类型，两种类型供选择：ASCII / Binary</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h1><ol>
<li>每一项测试所需的序列的stream length是不一样的，经测试如果选择全部测试项至少保证stream length &gt;= 10000bits，否则会出现错误。而如果单项测试查阅文档满足参数范围即可，比如选择1频率测试只需保证stream length&gt;100bits即可。</li>
<li>必须保证：流长度 × 流个数 &lt;= 文件大小</li>
<li>如果输入的文件是ACSII格式的话，启动程序时所输入的bitstream的单位是byte；而输入文件为Binary的话bitstream单位为bit。例如：第一步键入./assess 10000；第五步键入10 ；此时第六步选择0代表输入了10000×10×8（bits），输入1代表输入了10000×10（bits）。实际输入过程是要反着理解，先确定输入文件类型，进而确认bitstream、number，保证第一个公式</li>
</ol>
<h1 id="检测标准"><a href="#检测标准" class="headerlink" title="检测标准"></a><strong>检测标准</strong></h1><p>测试成功结束则会在 <strong>sts-2.1.2/experiments/AlgorithmTesting/</strong> 目录下生成测试报告，而针对每一个项目的结果会在其子目录下生成测试报告。</p>
<p>最终测试报告finalAnalysisReport.txt中P-value都大于等于0.01即可认为通过了NIST检验，这个数据越大越好。如果该数据为0，可能是由于数据量的问题则可以去每个子项目结果中去查看，会有SUCCESS字样！</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a><strong>Q&amp;A</strong></h1><ol>
<li><p>Q：Segment fault</p>
<p>A： bitstream*num &gt; fileSize即流的长度乘以流的个数超过了文件的大小通常会有error信息</p>
</li>
<li><p>Q：igamc: UNDERFLOW？</p>
<p>A：数据下溢，可能是数据格式的原因或者数据过于不随机</p>
</li>
<li><p>Q：P-value全部是0？</p>
<p>A：导致 <strong>igamc: UNDERFLOW</strong> 的原因都是有可能的，同时也可能是因为数据量不够所导致的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/2022/08/25/third-party/cmake/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>官网 : <a href="https://cmake.org/cmake/help/v3.15/">https://cmake.org/cmake/help/v3.15/</a></p>
</blockquote>
<p>CMake是跨平台的 免费和开源软件，用于使用独立于编译器的方法构建自动化、测试、打包和安装软件。CMake 本身并不是一个构建系统；它生成另一个系统的构建文件。它支持目录层次结构和依赖于多个库的应用程序。它与原生构建环境结合使用，例如Make、Qt Creator、Ninja、Android Studio、Apple 的Xcode和Microsoft Visual Studio。（摘自Wiki）</p>
<h1 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><p>cmake要求最低版本(选择性添加)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.0</span><span class="number">.0</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>编译工程名</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">project(xxx)</span><br><span class="line"><span class="comment">//会自动创建两个变量，PROJECT_SOURCE_DIR和PROJECT_NAME</span></span><br><span class="line"><span class="comment">//${PROJECT_SOURCE_DIR}：本CMakeLists.txt所在的文件夹路径</span></span><br><span class="line"><span class="comment">//${PROJECT_NAME}：本CMakeLists.txt的project名称</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>给部分文件或路径组合起别名, 通过${变量}获取变量内容</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(变量 文件名/路径/...)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置c / c++ 编译编译参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> (CMAKE_C_FLAGS <span class="string">"-Wall -O2"</span>)</span><br><span class="line"><span class="built_in">set</span> (CMAKE_CXX_FLAGS <span class="string">"-Wall -std=C++11"</span>)</span><br><span class="line">add_compile_options( -Wall )				<span class="comment">//该命令译选项是针对所有编译器的(包括c和c++编译器)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>为当前路径以及子目录的源文件加入由-D引入的define flag</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_definitions(-DFOO -DDEBUG ...)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>对子文件夹进行cmake编译</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_subdirectory(子文件夹名) </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>打印信息</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">message() 			<span class="comment">//直接添加打印的内容和变量即可,不需要双引号</span></span><br><span class="line">message(<span class="string">"PROJECT_SOURCE_DIR = ${PROJECT_SOURCE_DIR}"</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>帮助信息 </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 查看cmake默认变量		cmake --help-variable-<span class="built_in">list</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>用法：根据某个宏确定编译内容。比较字符串，相同返回true</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CPU_PLATFORM_BIT STREQUAL <span class="string">"64"</span>)</span><br><span class="line">    add_library(mylib generic_64bit.c)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    add_library(mylib generic_32bit.c)</span><br><span class="line">endif()  </span><br></pre></td></tr></tbody></table></figure>

<h2 id="编译目标"><a href="#编译目标" class="headerlink" title="编译目标"></a>编译目标</h2><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_executable(目标文件名字xxx 源文件)</span><br><span class="line"><span class="comment">//example: add_executable(${PROJECT_NAME} example_person.cpp)</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="动态-x2F-静态库"><a href="#动态-x2F-静态库" class="headerlink" title="动态 / 静态库"></a>动态 / 静态库</h3><p>将指定的源文件生成链接文件，然后添加到工程中去</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_library(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">[EXCLUDE_FROM_ALL]</span><br><span class="line">[source1] [source2] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;name&gt;表示库文件的名字，该库文件会根据命令里列出的源文件来创建。生成的库自动补全,如libxxx.so </span></span><br><span class="line"><span class="comment">//STATIC、SHARED和MODULE的作用是指定生成的库文件的类型。STATIC库是目标文件的归档文件，在链接其它目标的时候使用。SHARED库会被	动态链接（动态链接库），在运行时会被加载。MODULE库是一种不会被链接到其它目标中的插件，但是可能会在运行时使用dlopen-系列的函数	。默认状态下，库文件将会在于源文件目录树的构建目录树的位置被创建，该命令也会在这里被调用。</span></span><br><span class="line"><span class="comment">//source1 source2分别表示各个源文件</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="链接-x2F-路径"><a href="#链接-x2F-路径" class="headerlink" title="链接/路径"></a>链接/路径</h2><h3 id="头文件路径"><a href="#头文件路径" class="headerlink" title="头文件路径"></a>头文件路径</h3><p>添加头文件的查找路径, 相当于命令行的  <em><strong>-l</strong></em> 参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">include_directories(../thirdparty/comm/include)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="链接库路径"><a href="#链接库路径" class="headerlink" title="链接库路径"></a>链接库路径</h3><p>添加需要链接的库文件目录, 相当于命令行 <em><strong>-L</strong></em> 参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">link_directories(<span class="string">"/home/server/third/lib"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a>链接库</h3><p> 将目标文件与库文件进行链接</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">target_link_libraries(&lt;target&gt; [item1] [item2] [...] [[debug|optimized|general] &lt;item&gt;] ...)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//&lt;target&gt;是指通过add_executable()和add_library()指令生成已经创建的目标文件</span></span><br><span class="line"><span class="comment">//[item]表示库文件没有后缀的名字。默认情况下，库依赖项是传递的。当这个目标链接到另一个目标时，链接到这个目标的库也会出现在另一个目标的连接线上。这个传递的接口存储在interface_link_libraries的目标属性中，可以通过设置该属性直接重写传递接口。</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="安装（Install）"><a href="#安装（Install）" class="headerlink" title="安装（Install）"></a>安装（Install）</h2><ul>
<li>详情参考：<a href="https://cmake.org/cmake/help/v3.22/command/install.html">https://cmake.org/cmake/help/v3.22/command/install.html</a></li>
<li>作用：用于定义安装规则，安装内容包括可执行文件，静态库，动态库以及文件，目录，脚本等</li>
<li>使用方法：make install</li>
<li>目标安装路径：${CMAKE_INSTALL_PREFIX}指定，默认/usr/local</li>
</ul>
<h3 id="目标文件安装"><a href="#目标文件安装" class="headerlink" title="目标文件安装"></a>目标文件安装</h3><p>目标文件指的是我们通过 add_executable / add_library 得到的二进制文件或者库，只有这些文件才可以通过该命令装载到相应的位置</p>
<ul>
<li>可执行文件：RUNTIME</li>
<li>动态库：LIBRARY</li>
<li>静态库：ARCHIVE</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(TARGETS targets... [EXPORT &lt;export-name&gt;]</span><br><span class="line">        [RUNTIME_DEPENDENCIES args...|RUNTIME_DEPENDENCY_SET &lt;<span class="built_in">set</span>-name&gt;]</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|BUNDLE|</span><br><span class="line">          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]</span><br><span class="line">         [DESTINATION &lt;dir&gt;]</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">         [OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">         [NAMELINK_ONLY|NAMELINK_SKIP]</span><br><span class="line">        ] [...]</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line"><span class="comment">// example:</span></span><br><span class="line">install(TARGETS mybin mystaiclib mydynamiclib</span><br><span class="line">        RUNTIME DESTINATION bin</span><br><span class="line">        ARCHIVE DESTINATION lib</span><br><span class="line">        LIBRARY DESTINATION lib)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="普通文件安装"><a href="#普通文件安装" class="headerlink" title="普通文件安装"></a>普通文件安装</h3><p>普通文件即需要导出的头文件、依赖的三方库等等，该命令同时可以指定导出文件的权限（默认644）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(&lt;FILES|PROGRAMS&gt; files...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [PERMISSIONS permissions...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [RENAME &lt;name&gt;] [OPTIONAL] [EXCLUDE_FROM_ALL])</span><br><span class="line">        </span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">install(FILES mylib.h DESTINATION include)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="目录安装"><a href="#目录安装" class="headerlink" title="目录安装"></a>目录安装</h3><p>参数介绍：</p>
<ul>
<li>DIRECTORY：后面连接的是所在Source目录的相对路径（结尾是否是”/“对拷贝结果有一定影响）</li>
<li>PATTERN：使用正则表达式进行过滤</li>
<li>PERMISSIONS：指定PATTERN过滤后的文件权限。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(DIRECTORY dirs...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [FILE_PERMISSIONS permissions...]</span><br><span class="line">        [DIRECTORY_PERMISSIONS permissions...]</span><br><span class="line">        [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL]</span><br><span class="line">        [FILES_MATCHING]</span><br><span class="line">        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">         [EXCLUDE] [PERMISSIONS permissions...]] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">install(DIRECTORY src/ DESTINATION include/myproj  FILES_MATCHING PATTERN <span class="string">"*.h"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>Q: 编译参数添加了-lpthread 参数, 但是还是报undefined reference to `pthread_create’ </p>
<p>A : 需要使用target_link_libraries( target thread) 在这里链接thread库</p>
</li>
<li><p>Q: 如果在多级的目录下编译, 始终找不到问题报 undefine的问题 ?</p>
<p>A : 看一下是不是链接的库或目标文件格式不同, 一个c 一个c++ , 这样就会导致找不到符号错误</p>
</li>
<li><p>Q: undefined reference to `typeinfo for xxxBase_class’ ?</p>
<p>A: 基类的构造和析构函数需要加{ };  否则就会报这个问题</p>
</li>
</ol>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="PHYON"><a href="#PHYON" class="headerlink" title="PHYON"></a>PHYON</h3><p>.PHONY 在 makefile 中表示定义伪目标。所谓伪目标，就是它不代表一个真正的文件名，在执行 make 时可以指定这个目标来执行其所在规则定义的命令</p>
<h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><ul>
<li><p>=</p>
<p>最基本的赋值方式，语句与在文中的位置无关，系统自动推导将最终的赋值作为变量的值</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">str=123</span><br><span class="line"><span class="section">target:</span></span><br><span class="line">	@echo  <span class="variable">$(str)</span></span><br><span class="line">str=456</span><br><span class="line"><span class="comment"># 最终结果：456</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>：=</p>
<p>覆盖式赋值。如果变量在之前定义赋值过，本次的值将更新变量。该符号赋值只能推导该符号位置之前的值</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">str:=<span class="variable">$(str1)</span>123</span><br><span class="line">str1=456</span><br><span class="line"><span class="section">target:</span></span><br><span class="line">	@echo  <span class="variable">$(str)</span></span><br><span class="line"><span class="comment"># 最终结果：123（将str默认为空字符）</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>？=</p>
<p>如果当前变量在之前被赋值过，则此次赋值不执行，否则执行</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">str=123</span><br><span class="line">str?=456</span><br><span class="line"><span class="section">target:</span></span><br><span class="line">	@echo  <span class="variable">$(str)</span></span><br><span class="line"><span class="comment"># 最终结果 123</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>+=</p>
<p>追加赋值。旧值保持不变，将新值黏贴到旧值后面</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">str=123</span><br><span class="line">str+=456</span><br><span class="line"><span class="section">target:</span></span><br><span class="line">	@echo  <span class="variable">$(str)</span></span><br><span class="line"><span class="comment"># 最终结果：123 456</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table>
<thead>
<tr>
<th>通配符</th>
<th>使用说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配0个或者是任意个字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td>[]</td>
<td>我们可以指定匹配的字符放在 “[]” 中</td>
</tr>
<tr>
<td>%</td>
<td>匹配任意个字符</td>
</tr>
</tbody></table>
<h2 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h2><table>
<thead>
<tr>
<th>自动化变量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>$@</td>
<td align="center">表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td>
</tr>
<tr>
<td>$%</td>
<td align="center">当目标文件是一个静态库文件时，代表静态库的一个成员名。</td>
</tr>
<tr>
<td>$&lt;</td>
<td align="center">规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td>
</tr>
<tr>
<td>$?</td>
<td align="center">所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</td>
</tr>
<tr>
<td>$^</td>
<td align="center">代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量  $ 只记录它的第一次引用的情况。就是说变量 $ 会去掉重复的依赖文件。</td>
</tr>
<tr>
<td>$+</td>
<td align="center">类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td>
</tr>
<tr>
<td>$*</td>
<td align="center">在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。</td>
</tr>
</tbody></table>
<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><h3 id="添加前缀"><a href="#添加前缀" class="headerlink" title="添加前缀"></a>添加前缀</h3><ul>
<li>函数名：addprefix( )</li>
<li>语法：$(addprefix PREFIX/,${NAME…})</li>
<li>函数功能：为“NAMES…”中的每一个文件名添加前缀“PREFIX”。参数“NAMES…”是空格分割的文件名序列，将“PREFIX”添加到此序列的每一个文件名之前。</li>
<li>返回值：以单空格分割的添加了前缀“PREFIX”的文件名序列。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">$(addprefix src/,foo bar)</span><br><span class="line"><span class="comment">//返回值为“src/foo src/bar”</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ul>
<li>函数名：filter( )</li>
<li>语法：$(filter SUFFIX…,$(SOURCES))</li>
<li>作用：保留字串 “ $(SOURCES)” 中所有符合模式 “ SUFFIX ” 的单词</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sources := main.c AT.txt</span><br><span class="line">foo : $(sources)</span><br><span class="line">    cc $(filter %.c,%.s,$(sources)) -o foo</span><br></pre></td></tr></tbody></table></figure>



<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p>用于Makefile的Debug，打印分为三个等级：info、warning、error</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">$(info SRC = $(SRC))</span><br><span class="line">$(warning INC = $(INC))</span><br><span class="line"><span class="comment">//注意：执行到error会直接stop退出</span></span><br><span class="line">$(error INC = $(INC))</span><br></pre></td></tr></tbody></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
        <tag>CmakeLists.txt</tag>
      </tags>
  </entry>
  <entry>
    <title>LwIP+websocket</title>
    <url>/2023/04/19/third-party/lwip+websocket/</url>
    <content><![CDATA[<h1 id="WebSocket流程"><a href="#WebSocket流程" class="headerlink" title="WebSocket流程"></a>WebSocket流程</h1><blockquote>
<p>websocket <a href="https://github.com/dhbaird/easywsclient">https://github.com/dhbaird/easywsclient</a></p>
</blockquote>
<h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><ol>
<li>socket()</li>
<li>bind()</li>
<li>listen()</li>
<li>accept()</li>
<li>recv()</li>
</ol>
<h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><ol>
<li>socket()</li>
<li>connect()</li>
<li>send()</li>
</ol>
<h1 id="Lwip-API"><a href="#Lwip-API" class="headerlink" title="Lwip-API"></a>Lwip-API</h1><h2 id="lwip-socket"><a href="#lwip-socket" class="headerlink" title="lwip_socket"></a>lwip_socket</h2><ul>
<li><p>功能：用于根据指定的地址族、数据类型和协议来分配一个套接口的描述字及其所用的资源的函数</p>
</li>
<li><p>函数原型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> socket	(	 	domain,			\</span></span><br><span class="line"><span class="meta"> 						type,			\</span></span><br><span class="line"><span class="meta"> 						protocol 		\</span></span><br><span class="line"><span class="meta">				)	   lwip_socket(domain,type,protocol)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>参数选项</p>
<ul>
<li><p>domain：地址族AF_INET（IP_V4）、AF_INET6(IP_V6)</p>
</li>
<li><p>type：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_STREAM     1 <span class="comment">//流式套接字提供可靠的、面向连接的通信流；它使用TCP 协议，从而保证了数据传输的正确性和顺序性。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_DGRAM      2<span class="comment">// 数据报套接字定义了一种无连接的服 ，数据通过相互独立的报文进行传输，是无序的，并且不保证是可靠、无差错的。它使用数据报协议UDP。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_RAW        3<span class="comment">// 原始套接字允许对底层协议如IP或ICMP进行直接访问，功能强大但使用较为不便，主要用于一些协议的开发。</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>ptotocol</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IP      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_ICMP    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_TCP     6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_UDP     17</span></span><br><span class="line"><span class="comment">// 一般自动设置为0, 系统自动设置合适的协议</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="lwip-connect"><a href="#lwip-connect" class="headerlink" title="lwip_connect"></a>lwip_connect</h2><ul>
<li><p>函数功能：用于建立与指定socket的连接。一般用于客户端，</p>
</li>
<li><p>函数原型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> connect	(	 	s,		\</span></span><br><span class="line"><span class="meta"> 						name,	\</span></span><br><span class="line"><span class="meta"> 						namelen \</span></span><br><span class="line"><span class="meta">				)	   lwip_connect(s,name,namelen)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>s ：socket()返回文件描述符代表的套接字</li>
<li>const struct sockaddr *name：存放了服务端用于通信的地址和端口。</li>
<li>socklen_t namelen：name参数结构体的长度。</li>
</ul>
</li>
</ul>
<h2 id="lwip-setsockopt"><a href="#lwip-setsockopt" class="headerlink" title="lwip_setsockopt"></a>lwip_setsockopt</h2><ul>
<li><p>功能：设置与某个套接字关联的选项，当操作套接字选项时，选项位于的层和选项的名称必须给出</p>
</li>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">函数原型：<span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sock, 			<span class="comment">//将要被设置选项的套接字</span></span></span><br><span class="line"><span class="params">						<span class="type">int</span> level, 			<span class="comment">//选项所在的协议层</span></span></span><br><span class="line"><span class="params">						<span class="type">int</span> optname, 		<span class="comment">//需要访问的选项名</span></span></span><br><span class="line"><span class="params">						<span class="type">const</span> <span class="type">void</span> *optval, <span class="comment">//指向包含新选项值得缓冲</span></span></span><br><span class="line"><span class="params">						<span class="type">socklen_t</span> optlen)</span>	<span class="comment">//现选项的长度</span></span><br><span class="line">返 回 值：成功返回0；失败返回-1</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>参数选项</p>
<ul>
<li><p>level：参数（level）详细说明：level是指定控制套接字的层次，可以取如下三种值</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">选项名称(optname)　　　说明　　　　　          　　　　数据类型</span><br><span class="line">========================================================================</span><br><span class="line">SO_BROADCAST　　　　　 允许发送广播数据　　　　　　　　 <span class="type">int</span></span><br><span class="line">SO_DEBUG　　　　　　　  允许调试　　　　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_DONTROUTE　　　　　　不查找　　　　　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_ERROR　　　　　　　　获得套接字错误　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_KEEPALIVE　　　　　　保持连接　　　　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_LINGER　　　　　　　 延迟关闭连接　　　　　　　　　　<span class="keyword">struct</span> linger</span><br><span class="line">SO_OOBINLINE　　　　　　带外数据放入正常数据流　　　　　<span class="type">int</span></span><br><span class="line">SO_RCVBUF　　　　　　　 接收缓冲区大小　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_SNDBUF　　　　　　　 发送缓冲区大小　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_RCVLOWAT　　　　　　 接收缓冲区下限　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_SNDLOWAT　　　　　　 发送缓冲区下限　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_RCVTIMEO　　　　　　 接收超时　　　　　　　　　　　　<span class="keyword">struct</span> timeval</span><br><span class="line">SO_SNDTIMEO　　　　　　 发送超时　　　　　　　　　　　　<span class="keyword">struct</span> timeval</span><br><span class="line">SO_REUSERADDR　　　　　 允许重用本地地址和端口　　　　　<span class="type">int</span></span><br><span class="line">SO_TYPE　　　　　　　　 获得套接字类型　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_BSDCOMPAT　　　　　　与BSD系统兼容　　　　　　　　　 <span class="type">int</span></span><br><span class="line">========================================================================</span><br><span class="line"><span class="comment">// SOL_SOCKET：通用套接字选项</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">选项名称(optname)　　　说明　　　　　          　　　　数据类型</span><br><span class="line">========================================================================</span><br><span class="line">IP_HDRINCL　　　　　　　在数据包中包含IP首部　　　　　　<span class="type">int</span></span><br><span class="line">IP_OPTINOS　　　　　　　IP首部选项　　　　　　　　　　　<span class="type">int</span></span><br><span class="line">IP_TOS　　　　　　　　　类型</span><br><span class="line">IP_TTL　　　　　　　　　生存时间　　　　　　　　　　　　 <span class="type">int</span></span><br><span class="line">========================================================================</span><br><span class="line"><span class="comment">//IPPROTO_IP：IP选项</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">选项名称(optname)　　　说明　　　　　          　　　　数据类型</span><br><span class="line">========================================================================</span><br><span class="line">TCP_MAXSEG　　　　　　TCP最大数据段的大小　　　　　　　 <span class="type">int</span></span><br><span class="line">TCP_NODELAY　　　　　 不使用Nagle算法　　　　　　　　　 <span class="type">int</span></span><br><span class="line">========================================================================</span><br><span class="line"><span class="comment">// IPPROTO_TCP：TCP选项  </span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="lwip-fcntl"><a href="#lwip-fcntl" class="headerlink" title="lwip_fcntl"></a>lwip_fcntl</h2><ul>
<li>功能：fcntl 的最小实现。 目前仅实现了命令 F_GETFL 和 F_SETFL。 只有标志 O_NONBLOCK 被实现。</li>
</ul>
<h2 id="lwip-send-x2F-lwip-sendto-x2F-lwip-write"><a href="#lwip-send-x2F-lwip-sendto-x2F-lwip-write" class="headerlink" title="lwip_send / lwip_sendto / lwip_write"></a>lwip_send / lwip_sendto / lwip_write</h2><ul>
<li><p>功能：发送数据</p>
</li>
<li><p>区别：</p>
<ul>
<li>lwip_send：核心， 最终的调用</li>
<li>lwip_write：直接调用lwip_send</li>
<li>Lwip_sendto：相较于lwip_to多了远程主机的ip地址和端口号相关的参数，处理中多了netconn_connect的调用（lwip_connect + lwip_send）</li>
</ul>
</li>
<li><p>函数原型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sendmsg	(	 	s,			\</span></span><br><span class="line"><span class="meta"> 						message,	\</span></span><br><span class="line"><span class="meta"> 						flags 		\</span></span><br><span class="line"><span class="meta">				)	   lwip_sendmsg(s,message,flags)</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="lwip-select"><a href="#lwip-select" class="headerlink" title="lwip_select"></a>lwip_select</h2><ul>
<li><p>功能：用于I/O多路复用的API，使用select可以同时监听多个socket的状态，以便读写数据</p>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> select	(	maxfdp1,		\</span></span><br><span class="line"><span class="meta"> 					readset,		\</span></span><br><span class="line"><span class="meta"> 					writeset,		\</span></span><br><span class="line"><span class="meta"> 					exceptset,		\</span></span><br><span class="line"><span class="meta"> 					timeout 		\</span></span><br><span class="line"><span class="meta">				)	lwip_select(maxfdp1,readset,writeset,exceptset,timeout)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>参数含义</p>
<ul>
<li><p>maxfdp1：要检查的最大文件描述符的数目，一般是最大dp+1</p>
</li>
<li><p>readset/writeset/exceptset：</p>
<p>fd_set类型，指向需要监听的可读、可写和异常事件的文件描述符集合</p>
</li>
</ul>
</li>
</ul>
<h2 id="lwip-recv"><a href="#lwip-recv" class="headerlink" title="lwip_recv"></a>lwip_recv</h2><ul>
<li><p>函数功能：接受数据</p>
</li>
<li><p>函数原型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> recv	(	 	s,	\</span></span><br><span class="line"><span class="meta"> 						mem,\</span></span><br><span class="line"><span class="meta"> 						len,\</span></span><br><span class="line"><span class="meta"> 						flags \</span></span><br><span class="line"><span class="meta">				)	   lwip_recv(s,mem,len,flags)</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：调用lwip_send / lwip_recv时出现WSAEWOULDBLOCK / WSAEINPROGRESS</p>
<p>A：本质上以上两个错误码不是错误，而是一种警告，接收方告诉发送方它现在处于busy状态</p>
<p>​		WSAEWOULDBLOCK的意思是output buffer已经满了，无法再写入数据。按照网上博主的说法，在绝大多数情况下其实不会出现buffer满的情况，而是		处于busy状态。我理解的这与overrun的意思差不多，只不过这里不会对数据正确性、完整性造成影响，接收方告诉我它的缓冲区满了或者数据已经处理		不过来了，它不再接受数据了，所以给我们一个异常。</p>
<p>​		WSAEINPROGRESS:一个阻塞的WINDOWS套接口调用正在运行中。</p>
<p>解决：当出现 WSAEWOULDBLOCK 异常后直到空出 Output Buffer 时，系统会发送一个 FD_WRITE 给发送方。我们完全可以在等收到 FD_WRITE 消息后再重新发送从出现异常开始的数据包即可（该包需要全部重新发送）。</p>
<blockquote>
<p><a href="https://bbs.csdn.net/topics/70198557">参考链接</a></p>
</blockquote>
</li>
<li></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://blog.csdn.net/wwwyue1985/article/details/113789192">Lwip之API接口与原理</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_39854159/article/details/120693512">LWIP学习之Socket （API篇）</a></p>
</li>
<li><p><a href="https://www.nongnu.org/lwip/2_0_x/group__socket.html#gae3d13671f622e17c17317c9a16dfd0ee">Lwip API</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
      <tags>
        <tag>lwip websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>51job爬虫项目</title>
    <url>/2022/12/03/item/51job/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>紧接着豆瓣爬虫的项目，该项目作为其后的练习和扩展，算是一个较为不错的上手练习。本文所涉及的是对于51job数据的爬取、解析和保存。对于数据可视化操作，在后续会持续更新，请关注！<br>在下面代码中有些函数内部调用了其他函数，需要补全各个部分的函数。如果需要源码请私信或者评论。</p>
<blockquote>
<p>具体关于库的操作我选择了一些官方文档和较好理解的解读文章做链接，知识点比较全面请参考下列表。</p>
</blockquote>
<ul>
<li><p><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/">详情页URL获取模块：selenium</a></p>
</li>
<li><p><a href="https://requests.readthedocs.io/zh_CN/latest/">URL处理第三方模块：requests</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/9135d7833d6d">数据提取etree模块：lxml</a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.7/library/sqlite3.html">数据库保存模块：sqlite3</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/python-robot/p/9958352.html">本地文件保存模块：xlwt</a></p>
</li>
</ul>
<h1 id="数据爬取与解析"><a href="#数据爬取与解析" class="headerlink" title="数据爬取与解析"></a>数据爬取与解析</h1><h2 id="详情页链接的获取：selenium"><a href="#详情页链接的获取：selenium" class="headerlink" title="详情页链接的获取：selenium"></a>详情页链接的获取：selenium</h2><p>selenium作为web自动化测试工具，目前在python爬虫中应用也越来越广泛。其主要应用原理是：通过完全模拟浏览器的操作，比如输入框输入、点击超链接元素、下拉滚动条等等来拿到js渲染之后的代码。<br>必要性：之前用的requests是对一个页面发送请求，只能获得当前加载出来的部分页面即最初的源代码，动态加载的数据是获取不到的，比如js渲染后的代码、下拉滚轮得到的数据和一些框内隐藏元素等等。<br>对于selenium的解读，<a href="https://blog.csdn.net/heartbeat196/article/details/113831482">请点击click</a>！</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#获得所有网页详情页链接</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_link</span>():</span><br><span class="line">    linklist = []</span><br><span class="line">    <span class="comment">#创建驱动器对象</span></span><br><span class="line">    wd = webdriver.Chrome(<span class="string">r'C:\Program Files\Google\Chrome\Application\chromedriver.exe'</span>)</span><br><span class="line">    wd.implicitly_wait(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">#访问51job网站</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">        wd.get(<span class="string">f"https://search.51job.com/list/010000,000000,0000,00,9,99,keyword,2,<span class="subst">{i}</span>.html?"</span>)</span><br><span class="line">        <span class="comment">#查找每每一条信息链接进入详情页</span></span><br><span class="line">        joblists = wd.find_elements_by_xpath(<span class="string">'//div[@class="j_joblist"]/div/a'</span>)</span><br><span class="line">        <span class="keyword">for</span> joblist <span class="keyword">in</span> joblists:</span><br><span class="line">            con_link = joblist.get_attribute(<span class="string">"href"</span>)</span><br><span class="line">            linklist.append(con_link)</span><br><span class="line">    wd.quit()</span><br><span class="line">    <span class="keyword">return</span> linklist</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注释：</p>
<ol>
<li>代码中的 webdriver.Chrome，后面是自己所用的驱动器的本地地址。</li>
<li>webdriver对象wd，调用 get方法，后面括号内为自己所要访问的网页链接地址。</li>
</ol>
</blockquote>
<h2 id="数据爬取与解析：xpath"><a href="#数据爬取与解析：xpath" class="headerlink" title="数据爬取与解析：xpath"></a>数据爬取与解析：xpath</h2><p>由于自己习惯于使用xpath方法解析，在此只做xpath解析的方法，如果需要re正则表达式或者BeautifulSoup解析，评论后续会更新。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>():</span><br><span class="line">    job_information = []</span><br><span class="line">    url_lists = get_link()</span><br><span class="line">    <span class="keyword">for</span> i,url <span class="keyword">in</span> <span class="built_in">enumerate</span>(url_lists):</span><br><span class="line">        datalist=[]</span><br><span class="line">        header = {</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0(Windows NT 10.0;Win64;x64)AppleWebKit/537.36(KHTML,likeGecko)Chrome/88.0.4324.150Safari/537.36"</span></span><br><span class="line">        }</span><br><span class="line">        response = requests.get(url, headers=header)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            html = response.content.decode(<span class="string">"gbk"</span>)</span><br><span class="line">            data = etree.HTML(html)</span><br><span class="line">            link = url</span><br><span class="line">            datalist.append(link)		<span class="comment">#存入岗位链接</span></span><br><span class="line">            title = data.xpath(<span class="string">r'//div[@class="cn"]/h1/@title'</span>)[<span class="number">0</span>]</span><br><span class="line">            datalist.append(title)		<span class="comment">#存入岗位名称</span></span><br><span class="line">            salary = data.xpath(<span class="string">r'//div[@class="cn"]/strong/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">            datalist.append(salary)</span><br><span class="line">            information = data.xpath(<span class="string">r'//p[@class="msg ltype"]/@title'</span>)[<span class="number">0</span>]</span><br><span class="line">            information = re.sub(<span class="string">r"\s+"</span>, <span class="string">""</span>, information)  <span class="comment"># 去除空白格</span></span><br><span class="line">            experience = information.split(<span class="string">"|"</span>)[<span class="number">1</span>]</span><br><span class="line">            datalist.append(experience)</span><br><span class="line">            education = information.split(<span class="string">"|"</span>)[<span class="number">2</span>]</span><br><span class="line">            datalist.append(education)</span><br><span class="line">            num = information.split(<span class="string">"|"</span>)[<span class="number">3</span>]</span><br><span class="line">            datalist.append(num)</span><br><span class="line">            place = data.xpath(<span class="string">r'//p[@class="fp"]/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">            datalist.append(place)</span><br><span class="line">            treatment = data.xpath(<span class="string">r'//span[@class="sp4"]/text()'</span>)</span><br><span class="line">            treatment = <span class="string">" "</span>.join(treatment)</span><br><span class="line">            datalist.append(treatment)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"-----第{}条------"</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            job_information.append(datalist)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"-----第{}条出错，原因是{}------"</span>.<span class="built_in">format</span>(i,e))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">#print(job_information)		#测试</span></span><br><span class="line">    <span class="keyword">return</span> job_information</span><br></pre></td></tr></tbody></table></figure>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="Excel本地保存"><a href="#Excel本地保存" class="headerlink" title="Excel本地保存"></a>Excel本地保存</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_data_excel</span>(<span class="params">datalist</span>):</span><br><span class="line">    workbook = xlwt.Workbook(encoding=<span class="string">"gbk"</span>, style_compression=<span class="number">0</span>)</span><br><span class="line">    worksheet = workbook.add_sheet(<span class="string">"python"</span>)</span><br><span class="line">    col = [<span class="string">"链接"</span>, <span class="string">"岗位名称"</span>, <span class="string">"薪资"</span>, <span class="string">"工作经验"</span>, <span class="string">"学历"</span>, <span class="string">"招聘人数"</span>, <span class="string">"工作地点"</span>, <span class="string">"福利"</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">        worksheet.write(<span class="number">0</span>, i, col[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(datalist)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">            worksheet.write(i+<span class="number">1</span>,j,datalist[i][j])</span><br><span class="line">    workbook.save(<span class="string">"北京-python工作.xls"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Excel数据保存结果展示"><a href="#Excel数据保存结果展示" class="headerlink" title="Excel数据保存结果展示"></a>Excel数据保存结果展示</h2><p><img src="/images/item/51job-1.png" alt="在这里插入图片描述"></p>
<h2 id="sqlite数据库保存"><a href="#sqlite数据库保存" class="headerlink" title="sqlite数据库保存"></a>sqlite数据库保存</h2><p>在此部分只写了数据库保存的工作，数据库的初始化创建需函数sql_init需要添加即可使用。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_data_sql</span>(<span class="params">datalist,dbpath</span>):</span><br><span class="line">    sql_init(dbpath)</span><br><span class="line">    conn = sqlite3.connect(dbpath)</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datalist:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            data[index] = <span class="string">'"'</span> + data[index] + <span class="string">'"'</span></span><br><span class="line">        sql = <span class="string">'''</span></span><br><span class="line"><span class="string">        insert into job_information(</span></span><br><span class="line"><span class="string">            link,title,salary,experience,education,num,place,treatment)</span></span><br><span class="line"><span class="string">            values(%s)'''</span>%<span class="string">","</span>.join(data)</span><br><span class="line">        <span class="comment">#print(sql)     #测试sql语句是否正确</span></span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        conn.commit()</span><br><span class="line">    cur.close()</span><br><span class="line">    conn.close()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="sqlite数据库保存结果展示"><a href="#sqlite数据库保存结果展示" class="headerlink" title="sqlite数据库保存结果展示"></a>sqlite数据库保存结果展示</h2><p><img src="/images/item/51job-2.png" alt="在这里插入图片描述"></p>
<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p>null</p>
]]></content>
      <categories>
        <category>Item</category>
      </categories>
  </entry>
  <entry>
    <title>豆瓣电影Top250数据爬取、数据分析及数据可视化</title>
    <url>/2022/12/03/item/doubanTop250Spider/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在爬虫学习中，一套完整的项目实战对于代码和计算机思维能力有很大的提升。本文基于B站视频<a href="https://www.bilibili.com/video/BV12E411A7ZQ?from=search&amp;seid=4741588992451392787">《Python爬虫基础5天速成（2021全新合集）Python入门+数据可视化》</a>关于 “豆瓣电影Top250” 项目做出的总结、拓展与分享。<br>在本文中，只展示数据爬取到数据保存的工作，数据可视化部分只做部分分析和结果展示。具体关于库的操作我选择了一些官方文档做链接，知识点比较全面请参考下列表。如果想要项目源代码，请评论或私信。</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.7/library/urllib.html?highlight=urllib">URL处理系统模块：urllib</a></li>
<li><a href="https://requests.readthedocs.io/zh_CN/latest/">URL处理第三方模块：requests</a></li>
<li><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/">数据提取bs4模块：BeautifulSoup</a></li>
<li><a href="https://docs.python.org/zh-cn/3.7/library/re.html">数据提取正则表达式模块：re</a></li>
<li><a href="https://www.jianshu.com/p/9135d7833d6d">数据提取模块 ：lxml</a></li>
<li><a href="https://docs.python.org/zh-cn/3.7/library/sqlite3.html">数据库保存模块：sqlite3</a></li>
<li><a href="https://www.cnblogs.com/python-robot/p/9958352.html">本地文件保存模块：xlwt</a></li>
</ul>
<h1 id="数据爬取与解析"><a href="#数据爬取与解析" class="headerlink" title="数据爬取与解析"></a>数据爬取与解析</h1><h2 id="数据爬取"><a href="#数据爬取" class="headerlink" title="数据爬取"></a>数据爬取</h2><p>数据爬取工作是整个工程的第一步，这一阶段所要做的工作是将网页上带有我们需要的信息的网页源码抓取下来。<strong>建议在此步骤时，如果数据量不大全部抓取保存到本地；如果数据量很大，则先保存一组到多组数据到本地</strong>。在接下的数据解析时通过本地文件解析，这样做会避免后面多次访问网站而被封ip，当然针对被封ip有相应的解决办法，但是这些内容涉及到网络知识，建议后面再学。</p>
<h3 id="urllib方法"><a href="#urllib方法" class="headerlink" title="urllib方法"></a>urllib方法</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">base_url = <span class="string">"https://movie.douban.com/top250?start="</span></span><br><span class="line">header = {</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">#构建请求</span></span><br><span class="line">req = urllib.request.Request(url=base_url,headers=header)</span><br><span class="line"><span class="comment">#得到响应</span></span><br><span class="line">response = urllib.request.urlopen(req)</span><br><span class="line">html = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="requests方法"><a href="#requests方法" class="headerlink" title="requests方法"></a>requests方法</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">base_url = <span class="string">"https://movie.douban.com/top250?start="</span></span><br><span class="line">header = {</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"</span></span><br><span class="line">}</span><br><span class="line">response = requests.get(url=base_url,headers=header)</span><br><span class="line">data = response.content.decode()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h2><p>数据解析作为第二步是整个工程的核心，这一步直接决定了 我们是否能够在海量的数据中只得到我们想要的数据。爬虫中三种重要的数据解析的方法分别是：BeautifulSoup、re正则表达式和xpath，三种方法没有优劣好坏，按照我前面给出的文档，自己用好一种即可满足需求，当然三种方法根据场景使用是最高效的，如果你是大佬的话👍。<br>我自己常用的是xpath方法。第一，xpath路径可以直接在网页上进行复制；第二，可以通过<a href="https://blog.csdn.net/heartbeat196/article/details/113790232">XPath Helper工具</a>进行更好的测试，我在之前的博客有提到可以<a href="https://blog.csdn.net/heartbeat196/article/details/113790232">点击</a>查看。下面我用三种不同的方法对保存到本地的一页上的数据进行了解析。</p>
<h3 id="BeaufifulSoup"><a href="#BeaufifulSoup" class="headerlink" title="BeaufifulSoup"></a>BeaufifulSoup</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#将要解析的网站打开</span></span><br><span class="line">html = <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"rb"</span>)</span><br><span class="line"><span class="comment">#构建BeautifulSoup对象</span></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">"html.parser"</span>)</span><br><span class="line"><span class="comment">#得到每一块的内容</span></span><br><span class="line">blocks = soup.select(<span class="string">".grid_view .item"</span>)</span><br><span class="line"><span class="comment">#构建电影列表</span></span><br><span class="line">movie_list = []</span><br><span class="line"><span class="comment">#电影链接和电影图片链接</span></span><br><span class="line"><span class="keyword">for</span> index,block <span class="keyword">in</span> <span class="built_in">enumerate</span>(blocks):</span><br><span class="line">    movie_dict = {}</span><br><span class="line">    movie_dict[<span class="string">"movie_href"</span>] = block.select(<span class="string">"a"</span>)[<span class="number">0</span>].get(<span class="string">"href"</span>)       <span class="comment">#电影详情页链接</span></span><br><span class="line">    movie_dict[<span class="string">"pic_href"</span>] = block.select(<span class="string">"img"</span>)[<span class="number">0</span>].get(<span class="string">"src"</span>)        <span class="comment">#电影链接</span></span><br><span class="line">    title = block.select(<span class="string">".title"</span>)                      <span class="comment">#电影名字</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(title)==<span class="number">2</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = block.select(<span class="string">".title"</span>)[<span class="number">0</span>].text            <span class="comment">#电影中文名字</span></span><br><span class="line">        o_title = block.select(<span class="string">".title"</span>)[<span class="number">1</span>].text            <span class="comment"># 电影中文名字</span></span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = o_title.replace(<span class="string">"/"</span>,<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = block.select(<span class="string">".title"</span>)[<span class="number">0</span>].text            <span class="comment">#电影中文名字</span></span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = <span class="string">" "</span>                                       <span class="comment">#电影外文名字</span></span><br><span class="line">    movie_dict[<span class="string">"rate"</span>] = block.select(<span class="string">".star .rating_num"</span>)[<span class="number">0</span>].text        <span class="comment">#电影评分</span></span><br><span class="line">    movie_dict[<span class="string">"judge"</span>] = block.select(<span class="string">".star span"</span>)[<span class="number">3</span>].text[:-<span class="number">3</span>]         <span class="comment">#评分人数</span></span><br><span class="line">    bd = block.select(<span class="string">".bd p"</span>)[<span class="number">0</span>].text</span><br><span class="line">    movie_dict[<span class="string">"bd"</span>] = re.sub(<span class="string">" "</span>,<span class="string">""</span>,bd)</span><br><span class="line">    movie_dict[<span class="string">"inq"</span>] = block.select(<span class="string">".quote .inq"</span>)[<span class="number">0</span>].text.replace(<span class="string">"。"</span>,<span class="string">""</span>)</span><br><span class="line">    movie_list.append(movie_dict)</span><br><span class="line"><span class="comment">#打印测试</span></span><br><span class="line"><span class="built_in">print</span>(movie_list)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#将要解析的网站打开</span></span><br><span class="line">html = <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"rb"</span>)</span><br><span class="line">content = html.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment">#构建etree对象</span></span><br><span class="line">data = etree.HTML(content)</span><br><span class="line"><span class="comment">#获取多个电影信息列表</span></span><br><span class="line">divs = data.xpath(<span class="string">'//div[@class="item"]'</span>)</span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    movie_dict = { }</span><br><span class="line">    movie_dict[<span class="string">"movie_href"</span>] = div.xpath(<span class="string">'div[@class="pic"]/a/@href'</span>)</span><br><span class="line">    <span class="comment">#print(movie_href)          #测试</span></span><br><span class="line">    movie_dict[<span class="string">"pic_href"</span>] = div.xpath(<span class="string">'div[@class="pic"]//img/@src'</span>)</span><br><span class="line">    <span class="comment">#print(pic_href)           #测试</span></span><br><span class="line">    title = div.xpath(<span class="string">'div[@class="info"]//a/span[@class="title"]/text()'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(title)==<span class="number">2</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = title[<span class="number">0</span>]</span><br><span class="line">        o_title = title[<span class="number">1</span>].replace(<span class="string">"/"</span>,<span class="string">""</span>)</span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = <span class="string">""</span>.join(o_title.split())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = title[<span class="number">0</span>]</span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = <span class="string">" "</span></span><br><span class="line">    <span class="comment">#print(c_title,o_title)      #测试</span></span><br><span class="line">    movie_dict[<span class="string">"rate"</span>] = div.xpath(<span class="string">'div//div[2]/div/span[2]/text()'</span>)</span><br><span class="line">    <span class="comment">#print(rate)                #测试</span></span><br><span class="line">    judge = div.xpath(<span class="string">'div//div[2]/div/span[4]/text()'</span>)</span><br><span class="line">    movie_dict[<span class="string">"judge"</span>] = (<span class="built_in">str</span>(judge))[<span class="number">2</span>:-<span class="number">5</span>]</span><br><span class="line">    <span class="comment">#print(judge)                #测试</span></span><br><span class="line">    bd = <span class="built_in">str</span>(div.xpath(<span class="string">'div//div[@class="bd"]/p[1]/text()'</span>))</span><br><span class="line">    movie_dict[<span class="string">"bd"</span>] = bd.replace(<span class="string">" "</span>,<span class="string">""</span>).replace(<span class="string">r"\xa0"</span>,<span class="string">""</span>).replace(<span class="string">r"\r"</span>,<span class="string">""</span>).replace(<span class="string">r"\n"</span>,<span class="string">""</span>)</span><br><span class="line">    <span class="comment">#print(bd)                   #测试</span></span><br><span class="line">    <span class="built_in">print</span>(movie_dict)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="re正则表达式"><a href="#re正则表达式" class="headerlink" title="re正则表达式"></a>re正则表达式</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment">#影片详情链接规则</span></span><br><span class="line">findLink = re.<span class="built_in">compile</span>(<span class="string">r'&lt;a href="(.*?)"&gt;'</span>)        <span class="comment">#创建正则表达式对象，表示规则（字符串的模式）</span></span><br><span class="line"><span class="comment">#影片图片规则</span></span><br><span class="line">findSrclink = re.<span class="built_in">compile</span>(<span class="string">r'&lt;img.*src="(.*?)"'</span>,re.S)</span><br><span class="line"><span class="comment">#影片片名规则</span></span><br><span class="line">findTitle = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span class="title"&gt;(.*)&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#影片的评分规则</span></span><br><span class="line">findGrade = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span class="rating_num" property="v:average"&gt;(.*)&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#评价人数规则</span></span><br><span class="line">findJud = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span&gt;(.*)人评价&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#找到概况</span></span><br><span class="line">findInq = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span class="inq"&gt;(.*)&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#影片相关内容</span></span><br><span class="line">findBd = re.<span class="built_in">compile</span>(<span class="string">r'&lt;p class=""&gt;(.*?)&lt;/p&gt;'</span>,re.S)</span><br><span class="line"><span class="comment">#将要解析的网站打开</span></span><br><span class="line">html = <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"rb"</span>)</span><br><span class="line">content = html.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">datalist = []</span><br><span class="line">soup = BeautifulSoup(content, <span class="string">"html.parser"</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> soup.find_all(<span class="string">"div"</span>,class_ = <span class="string">"item"</span>):</span><br><span class="line">    item = <span class="built_in">str</span>(item)</span><br><span class="line">    <span class="comment">#print(html)                                             #测试电影信息的一小段有没有内解析拿到</span></span><br><span class="line">    data = [ ]</span><br><span class="line">    title = re.findall(findTitle,item)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(title)==<span class="number">2</span>):</span><br><span class="line">        Ctitle = title[<span class="number">0</span>]</span><br><span class="line">        data.append(Ctitle)</span><br><span class="line">        Ftitle = title[<span class="number">1</span>]</span><br><span class="line">        Ftitle = title[<span class="number">1</span>].replace(<span class="string">"/"</span>, <span class="string">""</span>)</span><br><span class="line">        Ftitle = <span class="string">""</span>.join(Ftitle.split())</span><br><span class="line">        data.append(Ftitle)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Ctitle = title[<span class="number">0</span>]</span><br><span class="line">        data.append(Ctitle)</span><br><span class="line">        Ftitle = <span class="string">" "</span></span><br><span class="line">        data.append(Ftitle)</span><br><span class="line">    link = re.findall(findLink,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(link)</span><br><span class="line">    srclink = re.findall(findSrclink,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(srclink)</span><br><span class="line">    grade = re.findall(findGrade,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(grade)</span><br><span class="line">    judge = re.findall(findJud,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(judge)</span><br><span class="line">    inq = re.findall(findInq,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(inq)</span><br><span class="line">    bd = re.findall(findBd,item)[<span class="number">0</span>]</span><br><span class="line">    bd = re.sub(<span class="string">'&lt;br(\s+)?/&gt;(\s+)?'</span>,<span class="string">" "</span>,bd)</span><br><span class="line">    bd = re.sub(<span class="string">"/"</span>,<span class="string">" "</span>,bd)</span><br><span class="line">    bd = <span class="string">""</span>.join(bd.split())</span><br><span class="line">    data.append(bd)</span><br><span class="line">    datalist.append(data)</span><br><span class="line"><span class="built_in">print</span>(datalist)            <span class="comment">#测试所有列表是否被打印</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="本地excel保存"><a href="#本地excel保存" class="headerlink" title="本地excel保存"></a>本地excel保存</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line">workbook = xlwt.Workbook(encoding=<span class="string">"utf-8"</span>, style_compression=<span class="number">0</span>)</span><br><span class="line">worksheet = workbook.add_sheet(<span class="string">"豆瓣电影250"</span>)</span><br><span class="line">col = [<span class="string">"中文名"</span>, <span class="string">"外文名"</span>, <span class="string">"电影链接"</span>, <span class="string">"图片链接"</span>, <span class="string">"评分"</span>, <span class="string">"评价人数"</span>, <span class="string">"概评"</span>, <span class="string">"概述"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">    worksheet.write(<span class="number">0</span>, i, col[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(datalist)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">        worksheet.write(i + <span class="number">1</span>, j, datalist[i][j])</span><br><span class="line">workbook.save(<span class="string">"豆瓣top250_firstPage.xls"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="sqlite数据库保存"><a href="#sqlite数据库保存" class="headerlink" title="sqlite数据库保存"></a>sqlite数据库保存</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_db</span>(<span class="params">dbpath</span>):</span><br><span class="line">    sql = <span class="string">'''</span></span><br><span class="line"><span class="string">        create table movie250 </span></span><br><span class="line"><span class="string">        (</span></span><br><span class="line"><span class="string">        id integer primary key autoincrement,</span></span><br><span class="line"><span class="string">        info_link text,</span></span><br><span class="line"><span class="string">        pic_link text,</span></span><br><span class="line"><span class="string">        cname varchar,</span></span><br><span class="line"><span class="string">        ename varchar,</span></span><br><span class="line"><span class="string">        score numeric ,</span></span><br><span class="line"><span class="string">        rated numeric ,</span></span><br><span class="line"><span class="string">        instroduction text,</span></span><br><span class="line"><span class="string">        info text</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    '''</span>  <span class="comment"># 创建数据表</span></span><br><span class="line">    conn = sqlite3.connect(dbpath)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    conn.commit()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">saveData2DB</span>(<span class="params">datalist, dbpath</span>):</span><br><span class="line">    <span class="comment">#init_db(dbpath)</span></span><br><span class="line">    conn = sqlite3.connect(dbpath)</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datalist:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        	data[index] = <span class="string">'"'</span> + data[index] + <span class="string">'"'</span></span><br><span class="line">        sql = <span class="string">'''</span></span><br><span class="line"><span class="string">                insert into movie250 (</span></span><br><span class="line"><span class="string">                info_link,pic_link,cname,ename,score,rated,instroduction,info) </span></span><br><span class="line"><span class="string">                values(%s)'''</span> % <span class="string">","</span>.join(data)</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        conn.commit()</span><br><span class="line">    cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line">saveData2DB(datalist,<span class="string">"movie.db"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="/images/item/douban-1.png" alt="在这里插入图片描述"><br><img src="/images/item/douban-2.png" alt="在这里插入图片描述"></p>
<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a><a href="https://dormousehole.readthedocs.io/en/latest/">Flask</a></h2><p>Flask 是一个微型的 Python 开发的 Web 框架，基于Werkzeug WSGI工具箱和Jinja2 模板引擎。 Flask使用BSD授权。 Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数据库、窗体验证工具。<br>简单来说在此项目中，Flask框架给我们提供了一个本地网页平台展示数据。我们根据不同的路由地址进行到不同的页面访问。如下图是首界面，通过不同的链接地址可以实现页面跳转，当然只是本地！<br><img src="/images/item/douban-3.png" alt="在这里插入图片描述"></p>
<h2 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a><a href="https://echarts.apache.org/en/index.html">Echarts</a></h2><p>Echarts是一个纯基于js的图表库，可以流畅的运行在 PC 和移动设备上。在本项目中可以将数据进行统计分类从而用不同的展示方法进行展现。在Echarts中可以支持的图表类型有很多，同时其有一个很好的点在于它能满足我们实时修改查看，最终形成自己想要的图，便将js代码复制粘贴到我们所需要的网页代码的地方。<br>由于在页面内有动态显示，所以不在进行展示。</p>
<h2 id="WordCloud"><a href="#WordCloud" class="headerlink" title="WordCloud"></a>WordCloud</h2><p>词云展示方法是近些年来较为常用的数据可视化方法。其主要是通过分词技术将一篇文章或者一段话分成若干单词，然后统计这些词出现的频率，我们根据自定义化设置画布和这些词出现的颜色大小等等来得到某个词云。词云中重要的是画布的配置、自己所要定义的形式是什么样子，其他更多的是某些固定的方法。下图为我通过爬取毛不易的歌词内容获得毛不易的歌词词云图，如果需要此项目源码或者方法请私信。<br><img src="/images/item/douban-4.png" alt="在这里插入图片描述"></p>
<h1 id="新手问题总结与解决方法"><a href="#新手问题总结与解决方法" class="headerlink" title="新手问题总结与解决方法"></a>新手问题总结与解决方法</h1><h2 id="ip被封"><a href="#ip被封" class="headerlink" title="ip被封"></a>ip被封</h2><p>ip被封可能是新手在爬虫学习阶段遇到的最大的问题。首先如果是初学想要尽快实现一些成果时，建议在合理范围内减少爬取次数，如果我们能获得网页内容了首先将其存到本地文件夹下进行后续的测试和解析。俗话说：上有政策下有对策，面对ip被封：基础阶段我们可以添加请求头，尽可能的进行伪装像一个浏览器在访问；再进一步我们可以自己构建代理ip函数，仿照源码添加免费ip，构建handler处理器使用opener方法也可以；如果有能力的话，可以学习代理ip池的方法来解决该问题。<br>当然，爬虫我们是要在合法范围内进行抓取，如果某些数据是机密或者不能访问的，我们还一直访问可能就很快有自己的小手镯子了🔓。我们只爬取我们可以访问到的，爬虫只是提高效率，不是翻过禁墙。</p>
<h2 id="查看网页源码和”F12-Elements”后不一致"><a href="#查看网页源码和”F12-Elements”后不一致" class="headerlink" title="查看网页源码和”F12 Elements”后不一致"></a>查看网页源码和”F12 Elements”后不一致</h2><p>该问题可以总结为用一般方法有些需要的元素抓取不到。在本次项目中我们爬取的页面是静态网页所以可以直接抓取，但是对于动态网页就会无能为力。<br>查看网页源码：最原始的代码，指的是服务器直接发送到浏览器的代码。<br>F12检查元素：js渲染后的代码。而确实的部分就是js所渲染的。<br>如果我们想要抓取这部分代码可以采取以下两种方法：</p>
<ol>
<li>在页面上进行抓包，获取表单的元素和js链接提交请求</li>
<li>通过selenium技术，模拟用户打开网页，进行自动化的抓取。</li>
</ol>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>以上两个问题是我在这个项目中所遇到的，当然在面对更复杂的爬虫工作时，会有更加繁琐的问题出现。还有一些其他问题，我将其总结为基础知识问题。在很多初学的时候，我们获得的数据往往以不同的格式进行存储，但是某些方法只能针对某些固定数据格式，这些需要我们提起注意；还有就是我们不可避免的马虎问题，关键词拼写错误，变量书写错误等等，这些最好的解决办法就是孰能生巧。<br>最后就是建议大家在完成一个项目时选择分块按照不同的模块去练习测试，最终完成项目。</p>
]]></content>
      <categories>
        <category>Item</category>
      </categories>
  </entry>
  <entry>
    <title>LwIP协议栈</title>
    <url>/2022/11/30/third-party/lwip/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>Lwip官网：<a href="https://savannah.nongnu.org/projects/lwip/">https://savannah.nongnu.org/projects/lwip/</a></p>
</blockquote>
<p>LWIP（light weight ip）轻型IP协议，有无操作系统的支持都可以运行。LwIP实现的重点是在保持TCP协议主要功能的基础上减少对RAM 的占用，它只需十几KB的RAM和40K左右的ROM就可以运行，这使LwIP协议栈适合在低端的嵌入式系统中使用。</p>
<p>LWIP支持的协议种类：</p>
<ul>
<li>DNS，域名解析；</li>
<li>SNMP，简单网络管理协议；</li>
<li>DHCP，动态主机配置协议；</li>
<li>UDP 协议，用户数据报协议；</li>
<li>TCP 协议，支持 TCP 拥塞控制， RTT 估计，快速恢复与重传等；</li>
<li>IP 协议，包括 IPv4 和 IPv6，支持 IP 分片与重装，支持多网络接口下数据转发；</li>
<li>AUTOIP， IP 地址自动配置；</li>
<li>ICMP 协议，用于网络调试与维护；</li>
<li>IGMP 协议，用于网络组管理，可以实现多播数据的接收；</li>
<li>ARP 协议，以太网地址解析协议；</li>
<li>PPP，点对点协议，支持 PPPoE</li>
</ul>
<h1 id="LwIP架构"><a href="#LwIP架构" class="headerlink" title="LwIP架构"></a>LwIP架构</h1><p>LwIP 符合 TCP/IP 模型架构，规定了数据的格式、传输、路由和接收，以实现端到端的通信。 此模型包括四个抽象层，用于根据涉及的网络范围，对所有相关协议排序。这几 层从低到高依次为：</p>
<ul>
<li><p>链路层包含了局域网的单网段 （链路）通信技术</p>
</li>
<li><p>网际层 （IP）将独立的网络连接起来，建立互联</p>
</li>
<li><p>传输层处理主机端口到主机端口的通信</p>
</li>
<li><p>应用层在实现多个应用进程相互通信的同时，完成应用所需的服务 （例如：数据处理）</p>
<p><img src="/images/third-party/lwip.png"></p>
</li>
</ul>
<h1 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h1><h2 id="RAW-API"><a href="#RAW-API" class="headerlink" title="RAW API"></a>RAW API</h2><p>内核回调型API，当初始化应用时，用户需要为不同内核事件注册所需的回调函数 （例如 TCP_Sent、 TCP_error…）。当相应事件发生时， LwIP 会自发地调用相关的回调函数。<em>没有操作系统支持中，只能使用RAW API开发</em></p>
<table>
<thead>
<tr>
<th></th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TCP连接建立</td>
<td>tcp_new</td>
<td>建立一个新的 TCP PCB （协议控制块）。</td>
</tr>
<tr>
<td></td>
<td>tcp_bind</td>
<td>将 TCP PCB 绑定到本地 IP 地址和端口。</td>
</tr>
<tr>
<td></td>
<td>tcp_listen</td>
<td>启动 TCP PCB 上的监听进程。</td>
</tr>
<tr>
<td></td>
<td>tcp_accept</td>
<td>注册回调函数，连接成功建立后调用。</td>
</tr>
<tr>
<td></td>
<td>tcp_connect</td>
<td>发送连接建立请求。</td>
</tr>
<tr>
<td>发送TCP数据</td>
<td>tcp_write</td>
<td>将发送数据写入 TCP 缓冲区中。</td>
</tr>
<tr>
<td></td>
<td>tcp_sent</td>
<td>注册回调函数，数据发送成功后调用。</td>
</tr>
<tr>
<td></td>
<td>tcp_output</td>
<td>发送 TCP 缓冲区中的数据</td>
</tr>
<tr>
<td>接收TCP数据</td>
<td>tcp_recv</td>
<td>注册回调函数， TCP 接收到数据后调用</td>
</tr>
<tr>
<td>应用轮询</td>
<td>tcp_poll</td>
<td>注册回调函数，TCP慢定时器调用（500ms一次）。</td>
</tr>
<tr>
<td>关闭并终止连接</td>
<td>tcp_close</td>
<td>主动关闭。</td>
</tr>
<tr>
<td></td>
<td>tcp_err</td>
<td>注册回调函数，出错时调用。</td>
</tr>
<tr>
<td></td>
<td>tcp_abort</td>
<td>中止连接，向远程主机发送 RST。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>udp_new</td>
<td>创建新的 UDP PCB。</td>
</tr>
<tr>
<td></td>
<td>udp_remove</td>
<td>移除 UDP PCB 并释放相关资源。</td>
</tr>
<tr>
<td></td>
<td>udp_bind</td>
<td>将 UDP PCB 与本地 IP 地址和端口绑定。</td>
</tr>
<tr>
<td></td>
<td>udp_connect</td>
<td>建立 UDP PCB 远程 IP 地址和端口。</td>
</tr>
<tr>
<td></td>
<td>udp_disconnect</td>
<td>移除 UDP PCB 远程 IP 和端口。</td>
</tr>
<tr>
<td></td>
<td>udp_send</td>
<td>发送 UDP 数据</td>
</tr>
<tr>
<td></td>
<td>udp_recv</td>
<td>注册回调函数，当收到新数据报时即对其调用。</td>
</tr>
</tbody></table>
<h2 id="Netconn-API"><a href="#Netconn-API" class="headerlink" title="Netconn API"></a>Netconn API</h2><p>Netconn API 为高层有序 API，其执行模型基于典型的阻塞式打开 - 读 - 写 - 关闭机制。 若要正常工作，此 API 必须处于多线程工作模式，该模式需为 LwIP TCP/IP 栈实现专用线程， 并 / 或为应用实现多个线程。</p>
<p>基于操作系统的IPC机制（即信号量和邮箱机制）实现的，将LWIP内核代码和网络应用程序分离成了独立的线程，因此LWIP内核线程就只负责数据包的TCP/IP封装和拆封，而不用进行数据的应用层处理，大大提高了系统对网络数据包的处理效率</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>netconn_new</td>
<td>创建一个新连接。</td>
</tr>
<tr>
<td>netconn_delete</td>
<td>删除一个已有连接。</td>
</tr>
<tr>
<td>netconn_bind</td>
<td>将连接绑定到本地 IP 地址和端口。</td>
</tr>
<tr>
<td>netconn_connect</td>
<td>连接远程 IP 地址和端口。</td>
</tr>
<tr>
<td>netconn_send</td>
<td>通过 UDP 发送数据。</td>
</tr>
<tr>
<td>netconn_recv</td>
<td>接收数据。</td>
</tr>
<tr>
<td>netconn_listen</td>
<td>置 TCP netconn 处于监听模式。</td>
</tr>
<tr>
<td>netconn_accept</td>
<td>接受正在监听状态的 TCP 连接上的传入连接。</td>
</tr>
<tr>
<td>netconn_write</td>
<td>通过 TCP 数据 （将数据写入 TCP 缓冲区）。</td>
</tr>
<tr>
<td>netconn_close</td>
<td>主动关闭 TCP netconn。</td>
</tr>
</tbody></table>
<h2 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h2><p>了标准 BSD 套接字 API。它是有序 API，在内部构建于 Netconn API 之上，对网络连接进行了高级的抽象，使得用户可以像操作文件一样操作网络连接	</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>socket</td>
<td>创建一个新套接字。</td>
</tr>
<tr>
<td>bind</td>
<td>将套接字绑定到 IP 地址和端口。</td>
</tr>
<tr>
<td>listen</td>
<td>监听套接字连接。</td>
</tr>
<tr>
<td>connect</td>
<td>将套接字连接到远程主机 IP 地址和端口。</td>
</tr>
<tr>
<td>accept</td>
<td>在套接字上接受新连接。</td>
</tr>
<tr>
<td>read</td>
<td>从套接字读取数据。</td>
</tr>
<tr>
<td>write</td>
<td>向套接字写入数据。</td>
</tr>
<tr>
<td>close</td>
<td>关闭套接字 （删除套接字）。</td>
</tr>
</tbody></table>
<h1 id="LwIP配置"><a href="#LwIP配置" class="headerlink" title="LwIP配置"></a>LwIP配置</h1><p>lwipopts.h 文件允许用户充分配置栈及其所有模块。用户不需要定义 所有 LwIP 选项：如果未定义某选项，则使用 opt.h 文件中定义的默认值。因此， lwipopts.h 提供了覆盖许多 lwIP 行为的方法。</p>
<table>
<thead>
<tr>
<th><strong>Lwip 内存选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MEM_SIZE</td>
<td>LwIP 堆内存大小：用于所有 LwIP 动态内存分配</td>
</tr>
<tr>
<td>MEMP_NUM_PBUF</td>
<td>MEM_REF 和 MEM_ROM pbuf 总数</td>
</tr>
<tr>
<td>MEMP_NUM_UDP_PCB</td>
<td>UDP PCB 结构体的总数</td>
</tr>
<tr>
<td>MEMP_NUM_TCP_PCB</td>
<td>TCP PCB 结构体的总数</td>
</tr>
<tr>
<td>MEMP_NUM_TCP_PCB_LISTEN</td>
<td>处于监听状态的 TCP PCB 总数</td>
</tr>
<tr>
<td>MEMP_NUM_TCP_SEG</td>
<td>最多同时在 TCP 缓冲队列中的报文段数量</td>
</tr>
<tr>
<td>PBUF_POOL_SIZE</td>
<td>PBUF_POOL 类型的 pbuf 总数</td>
</tr>
<tr>
<td>PBUF_POOL_BUFSIZE</td>
<td>PBUF_POOL 类型 pbuf 的大小</td>
</tr>
<tr>
<td>TCP_MSS</td>
<td>最大 TCP 报文段 （MTU - IP 报头大小 - TCP 报头大小）</td>
</tr>
<tr>
<td>TCP_SND_BUF</td>
<td>对于一个连接， TCP 的发送缓冲空间</td>
</tr>
<tr>
<td>TCP_SND_QUEUELEN</td>
<td>TCP 发送队列中 pbuf 的最大数</td>
</tr>
<tr>
<td>TCP_WND</td>
<td>TCP 接收窗大小</td>
</tr>
</tbody></table>
<h1 id="LwIP内存管理"><a href="#LwIP内存管理" class="headerlink" title="LwIP内存管理"></a>LwIP内存管理</h1><p>LwIP有两种内存管理方式：内存池、内存堆</p>
<p>参考链接：<a href="https://blog.csdn.net/jiangjunjie_2005/article/details/26051399#t9">https://blog.csdn.net/jiangjunjie_2005/article/details/26051399#t9</a></p>
<h1 id="实现TCP服务器"><a href="#实现TCP服务器" class="headerlink" title="实现TCP服务器"></a>实现TCP服务器</h1><blockquote>
<p>echoserver实现：<a href="https://github.com/yangLieee/codebackup/tree/master/iperf">https://github.com/yangLieee/codebackup/tree/master/iperf</a></p>
</blockquote>
<ol>
<li><p>新建控制块 </p>
<p>使用tcp_new()函数建立一个TCP控制块。</p>
</li>
<li><p>绑定控制块</p>
<p>对于服务器来说，新建一个控制快后，需要在控制块上绑定本地IP和端口，以方便客户端的连接。</p>
</li>
<li><p>控制块侦听</p>
<p>使用tcp_listen函数，对于服务器来说，需要显性调用tcp_listen函数以使控制块进入监听状态，等待客户端的连接请求。</p>
</li>
<li><p>建立连接</p>
<p>在tcp_listen函数进入服务器监听状态后，需要马上使用tcp_accept函数来注册一个接收处理函数，因为一旦有客户端连接请求被成功建立后，服务器就会调用这个处理函数。</p>
</li>
<li><p>接受并处理数据</p>
<p>一旦连接成功，accept回调函数会调用tcp_recv函数注册一个接收完成的处理函数。对于服务器来说，接收到了客户端的数据或操作要求，就会调用这一回调函数进行处理。这其实是一个复杂的过程：接收到数据后，首先通知更新接受窗口（使用tcp_recved函数），处理并发送数据（使用tcp_write函数），数据发送成功则清除已发送的数据（使用tcp_sent函数），最后关闭连接（使用函数tcp_close）。</p>
</li>
</ol>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：<a href="https://blog.csdn.net/tanmx219/article/details/105930028">tcp_recvd正确调用方法</a>？</p>
<p>A：很多源码是在tcp_server_sent发送函数中调tcp_recvd，如果用户不是用来echo（立即发回相同的报文），而是真正要处理事务的时候，这种用法是错误的：此时，接收窗口大小由发送窗口决定，如果没有发送新数据，接收窗口就会越来越小，直到最后无法接收数据。<strong>正确的用法是：在收到数据后，应用层调用tcp_recved函数恢复原来的窗口大小；而在发送函数中，不用管窗口的事！</strong></p>
</li>
<li><p>Q：调用lwip iperf接口，无法关闭server?</p>
<p>A：lwip iperf只是实现当client断开连接删除掉其相关pcb结构体，而没有断开tcp连接没有释放监听端口，仿照lwiperf_tcp_close函数实现一个新的针对server关闭的接口即可</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.kancloud.cn/jiejietop/tcpip/988613">LwIP应用开发指南</a></li>
<li><a href="https://blog.csdn.net/weixin_54217950/article/details/121344759">网络基础之协议栈</a></li>
<li><a href="https://www.st.com/resource/zh/user_manual/um1713-developing-applications-on-stm32cube-with-lwip-tcpip-stack-stmicroelectronics.pdf">使用 LwIP TCP/IP 栈在 STM32Cube 上开发应用</a></li>
<li><a href="https://blog.51cto.com/u_15262460/2883223">LwIP使用经验</a></li>
<li><a href="https://blog.csdn.net/zhzht19861011/article/details/125322654">TCP回调函数是何时调用的</a></li>
<li><a href="https://blog.csdn.net/zhzht19861011/article/details/125278742">协议栈什么情况下发送 RST 标志</a></li>
</ol>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
      <tags>
        <tag>lwip</tag>
      </tags>
  </entry>
  <entry>
    <title>Mplayer编译及使用说明</title>
    <url>/2023/03/07/third-party/mplayer/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>官网：<a href="http://www.mplayerhq.hu/design7/news.html">http://www.mplayerhq.hu/design7/news.html</a></p>
</blockquote>
<p><strong>MPlayer</strong>是一款开源的多媒体播放器，以GNU通用公共许可证发布。此款软件可在各主流操作系统使用，例如Linux和其他类Unix操作系统、微软Windows系统及苹果电脑的Mac OS 系统。MPlayer是建基于命令行界面，在各操作系统可选择安装不同的图形界面。</p>
<h1 id="ubuntu下编译过程"><a href="#ubuntu下编译过程" class="headerlink" title="ubuntu下编译过程"></a>ubuntu下编译过程</h1><ol>
<li><p>下载并解压源码文件<a href="http://www.mplayerhq.hu/design7/news.html">click here</a></p>
</li>
<li><p>生成配置文件（目前直接走默认参数选项）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接执行./configure错误，--yasm=<span class="string">''</span>参数是根据提示没有找到yasm，可通过该命令直接执行</span></span><br><span class="line">./configure --yasm=''</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make完成既可看到文件夹下存在mplayer可执行文件</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>安装</p>
</li>
</ol>
   <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将mplayer及依赖的库文件进行安装, 不安装也可以进行使用</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure>

<h1 id="源码文件"><a href="#源码文件" class="headerlink" title="源码文件"></a>源码文件</h1><ul>
<li><p>vd__*	</p>
<p><strong>video decode</strong>  与解码相关的,解码器只是负责把解码完成的帧传输给vo，如何显示是vo的函数实现;</p>
</li>
<li><p>vf__*  </p>
<p><strong>video filter</strong>  所有过滤器的定义，当命令行输入-vf的参数，规则会去相应的filter函数解析。例如： -vf rotate=2,vf_rotate.c的函数进行进行rotate函数的解析。</p>
</li>
<li><p>vo_*</p>
<p><strong>video output</strong>   输出的函数定义，每一个函数对应实现一种或几种的功能。例如：vo_md5sum.c得到md5的一个值</p>
</li>
<li><p>DOCS 文档</p>
</li>
</ul>
<h1 id="mplayer流程"><a href="#mplayer流程" class="headerlink" title="mplayer流程"></a>mplayer流程</h1><ol>
<li><p>调用 AddExcept（）注册异常处理函数</p>
</li>
<li><p>initmplayer();   //初始化，创建快进和暂停的信号量</p>
</li>
<li><p>InitTimer();初始化计时器</p>
</li>
<li><p>mp_msg_init();初始化消息系统</p>
</li>
<li><p>set_path_env();设置路径、环境</p>
</li>
<li><p>ipu_image_start();ipu初始化</p>
</li>
<li><p>mplayer_showmode(1);设置显示模式</p>
</li>
<li><p>parse_codec_cfg(NULL);解析codec配置寄存器</p>
</li>
<li><p>打开数据流</p>
</li>
<li><p>分析播放树</p>
</li>
<li><p>添加播放树列表</p>
</li>
<li><p>初始化预填充缓存</p>
</li>
<li><p>打开播放的文件</p>
</li>
<li><p>创建buffer</p>
</li>
<li><p>打开数据流</p>
</li>
<li><p>检测数据流类型（音频格式和视频格式）</p>
</li>
<li><p>分析音频流视频流的信息（原始视频尺寸、分辨率、帧频率、码流大小）</p>
</li>
<li><p>启动相应的分离器</p>
</li>
<li><p>分析剪辑信息</p>
</li>
<li><p>初始化codec（多媒体数字信号编解码器）</p>
</li>
<li><p>选择打开相应的视频解码器</p>
</li>
<li><p>初始化视频解码器，分析视频流信息</p>
</li>
<li><p>选择打开相应的音频解码器</p>
</li>
<li><p>初始化音频解码器、PCM，分析音频信息</p>
</li>
<li><p>同步音频视频输出</p>
</li>
<li><p>开始播放</p>
</li>
</ol>
<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><ul>
<li><p>-list-options 打 印 所有 可 用 的 选 项</p>
</li>
<li><p>-vf   选择视频相关参数</p>
<ul>
<li><p>format 选择解码之后的格式输出</p>
</li>
<li><ul>
<li>NV12  /  NV21</li>
<li>BGRA</li>
<li>RGB</li>
</ul>
</li>
<li><p>rotate  选择旋转的角度输出</p>
</li>
<li><ul>
<li>1  顺时针旋转90</li>
<li>2  顺时针旋转270</li>
<li>4  旋转0度</li>
</ul>
</li>
</ul>
</li>
<li><p>-slave  从模式，mplayer会从标准输入读一个换行符（/n）分隔开的命令。</p>
</li>
<li><p>-quiet   去除杂项信息, 使 控制屏幕输出简略；尤其是阻止显示状态行（即 A: 0.7 V: 0.6 A-V: 0.068 …）</p>
</li>
<li><p>-speed &lt;0.01 - 100&gt;选择播放速率</p>
</li>
<li><p>-vo 指定视频输出驱动的优先级列表</p>
</li>
<li><p>-vc  选择编解码器，  -vc help 可以列出所有视频解码器，其中中括号里面是.dll的是我们无法使用的</p>
</li>
<li><ul>
<li>ffm264   264软解码</li>
<li>ffh264v4l2m2m  264硬解码</li>
</ul>
</li>
<li><p>-ao 指定音频输出驱动的优先级列表</p>
</li>
<li><p>-ac 指定音频解码器优先级列表</p>
</li>
<li><p>-zoom -x 800 -y 400 指令播放窗体的大小</p>
</li>
<li><p>-input  输入</p>
</li>
<li><ul>
<li>cmdlist  列出所有可绑定按键的命令</li>
<li>file 命令输入通道。制定输入fifo的名字，写入控制命令，与slave参数一起使用</li>
</ul>
</li>
</ul>
<h1 id="slave模式"><a href="#slave模式" class="headerlink" title="slave模式"></a>slave模式</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>MPlayer为后台运行其他程序，不再截获键盘事件，MPlayer会从标准输入读一个换行符（/n）分隔开的命令。</p>
<p>大多数slave模式命令相当于命令行选项。</p>
<ul>
<li><p>命令行播放通过 -input file= 参数监听某个管道</p>
</li>
<li><p>另起一个线程，创建同名管道并输入6.2所示控制参数即可达到控制mplayer的效果</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> /tmp/fifofile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mplayer -slave -input file=/tmp/fifofile &lt;movie&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>具体使用说明可以参考源文件下DOCS/tech/slave.txt</p>
<h2 id="控制参数"><a href="#控制参数" class="headerlink" title="控制参数"></a>控制参数</h2><p><strong>mplayer -input cmdlist</strong> 命令可以打印出一份可以输入清单</p>
<ul>
<li>get_file_name  打印当前文件名</li>
<li>get_percent_pos   打印出文件中的当前位置为整数百分比(0-100）</li>
<li>get_time_length   打印当前文件长度用秒表示</li>
<li>get_time_pos   打印文件当前位置用秒表示</li>
<li>seek  定位电影的某些地方<ul>
<li>0 是一个相对定位+/- （默认值）</li>
<li>1 是定位％在电影里</li>
<li>2 是寻求一个绝对位置的秒。</li>
</ul>
</li>
<li>quit   推出mplayer进程</li>
<li>stop   停止播放</li>
<li>exit   从OSD菜单退出控制台。不像’quit’，不退出MPlayer的</li>
</ul>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>针对slave使用方法，简单写了几个函数作为参考示例</p>
<p>github仓库（mplayerInterface文件夹）：<a href="https://github.com/yangLieee/codebackup.git">click here</a></p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>MPlayer interrupted by signal 13 in module: key_events ？</p>
<p>因为Mplayer是通过换行符(“\n”)来分隔不同的命令，所以我们在编程中不管是写入到管道文件还是写入到QT的进程中在命令后面一定要加入换行符(“\n”),这样Mplayer才能辨别。</p>
</li>
<li><p>只有在串口有输出，adb shell没有输出 </p>
<p>错误信息：Cannot find HOME directory.</p>
<p>解决方法：setenv(“HOME”，“/”，“1”)</p>
</li>
<li><p>在vo部分添加 rotate功能 之后, 只有一个方向可以正常显示?</p>
</li>
</ol>
<p>   对于nv12格式的图片和数据, uv_stride和stride这两个参数影响LCD最终显示的效果. 在旋转之后需要将对应的宽高对应到相应的stride中, 最终可以正常显示</p>
<ol start="4">
<li><p>mpi被mplayer用来存储解码之后的图像（mp_image.h中定义），得到mpi之后，vf被调用，整个filter链上钉filter都被调用了一遍包括最后的vo; 在vo的put_image里把图像输出到显示器上。这个时候需要考虑图像的存储方法，即用哪种颜色空间。</p>
</li>
<li><p><a href="https://blog.csdn.net/willand1981/article/details/5783107">https://blog.csdn.net/willand1981/article/details/5783107</a></p>
</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><a href="http://www.mplayerhq.hu/DOCS/man/zh_CN/mplayer.1.html">Mplayer和mencoder使用文档简介</a></p>
</li>
<li><p><a href="http://www.mplayerhq.hu/DOCS/HTML/zh_CN/index.html">Mplayer使用文档</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qizheguang/article/details/50552810">mplayer流程及相关函数说明</a></p>
</li>
<li><p><a href="https://blog.csdn.net/liangkaiming/article/details/5790893">slave 模式文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
  </entry>
  <entry>
    <title>XPath Helper安装及使用</title>
    <url>/2022/12/03/third-party/xpath/</url>
    <content><![CDATA[<h1 id="引语"><a href="#引语" class="headerlink" title="引语"></a>引语</h1><p><em>在爬虫各个应用场景下，数据解析为其中重要的一环。而在数据解析中，BeautifulSoup、Xpath以及正则表达式等多种方法均为利器，在实际应用中根据不同场景选择不同的方法是最高效的，但是对各个方法的掌握程度要求很高。事实上，精通一种方法就已经满足需要了，再此基础之上，用辅助工具帮助理解提高效率。<br>本文将提供给“爬虫大师们”使用xpath方法的辅助工具XPath Helper插件。</em></p>
<h1 id="XPath-Helper简介"><a href="#XPath-Helper简介" class="headerlink" title="XPath Helper简介"></a>XPath Helper简介</h1><p>XPath即为XML路径语言，它是一种用来确定XML(标准通用标记语言的子集)文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。起初XPath的提出的初衷是将其作为一个通用的、介于XPointer与XSL间的语法模型。<br>XPath Helper是一款专用于chrome内核浏览器的实用型爬虫网页解析工具。XPath Helper插件功能强劲，支持进行XPath查询功能。XPath Help插件可以帮助用户在各类网站上通过按shift键选择想要查看的页面元素来提取查询其代码，同时还支持用户对查询出来的代码进行编辑，而编辑出的结果将立即显示在旁边的结果框中。</p>
<h1 id="XPath-Helper安装方法"><a href="#XPath-Helper安装方法" class="headerlink" title="XPath Helper安装方法"></a>XPath Helper安装方法</h1><ol>
<li>根据下面的链接将文件下载到本地。<br>链接：<a href="https://pan.baidu.com/s/18_Ws5qjHW9skhE1cb1jtYA">https://pan.baidu.com/s/18_Ws5qjHW9skhE1cb1jtYA</a><br>提取码：x0no</li>
<li>下载完成后，将文件的后缀名改为“.zip”，并进行解压。</li>
<li>解压之后有两个文件，将文件名为“2.0.2_0.crx”后缀名改为“.zip”，并对其进行二次解压。<br>==至此，所有弹出的提示语句全部选择  是==</li>
<li>二次解压完成，获得如下图所示的文件夹。如果红色框内文件夹如图所示，将“_metadata”改为“metadata”。如果默认就是“metadata”则不需要做任何操作。<br><img src="/images/third-party/xpath-1.png"></li>
<li>进入自己对应的浏览器。在此，我以Google浏览器为基础操作。<br><strong>点击谷歌右上角的三个点的按钮<br>选择更多工具——&gt;选择扩展程序<br>进入，打开开发者模式，加载已解压的扩展程序，选择相应的已解压的文件，确认！<br>重启浏览器，确认可以正常使用</strong></li>
<li>如下图表示创建成功。<img src="/images/third-party/xpath-2.png" alt="在这里插入图片描述"></li>
</ol>
<h1 id="XPath-Helper简单使用方法"><a href="#XPath-Helper简单使用方法" class="headerlink" title="XPath Helper简单使用方法"></a>XPath Helper简单使用方法</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>获取页面元素的xpath地址。</li>
<li>验证用户自己写的xpath地址是否正确。</li>
</ol>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>打开/关闭XPath Helper快捷键：Ctrl+Shift+x</li>
<li>打开Xpath Helper后的结果如下图所示<br> <img src="/images/third-party/xpath-3.png" alt="在这里插入图片描述"></li>
<li>打开该插件的情况下，按住Shift在页面内进行移动，鼠标所经过之处会有黄色方框显示，下图为在CSDN首页，选中标题引导框的结果。左侧的query框内即为选中内容的xpath地址。<br><img src="/images/third-party/xpath-4.png" alt="在这里插入图片描述"></li>
<li>如果作为验证的方法，在query框内写入自己写入xpath地址，看result框内是否是自己想要抓取的元素，如果不正确，可以实时在query内进行修改，直至获得正确xpath地址。<br><img src="/images/third-party/xpath-5.png" alt="在这里插入图片描述"></li>
</ul>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
  </entry>
  <entry>
    <title>智能家居模型设计</title>
    <url>/2022/12/03/item/smartHome/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>伴随着通信技术的不断发展和社会环境的进步，人们对更智能化的生活有了更高的追求。物联网智能家居已经不能算是新鲜的名词了，其单品及互联应用也都已经非常广泛了。本设计基于STM32单片机，通过ESP8266无线通信模块以及连接相应的传感器及外设对智能家居的场景进行模拟。本文最初写于今年6月，现在从事嵌入式工作一段时间后现在再次将我的毕业设计重新进行整理和思考，希望能对读者有所帮助！</p>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>对于任何一个项目或者工程的开始第一步永远是先明确需求，知道自己做成什么样子的东西。在我参考了一些资料并阅读了几篇文献后，对其有了初认识。我理解的智能家居就是从感知层出发对环境进行监测，通过传输层遵从一定的网络协议对数据进行传输同时通过软件对数据进行整理分析，并在应用层（家具状态）做出相应的动作。最终我将该流程整理成下图所示的实物模拟，进而对其进行模块的抽象。基于此，进行下面的硬件设计选型及软件实现等等。<br><img src="/images/item/smarthome-1.png"></p>
<h1 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h1><h2 id="硬件选型原则"><a href="#硬件选型原则" class="headerlink" title="硬件选型原则"></a>硬件选型原则</h2><p>由于该项目是模型设计，对于硬件的选型整体上是以==低成本、低功耗、高集成、高仿真度==为原则的。</p>
<ul>
<li>满足功能及性能需求。本设计的侧重点不在于数据的精确和控制的灵敏，故没有严格参数要求。</li>
<li>易上手的“大众”产品。对于这些元件我们可以很容易的找到相关资料，而且避免踩坑。</li>
<li>兼容性。由于是模块化设计，对于部分模块的兼容性是要有一定的要求的。</li>
</ul>
<h2 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h2><p>如下是对于硬件的选型及相关介绍，最后附有一张所有用到的硬件的图片。</p>
<p><em><strong>1. 主控模块—-STM32F103C8T6</strong></em></p>
<p>   我相信51应该是大部分电子同学入手的第一款单片机。诚然，51有其灵活轻巧之处，但是stm32具有强大外设接口和较高的运行速度（STM32F103的CPU最高速度达72 MHz，具有16KB ~ 1MB Flash、多种控制外设、USB全速接口和CAN；多达112个快速I/O口、11个定时器和13个通信接口） 此外STM32还提供了三种省电模式和两种调试方式。其灵活的调试方法、多样的功能特点和较优的性能参数同样也是选择STM32作为主控芯片的原因。  </p>
<p><em><strong>2. 无线通信模块—-ESP01S无线通信模块</strong></em></p>
<p>   基于此模块首先考虑的是通信方式，如果不谈应用场景，比较传输速度、传输距离和安全性，zigbee和蓝牙会是更好的选择。但是在智能家居的场景下，wifi无疑会是更优选，因为当下wifi已经基本普及到了每个家庭，模拟还原度会更高。接下来是具体芯片的选择，安信可的ESP8266模组很多都可以在该场景下应用，其具体的区分主要体现在封装方式、硬件配置、资源引脚等等方面。具体的区分可以参考安信可官网给出的文档说明，<a href="https://www.ai-thinker.com/product/esp8266">please click</a>！</p>
<p><em><strong>3. 环境监测模块</strong></em></p>
<ul>
<li><p>温湿度监测—-DHT11</p>
<blockquote>
<p>  DHT11是一款有已校准数字信号输出的温湿度传感器。此传感器使用起来简单，精度和性能参数足够满足环境监测的场景。其遵从单总线协议，有严格的时序要求。主机先要发送一个至少18ms的低电平，在这个过程中，DHT11内部完成AD转换等操作，当主机拉高后，有20-40us时间，这个时间用于主机做输入输出切换，当主机释放总线控制权（此时主机为输入状态，总线被上拉电阻拉高），DHT11尝试将总线拉低，成功拉低后就开始准备发送数据了，再拉高一次就开始传输数据了。</p>
</blockquote>
</li>
<li><p>空气质量监测—-MQ135<br> &gt; MQ系列传感器是监测空气环境最常用的传感器，大概十几个都是针对不同污染物进行检测的，本次实验我们采用的是MQ135，主要针对氨气、苯、酒精、烟雾颗粒进行空气质量检测，同样根据自己的需求可以选择其他型号的传感器吧，比如烟雾、酒精、一氧化碳等等。</p>
</li>
<li><p>光照监测—-BH1750</p>
<blockquote>
<p> BH1750传感器有接近视觉灵敏度的光谱灵敏度特性，它支持I2CBUS接口，支持1.8v逻辑输入接口。传感器有两种可选的I2Cslave地址，无需其他外部件。光源依赖性弱，受红外线影响很小。传感器通过降低功率功能，实现低电流化。</p>
</blockquote>
</li>
</ul>
<p><em><strong>4. 数据展示模块—-OLED</strong></em></p>
<p>   数据显示无非就是OLED、LCD、TFT屏幕等等。该模块的作用是对监测到的环境数据及家具的状态进行实时显示。OLED相较于LCD屏幕则不需要背光层，同样也不需要发出光亮的液晶层；而相较于TFT有更高的性价比，最终选择了0.96寸OLED屏幕。</p>
<p><em><strong>5. 家具模拟模块</strong></em></p>
<p>   家具模拟模块主要是模拟到了门、窗、灯和风扇。具体是通过步进电机、舵机、LED灯和风扇模块实现的。而应用也很简单，配置IO口的工作模式，控制GPIO口输出的高低电平即可。<br>   <img src="/images/item/smarthome-2.png"></p>
<h2 id="PCB设计"><a href="#PCB设计" class="headerlink" title="PCB设计"></a>PCB设计</h2><p>对于以上众多元件和模块，如果用导线直接连接起来的话，我只能想到一个词形容：一团乱麻！因此设计PCB板就成了解决该问题的最好方法。可能有的同学在大学期间学习过如何画板打板，有些同学没有接触过，以我自己的经验来讲，学习一两周时间对于绘制该项目PCB已经绰绰有余。该项目并不需要在板子上有各个电路的设计（有能力的同学可以设计一个电源电路），因此只需要布局布线即可还是比较简单的，以下是我所设计的板子 。</p>
<p>该部分的设计让自己对于整个硬件资源的了解及使用有一个新的认识。在主控芯片有限的硬件资源、有限空间的电路板上，如何能充分利用每个元件的形状大小和性能特点来做到彼此之间的交互是该部分的重难点。<br>==Tips：阅读每根pin的功能，分配好主控芯片的各个管脚资源==</p>
<p><img src="/images/item/smarthome-3.png"></p>
<h1 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h1><p>整个代码工程内容相对较大，在此就不进行详细的展示了如果有需要可以私信我。在此只展示部分主函数代码和相关头文件等，除此之外，数据上云格式定义、命令下发、各个模块的驱动函数同样重要！</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"math.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"string.h"</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"dht11.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"BH1750.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED_I2C.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"usart.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"timer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"exti.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"door_bsp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fan.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"esp8266.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MqttKit.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"onenet.h"</span></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span>					<span class="comment">//定义结构体</span></span><br><span class="line">	<span class="type">uint8_t</span> temp;				<span class="comment">//温度</span></span><br><span class="line">	<span class="type">uint8_t</span> humi;				<span class="comment">//湿度</span></span><br><span class="line">	<span class="type">float</span> mq;					<span class="comment">//MQ135传感器</span></span><br><span class="line">	<span class="type">float</span> sun;					<span class="comment">//光照强度传感器</span></span><br><span class="line">	<span class="type">uint8_t</span> LED_FLAG;			<span class="comment">//LED</span></span><br><span class="line">	<span class="type">uint8_t</span> FAN_FLAG;			<span class="comment">//风扇</span></span><br><span class="line">	<span class="type">uint8_t</span> DOOR_FLAG;			<span class="comment">//步进电机</span></span><br><span class="line">	<span class="type">uint8_t</span> WARNING_FLAG;		<span class="comment">//步进电机</span></span><br><span class="line">}SendData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> SendData send_data;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> cmd_rev_flag;</span><br><span class="line">SendData send_data = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> ,<span class="number">0</span>};	<span class="comment">//初始化</span></span><br><span class="line"><span class="type">uint8_t</span> cmd_rev_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *data_ptr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> timeCount = <span class="number">0</span>;	<span class="comment">//发送间隔变量</span></span><br><span class="line">	Hardware_Init();</span><br><span class="line">	Net_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{  		</span><br><span class="line">		<span class="keyword">if</span>(++timeCount &gt;= <span class="number">200</span> || (cmd_rev_flag == <span class="number">1</span>))	</span><br><span class="line">{	</span><br><span class="line">			DHT11_Read_Data(&amp;send_data.temp,&amp;send_data.humi);</span><br><span class="line">			send_data.mq=(<span class="type">float</span>)(Get_Adc_Average(ADC_Channel_1,<span class="number">10</span>))*(<span class="number">3.3</span>/<span class="number">4096</span>);	</span><br><span class="line">			send_data.sun = LIght_Intensity();										 </span><br><span class="line">			OneNet_SendData();	<span class="comment">//发送数据</span></span><br><span class="line">			timeCount = <span class="number">0</span>;</span><br><span class="line">			cmd_rev_flag=<span class="number">0</span>;</span><br><span class="line">			ESP8266_Clear();</span><br><span class="line">		}</span><br><span class="line">		data_ptr = ESP8266_GetIPD(<span class="number">0</span>);		<span class="comment">//检查是否有下发指定</span></span><br><span class="line">		<span class="keyword">if</span>(data_ptr != <span class="literal">NULL</span>)</span><br><span class="line">			OneNet_RevPro(data_ptr);</span><br><span class="line">		delay_ms(<span class="number">10</span>);</span><br><span class="line">	}		 </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="硬件初始化"><a href="#硬件初始化" class="headerlink" title="硬件初始化"></a>硬件初始化</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Hardware_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	delay_init();	    		<span class="comment">//延时函数初始化</span></span><br><span class="line">	TIM2_Int_Init(<span class="number">4999</span>,<span class="number">7199</span>);  	<span class="comment">//用于OLED显示</span></span><br><span class="line">	Usart1_Init(<span class="number">115200</span>);		<span class="comment">//串口调试</span></span><br><span class="line">	Usart2_Init(<span class="number">115200</span>);		<span class="comment">//esp8266--stm32通信</span></span><br><span class="line">	OLED_Init();				<span class="comment">//OLED初始化</span></span><br><span class="line">	OLED_CLS();</span><br><span class="line">	KEY_Init();					<span class="comment">//按键初始化</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">								<span class="comment">//设置中断优先级分组2，为后面外部中断做基础</span></span><br><span class="line">	EXTIX_Init();				<span class="comment">//判断键值执行操作</span></span><br><span class="line">	DHT11_Init();				<span class="comment">//温湿度传感器初始化</span></span><br><span class="line">	Adc_Init();					<span class="comment">//空气检测初始化</span></span><br><span class="line">	BH1750_Init();				<span class="comment">//光照</span></span><br><span class="line">	TIM3_Int_Init(<span class="number">4999</span>,<span class="number">7199</span>);  	<span class="comment">//报警显示</span></span><br><span class="line">	ESP8266_Init();				<span class="comment">//初始化ESP8266</span></span><br><span class="line">	<span class="keyword">while</span>(OneNet_DevLink())		<span class="comment">//接入OneNET</span></span><br><span class="line">	delay_ms(<span class="number">500</span>);</span><br><span class="line">}	</span><br></pre></td></tr></tbody></table></figure>

<h1 id="云平台选择"><a href="#云平台选择" class="headerlink" title="云平台选择"></a>云平台选择</h1><p>本设计还有一个重要的部分就是对于云平台的选择，本项目选择的是中国移动物联网云平台OneNET。当然，如果有能力的同学自己做个app更好。</p>
<p>目前很多云平台厂商都支持了对于个人开发者的物联网应用的需求，我见到用到最多的包括阿里云、腾讯云、机智云、OneNET等等。这些平台对对于个人开发者还是很有好的，有着比较完善的流程。我个人使用过机智云和OneNET，对此做出以下建议。</p>
<ul>
<li>OneNET：更适合已有工程文件，在此基础之上进行通信部分的开发。其对于最终的界面设计很开放，可以自行设计图标及显示方式等；</li>
<li>机智云：适合没有工程文件，从刚开始就选择使用该物联网云平台。可以在平台上生成代码包进行开发；</li>
</ul>
<h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><h2 id="实物图与手机界面"><a href="#实物图与手机界面" class="headerlink" title="实物图与手机界面"></a>实物图与手机界面</h2><p><img src="/images/item/smarthome-4.png"></p>
<h2 id="云平台数据可视化界面"><a href="#云平台数据可视化界面" class="headerlink" title="云平台数据可视化界面"></a>云平台数据可视化界面</h2><p><img src="/images/item/smarthome-5.png"></p>
<h2 id="云平台控制界面"><a href="#云平台控制界面" class="headerlink" title="云平台控制界面"></a>云平台控制界面</h2><p><img src="/images/item/smarthome-6.png"></p>
<h1 id="实现功能及扩展"><a href="#实现功能及扩展" class="headerlink" title="实现功能及扩展"></a>实现功能及扩展</h1><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ul>
<li><p>监测：空气中温度、湿度、光照和空气质量等环境因素；</p>
</li>
<li><p>控制：模拟的“家居”：门、灯、窗帘、风扇；</p>
</li>
<li><p>显示：OLED显示、手机显示、电脑显示；</p>
</li>
<li><p>控制方式：按键控制、手机控制、电脑控制；</p>
</li>
<li><p>报警：设置环境因素阈值，超标开发板的灯亮起（可改成蜂鸣器）</p>
</li>
<li><p>以上所有环境及家具状态都可以可视化显示</p>
</li>
</ul>
<h2 id="可扩展功能"><a href="#可扩展功能" class="headerlink" title="可扩展功能"></a>可扩展功能</h2><p>该系统具有很高的扩展性，做出基础模型之后可以进行二次开发。需要注意的是将硬件资源分配好。</p>
<ul>
<li>语音模块。语音控制智能家居的状态。</li>
<li>安防系统。添加指纹、RFID、面部识别等开门方式。</li>
<li>告警系统。目前只是遇到告警平台自动提醒，可以添加短信通知功能。</li>
<li>模式选择。居家多种模式自动切换，娱乐模式、休息模式、离家模式等等，家具可以对应着不同状态。</li>
<li>……</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本设计对于智能家居控制系统的模拟从传统到智能、从前端到后端，覆盖面、还原度还是比较高的；其次，系统的兼容性和可扩展移植性较高，基于此可以进行二次开发，可以扩展的内容我在上面也有总结。我认为相对容易上手的就是对于监测到的数据进行进一步分析应用。最后就是其应用性，当自己设计好电源模块可以独立供电后就可以直接应用到生活中，即使不做毕设diy一个环境监测的系统也是不错的。整体来说，本设计实现的功能是：四测三显两控一平台，基本实现了智能家居模拟的基本的要求。同样该项目还可以应用到环境监测等方面的，但是其侧重点更要偏向数据的分析和处理。</p>
<p>行文至此就结束啦，如果有不足之处或者更好的想法可以一起交流 ~</p>
]]></content>
      <categories>
        <category>Item</category>
      </categories>
      <tags>
        <tag>毕业设计</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite</title>
    <url>/2023/04/11/third-party/sqlite3/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>sqlite中文网站：<a href="https://www.sqlite.net.cn/">https://www.sqlite.net.cn/</a></p>
</blockquote>
<p>SQLite是一种C语言库，它实现了一个&nbsp;小型、快速、自包含、高可靠性，&nbsp;功能齐全的SQL数据库引擎。SQLite是世界上最常用的数据库引擎，广泛应用于嵌入式领域。</p>
<p>与大多数其他SQL数据库不同，SQLite没有单独的服务器进程。SQLite直接读取和写入普通磁盘文件。具有多个表，索引，触发器和视图的完整SQL数据库包含在单个磁盘文件中。</p>
<h1 id="Shell命令"><a href="#Shell命令" class="headerlink" title="Shell命令"></a>Shell命令</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建数据库</span></span><br><span class="line"># sqlite3 test.db</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据库</span></span><br><span class="line"># .database</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建表格</span></span><br><span class="line"># CREATE TABLE <span class="title function_">user</span><span class="params">(Id integer PRIMARY KEY, name text)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询表格</span></span><br><span class="line"># .tables</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">#  INSERT INTO user <span class="title function_">VALUES</span><span class="params">(<span class="number">1</span>, <span class="string">'小张'</span>)</span>;</span><br><span class="line">#  INSERT INTO user <span class="title function_">VALUES</span><span class="params">(<span class="number">2</span>, <span class="string">'小陈'</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据(一定要有分号)</span></span><br><span class="line"><span class="meta"># select * from user;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出命令行环境</span></span><br><span class="line"># .quit / .<span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示数据库结构</span></span><br><span class="line"># .schema</span><br></pre></td></tr></tbody></table></figure>

<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>约束就是用来进一步描述每一列数据属性的。</p>
<h2 id="非空-NOT-NULL"><a href="#非空-NOT-NULL" class="headerlink" title="非空 NOT NULL"></a>非空 NOT NULL</h2><p>有一些字段我们可能一时不知到该填些什么，同时它也没设定默认值， 当添加数据时，我们把这样的字段空着不填，系统认为他是 NULL 值。但是还有另外一类字段，必须被填上数据，如果不填，系统就会报错。 这样的字段被称为 NOT NULL 非空字段,需要在定义表的时候事先声明。</p>
<h2 id="唯一-UNIQUE"><a href="#唯一-UNIQUE" class="headerlink" title="唯一 UNIQUE"></a>唯一 UNIQUE</h2><p>除了主列以外，还有一些列也不能有重复值。</p>
<h2 id="主键-PRIMARY-KEY"><a href="#主键-PRIMARY-KEY" class="headerlink" title="主键 PRIMARY KEY"></a>主键 PRIMARY KEY</h2><p>一般是整数或者字符串，只要保证唯一就行。 在 SQLite 中，主键如果是整数类型，该列的值可以自动增长。</p>
<h2 id="外键-FOREIGN-KEY"><a href="#外键-FOREIGN-KEY" class="headerlink" title="外键 FOREIGN KEY"></a>外键 FOREIGN KEY</h2><p>我们的数据库中已经有 Teachers 表了，假如我们再建立一个 Students 表， 要求 Students 表中的每一个学生都对应一个 Teachers 表中的教师。 很简单，只需要在 Students 表中建立一个 TeacherId 字段，保存对应教师的 Id 号， 这样，学生和教师之间就建立了关系。 问题是：我们有可能给学生存入一个不在 Teachers 表中的 TeacherId 值， 而且发现不了这个错误。 这种情况下，可以把 Students 表中 TeacherId 字段声明为一个外键， 让它的值对应到 Teachers 表中的 Id 字段上。 这样，一旦在 Students 表中存入一个不存在的教师 Id ，系统就会报错。</p>
<h2 id="默认值-DEFAULT"><a href="#默认值-DEFAULT" class="headerlink" title="默认值 DEFAULT"></a>默认值 DEFAULT</h2><p>有一些特别的字段列，在每一条记录中，他的值基本上都是一样的。只是在个别情况下才改为别的值，这样的字段列我们可以给他设一个默认值。</p>
<h2 id="条件检查-CHECK"><a href="#条件检查-CHECK" class="headerlink" title="条件检查 CHECK"></a>条件检查 CHECK</h2><p>某些值必须符合一定的条件才允许存入，这是就需要用到这个 CHECK 约束。</p>
<h1 id="VFS在linux下架构图"><a href="#VFS在linux下架构图" class="headerlink" title="VFS在linux下架构图"></a>VFS在linux下架构图</h1><p>Linux系统的User使用GLIBC（POSIX标准、GUN C运行时库）作为应用程序的运行时库，然后通过操作系统，将其转换为系统调用SCI（system-call interface），SCI是操作系统内核定义的系统调用接口，这层抽象允许用户程序的I/O操作转换为内核的接口调用。VFS提供了一个抽象层，将POSIX API接口与不同存储设备的具体接口实现进行了分离，使得底层的文件系统类型、设备类型对上层应用程序透明。</p>
<p><img src="/images/third-party/sqlite.png" alt="在这里插入图片描述"></p>
<h1 id="sqlite3-vfs"><a href="#sqlite3-vfs" class="headerlink" title="sqlite3 vfs"></a>sqlite3 vfs</h1><p>API：<a href="https://www.sqlite.net.cn/cintro.html">https://www.sqlite.net.cn/cintro.html</a></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 注册一个VFS系统，支持多个创建通过第二个参数使能</span></span><br><span class="line"># sqlite3_vfs_register(sqlite3_vfs *pVfs, <span class="type">int</span> makeDflt)</span><br><span class="line"><span class="comment">// 使用demo vfs替换默认的vfs</span></span><br><span class="line"># sqlite3_open_v2(<span class="string">"demo.db"</span>, &amp;db, SQLITE_OPEN_READWRITE, <span class="string">"demo"</span>);</span><br></pre></td></tr></tbody></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.51cto.com/u_15169172/2710683">一文搞懂嵌入式数据库sqlite3</a></p>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>电池电量检测</title>
    <url>/2023/03/06/work-expericence/%E7%94%B5%E6%B1%A0%E7%94%B5%E9%87%8F%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>近期在做关于电池电量检测的工作，而硬件电路并没有使用库仑计（在部分嵌入式场景下成本太高），而是使用分压电路ADC采样。基于此对相关学习到的内容做总结和分享</p>
<h1 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h1><ul>
<li>锂电池的放电非线性；</li>
<li>充放电瞬间，电压值是突变的</li>
<li>锂电池随着使用电量减少，需要实现自动校准</li>
<li>……</li>
</ul>
<h1 id="充电IC基础原理"><a href="#充电IC基础原理" class="headerlink" title="充电IC基础原理"></a>充电IC基础原理</h1><h2 id="IC充电阶段"><a href="#IC充电阶段" class="headerlink" title="IC充电阶段"></a>IC充电阶段</h2><ul>
<li><p>涓流充电（Trickle Charge）</p>
<p>涓流充电阶段通常只在电池电压低于一个极低水平时采用。</p>
<p>在这种状态下，电池组的内部保护 IC 可能由于深度放电或发生过流事件已经断开了电池。充电器 IC 提供一个小电流（通常为 50mA）为电池组的电容充电，以触发保护 IC ，合上其 FET重新连接电池。虽然涓流充电通常只持续几秒钟，但充电器 IC 仍然需要集成一个定时器。如果电池组在一定时间内未重新连接，则定时器停止充电，因为这表明电池已损坏。</p>
</li>
<li><p>预充电（PreCharge）</p>
<p>一旦电池组重新连接或处于放电状态，就进入预充电阶段。</p>
<p>预充电期间，充电IC开始以一个较低的电流水平为耗尽的电池安全充电，该电流通常为 C / 10（C 为容量，以 mAh 为单位）。预充电使电池电压缓慢上升。其目的是在低电流水平下对电池进行安全的充电，以防止损坏电池，直到其电压达到一个较高的水平。</p>
</li>
<li><p>恒流充电（Constant Current Charge）</p>
<p>恒流（CC）充电也被称作快速充电阶段，恒流充电在预充电之后开始。</p>
<p>在恒流充电阶段，电池可以安全地处理 0.5C 至3C 之间的较高充电电流。恒流充电会持续到电池电压达到“满电”或浮动电压水平，然后进入恒压充电阶段。</p>
</li>
<li><p>恒压充电（Constant voltage Charge）</p>
<p>充电器 IC 会在恒流充电期间监测电池电压。一旦电池达到恒压充电阈值，充电器IC就会从恒流转换至恒压调节阶段。当充电器 IC 监测到外部电池组电压超过了电池组中的实际电池电压，就开始执行恒压充电。这是由于存在内部电池电阻、PCB 电阻和来自保护 FET 和单电池的等效串联电阻 (ESR)。充电器 IC 不应允许电池电压超过其最大浮动电压，以保证安全的运行。</p>
</li>
<li><p>截止阶段</p>
<p>对于浮充型充电芯片，当达到浮充阈值，输出恒定电压</p>
<p>对于关断型充电芯片，当充电充满，芯片处于关断待机状态，无充电电流</p>
</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li>对于IC各个充电阶段需要参考IC的手册最终确定有哪些阶段，有些将涓流充电和预充电合成一个阶段处理，所以需要具体分析。</li>
<li>有些充电IC提供了可编程配置阈值的功能，即通过连接不同的阻值来对其进行设置，如果没有需要参考手册确定每个阶段的阈值分别是多少。配置的阈值能够提供一层额外的安全保护，保护电池免受过压、过热条件以及过载的影响，从而避免电池的永久损坏或容量降级。</li>
</ol>
<h1 id="流程整理"><a href="#流程整理" class="headerlink" title="流程整理"></a>流程整理</h1><ol>
<li><p>配置 ADC</p>
<p>中断模式、设置重复采样时间、设置采样次数</p>
<ul>
<li>Vadc = adcNumer(ADC采样数据) x Vref（ADC基准电压）/  （2^ADC量化位数）</li>
<li>Vbat = k（电阻分压系数比） ×  Vadc</li>
</ul>
</li>
<li><p>配置 Timer</p>
<p>配置ADC采样的时间即多久进行一次电池电量检测</p>
</li>
<li><p>启动电池电量检测主线程</p>
</li>
<li><p>等待USB插拔事件中断或者Timer时间触发电池检测</p>
<ul>
<li>打开ADC采样通道</li>
<li>获取ADC数据</li>
<li>关闭ADC采样通道</li>
<li>计算最终输出的电池电量</li>
</ul>
</li>
</ol>
<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/************************************   ADC    *******************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">adc_interrupt_cb</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// calculate adc voltage</span></span><br><span class="line">    <span class="comment">// 校准：采集多次去掉一个最小值、去掉一个最大值，取平均值</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">adc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// config adc interrupt mode and callback</span></span><br><span class="line">    <span class="comment">// config adc sampling times</span></span><br><span class="line">    <span class="comment">// enable adc channels</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/************************************   USB    *******************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_interrupt_callback</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// get usb charging / discharging state</span></span><br><span class="line">    <span class="comment">// put battery detect time to default</span></span><br><span class="line">    <span class="comment">// enable adc sampling(enter adc_interrupt_cb)</span></span><br><span class="line">}   </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// request drv_bus gpio</span></span><br><span class="line">    <span class="comment">// config  drv_bus interrupt and trigger mode</span></span><br><span class="line">    <span class="comment">// config  interrupt callback</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/***********************************    TIMER     ***************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_interrupt_cb</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// enable adc sampling(enter adc_interrupt_cb)</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// config timer</span></span><br><span class="line">    <span class="comment">// config default battery detect time to timer</span></span><br><span class="line">    <span class="comment">// config timer interrupt callback</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/***********************************   BATTERY    ***************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_battery_voltage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// enable channels</span></span><br><span class="line">    <span class="comment">// get battery voltage</span></span><br><span class="line">    <span class="comment">// disable channels</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adjust_battery_voltage</span><span class="params">(<span class="type">int</span> vbat)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// record pre_percent pre_voltage</span></span><br><span class="line">    <span class="comment">// record voltage and timestamp, calculate new battery detect time</span></span><br><span class="line">    <span class="comment">// other optimize ways</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">calculate_battery_percent</span><span class="params">(<span class="type">int</span> vbat)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 需要厂家提供电池充放电电池容量百分比对应的电压</span></span><br><span class="line">    <span class="comment">// 查表===&gt;计算出百分比</span></span><br><span class="line">    <span class="comment">// 策略：</span></span><br><span class="line">    <span class="comment">//   最终的百分比相较于上一次是否有跳变，+-1；</span></span><br><span class="line">    <span class="comment">//   充电百分比减少，放电百分比增加。不被允许，需要对这两种情况处理掉</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//电池电量检测函数可以进一步优化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">battery_detect_thread</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    adc_init();</span><br><span class="line">    usb_init();</span><br><span class="line">    timer_init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// calculate battery percent</span></span><br><span class="line">        <span class="type">int</span> vbat = get_battery_voltage();</span><br><span class="line">        vbat = adjust_battery_voltage(vbat);</span><br><span class="line">        <span class="type">int</span> percent = calculate_battery_percent(vbat);</span><br><span class="line">    }</span><br><span class="line">    adc_deinit();</span><br><span class="line">    usb_deinit();</span><br><span class="line">    timer_deinit();</span><br><span class="line">}   </span><br></pre></td></tr></tbody></table></figure>

<h1 id="误差来源"><a href="#误差来源" class="headerlink" title="误差来源"></a>误差来源</h1><ol>
<li>ADC量化误差</li>
<li>分压电阻值不准确，导致分压比不确定带来的误差</li>
<li>OCV表格内记录的是阶段性的电压与容量比，每一格实际上不是线性变化的，但在实际处理过程中按照线性来处理</li>
</ol>
<h1 id="校准误差及优化策略"><a href="#校准误差及优化策略" class="headerlink" title="校准误差及优化策略"></a>校准误差及优化策略</h1><ol>
<li><p>ADC采样</p>
<p>平均值滤波。取十次adc数据，去掉最大值、最小值取平均值</p>
</li>
<li><p>插入usb / 拔出usb瞬间触发电池检测</p>
</li>
<li><p>记录最近十次采样的结果及sysTime，计算掉电或上电1%容量所消耗的时间，从而可以计算出下一次检测的时间间隔</p>
</li>
<li><p>在最终电池电量的显示上，需要逐步递增逼近采集的值不能突变</p>
</li>
<li><p>校准：根据一个确定状态下，确定的电压值和我们采集到的电压值，计算出偏差，校准</p>
</li>
</ol>
<h1 id="缩写表"><a href="#缩写表" class="headerlink" title="缩写表"></a>缩写表</h1><ul>
<li><p>OCV：Open Circuitt Voltage  开路电压</p>
</li>
<li><p>CV：Cyclic Voltammetry 循环伏安法（改变电位以得到氧化还原电流方向之方法）</p>
</li>
<li><p>UVLO：Under Voltage Lock Out 欠压锁定（输入电压低于某一值时，电源芯片不工作，处于保护状态）</p>
</li>
<li><p>OVP：Over Voltage Protection  过压保护</p>
</li>
<li><p>UVP：Under voltage Protection  欠压保护</p>
</li>
<li><p>ASOC：Absolute State-Of-Charge  绝对电荷状态 （绝对荷电状态则是一个当电池制造完成时，根据所设计的固定容量值所计算出来的的参考值）</p>
</li>
<li><p>RSOC： Relative State-Of-Charge 相对电荷状态（相对荷电状态的范围是 0% - 100%）</p>
</li>
</ul>
<p>一个全新完全充电电池的绝对荷电状态是100%；而老化的电池即便完全充电，在不同充放电情况中也无法到100%。</p>
<h1 id="IC原理图及其它参考资料"><a href="#IC原理图及其它参考资料" class="headerlink" title="IC原理图及其它参考资料"></a>IC原理图及其它参考资料</h1><ol>
<li><a href="https://www.dioo.com/uploads/product/20210521/77eaa63f9de5e6b03018958741f47a52.pdf">DIO58056</a></li>
<li><a href="https://www.docin.com/p-2290652672.html">SY8602</a></li>
<li><a href="https://www.ti.com.cn/cn/lit/an/zhcaaf7/zhcaaf7.pdf">TI电量计设计指导</a></li>
<li><a href="https://blog.csdn.net/Linux_LR/article/details/119787382">ADC电量检测与校准</a></li>
</ol>
]]></content>
      <categories>
        <category>Work Experience</category>
      </categories>
  </entry>
  <entry>
    <title>ADC</title>
    <url>/2023/03/18/computerSystem/Peripherals/ADC/</url>
    <content><![CDATA[<h1 id="ADC基础"><a href="#ADC基础" class="headerlink" title="ADC基础"></a>ADC基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>ADC：Analog to Digital Converter，模数转换器</li>
<li>模拟信号：随时间变化连续的信号，一段时间内有无数个取值 </li>
<li>数字信号：随时间变化离散的信号，一段时间内有固定个数的取值</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ol>
<li><strong>采样 Sampling：</strong>按照一定的频率对模拟信号的瞬时时刻进行样本采集；</li>
<li><strong>量化 Quantization：</strong>对采样点的幅度赋予具体的数值；</li>
<li><strong>编码 Encoding：</strong>按照一定的格式记录数据；</li>
</ol>
<p><img src="/images/computerSystem/Peripherals/ADC.png" alt="image"></p>
<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ol>
<li><strong>采样速率 / 时钟频率</strong>：单位时间内能进行采样的次数	</li>
<li><strong>位宽 / 分辨率：</strong>输入信号值的最小变化</li>
<li>其它细化指标<ul>
<li>DLN：微分非线性，相对指标</li>
<li>ILN： 积分非线性，绝对指标</li>
<li>SFDR：无杂散动态范围</li>
</ul>
</li>
</ol>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="SAR"><a href="#SAR" class="headerlink" title="SAR"></a>SAR</h3><ul>
<li>SAR：Successive Approximation Register，逐次逼近型</li>
<li>原理：二分查找</li>
<li>特点：低延迟，低功耗</li>
</ul>
<h3 id="∆-∑"><a href="#∆-∑" class="headerlink" title="∆ -∑"></a><strong>∆ -∑</strong></h3><ul>
<li>∆ -∑ ：Delta-Sigma ADC</li>
<li>原理：就是把待测信号Vin与参考电压之间的差值进行不断的累积并通过反馈令这个差值趋于零（尺子量纸）</li>
<li>特点：精度高，延迟相较于SAR高</li>
</ul>
<h2 id="信号误差来源"><a href="#信号误差来源" class="headerlink" title="信号误差来源"></a>信号误差来源</h2><ul>
<li>电磁辐射 EMI</li>
<li>电路板设计缺陷</li>
<li>电源电压的变化</li>
<li>环境的变化</li>
<li>量化误差（内部）</li>
</ul>
<h1 id="SAR-A-x2F-D-Controller"><a href="#SAR-A-x2F-D-Controller" class="headerlink" title="SAR A/D Controller"></a>SAR A/D Controller</h1><p>该部分涉密不做具体说明</p>
<h2 id="逻辑框图"><a href="#逻辑框图" class="headerlink" title="逻辑框图"></a>逻辑框图</h2><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><ul>
<li><p>轮询Polling</p>
</li>
<li><p>中断Interrupt</p>
<p>使用中断方式采样完成后会自动进入中断服务函数。节约CPU资源</p>
</li>
<li><p>定时器触发</p>
</li>
<li><p>DMA</p>
</li>
</ul>
<h1 id="结果计算"><a href="#结果计算" class="headerlink" title="结果计算"></a>结果计算</h1><p>Vout = ADATA / ( 2 ^ Resolution) × Vref_ADC</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>ADC Clock Divide 寄存器分频系数计算公式x1600与x2000不一致</p>
</li>
<li><p>ADVDATn(0-3)寄存器读出结果后 AUXEN(0-3) 寄存器自动清零（但是如果将采样模式设置为重复采样模式则不会自动清零）</p>
</li>
<li><p>ADC 最终计算得到的结果可能是中间结果，需要对照原理图看是否有分压，进一步计算最终结果</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.ti.com/seclit/eb/slyw038c/slyw038c.pdf">模拟工程师口袋参考指南</a></li>
<li><a href="https://training.ti.com/ti-precision-labs-adcs">TI高精度实验室培训视频</a></li>
</ul>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>ADC</category>
      </categories>
  </entry>
  <entry>
    <title>IIS</title>
    <url>/2023/04/05/computerSystem/protocol/IIS/</url>
    <content><![CDATA[<p>ADC将模拟信号转换为数字信号，而数字信号的音频数据则是按照一定标准（硬件传输协议）传入SOC中进行处理；同理DAC将数字信号转换为模拟信号，模拟信号的音频数据也是按照同样的标准将数据传输到喇叭进行声音的播放</p>
<h1 id="数字音频信号传输标准"><a href="#数字音频信号传输标准" class="headerlink" title="数字音频信号传输标准"></a>数字音频信号传输标准</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>数字音频信号传输标准也可以称作音频硬件传输协议，主要包括：</p>
<ul>
<li>I2S：Integrated Interchip Sound，集成电路内部音频</li>
<li>PCM：Pulse Code Modulation，脉冲编码调制</li>
<li>PDM：Pulse Density Modulation，脉冲密度调制</li>
<li>S/PDIF：Sony/Philips Digital Interface，索尼/飞利浦数字接口</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>PCM：单声道，时延小。打电话之间的数据；</p>
<p>I2S：双声道，速度快。主要用于传输音乐；</p>
<p>PDM：尺寸受限的场景。手机cpu到蓝牙的通话实时音频；</p>
<p>S/PDIF：用于板间长距离及需要电缆连接的场合</p>
<h1 id="I2S基础"><a href="#I2S基础" class="headerlink" title="I2S基础"></a>I2S基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>I2S(Inter-IC Sound)总线,  又称集成电路内置音频总线，是飞利浦半导体公司(现为恩智浦半导体公司)针对数字音频设备之间的音频数据传输而制定的一种总线标准。</p>
<p>该总线专门用于音频设备之间的数据传输，广泛应用于各种多媒体系统。</p>
<p>它采用了独立的导线传输时钟与数据信号的设计，通过将数据和时钟信号分离，避免了因时差诱发的失真，为用户节省了购买抵抗音频抖动的专业设备的费用。</p>
<h2 id="信号定义"><a href="#信号定义" class="headerlink" title="信号定义"></a>信号定义</h2><h3 id="WS"><a href="#WS" class="headerlink" title="WS"></a>WS</h3><p>WS：Word Select，左右声道选择信号（也称帧时钟 Left Right Clock）</p>
<p>标准I2S定义：WS=0，表示正在传输左声道的数据；WS=1，表示正在传输右声道的数据。</p>
<h3 id="SCK"><a href="#SCK" class="headerlink" title="SCK"></a>SCK</h3><p>SCK：Serial Clock，串行时钟信号（也称位时钟Bit Clock）</p>
<p>SCK是模块内的同步信号，从模式时由外部提供，主模式时由模块内部自己产生。对应数字音频的每一位数据，SCK都有一个脉冲。</p>
<h3 id="SD"><a href="#SD" class="headerlink" title="SD"></a>SD</h3><p>SD：Serial Data，串行数据信号（分时复用）</p>
<p>SD以二进制补码形式在数据线上传输，并且按照由高位(MSB)到低位(LSB)依次进行传输。之所以这样设计是为了保证重要的数据能够保存下来。因为发送设备和接收设备的字长可能不一样，如果接收设备接受的字长比规定的字长长的话就会产生截断，将超出字长部分忽略，相反如果接收设备接收的字长比规定字长短就会将空位补0。这样确保了最高有效位能够传输。</p>
<ul>
<li>LSB：Least Significant Bit，最低有效位</li>
<li>MSB：Most Significant Bit，最高有效位</li>
</ul>
<blockquote>
<p>发送器可以在时钟脉冲的前沿或后沿发送数据,，这可以在相应的控制寄存器中配置。但是接收器仅在时钟脉冲的前沿锁存串行数据和 WS。</p>
</blockquote>
<h3 id="MCLK"><a href="#MCLK" class="headerlink" title="MCLK"></a>MCLK</h3><p>除此之外，通常还有还有一个SYSCLK（MCLK），用于提供给音频功放工作时钟，通常是2/4/8倍的BCLK</p>
<h2 id="系统框图"><a href="#系统框图" class="headerlink" title="系统框图"></a>系统框图</h2><ul>
<li>只有一个主设备，并且SCK和WS信号一定是主设备产生</li>
<li>在复杂系统中，通常有多个发送器和接收器，此时通常有外部控制器进行控制</li>
</ul>
<p><img src="/images/computerSystem/protocol/I2S-1.png" alt="image"></p>
<h1 id="典型I2S时序图"><a href="#典型I2S时序图" class="headerlink" title="典型I2S时序图"></a>典型I2S时序图</h1><blockquote>
<p>说明：本部分的作图是以位宽为16bit为例进行说明</p>
<p>可以参考文章尾TI CODEC文中对于时序的描述</p>
</blockquote>
<p>随着技术的发展，I2S也出现了一些变种，但是换汤不换药协议核心是不变的。</p>
<p>根据SD相较于LRCLK的位置的不同分为三种模式：I2S格式（PHILIPS模式）、左对齐格式（较少使用）、右对齐格式（日本格式/SONY格式）</p>
<h2 id="共通特性"><a href="#共通特性" class="headerlink" title="共通特性"></a>共通特性</h2><ol>
<li><p>WS叫字选择，即每一个高低电平持续时间内传输的是一个字（32bit）的数据；</p>
</li>
<li><p>SCK叫位时钟，用于同步数据传输，波形为方波（对应WS一个周期最大有64个方波）</p>
</li>
<li><p>WS的频率等于采样频率。假设采样频率44.1khz，即1秒内有44100采样点（44100个周期）</p>
</li>
<li><p>SCK的频率 = 声道数 * 采样频率 * 采样位数。</p>
</li>
</ol>
<h2 id="I2S格式"><a href="#I2S格式" class="headerlink" title="I2S格式"></a>I2S格式</h2><ul>
<li><p>左声道的MSB在字时钟下降沿后的第二个位时钟上升沿有效。 同样，右声道的MSB在字时钟上升沿后的第二个位时钟上升沿有效</p>
</li>
<li><p>SCK延迟一个时钟位开始传输数据（为接收器提供了时间来存储已经接收的字，并清除下一个字的输入寄存器）</p>
</li>
</ul>
<p><img src="/images/computerSystem/protocol/I2S-2.png" alt="image"></p>
<h2 id="左对齐"><a href="#左对齐" class="headerlink" title="左对齐"></a>左对齐</h2><ul>
<li>左对齐模式下，右声道的 MSB 在字时钟下降沿之后的位时钟上升沿有效。 同样，左声道的MSB在字时钟上升沿之后的位时钟上升沿有效</li>
</ul>
<p><img src="/images/computerSystem/protocol/I2S-3.png" alt="image"></p>
<h2 id="右对齐"><a href="#右对齐" class="headerlink" title="右对齐"></a>右对齐</h2><ul>
<li><p>右对齐模式，左声道的 LSB 在字时钟下降沿之前的位时钟上升沿有效。 同样，右声道的 LSB 在字时钟上升沿之前的位时钟上升沿有效。</p>
</li>
<li><p>接收设备必须事先知道待传数据的字长</p>
</li>
</ul>
<p><img src="/images/computerSystem/protocol/I2S-4.png" alt="image"></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>发送端和接收端的数据格式要一致，同为左对齐、右对齐或I2S格式</p>
</li>
<li><p>标准左对齐和标准右对齐模式的LRCK/WS高低电平对应的左右声道与标准I2S模式的规定相反。I2S：0：L，1：R；左对齐/右对齐：0：R，1：L；</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://users.ece.utexas.edu/~bevans/courses/realtime/lectures/10_Data_Conversion/AP_Understanding_PDM_Digital_Audio.pdf">Understanding PDM Digital Audio</a> </li>
<li><a href="https://www.sparkfun.com/datasheets/BreakoutBoards/I2SBUS.pdf">I2S Bus Specification</a></li>
<li><a href="https://www.elprocus.com/i2s-protocol/">I2S Protocol : Working, Differences &amp; Its Applications</a></li>
<li><a href="https://www.crifan.com/common_audio_interface_tdm_pdm_i2s_pcm/">音频接口：TDM，PDM，I2S，PCM 简介</a></li>
<li><a href="https://www.ti.com.cn/cn/lit/ds/symlink/tlv320aic31.pdf">TI CODEC手册</a></li>
</ul>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>storage system</tag>
        <tag>I2S</tag>
      </tags>
  </entry>
  <entry>
    <title>GPIO</title>
    <url>/2022/09/22/computerSystem/Peripherals/GPIO/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>GPIO：General Purpose Input Output，通用输入输出，简称为“IO口”，芯片与外围设备交互的硬件接口</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>以下图片来自STM32的GPIO硬件电路图</p>
<p><img src="/images/computerSystem/Peripherals/GPIO-1.png" alt="image"></p>
<p>施密特触发器：在正向递增和负向递减两个方向有不同的阈值，有一定的抗干扰能力，外部的小扰动不会导致cpu误判，直至剧烈变化或者真的有电平的变化。</p>
<h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><h2 id="输入（4）"><a href="#输入（4）" class="headerlink" title="输入（4）"></a>输入（4）</h2><ol>
<li>浮空输入：多用于外部按键输入，io状态不确定完全由外部输入决定</li>
<li>上拉输入：IO口输入设定为高电平输入（1），检测低电平或下降沿</li>
<li>下拉输入：IO口输入设定为低电平输入（0）</li>
<li>模拟输入：ADC模拟输入，测量外部电压幅值不通过TTL</li>
</ol>
<h2 id="输出（4）"><a href="#输出（4）" class="headerlink" title="输出（4）"></a>输出（4）</h2><ol>
<li>推挽输出：输出高低电平</li>
<li>开漏输出：只有一个NMOS导通，只能输出低电平+高阻态，不能输出高电平；当NMOS导通输出低电平，截至输出高阻态。用作线与，电平不匹配的场合，外部上拉</li>
<li>复用推挽输出：需要输出高低电平的其他模式，如：spi uart</li>
<li>复用开漏输出：普通i2c处于该模式</li>
</ol>
<h1 id="GPIO寄存器"><a href="#GPIO寄存器" class="headerlink" title="GPIO寄存器"></a>GPIO寄存器</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>以stm32为例</p>
<ul>
<li>GPIO 端口模式寄存器 (GPIOx_MODER) (x = A…I)</li>
<li>GPIO 端口输出类型寄存器 (GPIOx_OTYPER) (x = A…I)</li>
<li>GPIO 端口输出速度寄存器 (GPIOx_OSPEEDR) (x = A…I/)</li>
<li>GPIO 端口上拉/下拉寄存器 (GPIOx_PUPDR) (x = A…I/)</li>
<li>GPIO 端口输入数据寄存器 (GPIOx_IDR) (x = A…I)</li>
<li>GPIO 端口输出数据寄存器 (GPIOx_ODR) (x = A…I)</li>
<li>GPIO 端口置位/复位寄存器 (GPIOx_BSRR) (x = A…I)</li>
</ul>
<h2 id="GPIO-Shadow"><a href="#GPIO-Shadow" class="headerlink" title="GPIO Shadow"></a>GPIO Shadow</h2><p>由于设置某个模式的过程中配置的不只是一个寄存器，配置过程中就可能出现别的状态的产生，导致错误。而使用shadow寄存器，可以先将所有需要配置的寄存器分别设置进去，但不生效，直至全部设置完毕，再指定GPID即要映射的组上去生效！避免了中间非必要状态的产生。</p>
<h1 id="用户层应用"><a href="#用户层应用" class="headerlink" title="用户层应用"></a>用户层应用</h1><h2 id="配置GPIO"><a href="#配置GPIO" class="headerlink" title="配置GPIO"></a>配置GPIO</h2><p>在内核导出 gpio 节点的前提下， 可以操作/sys/class/gpio 节点， 控制 gpio 输入输出</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">导出节点：  echo <span class="number">20</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">export</span></span></span><br><span class="line"><span class="class">设置方向：  <span class="title">echo</span> [<span class="title">out</span> / <span class="title">in</span>] &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio20</span>/<span class="title">direction</span></span></span><br><span class="line"><span class="class">设置值：    <span class="title">echo</span> [0 / 1] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">value</span></span></span><br><span class="line"><span class="class">设置触发模式：<span class="title">echo</span> [<span class="title">none</span> / <span class="title">rising</span> / <span class="title">falling</span> /  <span class="title">both</span>] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">edge</span></span></span><br><span class="line"><span class="class">翻转属性：  <span class="title">echo</span> [0 / 1] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">active_low</span></span></span><br><span class="line"><span class="class">移除节点：  <span class="title">echo</span> 20 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">unexport</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>注意事项</p>
<ul>
<li>direction<br>如果内核不支持改变 GPIO 的方向，或者在导出时内核代码没有明确允许用户空间可以重新配置 GPIO 方向， 那么这个属性将不存在。</li>
<li>value<br>输出时，控制高低电平；输入时，获取高低电平</li>
<li>edge<br>控制中断触发模式，引脚被配置为中断后可以使用poll() 函数监听引脚<br>非中断引脚、上升沿触发、下降沿触发、边沿触发</li>
<li>active_low<br>用于翻转电平，当外部有效信号与GPIO有效信号不一致（即0可能表示有效，1也有可能表示有效）</li>
</ul>
<h2 id="查看GPIO配置"><a href="#查看GPIO配置" class="headerlink" title="查看GPIO配置"></a>查看GPIO配置</h2><p>不同的厂商对于GPIO配置结果的查看方式有所不同，以下以Ingenic-x2000为例对应相关的手册可以确定相应的IO状态</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">/<span class="meta"># cat /sys/devices/platform/apb/10010000.pinctrl/dump_gpio</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下图, 下面会有每一个GPIO状态</span></span><br><span class="line">REG 	|+++GPA++|+++GPB++|+++GPC++|+++GPD++|</span><br><span class="line"></span><br><span class="line">INL 	|<span class="number">0</span>c3fffff|<span class="number">67f</span>6036f|<span class="number">0110f</span>ef4|<span class="number">0f</span>7fffff|</span><br><span class="line">INT 	|<span class="number">02b</span>00000|<span class="number">30440000</span>|<span class="number">00000081</span>|<span class="number">00000100</span>|</span><br><span class="line">MSK 	|<span class="number">194f</span>cfff|ce0a0040|<span class="number">74f</span>f0076|<span class="number">003f</span>feff|</span><br><span class="line">PAT1 	|<span class="number">0265</span>cfff|f6440000|<span class="number">77</span>efc0fb|<span class="number">003f</span>fbff|</span><br><span class="line">PAT0 	|<span class="number">0f</span>8a3000|<span class="number">1033</span>efc0|<span class="number">88100005</span>|<span class="number">00000400</span>|</span><br><span class="line">EDG 	|<span class="number">3f</span>ffff00|f6037f00|<span class="number">10f</span>ff400|<span class="number">7f</span>ffff00|</span><br><span class="line">PLUP 	|<span class="number">14000000</span>|<span class="number">41800000</span>|<span class="number">00200001</span>|<span class="number">00000100</span>|</span><br><span class="line">PLDWN 	|<span class="number">00000000</span>|<span class="number">800000</span>c0|<span class="number">00100002</span>|<span class="number">00000000</span>|</span><br><span class="line">FLAG 	|<span class="number">00000000</span>|<span class="number">00000000</span>|<span class="number">00000000</span>|<span class="number">00000000</span>|</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="相关功能"><a href="#相关功能" class="headerlink" title="相关功能"></a>相关功能</h1><p>在低功耗场景下，系统休眠以后部分硬件时钟可能关闭。但是GPIO不依赖时钟，故可以配置IO作为中断源对CPU进行唤醒</p>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>GPIO</category>
      </categories>
  </entry>
  <entry>
    <title>DDR基础与原理</title>
    <url>/2023/04/05/computerSystem/storage/DDR/</url>
    <content><![CDATA[<p><a href="https://yanglieee.com/2023/02/07/computerSystem/%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/">前面的文章</a>对SRAM的Cache做了详细分析，而这部分将对另一种随机存取器动态随机存储器DRAM做进一步说明。本文大部分是基于BranchEducation的视频内容和其它文章进行行文的，文章截图全部来自视频，部分是自己所画，视频连接放在最后的参考资料部分。</p>
<h1 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h1><p>DRAM：Dynamic Random Access Memory，动态随机存储器。</p>
<p>在DRAM的分类中，SDRAM（Synchronous DRAM）同步动态随机存储器在各个行业则占较大的比例。而我们经常听到的DDR（Double Data Rate SDRAM）即双倍速率SDRAM则又是SDRAM中的主要代表，本篇将着重对DDR原理进行分析</p>
<p>DRAM是程序运行的和临时数据存储的媒介，无论是计算机还是手机的参数主存大小即指的是DRAM的大小。在工作中我们其实很少区分DDR和DRAM，严格来说DDR只能是DRAM中的一种，whatever，工作中不影响正常理解和使用就好。</p>
<h1 id="DDR-SDRAM"><a href="#DDR-SDRAM" class="headerlink" title="DDR SDRAM"></a>DDR SDRAM</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Wiki：<a href="https://en.wikipedia.org/wiki/DDR_SDRAM">英文</a>；<a href="https://zh.m.wikipedia.org/wiki/DDR_SDRAM">中文</a></p>
</blockquote>
<ul>
<li><p>DDR SDRAM：Double Data Rate Synchronous Dynamic Random Access Memory，双倍数据率同步动态随机存取存储器。之所以“同步”是指内存的工作需要同步时钟，命令的发送和数据的传输都要以此为基准；“动态”则是因为我们需要为其提供电压定时刷新来保证数据的完整性，掉电则数据丢失；“双倍”则是由于其在时钟的上升沿和下降沿都可以进行数据的传输</p>
</li>
<li><p>LPDDR SDRAM：Low-Power Double Data Rate SDRAM，是一种功耗较低的同步动态随机存取存储器，主要用于移动计算机和手机等设备。较旧的变体也称为移动 DDR，缩写为 mDDR。现代 LPDDR SDRAM 与DDR SDRAM截然不同，具有多种差异，甚至LPDDR 技术标准是独立于 DDR 标准开发的。（本篇不对此做详细说明）</p>
</li>
</ul>
<h2 id="各版本参数对比"><a href="#各版本参数对比" class="headerlink" title="各版本参数对比"></a>各版本参数对比</h2><table>
<thead>
<tr>
<th align="center">DDR SDRAM Standard</th>
<th align="center">Bus clock (MHz)</th>
<th align="center">Internal rate (MHz)</th>
<th align="center">Prefetch (min burst)</th>
<th align="center">Transfer Rate (MT/s)</th>
<th align="center">Voltage</th>
<th align="center"><a href="https://zh.m.wikipedia.org/wiki/DIMM">DIMM</a> pins</th>
<th align="center"><a href="https://zh.m.wikipedia.org/wiki/SO-DIMM">SO-DIMM</a> pins</th>
<th align="center"><a href="https://zh.m.wikipedia.org/w/index.php?title=MicroDIMM&amp;action=edit&amp;redlink=1">MicroDIMM</a> pins</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>DDR</strong></td>
<td align="center">100–200</td>
<td align="center">100–200</td>
<td align="center">2n</td>
<td align="center">200–400</td>
<td align="center">2.5/2.6</td>
<td align="center">184</td>
<td align="center">200</td>
<td align="center">172</td>
</tr>
<tr>
<td align="center"><a href="https://zh.m.wikipedia.org/wiki/DDR2_SDRAM">DDR2</a></td>
<td align="center">200–533</td>
<td align="center">100–266</td>
<td align="center">4n</td>
<td align="center">400–1066</td>
<td align="center">1.8</td>
<td align="center">240</td>
<td align="center">200</td>
<td align="center">214</td>
</tr>
<tr>
<td align="center"><a href="https://zh.m.wikipedia.org/wiki/DDR3_SDRAM">DDR3</a></td>
<td align="center">400–1066</td>
<td align="center">100–266</td>
<td align="center">8n</td>
<td align="center">800–2400</td>
<td align="center">1.5</td>
<td align="center">240</td>
<td align="center">204</td>
<td align="center">214</td>
</tr>
<tr>
<td align="center"><a href="https://zh.m.wikipedia.org/wiki/DDR4_SDRAM">DDR4</a></td>
<td align="center">800–1200</td>
<td align="center">200–300</td>
<td align="center">16n</td>
<td align="center">1600–5067</td>
<td align="center">1.2</td>
<td align="center">288</td>
<td align="center">260</td>
<td align="center">214</td>
</tr>
</tbody></table>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>channel：通道，属于控制器端的概念。可以简单理解为一个通道对应一个DDR控制器，每个通道拥有一组地址线、控制线和数据线</p>
</li>
<li><p>SIMM：Single In-line Memory Module，单列内存模组。内存模组电路板与主板插槽的接口只有一列引脚</p>
</li>
<li><p>DIMM：Double In-line Memory Module，双列内存模组，主板上的一个内存插槽，内存模组电路板与主板插槽的接口有两列引脚。一个Channel可以包括多个DIMM。</p>
</li>
<li><p>Rank：CPU在一个时钟周期取数据的大小取决于数据总线的位宽（这个位宽被称为物理 Bank（Physical Bank)，通常内存颗粒都没有P-Bank大小的位宽，这时就需要多个内存颗粒组合起来满足CPU的一次访存。假设P-Bank=64bit即64位数据总线，而内存颗粒Chip的位宽是8bit，则8个chip组成了一个Rank。</p>
</li>
<li><p>Chip：1个chip大多是4bit/8bit/16bit等，多个chip组成一个rank，配合完成一次访问的位宽要求。这就是颗粒。内存颗粒共享地址和命令总线，各自有自己的数据总线</p>
</li>
<li><p>Bank：也称Logic Bank逻辑Bank，与物理bank的概念相对应。由于成本、技术以及SDRAM工作原理的限制，做一个全容量的Bank不太现实（寻址冲突），所以在寻址时需要先选中Bank，在根据行列选中数据。DDR2、DDR3已经有8个Bank </p>
</li>
<li><p>row/column：行列，存储的最小单元，每一个行列交叉点存储了1bit的数据。</p>
</li>
</ul>
<p>笼统上讲从大到小为：<strong>channel ＞ DIMM ＞ rank ＞ chip ＞ bank ＞ row/column</strong>，如下图：</p>
<p><img src="/images/computerSystem/storage/ddr-1.png" alt="image"></p>
<h2 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h2><p>SDRAM总存储容量 = 行数 x 列数 x L-Bank数量  = 存储单元个数 x 存储单元容量（4bit/8bit/16bit）</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><blockquote>
<p>Tips：判断MOS管是N沟道还是P沟道，里N外P，即箭头指向G是NMOS，反之是PMOS</p>
</blockquote>
<p>利用了电容能够保持电荷及其充放电的特性。目前市场最常用的存储1bit数据的SDRAM的结构是由一个MOS管、一个电容和两根导线组成的。电容一段连接晶体管一端另一端接地、字线连接MOS管的栅极，位线连接到晶体管通道的另一端，如下图所示：</p>
<p><img src="/images/computerSystem/storage/ddr-2.png" alt="image"></p>
<ul>
<li><p>写</p>
<p>当字线（WL）电压为逻辑1时开关打开，存储单元选通，如果此时位线（BL）为高电压，则向电容中充电，则就是向存储单元中写1；相反如果WL=1，BL=0电容放电，这就是向存储单元中写0</p>
</li>
<li><p>读</p>
<p>当字线（WL）电压为逻辑1时开关打开，此时在位线上连接电量计就可以测量电容中存储的的值。如果电容放电，那么就表示这个单元里原来存的值是 1，如果电容不放电，则表示原来的值是 0。可见当DRAM进行数据读取的时候会使存储单元中的1变成0，是有破坏性的，而实际中我们需要读出继续保持数据或电荷，后面有对此的解决办法（感应放大器）</p>
</li>
</ul>
<p>当字线关闭的时候就不进行任何读写操作了，晶体管也紧跟着被关闭，电容器与位线隔离从而保存了之前写入的数据或电荷。但是由于晶体管十分小，存储在电容器中的电荷会在通道上慢慢泄露，因此又需要另外的技术来对此进行修复（Recharge）</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>下图是对一个bank的一部分作图进行说明。行译码器、列选择复用器之所以这样设计是因为：当数据进行读写的时候，只需要打开某一个固定行（其它行关闭）即可，这样子该行所在的电容将连接到位线上，而在进行列选择的时候，由于是进行多比特的选择（4bit/8bit）所以要这里的列多路复用器相当于列中的第几组（组数*位宽）</p>
<p><img src="/images/computerSystem/storage/ddr-3.png" alt="image"></p>
<h2 id="读-x2F-写"><a href="#读-x2F-写" class="headerlink" title="读/写"></a>读/写</h2><h3 id="通用流程"><a href="#通用流程" class="headerlink" title="通用流程"></a>通用流程</h3><blockquote>
<p>预充电电压根据DDR每一代是有所不同的，但一定是充电电压的一半</p>
</blockquote>
<ol>
<li>选择bank；</li>
<li>关闭所有行；关闭所有字线，隔离所有电容</li>
<li>预充电；将所有位线的电压升值供电电压一半（DDR5：0.55V；DDR4：0.6V；DDR3：0.75V）</li>
<li>行选择；字线上电打开MOS管形成的开关，电容连接到对应的位线</li>
<li>列选择；位线通过多路复用选择器连接到数据线上</li>
</ol>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>读（保证数据不丢失）</p>
<p>行选择时，当字线选中后，该行所在的电容被连接到对应的位线。如果电容存储的数据是1（电容压差是供电电压1.1 / 1.2 / 1.4），由于位线预充电后电压至供电电压的一半，所以电荷将从电容流向位线，进而位线电压增加，这时位线下面所连接的感应放大器能感受到这种轻微的变化或扰动，并放大这一变化，将位线电压再增加到供电电压（1.1 / 1.2 / 1.4）；相反，如果存储的是0，电荷将从位线流向电容，位线电压降低，感应放大器放大这一变化，将位线电压降低至0V。这样就保证了既能够通过位线读取数据又保证电容数据不丢失</p>
</li>
<li><p>写</p>
<p>写流程与读类似，但当要写入的数据–&gt;数据总线–&gt;写驱动器器–&gt;多路选择复用器–&gt;感应放大器—&gt;位线 这样流程下来的时候，由于写驱动器的存在，它比感应放大器强大的多，这将会导致写驱动器出来的数据直接覆盖掉位线上原有的数据</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>假设32位地址总线，32个bank，65536（2^16^）行，8192（2^13^）列，8bitddr颗粒</p>
<ul>
<li>0-4，5位地址将选择某个bank</li>
<li>行关闭 + 预充电</li>
<li>5-21，16位选择某个行</li>
<li>22-31，10bit选择某个组（每一组8列，这个由L-bank位宽决定）</li>
</ul>
<h2 id="刷新Refresh"><a href="#刷新Refresh" class="headerlink" title="刷新Refresh"></a>刷新Refresh</h2><p>refresh每一行的刷新时间是50ns。而整个bank刷新的时间间隔是64ms/次（小于电荷泄露1-&gt;0的最短时间）</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>由于SDRAM最小存储单元电路形式是电容，电容是有自放电的特性。长时间存储电容电荷会漏电，故需要刷新和预充电进行补充。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>自动刷新（Auto Refresh，简称AR/REF，需要CK，CKE高）</li>
<li>自刷新（Self Refresh，简称SR/SRE-SRF，SDRAM内部产生，不依赖CK，CKE低，用于休眠模式或低功耗）</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>关闭所有行</li>
<li>预充电</li>
<li>打开行，感应放大并填充电荷</li>
<li>从第一行到最后一行重复第3步骤</li>
</ol>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><ul>
<li>CAS：Column Address Select，列地址选择</li>
<li>RAS：Row Address Select，行地址选择</li>
<li>CAS Latency：(CL）CAS延迟。指的是从行打开到到接收到存储在列中的数据的时间</li>
<li>tRCD：RAS to CAS Delay RAS-CAS延迟，激活时间。指的是在字线全部关闭，位线被预充电的情况下，打开一行所需要的时间</li>
<li>tRP：RAS Precharge Time ，行预充电时间。指的是再打开一行之前对位线进行预充电的时间</li>
<li>tRAS：激活一行和接下来预充电之间的时间</li>
</ul>
<p><img src="/images/computerSystem/storage/ddr-4.png" alt="image"></p>
<h1 id="优化-x2F-访存加速"><a href="#优化-x2F-访存加速" class="headerlink" title="优化/访存加速"></a>优化/访存加速</h1><h2 id="行命中"><a href="#行命中" class="headerlink" title="行命中"></a>行命中</h2><p>在DRAM的读写过程中，其中比较耗时的步骤应该就是行打开。</p>
<p>可以考虑这样一个场景：CPU第一次访存是在249行，第二次所需要的数据大概率也可能在249行，因此在第一次和第二次访存中间我们就可以不关闭行了，而是等到新的行访存再进行整个读写步骤。进而将一个bank内的情况推广到整个内存颗粒，每一个bank上都存在一行未关闭（即上次访存数据所在的行），而当下次访存所在的行如果打开则成为Row Hit行命中，如果没有称为Row Miss（参考【5参数】章节的图片）</p>
<h2 id="Burst-Buffer"><a href="#Burst-Buffer" class="headerlink" title="Burst Buffer"></a>Burst Buffer</h2><p>Burst：突发，是指在同一行中相邻的存储单元连续进行数据传输的方式，连续传输所涉及到存储单元（列）的数量就是突发长度（Burst Lengths，简称 BL）。 </p>
<p>如果所示就是两个128bit的burst buffer，上端连接列选择即数据段，下面连接读写驱动器。人们只要指定起始列地址与突发长度，内存就会依次地自动对后面 相应数量的存储单元进行读/写操作而不再需要控制器连续地提供列地址。这样，除了第一笔数据的传输需要若干个周期（主要是之前的延迟，一般的是 tRCD+CL）外，其后每个数据只需一个周期的即可获得。</p>
<p>至于 BL 的数值，也是不能随便设或在数据进行传输前临时决定。一定要参考相应的数据手册进行设置，比较常见的设定是 4 和 8。</p>
<p><img src="/images/computerSystem/storage/ddr-5.png" alt="image"></p>
<h2 id="感应放大器"><a href="#感应放大器" class="headerlink" title="感应放大器"></a>感应放大器</h2><ul>
<li><p>优化方式</p>
<p>让每一个感应放大器上由两个位线连接到其上，让交替排列的存储单元分别连接在左侧和右侧的位线。交叉耦合反相器的存在使得一半的位线处于1，另一半处于0，这被称为差分对</p>
</li>
<li><p>好处：</p>
<ol>
<li>预充电时，由于差分对两侧一边是0，一边是1，所以断开两个反相器然后通过三极管将两个位线连接，电压将降低到中值</li>
<li>抗噪音</li>
<li>减少位线寄生电容</li>
</ol>
</li>
</ul>
<p><img src="/images/computerSystem/storage/ddr-6.png" alt="image"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote>
<p>1、2链接为同一视频，区别在于1是Youtube英文版，2是B站中文译版</p>
</blockquote>
<ol>
<li><a href="https://www.youtube.com/watch?v=7J7X7aZvMXQ&amp;t=831s">How does Computer Memory Work?</a></li>
<li><a href="https://www.bilibili.com/video/BV1vP411c7pt/?s">计算机如何工作？</a></li>
<li><a href="https://www.bilibili.com/video/BV1ZZ4y1M79G/">SDRAM与DDR2存储器原理详解【FPGA应用场景】</a></li>
<li><a href="http://www.bdtic.com/datasheet/Micron/64Mb_x4_x8_x16SDRAM.pdf">美光SDRAM MT48LC2M32B2TG-7 数据手册</a></li>
</ol>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
        <category>DDR</category>
      </categories>
      <tags>
        <tag>storage system</tag>
        <tag>DDR</tag>
      </tags>
  </entry>
  <entry>
    <title>MESI协议的优化与内存屏障</title>
    <url>/2023/03/06/computerSystem/storage/MESI%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>无论是计算机硬件还是软件，新的技术的出现的初衷一定是为了解决某项需求，而随之而来的可能会带来新的问题，无所谓解决就是了！</p>
<h1 id="MESI带来的性能问题"><a href="#MESI带来的性能问题" class="headerlink" title="MESI带来的性能问题"></a>MESI带来的性能问题</h1><p>从本质上来讲MESI协议解决的是数据的核间同步问题，但是严格遵守MESI协议一定又会带来新的问题。以下两种情况会再次带来性能问题：</p>
<ol>
<li>更新Shared状态的Cache。当某个缓存行的状态是Shared时，CPU想要修改该缓存行的数据，一定会产生总线事件通知其它CPU将该缓存行副本状态置Invalid，当拥有该缓存行副本的CPU确认并回复它“Invalid acknowledgement”以后，它才能进行数据更新。</li>
<li>更新Invalid状态的Cache。当某个缓存行的状态是Invalid时，CPU想要修改该缓存行的数据，一定会产生总线事件从其它CPU甚至是主存中加载进最新数据，进而基于最新数据进行更新。</li>
</ol>
<h1 id="MESI协议优化"><a href="#MESI协议优化" class="headerlink" title="MESI协议优化"></a>MESI协议优化</h1><p>MESI协议以上两个痛点可以发现是由于事务串行化所带来的负面影响。所以解决这两个问题的关键就是使MESI协议的请求异步化，释放总线提高并行度。因而就有了在硬件上增加写缓存区和失效队列两种方法。</p>
<h2 id="写缓冲-Store-Buffer"><a href="#写缓冲-Store-Buffer" class="headerlink" title="写缓冲 Store Buffer"></a>写缓冲 Store Buffer</h2><p><img src="/images/computerSystem/storage/cache-9.png" alt="image"></p>
<p>基于之前的缓存结构，增加完Store Buffer之后的结果如上图所示。</p>
<p>整个同步过程：CPU想要修改某个缓存数据，首先通过总线广播获得总线所有权，发出信号通知其它CPU需要将该缓存块数据置无效，然后将需要更新的数据放入到Store Buffer。而此时就可以释放总线所有权去做其它的事情不用等待收到ACK（效率提高在此），等其它cpu都收到再由Store Buffer慢慢做核间同步，刷入Cache的值即可</p>
<p>当CPU读数据时，首先会先在Store Buffer中查询记录是否存在，如果存在则会从写缓冲区中直接获取，这一机制即是 Store Fowarding。</p>
<h2 id="失效队列-Invalid-Queue"><a href="#失效队列-Invalid-Queue" class="headerlink" title="失效队列 Invalid Queue"></a>失效队列 Invalid Queue</h2><p><img src="/images/computerSystem/storage/cache-10.png" alt="image"></p>
<p>在Store Buffer基础之上，增加完Invalid Queue之后的结构如上图所示</p>
<p>失效队列的存在可以说是更好的使Store Buffer工作。当CPU收到使某个缓存行失效的请求时，如果迟迟不回复ACK则可能导致Store Buffer里数据越来越多最终溢出，因此Invalid Queue的存在可以说是为了平衡Store Buffer写入速度和收到ACK速度</p>
<p>过程：当CPU Core收到使某个cache失效的消息时，先回复确认收到的消息，然后将失效的数据加入到Invalidate Queue中。而队列的实失效的操作等待空闲时候在进行处理。</p>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><h2 id="MESI优化之后带来的问题"><a href="#MESI优化之后带来的问题" class="headerlink" title="MESI优化之后带来的问题"></a>MESI优化之后带来的问题</h2><p>MESI协议本身属于强一致性协议，但是经过性能的优化变成了弱一致性协议，这就导致在某些中间状态下多核CPU的数据可能并不一致。</p>
<h3 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h3><p>由于Store Buffer的引入将部分事务变成并行，这就将导致数据的更新顺序将不会严格按照代码顺序执行，进而导致其它CPU拿到正确数据的时机延后。例如：CPU需要顺序执行A、B两条写指令，A在CPU0的缓存行状态是S，B在CPU0的缓存行状态是E，最终的cache对于两条指令所对应的两个数据的更新的顺序可能不是我们所期望的</p>
<h3 id="Invalid-Queue"><a href="#Invalid-Queue" class="headerlink" title="Invalid Queue"></a>Invalid Queue</h3><p>CPU1在回复ACK之后实际并没有对数据所在的缓存行置Invalid，而是放入到队列中。假如此刻CPU0更新了缓存行这将导致该数据在两个核的cache上表现不一致</p>
<h3 id="Reorder"><a href="#Reorder" class="headerlink" title="Reorder"></a>Reorder</h3><p>指令重排序从源头上就造成了指令实际执行的顺序与我们代码所期望执行的顺序存在差别。而Reorder设计的本质实际上是为了对我们的代码进行优化，提高cache命令率从而提高执行效率</p>
<ul>
<li>编译器重排序</li>
<li>CPU乱序执行</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>其实对于以上MESI优化带来的问题归根结底是在多核CPU上导致最终结果的偏差。进一步思考是多核CPU同时修改同一个变量时而引发的问题，而在实际过程中这种情况是比较少的。在效率和极少数数据不正确两者的考量下，继续基于此进行优化，但是不是硬件优化而是通过软件由程序员保证数据的一致性。因此在需要核间的同步的情况下，多线程对于数据的修改和对于数据的使用需要引起注意，在适当的地方添加内存屏障</p>
<p>内存屏障（Memory Barriers）其实可以理解为一道墙，前面的读写操作没有完成后面的读写操作不能发生</p>
<h2 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h2><p>本质：读屏障前后指令的读操作不能翻越屏障！强制CPU在屏障前的读操作处理到所有Invalid Queue中的数据，获取到最新的数据。</p>
<h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>本质：写屏障前后指令的写操作不能翻阅屏障！强制CPU在屏障前的写操作清空Store Buffer内容，将数据更新至cache甚至主存</p>
<h2 id="读写屏障"><a href="#读写屏障" class="headerlink" title="读写屏障"></a>读写屏障</h2><p>以上两种屏障只有在区分读写屏障的体系结构里才会有作用，比如 alpha 结构。而在 X86 和 Arm 中是没有作用的，这是因为 X86 采用的 TSO 模型不存在缓存一致性的问题，而 Arm 则是采用了另一种称为单向屏障的分类方式。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/375706879">缓存一致性硬核讲解</a></li>
<li>编程高必学的内存知识（极客时间 海纳）</li>
</ul>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>storage system</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存一致性协议</title>
    <url>/2023/03/06/computerSystem/storage/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="导语-cache、主存与CPU的通信"><a href="#导语-cache、主存与CPU的通信" class="headerlink" title="导语 - cache、主存与CPU的通信"></a>导语 - cache、主存与CPU的通信</h1><p><img src="/images/computerSystem/storage/cache-6.png" alt="image"></p>
<p>如图所示，私有Cache是每个处理器核心所特有的比如L1、L2，共享 Cache是所有处理器核心的共享缓存比如L3，而整体Cache与主存的数据交互是要通过总线进行的。当两个核加载了主存的同一块缓存副本，其中一个核进行了数据的更改，是否要写入主存？是否要通知给其它CPU核心进行修改？因此对于多核CPU来讲，缓存在提高效率的同时也带来了缓存一致性的问题，而这个问题是需要进行解决的</p>
<h1 id="核心需求"><a href="#核心需求" class="headerlink" title="核心需求"></a>核心需求</h1><p>缓存一致性核心核心需要解决的问题就是：<strong>将本CPU更新的数据有效的传播到其它CPU本地缓存中</strong></p>
<p>进一步可以总结成需要遵从两个特性</p>
<ol>
<li>写传播：CPU Core的对内存的写操作，其它CPU Core可见</li>
<li>事务串行化：其它CPU Core看到的内存的写操作的顺序是一致的</li>
</ol>
<p>写传播可以保证修改的数据能够传播给其它CPU，而事物串行化则保证数据在其它CPU内的正确性。比如CPU有3个Core，Core1将x修改为3，Core2将数据修改为5，两个事务需要同步到Core3同时Core1 Core2互相同步，如果不保证串行，最终的数据很大概率是错误的</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h2><p><a href="https://www.inf.ed.ac.uk/teaching/courses/pa/Notes/lecture05-snooping.pdf">嗅探一致性协议</a></p>
<p> 总线除了能在一个主模块和一个从模块之间传输数据，还支持一个主模块对多个从模块写入数据，这种操作就是广播。</p>
<p>写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心，最常⻅实现的方式是总线嗅探(<strong>Bus Snooping</strong>)。当某个CPU Core的缓存行有更新时，需要将所有的读写操作广播到所有 CPU Core，而虽然总线上其它CPU Core的私有缓存不一定有对应的缓存行，但也要时刻监视或侦听总线，以验证它是否具有所请求数据块的副本，如果存在使对应的缓存副本失效或更新。使用广播的方式看似一视同仁，实际这样做大大增加了总线的负担。</p>
<h2 id="Directory-based-机制"><a href="#Directory-based-机制" class="headerlink" title="Directory-based 机制"></a>Directory-based 机制</h2><p><a href="https://courses.cs.washington.edu/courses/cse471/00au/Lectures/luke_directories.pdf">基于目录的缓存一致性协议</a></p>
<p>针对总线嗅探的缺点，<strong>Directory-based 机制</strong>采点对点的传播，基于目录机制总线事件只会传给自己感兴趣的CPU。这是因为所有缓存行的信息，都被记录在 directory 中。比如会记录每个缓存行当前都在那些核的缓存中，直接将缓存行修改的消息发送到那些核。这么做的也有个缺点是每次总线的传输都到 directory 做一次检查，产生耗时。</p>
<h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p>总线的独占性要求同一时刻最多只有一个主模块占用总线，天然地会将所有核心对内存的读写操作串行化。如果多个核心同时发起总线事务，此时总线仲裁单元会对竞争做出仲裁，未获胜的事务只能等待获胜的事务处理完成后才能执行。对于写缓存来讲，多核并发的写事件会通过<strong>总线仲裁机制</strong>转换成串行化的写事件序列</p>
<h2 id="缓存写策略"><a href="#缓存写策略" class="headerlink" title="缓存写策略"></a>缓存写策略</h2><ul>
<li>写分配 Write Allocate：要写入的数据不在缓存中，需要将该数据对应的内存块读入缓存；</li>
<li>写不分配 Write Not Allocate：要写入的数据不在缓存中，无需将该数据对应的内存块读入缓存，而是直接写入主存；</li>
<li>写穿 Write Through：写入缓存到的数据立马传播到主存；</li>
<li>写回 Write Back：写入缓存的数据不会立马传播到主存，而是该缓存块被替换时才更新；</li>
<li>写更新 Write Update：每次缓存写入新值，发起一次总线请求，通知其它CPU如果拥有该缓存块的副本就更新为新的值（需要传新的值）</li>
<li>写无效 Write Invalid：每次缓存写入新值，发起一次总线请求，通知其它CPU如果拥有该缓存块副本置为无效状态，如果未来需要在来要新的值（不需要传新的值）</li>
</ul>
<h1 id="缓存一致性协议种类"><a href="#缓存一致性协议种类" class="headerlink" title="缓存一致性协议种类"></a>缓存一致性协议种类</h1><blockquote>
<p> 该表格翻译自 <a href="https://people.eecs.berkeley.edu/~pattrsn/252F96/Lecture18.pdf">Snooping vs. Directory Based Coherency</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>名字</th>
<th>协议类型</th>
<th>内存写策略</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>Write Once</td>
<td>写无效</td>
<td>第一次写之后写回</td>
<td>First snoopy protocol</td>
</tr>
<tr>
<td>Synapse N+1</td>
<td>写无效</td>
<td>写回</td>
<td>1st cache-coherent MPs</td>
</tr>
<tr>
<td>Berkeley</td>
<td>写无效</td>
<td>写回</td>
<td>伯克利 SPUR</td>
</tr>
<tr>
<td>Illinois</td>
<td>写无效</td>
<td>写回</td>
<td>SGI Power and Challenge</td>
</tr>
<tr>
<td>“Firefly”</td>
<td>写广播（写更新)</td>
<td>写回私有，写穿共享</td>
<td>SPARCCenter 2000</td>
</tr>
<tr>
<td>MESI</td>
<td>写无效</td>
<td>写回</td>
<td>奔腾，PowerPC</td>
</tr>
</tbody></table>
<h1 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过缓存一致性协议的种类核应用场景来看，MESI应用在Intel奔腾处理器和PowerPC上，可以说有着很广泛的应用了。</p>
<p>MESI是四个单词的首字母缩写（Modified，Exclusive，Shared， Invalid），这四个单词代表了四种状态。因此可以缓存行可以用2bit来唯一表征这四种状态的某一种状态。</p>
<ul>
<li>M：Modified，被修改的（也可以称为Dirty 脏的）。当前CPU对应的该缓存行数据被修改，拥有最新数据（private, != Memory）</li>
<li>E：Exclusive，独享的。该缓存行只存在于当前CPU中，并且数据有效（干净）(private, =Memory))</li>
<li>S：Shared，共享的。该缓存行也存在于其它CPU中，并且数据有效（干净）(shared, =Memory)</li>
<li>I：Invalid，无效的。当前CPU内的该缓存行数据失效(NULL)</li>
</ul>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><blockquote>
<p>本部分基于进行重新梳理</p>
</blockquote>
<h3 id="来自处理器的请求"><a href="#来自处理器的请求" class="headerlink" title="来自处理器的请求"></a>来自处理器的请求</h3><ul>
<li>PrRd：处理器请求读一个缓存块</li>
<li>PrWt ：处理器请求写一个缓存块</li>
</ul>
<p><img src="/images/computerSystem/storage/cache-7.png" alt="image"></p>
<ul>
<li><p>M：唯一且数据！=memory（最新数据）。读写依然是最新数据（！= memory）</p>
</li>
<li><p>E：唯一且数据=memory。读不影响状态，写则与主存数据不一致置M</p>
</li>
<li><p>S：共享且数据=memory。读不影响状态，写则将拥有最新数据置M，同时产生总线事务通知其它处理器要写该缓存</p>
</li>
<li><p>I：无效的，一定Cache Miss。读首先将数据加载进缓存，产生BusRd的总线事务，内存控制器响应请求，同时如果发现其它处理器也拥有该缓存块副本则置S，如果没有置E；写则产生BusRdx的总线事务，由于拥有最新数据状态置M</p>
</li>
</ul>
<h3 id="来自总线（其它处理器）的请求"><a href="#来自总线（其它处理器）的请求" class="headerlink" title="来自总线（其它处理器）的请求"></a>来自总线（其它处理器）的请求</h3><ul>
<li><p>BusRd：总线侦听到其它处理器请求读一个缓存块</p>
</li>
<li><p>BusRdX：总线侦听到其它处理器请求写一个自己没有缓存副本的缓存块</p>
</li>
<li><p>BusUpgr：总线侦听到其它处理器请求写本地缓存（该处理器拥有的缓存块）</p>
</li>
<li><p>Flush：总线侦听到其它处理器请求写回一个缓存块到主存（cache to memory）</p>
</li>
<li><p>FlushOpt：总线侦听到其它处理器请求将一个缓存块通过总线的方式发送另外一个处理器（cache to cache）</p>
<p><img src="/images/computerSystem/storage/cache-8.png" alt="image"></p>
</li>
<li><p>M：唯一且数据！=memory（最新数据）。 BusRd说明其它处理器要读，则需要写传播将数据写到主存，因为其它处理器读所以数据=memory且共享置状态S；当BusRdx或BusUpgr说明其它处理器要写，这两种情况无论发起请求的处理器有没有缓存一定不是最新的所以一定产生Flush的总线事务，并且其它处理器写完就不是最新的了置I</p>
</li>
<li><p>E：唯一且数据=memory。BusRd说明其它处理器要读，我的数据已经是最新的了所以产生FlushOpt总线事务，将该缓存块传走并置状态S；其它处理器写最终结果一定是我的私有缓存无效置I，但是如果发起总线事务的处理器没有该缓存我需要产生FlushOpt的总线事务将数据传输，否则不产生总线事务</p>
</li>
<li><p>S：共享且数据=memory。BusRd说明其它处理器要读，我的数据是最新的了所以产生FlushOpt总线事务，将该缓存块传走保持S状态；其它处理器写最终结果一定是我的私有缓存无效置I，但是如果发起总线事务的处理器没有该缓存我需要产生FlushOpt的总线事务将数据传输，否则不产生总线事务</p>
</li>
<li><p>I：无效的。各种读写情况都不会影响，继续保持状态</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《编程高手必学的内存知识》极客时间海纳</li>
<li><a href="https://juejin.cn/post/6844903965696458765">cache一致性里的MESI协议</a></li>
<li><a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm">MESI动画</a></li>
</ul>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>storage system</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache原理</title>
    <url>/2023/02/15/computerSystem/storage/%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>在大多数程序运行过程中，CPU对于内存的访问会表现出明显的倾向性，具体体现在两个方面：</p>
<ul>
<li>时间局部性：时间维度看，被引用过的内存位置，不远的将来将大概率再次被访问</li>
<li>空间局部性：空间维度看，被引用过的内存位置，不远的将来它附近的内存位置将大概率被访问</li>
</ul>
<h2 id="缓存块"><a href="#缓存块" class="headerlink" title="缓存块"></a>缓存块</h2><blockquote>
<p>linux查看缓存信息命令：getconf -a | grep CACHE</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>根据cache的作用可知cache当中存储的是主存的副本，其必须是要和主存进行数据交换的。基于效率角度考量，根据程序局部性原理，CPU是不会按照一个字节一个字节进行数据的加载至缓存中，而是按块进行加载，而这每一块就叫做cache line，也称缓存块</p>
<ul>
<li>缓存块（cache line），管理缓存结构的最小存储单元，目前常用的是64Bytes（内存系统支持Burst读/写效率更高）</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/images/computerSystem/storage/cache-3.png" alt="image"></p>
<ul>
<li>标识位V：表示该缓存块是否有效</li>
<li>标识位M：表示这个缓存块是否被修改，也就是脏位</li>
<li>Tag：和内存块匹配的标识</li>
<li>Data：缓存数据内容</li>
</ul>
<p>需要注意的是 V、M、Tag这几位是由硬件门电路实现的，并不占缓存空间。而Data才是真正的数据部分</p>
<h2 id="缓存命中-x2F-缺失"><a href="#缓存命中-x2F-缺失" class="headerlink" title="缓存命中/缺失"></a>缓存命中/缺失</h2><ul>
<li>Cache Hit：访存时，如果所需要的数据在cache中则成为缓存命中</li>
<li>Cache Miss：访存时，如果所需要的数据不在cache中则成为缓存缺失</li>
</ul>
<h1 id="缓存映射方式"><a href="#缓存映射方式" class="headerlink" title="缓存映射方式"></a>缓存映射方式</h1><blockquote>
<p>视频链接：<a href="https://www.bilibili.com/video/BV1Qd4y1J7XA">click here</a></p>
</blockquote>
<p>从概念上讲，高速缓存是一个相联存储器（Associative Memory）。硬件电路实现方式及映射策略的不同，缓存的映射方式分为三种：</p>
<ul>
<li>全相连映射：主存块可以映射到任一缓存行（缓存只有一个组，所有的内存块都放在这一个组的不同路上)</li>
<li>直接相连映射：主存块只能映射到固定的缓存行（缓存只有一个路，一个内存块只能放置在特定的组上）</li>
<li>组组相连映射：主存块只能映射到固定的缓存组，组内任一缓存行（缓存同时由多个组和多个路）</li>
</ul>
<p>片外的高速缓存通常是直接映射的，因为组相联需要更宽的接口，可以取得多个标签，并发匹配</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><table>
<thead>
<tr>
<th>组织方式</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>全相联映射</td>
<td>cache利用率高<br>块冲突低<br>淘汰算法复杂</td>
<td>小容量cache</td>
</tr>
<tr>
<td>直接相连映射</td>
<td>cache利用率低<br>块冲突高<br>淘汰算法简单</td>
<td>大容量cache</td>
</tr>
<tr>
<td>组相联映射</td>
<td>cache利用率较高<br>块冲突率较低<br>硬件实现复杂</td>
<td>中等容量cache</td>
</tr>
</tbody></table>
<h2 id="映射算法"><a href="#映射算法" class="headerlink" title="映射算法"></a>映射算法</h2><ul>
<li>全相联：cache行号 = random</li>
<li>直接相联：cache行号 = 内存块号 % cache行数</li>
<li>组相联：主存的数据块映射到Cache特定组的任意行，cache组号=主存块号 % cache组数</li>
</ul>
<h1 id="缓存块替换策略"><a href="#缓存块替换策略" class="headerlink" title="缓存块替换策略"></a>缓存块替换策略</h1><ul>
<li><p>随机法（RAND）</p>
<p>方法简单、易于实现，但命中率比较低。</p>
</li>
<li><p>先进先出算法（FIFO）</p>
<p>先进先出方法易于实现，命中率比随机法好些。</p>
</li>
<li><p>最近最久未使用算法（LRU，Least Recently Used）</p>
<p>可以比较好地遵循程序局部性原理</p>
</li>
</ul>
<h1 id="缓存写策略"><a href="#缓存写策略" class="headerlink" title="缓存写策略"></a>缓存写策略</h1><h2 id="write-back-写回"><a href="#write-back-写回" class="headerlink" title="write back 写回"></a>write back 写回</h2><p>将要写入的数据保留在高速缓存中，并进行标记（Dirty / Modified）。只有缓存块被替换的时候才会将数据写入主存</p>
<p><img src="/images/computerSystem/storage/cache-4.png" alt="image"></p>
<h2 id="write-through-写透-x2F-写穿-x2F-写直达"><a href="#write-through-写透-x2F-写穿-x2F-写直达" class="headerlink" title="write through 写透/写穿/写直达"></a>write through 写透/写穿/写直达</h2><p>CPU总是将数据直接写到主内存中</p>
<blockquote>
<p>note：如果等待写内存完成处理器的性能会急剧下降，通过写缓冲（Write Buffer）硬件可以弥补这一问题。将需要写入的数据存储在一个FIFO队列中（Write Buffer），由内存控制器进行写入操作</p>
</blockquote>
<p><img src="/images/computerSystem/storage/cache-5.png" alt="image"></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><blockquote>
<p>由于效率原因，写更新和写不分配这两种策略在现实中比较少出现</p>
</blockquote>
<ol>
<li><p>CPU 之间的更新策略</p>
<p>当某个 CPU 的缓存中执行写操作，修改其中的某个值时，其他 CPU 的缓存所保有该数据副本的更新策略分为：写更新（Write Update）和写无效（Write Invalidate）。</p>
</li>
<li><p>写缓存时数据是否被加载</p>
<p>当前要写入的数据不在缓存中时，根据是否要先将数据加载到缓存中，写策略分为：写分配（Write Allocate）和写不分配（Not Write Allocate）。</p>
</li>
</ol>
<h1 id="缓存效率"><a href="#缓存效率" class="headerlink" title="缓存效率"></a>缓存效率</h1><h2 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h2><p>两个参数的乘积：</p>
<ol>
<li><strong>高速缓存缺失率</strong>：cache miss / 被执行的指令次数</li>
<li><strong>高速缓存缺失重填的开销</strong>：cpu流水线重新计算从主存取数到缓存中的时间</li>
</ol>
<h2 id="cache-miss的原因？"><a href="#cache-miss的原因？" class="headerlink" title="cache miss的原因？"></a>cache miss的原因？</h2><blockquote>
<p>《see mips run》对于以下缺失类型分别称为：第一次访问；抖动；替换</p>
</blockquote>
<ol>
<li>强制缺失。第一次将数据块读入到缓存所产生的缺失，也被称为冷缺失（cold miss），因为当发生缓存缺失时，缓存是空的（冷的）；</li>
<li>冲突缺失。由于缓存的相连度有限导致的缺失（指在同一组内的缺失）；</li>
<li>容量缺失。由于缓存大小有限导致的缺失（描述范围是整个缓存）</li>
</ol>
<h2 id="如何提高利用率？"><a href="#如何提高利用率？" class="headerlink" title="如何提高利用率？"></a>如何提高利用率？</h2><ul>
<li>软件<ol>
<li>程序更小；</li>
<li>让程序经常执行的部分更小。对于一个程序错误处理/初始化代码等部分代码剥离出来，提高剩余程序的缓存命中率；</li>
<li>安排程序尽量不发生冲突缺失（抖动）</li>
<li>直到必须用到数据时才停止CPU。非阻塞读。取数操作执行完，继续执行不依赖该数据的代码（流水线乱序/分支指令等等）</li>
<li>多线程CPU</li>
</ol>
</li>
<li>硬件<ol>
<li>（1）让高速缓存变的更大（代价）</li>
<li>（1）增加缓存相连度（4路以上效果就不明显了，更高路相连缓存设计目的在于其它原因（降低功耗，不使用时关掉整路））</li>
<li>（1）增加额外层次的高速缓存（L2 L3 cache）</li>
<li>（2）增加带宽，cpu与主存物理位置更近（代价）</li>
<li>（2）增加内存burst带宽（现在很少使用）</li>
<li>（2）尽早地重启CPU</li>
<li>（2）<a href="https://oscpu.github.io/NutShell-doc/%E5%8A%9F%E8%83%BD%E9%83%A8%E4%BB%B6/cache.html">关键字优先</a></li>
</ol>
</li>
</ul>
<h1 id="管理缓存"><a href="#管理缓存" class="headerlink" title="管理缓存"></a>管理缓存</h1><blockquote>
<p>对于MIPS CPU，synci指令做了以下所有工作（用户特权级）</p>
</blockquote>
<p>上电之后CPU的高速缓存阵列内容通常是随机的。引导软件负责初始化高速缓存，系统启动并正常运行后，只有三种情况CPU必须进行干预：</p>
<ol>
<li><strong>DMA设备从内存取数据之前</strong>。如果是Write Back式写策略，需要将在高速缓存中未写入到主存的数据写入得到正确数据</li>
<li><strong>DMA设备写数据到内存之前</strong>。需要将高速缓存中对应的缓存行的标志位置Invalid（无效的）</li>
<li><strong>写指令</strong>。当cpu自身写一部分指令到内存用于稍后执行时，首先需要保证指令写入到内存中，其次保证 I-Cache 中对应的指令无效</li>
</ol>
<blockquote>
<p>视频推荐：</p>
<p><a href="https://www.bilibili.com/video/BV1QA411t7Uv">Cache地址映射与变换方法</a></p>
<p><a href="https://www.bilibili.com/video/BV1h3411h7kV">一张图解决主存和cache的映射问题</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>storage system</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache简介</title>
    <url>/2023/02/15/computerSystem/storage/%E7%BC%93%E5%AD%98%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>随着技术的不断进步，芯片制程和工艺有了极大的发展，相应的CPU的计算能力越来越强。作为程序员，我们希望有无线资源的快速存储器可以使用，但是快速存储器的成本非常高昂，因此访存变成了计算机系统的性能瓶颈。为了平衡cpu运行速度与访存速度之间的差异缓存被设计出来！</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>缓冲存储器，简称缓存(cache)，用于存储可能频繁访问的数据。</p>
<p>缓存结合了寄存器速度快和内存造价低的优点，因此通过缓存的设计使整个存储系统的性能接近寄存器，并且每字节的成本都接近内存，甚至是磁盘。</p>
<p>高速缓存的工作就是将内存中最近读写过的数据在高速缓存中保留一个<strong>备份</strong>，使这些数据能够快速地返回给CPU</p>
<h1 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h1><blockquote>
<p>本节内容大多取自极客时间，《编程高手必学的内存知识》海纳</p>
</blockquote>
<p>缓存的组成单元是SRAM，而目前SRAM通常采用了6管式的存储电路</p>
<p>简单来讲，SRAM 存储单元的特点是使用 6 个晶体管来实现。其中两个 P 型 MOS 管和两个 N 型 MOS 管组成两个反相器用于存储信息。还有两个用于控制存储单元是否选通。6 管 SRAM 的结构比触发器简单，速度也比较快</p>
<h2 id="连接图"><a href="#连接图" class="headerlink" title="连接图"></a>连接图</h2><p>如下图所示，M1 和 M3 两个 MOS 管，是 N 沟道场效应管，在高电压时导通；而 M2 和 M4 这两个 MOS，则是 P 沟道场效应管，在低电压时导通。本质上，M1 和 M2 一起组成了一个非门，M3 和 M4 一起组成了另一个非门，这两个非门的输出互为对方的输入，这样，两个非门就组成了一种可以存储比特值的电路。</p>
<p><img src="/images/computerSystem/storage/cache-0.png" alt="image"></p>
<h2 id="等效图"><a href="#等效图" class="headerlink" title="等效图"></a>等效图</h2><p><img src="/images/computerSystem/storage/cache-1.png" alt="image"></p>
<h2 id="读写原理"><a href="#读写原理" class="headerlink" title="读写原理"></a>读写原理</h2><p>当要读入SRAM数据时，字线 (Word Line, WL) 加高电平，使得每个基本单元的两个控制开关M5、M6导通，存储单元与位线 (Bit Line, BL) 连通。位线用于读取或写入基本单元的保存状态。</p>
<p>我们假定储存的内容为 1，即在 Q 处的电平为高。读取周期开始时，两条位线预先设成高电平，随后字线 WL 变成高电平，使得两个访问控制晶体管 M5 与 M6 导通。Q 的高电平使得晶体管 M1 导通，而 Q 反与 BL 反的预充值不同，使得 BL 反经由 M1 与 M5 放电而变成逻辑 0。在位线 BL 一侧，Q 反的低电平使得 M4 导通，再加上 M6 通路，位线就连接到 VDD 的高电压。</p>
<p>如果储存的内容为 0，相反的电路状态将会使 BL 反为 1，而 BL 为 0。这时，只需要 BL 与 BL 反有一个很小的电位差，读取的放大电路就会辨识出哪条位线是 1，哪条是 0。也就是说，当敏感度越高时，读取的速度就越快。</p>
<p>在写入周期开始时，把要写入的状态加载到位线。如果要写入 0，则设置 BL 反为 1 且 BL 为 0。随后字线 WL 加载为高电平，位线的状态被加载进 SRAM 的基本单元。</p>
<h1 id="缓存基础"><a href="#缓存基础" class="headerlink" title="缓存基础"></a>缓存基础</h1><h2 id="集成方式"><a href="#集成方式" class="headerlink" title="集成方式"></a>集成方式</h2><ul>
<li>分布式缓存：一个处理器对应一个缓存；</li>
<li>集中式缓存：多个处理器（核）共享一个内存；</li>
<li>混合式缓存：在 L3 采用集中式缓存，在 L1 和 L2 采用分布式缓存。</li>
</ul>
<p><img src="/images/computerSystem/storage/cache-2.png" alt="image"></p>
<h2 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h2><blockquote>
<p>冯诺依曼架构：指令和数据混合存储在同一存储器</p>
<p>哈弗架构：指令和数据独立存储，分别放在程序存储器和数据存储器</p>
</blockquote>
<p>在cache设计之初，cpu与内存之间只有一个cache。随着芯片工艺的提高，现代CPU通常采用二级/三级多级缓存结构。</p>
<ul>
<li>一级缓存（L1 Cache）：在Core内部，分为指令缓存（I-cache）和数据缓存（D-cache）（冯诺依曼架构）。容量通常在32~256KB，速度3 cycles</li>
<li>二级缓存（L2 Cache）：具体芯片Core内外不同。容量256KB~3MB不等，速度11cycles（哈弗架构）</li>
<li>三级缓存（L3 Cache）：在Core外部，所有CPU核心共享。容量更大，速度25cycles（哈弗架构）</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote>
<p><strong>统一缓存：</strong> 指令和数据统一存放在一个缓存中</p>
<p><strong>分离缓存：</strong> 指令和数据分别存放在不同缓存中</p>
</blockquote>
<h3 id="L1-采用分离缓存的原因？"><a href="#L1-采用分离缓存的原因？" class="headerlink" title="L1 采用分离缓存的原因？"></a>L1 采用分离缓存的原因？</h3><ol>
<li>流水线角度。可避免取指和执行时期的访存冲突。 在 CPU 内核中，取指和访存是由两个不同的硬件单元完成的。如果使用统一缓存，当 CPU 使用超前控制或流水线控制（并行执行）的控制方式时，会存在取指作和访存同时争用同一个缓存的情况，降低 CPU 运行效率</li>
<li>cache行为角度。I-cache大多是顺序取指，指令只有读没有写；D-cache是取数据变化较大，数据可读可写，最重要的是冯诺依曼的结构是指令和数据分离，I和D在一起只有相互干扰</li>
<li>物理设计角度。一块cache，同时需要数据和指令的访问，端口上是很难实现的</li>
</ol>
<h3 id="L1分离缓存、L2统一缓存？"><a href="#L1分离缓存、L2统一缓存？" class="headerlink" title="L1分离缓存、L2统一缓存？"></a>L1分离缓存、L2统一缓存？</h3><ol>
<li>成本角度。L1 cache miss 性能损失与增加L2分离缓存的成本的平衡</li>
<li>物理设计角度。分离式设计会占用逻辑电路的面积与设计难度，对于L1这种size比较小的采用分离式设计可以承受，但是对于更大的Cache全采用分离设计，无疑设计难度和面积都会加大</li>
<li>效率角度。分离缓存不适用所有情况，对于指令和数据存放大小的需求不同，无法做到动态调节cache的大小，可能会有浪费</li>
</ol>
<h3 id="cache放在片内的优势？"><a href="#cache放在片内的优势？" class="headerlink" title="cache放在片内的优势？"></a>cache放在片内的优势？</h3><ol>
<li>片内缓存物理距离更短，片内缓存与取指令单元和取数据单元的物理距离更短，速度更快；</li>
<li>片内缓存不占用系统总线， 片内缓存使用独立的 CPU 片内总线，可以减轻系统总线的负担。</li>
</ol>
<h3 id="不需要cache的场景？"><a href="#不需要cache的场景？" class="headerlink" title="不需要cache的场景？"></a>不需要cache的场景？</h3><p>51单片机、cortex-M0（–M4）系列ARM处理器都没有cache</p>
<ol>
<li>低功耗、低成本处理器并且工作频率不高（几十兆到几百兆）的处理器不需要，可能甚至不需要SRAM</li>
<li>cache无法保证实时性，缓存缺失时向RAM加载数据的时间是不等的</li>
</ol>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>storage system</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
</search>

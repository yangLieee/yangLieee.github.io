<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Libmad详解</title>
    <url>/2022/11/05/Audio-libmad/</url>
    <content><![CDATA[<p>简单来讲，libmad就是一个MP3文件的解码库。如果想要深入理解其中的实现需要对MP3文件格式有详细的了解，关于MP3文件格式的内容在这里我不赘述，之前的文章当中有过详细的讲解 <a href="https://yanglieee.com/2022/09/05/Audio-meet-1/">click here</a></p>
<h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><blockquote>
<p>Libmad 详解：<a href="https://www.underbit.com/products/mad/">https://www.underbit.com/products/mad/</a></p>
</blockquote>
<p> libmad 是一个高质量的 MPEG 音频解码器。目前支持  MPEG-1 和 MPEG-2 对较低采样频率的扩展，以及所谓的 MPEG 2.5 格式，三个音频层都在代码上做了实现。优势：</p>
<ul>
<li>24 位 PCM 输出</li>
<li>100% 定点（整数）计算</li>
<li>基于 ISO/IEC 标准的全新实施</li>
<li>根据 GNU 通用公共许可证 (GPL) 的条款分发</li>
</ul>
<h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p><a href="https://sourceforge.net/projects/mad/files/">https://sourceforge.net/projects/mad/files/</a></p>
<p><a href="https://www.linuxfromscratch.org/blfs/view/svn/multimedia/libmad.html">https://www.linuxfromscratch.org/blfs/view/svn/multimedia/libmad.html</a></p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>&lt; 基于 libmad-0.15.1b 版本&gt;</p>
<table>
<thead>
<tr>
<th>源文件</th>
<th>bit.c</th>
<th>decoder.c</th>
<th>fixed.c</th>
<th>frame.c</th>
<th>huffman.c</th>
<th>layer12.c</th>
<th>layer3.c</th>
<th>stream.c</th>
<th>synth.c</th>
<th>timer.c</th>
<th>version.c</th>
<th>minimad.c(demo)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>头文件</td>
<td>bit.h</td>
<td>decoder.h</td>
<td>fixed.h</td>
<td>frame.h</td>
<td>huffman.h</td>
<td>layer12.h</td>
<td>layer3.h</td>
<td>stream.h</td>
<td>synth.h</td>
<td>timer.h</td>
<td>version.h</td>
<td>global.h</td>
<td>mad.h（API）</td>
</tr>
<tr>
<td>dat文件</td>
<td>sf_table.dat</td>
<td>imdct_s.dat</td>
<td>qc_table.dat</td>
<td>D.dat</td>
<td>rq_table.dat</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>其他文件</td>
<td>Makefile</td>
<td>config</td>
<td>……</td>
<td></td>
<td>大部分内容不参与编译</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>具体使用方法可以参考minimad.c文件，这里面对api的使用有进一步的说明</p>
<p>同时也可以参考我基于Linux libmad写出来的一个音频播放器，源码链接 <a href="https://github.com/yangLieee/audioplayer">click here</a></p>
<h1 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h1><p>&lt; 仅介绍linux环境下编译方法 &gt; </p>
<ol>
<li>手写Makefile / CMakeLists.txt</li>
<li>系统提供的config<ul>
<li>执行 <strong>sed -i ‘/-fforce-mem/d’ configure</strong> ， 这条命令是为了适配高版本的gcc，因为高版本的gcc已经将-fforce-mem去除了</li>
<li>执行 <strong>./configure ,</strong> 文件夹下会生成Makefile</li>
<li>执行 <strong>sudo make; sudo install;</strong> </li>
<li>至此静态库和动态库已经生成，目录在/usr/local/lib</li>
</ul>
</li>
</ol>
<h1 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h1><ol>
<li><p>mad_decoder_init( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mad_decoder_init</span><span class="params">(<span class="keyword">struct</span> mad_decoder *, <span class="type">void</span> *,   </span></span><br><span class="line"><span class="params">           <span class="comment">/* input func  */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* header func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_header <span class="type">const</span> *),                   </span></span><br><span class="line"><span class="params">           <span class="comment">/* filter func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream <span class="type">const</span> *, <span class="keyword">struct</span> mad_frame *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* output func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_header <span class="type">const</span> *, <span class="keyword">struct</span> mad_pcm *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* error func  */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream *, <span class="keyword">struct</span> mad_frame *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* message func*/</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="type">void</span> *, <span class="type">unsigned</span> <span class="type">int</span> *))</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>mad_decoder_init( )是libmad中最终重要的函数之一，其作用是将line3~line8的六个回调函数注册到mad_decoder实例出来的decoder中。</p>
<ul>
<li><p><strong>必须自定义的参数：</strong>参数1：用户自己实例的一个解码器结构体；参数2：用户自定义的结构体指针，这个指针将用于整个解码的过程在回调函数之间进行数据的传输；参数3：输入的回调函数，该回调用于用户自定义将数据输入编码器的逻辑；参数6：输出的回调函数，同input callback func。自定义输出的分辨率吧：24bit / 16bit，可以存成文件亦可以直接通过pcm接口播放。Output回调函数在madlib每解码完成一个帧后被调用，直到全部解码完成或出错。参数8（异步工作模式下必选）：输出信息。</p>
</li>
<li><p><strong>选择性定义参数：</strong>其他参数属于自定义参数比如进行头解析、过滤筛选的回调函数等等，如果自己没有需求置0即可。</p>
</li>
</ul>
</li>
<li><p>mad_decoder_run( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mad_decoder_run</span><span class="params">(<span class="keyword">struct</span> mad_decoder *, <span class="keyword">enum</span> mad_decoder_mode)</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>该函数是解码的主流程函数，即解码器的入口函数，如果要追代码可以从此处开始进行剖析。</p>
<ul>
<li>参数1：用户自定义实例化并初始化的解码器decoder；</li>
<li>参数2：选择解码模式（SYNC / ASYNC）深入代码可以发现这个选择使得解码器进入不同的函数进行工作。</li>
</ul>
<p>所谓同步方式是指解码函数在解码完一帧后才返回并带回出错信息，异步方式是指解码函数在调用后立即返回，通过消息传递解码状态信息。(故异步方式必须定义message回调函数)</p>
</li>
<li><p>mad_decoder_finish( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mad_decoder_finish</span><span class="params">(<span class="keyword">struct</span> mad_decoder *)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>解码结束，用于清理工作，释放与流相关的任何动态内存。</p>
</li>
<li><p>mad_stream_buffer( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mad_stream_buffer</span><span class="params">(<span class="keyword">struct</span> mad_stream *, <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *, <span class="type">unsigned</span> <span class="type">long</span>)</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>该函数是input回调函数中最重要的函数，其作用是按照参数2、参数3即MP3文件在内存映像的起始地址和本次要传递的文件长度与mad_stream进行关联，形成libmad可识别的stream流</p>
<p>需要注意，这里传递多少数据完全是自定义的。如果一次性送入则整个解码过程调用一次input；如果一次性传递若干，output根据传递的数据进行解码，如果没有数据可解继续调用input。所以自己定义好输入逻辑即可。</p>
</li>
</ol>
<h1 id="重点数据结构"><a href="#重点数据结构" class="headerlink" title="重点数据结构"></a>重点数据结构</h1><ol>
<li><p>mad_stream</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h &amp;&amp; stream.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_stream</span> {</span>           </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *buffer;          <span class="comment">/* input bitstream buffer */</span>                                       <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *bufend;          <span class="comment">/* end of buffer */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> skiplen;                <span class="comment">/* bytes to skip before next frame */</span></span><br><span class="line">  <span class="type">int</span> sync;                             <span class="comment">/* stream sync found */</span>        </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> freerate;               <span class="comment">/* free bitrate (fixed) */</span>     </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *this_frame;      <span class="comment">/* start of current frame */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *next_frame;      <span class="comment">/* start of next frame */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mad_bitptr</span> <span class="title">ptr</span>;</span>                <span class="comment">/* current processing bit pointer */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mad_bitptr</span> <span class="title">anc_ptr</span>;</span>            <span class="comment">/* ancillary bits pointer */</span>   </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> anc_bitlen;              <span class="comment">/* number of ancillary bits */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="title function_">char</span> <span class="params">(*main_data)</span>[MAD_BUFFER_MDLEN];                  <span class="comment">/* Layer III main_data() */</span>    </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> md_len;                  <span class="comment">/* bytes in main_data */</span>  </span><br><span class="line">  <span class="type">int</span> options;                          <span class="comment">/* decoding options (see below) */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_error</span> <span class="title">error</span>;</span>                 <span class="comment">/* error code (see above) */</span>   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>该结构体记录了文件的地址、当前所处理的位置和解码前的Bitstream数据</p>
<p>mad_stream.bufend – mad_stream.next_frame就是剩余的未被解码的 MPEG 帧的数据的字节数量（假设此帧在缓冲区中不完整)</p>
</li>
<li><p>mad_header</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_header</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_layer</span> <span class="title">layer</span>;</span>             <span class="comment">/* audio layer (1, 2, or 3) */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_mode</span> <span class="title">mode</span>;</span>               <span class="comment">/* channel mode (see above) */</span></span><br><span class="line">  <span class="type">int</span> mode_extension;               <span class="comment">/* additional mode info */</span>                                             <span class="class"><span class="keyword">enum</span> <span class="title">mad_emphasis</span> <span class="title">emphasis</span>;</span>       <span class="comment">/* de-emphasis to use (see above) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bitrate;            <span class="comment">/* stream bitrate (bps) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> samplerate;          <span class="comment">/* sampling frequency (Hz) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> crc_check;         <span class="comment">/* frame CRC accumulator */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> crc_target;        <span class="comment">/* final target CRC checksum */</span></span><br><span class="line">  <span class="type">int</span> flags;                        <span class="comment">/* flags (see below) */</span></span><br><span class="line">  <span class="type">int</span> private_bits;                 <span class="comment">/* private bits (see below) */</span></span><br><span class="line">  <span class="type">mad_timer_t</span> duration;             <span class="comment">/* audio playing time of frame */</span></span><br><span class="line">};    </span><br></pre></td></tr></tbody></table></figure>

<p>通过注释很容易看出，该结构体记录了MPEG 帧的基本信息，比如MPEG 层数、声道模式、流比特率、采样率、比特率以及某些校验位等等。</p>
<blockquote>
<p>Tips：（bitrate % 32） 如果是整数说明该文件格式是CBR（constant bitrate，恒定比特率），否则是VBR（variable bitrate，可变比特率），这对文件播放时长是有影响的。</p>
</blockquote>
</li>
<li><p>mad_pcm</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_pcm</span> {</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> samplerate;          <span class="comment">/* sampling frequency (Hz) */</span>                                           <span class="type">unsigned</span> <span class="type">short</span> channels;          <span class="comment">/* number of channels */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> length;            <span class="comment">/* number of samples per channel */</span></span><br><span class="line">  <span class="type">mad_fixed_t</span> samples[<span class="number">2</span>][<span class="number">1152</span>];     <span class="comment">/* PCM output samples [ch][sample] */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>madlib解码器是以帧为单位进行解码的，mad_pcm每次最多解码出（1152 * channels）个PCM数据，每个采样点用int（32bit）表征但是只用了其中的24bit，至此可以直接输出数据保存文件或者直接调用音频播放的API进行播放。但目前大多数codec支持的是16bit量化分辨率，所以在输出时将数据饱和到16bit进行输出。</p>
</li>
<li><p>mad_flow</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">mad_flow</span> {</span></span><br><span class="line">  MAD_FLOW_CONTINUE = <span class="number">0x0000</span>,   <span class="comment">/* continue normally */</span>                                                     MAD_FLOW_STOP     = <span class="number">0x0010</span>,   <span class="comment">/* stop decoding normally */</span></span><br><span class="line">  MAD_FLOW_BREAK    = <span class="number">0x0011</span>,   <span class="comment">/* stop decoding and signal an error */</span></span><br><span class="line">  MAD_FLOW_IGNORE   = <span class="number">0x0020</span>    <span class="comment">/* ignore the current frame */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>所有回调函数的返回值均为该枚举类型，在解码的主流程中会通过不断判断解码器所调用的回调函数的状态来确认下一步的动作</p>
</li>
</ol>
<h1 id="相关调试经验"><a href="#相关调试经验" class="headerlink" title="相关调试经验"></a>相关调试经验</h1><ol>
<li><p>配置参数未选择</p>
<p>Q：编译正常通过，流程正确，但是输出的声音能听出是所需要的音频但是整体数据并不正确？</p>
<p>A：在mad.h中有若干的函数是根据平台的不同有不同的实现，由于编译过程中没有注意警告直接将其注释导致没有选择正确函数实现，导致最终的数据都是错误的。编译时添加相应的平台的参数即可，如果手动写cmake，参考给出的Makefile做参数选择！</p>
</li>
<li><p>线程栈空间大小分配不足</p>
<p>Q：在PC上测试正常播放，但是移植到小系统中经常出现stack overflow？</p>
<p>A：由于MP3一帧数据的采样点数为1152，使用 int 类型进行存储，所以核心函数 “ Ⅲ_decode” 至少需要6k的栈空间，如果是单独一个线程的话再加上其他的局部变量、函数跳转等等可能就超过8k。</p>
<p>​	  当时使用c++ 的thread进行的线程创建并不能配置栈空间大小，经过两天左右的debug查到是核心函数栈空间的溢出，最终使用pthread加大栈空间的大小运行即可。</p>
</li>
<li><p>动态解码的实现</p>
<p>Q：刚开始百度libmad的库，很多博客说只能调用一次input回调函数即一次加载所有的源数据，这对于实时控制造成不便？</p>
<p>A： 深入源码可以看出输入的的数据解码完成只要不返回STOP是可以继续填充数据的，这样临时的buffer就小一些并且可以试试控制完成播放器的功能。（需要注意如果一次输入的数据是几帧多一点，而多出来的需要放保存下次再此进行解码）</p>
</li>
<li><p>获得音频参数</p>
<p>Q：能够很快的获得音频信息？</p>
<p>A： 对于wav头很容易的可以找到音频的参数，但是MP3文件的信息保存在帧头中，所以可以进行一步预解码。即读入若干（512即可）byte数据解一帧的头就可以获得全部信息，包括：采样率、比特率、声道、音频时长等等。</p>
</li>
<li><p>获得播放进度 / 时长出现异常</p>
<p>Q：使用公式：当前文件位置 / 文件大小 × 文件总时长，获得当前播放时间出现异常？</p>
<p>A： 对于duration 和 fpos是用int的数据类型进行保存的，但是对于wav文件一般比较大在计算的时候超出了数据类型所能存储的最大长度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
  </entry>
  <entry>
    <title>Audio-初识</title>
    <url>/2022/08/31/Audio-meet/</url>
    <content><![CDATA[<p>跳动的音符，婉转的节奏，悠扬的歌声……</p>
<p>音乐无疑是最能愉悦身心的方式之一，那么歌手的音调、音色是如何存储到手机中，又是如何通过喇叭播放出来的呢？</p>
<p>下面我将通过几篇博客阐述我对音频的理解及部分调试经验，本章主要介绍音频的的基础知识</p>
<h1 id="信号分类"><a href="#信号分类" class="headerlink" title="信号分类"></a>信号分类</h1><p>声音严格意义来讲应该被叫做声音信号，而在维基百科中对于<strong>信号</strong>的定义是<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E9%87%8F/9984692">表示消息的物理量</a>，这样就很好理解了声音信号就是以声音为载体的一个物理量。而自然界中信号可以有如下的分类</p>
<p><img src="/images/linux/Audio/Audio-meet-1.png" alt="signal"></p>
<p>因此，按照信号变化分类声音信号属于随机信号；按照信号特征分类声音信号属于模拟信号</p>
<h1 id="模数转换"><a href="#模数转换" class="headerlink" title="模数转换"></a>模数转换</h1><p>上一部分了解到声音是模拟信号，而对于计算机来讲其只能处理数字信号即0和1，所以必须需要将声音模拟信号转换成数字信号，而这个过程叫做模数转换（Analog Digital Conversion），相应的完成该功能的硬件单元就叫做模数转换器(ADC)</p>
<p>完成该过程需要三部曲分别是：采样、量化、编码，整体过程如下图：</p>
<p><img src="/images/linux/Audio/Audio-meet-2.png" alt="ADC"></p>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p><em>重要参数：采样率</em></p>
<ul>
<li>定义：在时间轴上对信号进行离散化</li>
<li>原理：按照一定的频率对模拟信号的瞬时时刻进行样本采集</li>
</ul>
<p>其实采样作用通俗理解就是是采集样本。由于模拟信号是连续的，理论上我们需要采集无数个点才能完整的还原该信号，但是一来无穷的概念是不可能满足的，二来我们其实并不需要这么高的采样率。我们听觉是有延迟的就和视频帧不停的刷新欺骗我们的眼睛是画面连续的是一个道理。</p>
<p>所以采样率越高，声音的还原就越真实越自然，人对频率的识别范围是 20HZ - 22000HZ, 如果每秒钟能对声音做 22000 个采样, 回放时就足可以满足人耳的需求. 所以 22050 的采样频率是常用的, 44100已是CD音质, 超过48000的采样对人耳已经没有意义。这和电影的每秒 24 帧图片的道理差不多。</p>
<h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p><em>相关参数：采样位数</em></p>
<ul>
<li><p>定义：在幅度轴上对信号进行数字化</p>
</li>
<li><p>原理：对采样点的幅度赋予具体的数值，该数值由n位二进制表征（n = 8 / 16 / 32）</p>
</li>
</ul>
<p>采样位数越高说明划分的等级越精细。较低的采样位数损失精度，较高的采样位数可能造成软硬件资源的浪费</p>
<blockquote>
<p>小常识：标准CD音乐的质量就是16bit、44.1KHz采样</p>
</blockquote>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>定义：按照一定的格式记录 采样 和 量化 后的数据。后续会对部分格式的存储格式进行分析</p>
<h3 id="编码分类"><a href="#编码分类" class="headerlink" title="编码分类"></a>编码分类</h3><blockquote>
<p> 该部分内容转自 <a href="https://www.jianshu.com/p/28d3f108ef63">https://www.jianshu.com/p/28d3f108ef63</a></p>
</blockquote>
<h4 id="波形编码"><a href="#波形编码" class="headerlink" title="波形编码"></a>波形编码</h4><ul>
<li>定义：不利用生成音频信号的任何参数，直接将 <strong>时间域信号</strong> 变换为 <strong>数字代码</strong>，使重构的语音波形尽可能地与原始语音信号的 波形形状 保持一致。</li>
<li>原理：在 <strong>时间轴</strong> 上对模拟语音信号按一定的速率抽样，然后将幅度样本分层量化，并用代码表示。</li>
</ul>
<h4 id="参数编码"><a href="#参数编码" class="headerlink" title="参数编码"></a>参数编码</h4><p>从语音 <strong>波形信号</strong> 中提取生成语音的参数，使用这些参数通过语音生成模型重构出语音，使重构的语音信号尽可能地保持原始语音信号的语意。也就是说，参数编码是把语音信号产生的数字模型作为基础，然后求出数字模型的模型参数，再按照这些参数还原数字模型，进而合成语音。</p>
<h4 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h4><p>混合编码是指同时使用两种或两种以上的编码方法进行编码。这种编码方法克服了波形编码和参数编码的弱点，并结合了波形编码高质量和参数编码的低编码率，能够取得比较好的效果。</p>
<ul>
<li><p>WAV编码（波形编码）</p>
<p>WAV是编码的一种实现方式（其实它有非常多实现方式，但都是不会进行压缩操作）。就是在源 <strong>PCM</strong> 数据格式的前面加上44个字节。分别用来描述 <strong>PCM</strong> 的采样率、声道数、数据格式等信息。</p>
</li>
<li><p>MP3编码</p>
<p>MP3编码具有不错的压缩比，而且听感也接近于WAV文件，当然在不同的环境下，应该调整合适的参数来达到更好的效果。</p>
</li>
<li><p>AAC编码</p>
</li>
</ul>
<p>  AAC是目前比较热门的有损压缩编码技术，并且衍生了LC-AAC、HE-AAC、HE-AAC v2 三种主要编码格式。</p>
<p>  <strong>LC-AAC：</strong>是比较传统的AAC,主要应用于中高码率的场景编码(&gt;= 80Kbit/s)<br>   <strong>HE-AAC：</strong> 主要应用于低码率场景的编码(&lt;= 48Kbit/s)</p>
<ul>
<li><p>Ogg编码（有损）</p>
<p>Ogg编码是一种非常有潜力的编码，在各种码率下都有比较优秀的表现。尤其在低码率场景下。Ogg除了音质好之外，Ogg的编码算法也是非常出色。可以用更小的码率达到更好的音质。128Kbit/s的Ogg比192Kbit/s甚至更高码率的MP3更优质.但目前由软件还是硬件支持问题,都没法达到与MP3的使用广度.</p>
</li>
</ul>
<h1 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h1><p>一段悠扬的音乐经过采样、量化、编码就保存数字信号文件，而我们最终的目的一定不是只存成文件而是通过文件形式传播让更多人听到该音乐，因此一定存在DA转换，即还原数字信号为模拟信号的过程。那么在整个过程中有哪些参数表征了音频重要的信息呢？</p>
<p>不仅限于webrtc、ffmpeg、libmad等等音频编解码库，对于所有编解码器和codec来讲，音频源数据的三个参数至关重要：<strong>声道channel、采样率sampleRate、采样位数sampleBit</strong>。这三个参数之所以重要是因为有这几个参数就可以准确的知道一个裸的音频数据（PCM）的全部信息了。</p>
<h2 id="声道"><a href="#声道" class="headerlink" title="声道"></a>声道</h2><p>声道是指音频文件在录制时音源的数量位置和播放时相应的扬声器的数量（百度百科）。所以可想而知，其他参数相同的情况下，声道数越多定位越精准，同样所需扬声器和功放组件越多。</p>
<ul>
<li>单声道（mono）</li>
<li>双声道（stereo 立体声）：左声道 + 右声道，低音不分离，应用于音乐播放较多</li>
<li>2.1声道 ：左声道 + 右声道， 低音分离</li>
<li>5.1声道 ：左声道 + 右声道 + 低音声道 + 中央声道 + 左环绕 + 右环绕，应用于类传统影院和家庭影院中</li>
<li>7.1声道 ：左声道 + 右声道 + 低音声道 + 中央声道 + 左环绕 + 右环绕 + 左后环 + 右后环，常见的包括：Dolby Surround 7.1杜比7.1环绕声</li>
</ul>
<h2 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h2><p>采样率可以理解为采集样本的速率（故也可以称为采样速度或者采样频率），它定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。</p>
<p>例如：采样率为44100，意味着每秒钟对连续的声音信号采集44100次，同样对应得到的数字信号每秒的样本数量（具体可以参考采样过程）</p>
<h2 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h2><p>采样位数就是指某一瞬时时刻，量化声音大小（精细程度）的计量单位</p>
<ul>
<li>8bit ( 1Byte ) 对应0~255，将振幅划分为256个等级</li>
<li>16bit (2Byte) 对应0~65535，将振幅划分为65536个等级</li>
</ul>
<h2 id="样本格式"><a href="#样本格式" class="headerlink" title="样本格式"></a>样本格式</h2><h3 id="样本组合形式"><a href="#样本组合形式" class="headerlink" title="样本组合形式"></a>样本组合形式</h3><ul>
<li>交错模式：每个声道的样本数据交错存储排布</li>
<li>平面模式：每个声道的样本数据分开存储</li>
</ul>
<p>下面以stereo模式进行图示解释（C代表Channel）：</p>
<p>​    <img src="/images/linux/Audio/Audio-meet-3.png" alt="sample"></p>
<h3 id="FFmpeg-样本组织形式介绍"><a href="#FFmpeg-样本组织形式介绍" class="headerlink" title="FFmpeg 样本组织形式介绍"></a>FFmpeg 样本组织形式介绍</h3><ul>
<li>Packed格式，frame.data[0]包含所有的音频数据。</li>
<li>Planar格式，frame.data[i]表示第i个声道的数据（假设声道0是第一个）</li>
</ul>
<h3 id="FFmpeg-主要样本格式"><a href="#FFmpeg-主要样本格式" class="headerlink" title="FFmpeg 主要样本格式"></a>FFmpeg 主要样本格式</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AVSampleFormat</span> {</span></span><br><span class="line">    AV_SAMPLE_FMT_NONE = <span class="number">-1</span>,</span><br><span class="line">    AV_SAMPLE_FMT_U8,          <span class="comment">///&lt; unsigned 8 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S16,         <span class="comment">///&lt; signed 16 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S32,         <span class="comment">///&lt; signed 32 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_FLT,         <span class="comment">///&lt; float</span></span><br><span class="line">    AV_SAMPLE_FMT_DBL,         <span class="comment">///&lt; double</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_U8P,         <span class="comment">///&lt; unsigned 8 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S16P,        <span class="comment">///&lt; signed 16 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S32P,        <span class="comment">///&lt; signed 32 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_FLTP,        <span class="comment">///&lt; float, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_DBLP,        <span class="comment">///&lt; double, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S64,         <span class="comment">///&lt; signed 64 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S64P,        <span class="comment">///&lt; signed 64 bits, planar</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_NB           <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>说明：以P为结尾的是planar结构；Planar模式是FFmpeg内部存储模式，我们实际使用的音频文件都是Packed模式的。</p>
<h2 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h2><p>比特率指的是单位时间播放连续的媒体如压缩后的音频或视频的比特数量，在这个意义上讲，它相当于术语数字带宽消耗量，或吞吐量。单位bps / Kbps（bit per second）这里是bit而不是Byte（1Byte = 8bit）</p>
<p>虽然经常作为“速度”的参考，比特率并不测量“‘距离’/时间”，而是被传输或者被处理的“‘二进制码数量’/时间”，所以应该把它和传播速度区分开来，传播速度依赖于传输的介质并且有通常的物理意义。（来自维基百科）</p>
<h2 id="参数关系"><a href="#参数关系" class="headerlink" title="参数关系"></a>参数关系</h2><p>对于PCM裸数据： 文件时长 ≈（文件总大小 - 头信息）/ (采样率 * 采样位数 * 通道数 / 8) [也就是比特率]</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
  </entry>
  <entry>
    <title>Audio-再遇</title>
    <url>/2022/09/05/Audio-meet-1/</url>
    <content><![CDATA[<p>本篇内容对一节提到的编码进行扩展，将重点对PCM格式、WAVE格式、MP3格式进行详细解析。</p>
<h1 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h1><p>PCM : Pulse-Code Modulation 脉冲调制编码</p>
<p>PCM 本是一种调制方法的名称，进而通过该方法得到的音频数据也称作PCM数据，即裸数据。该数据是我们通过codec得到的最原始的数据！</p>
<p>​    <img src="/images/linux/Audio/Audio-remeet-1.png" alt="pic"></p>
<h1 id="WAVE"><a href="#WAVE" class="headerlink" title="WAVE"></a>WAVE</h1><p>WAVE : Waveform Audio File Format 波形音频文件格式, 即我们平时所说的wave文件</p>
<p>很简单，WAV文件格式结构体通常是用来保存PCM格式的原始数据，基于此添加一个文件头构成了WAV文件，即wave = wave头 + PCM数据。因此它通常也被称为无损音频，但是严格意义上来讲，WAV也可以存储其它压缩格式的音频数据。</p>
<h2 id="wav头"><a href="#wav头" class="headerlink" title="wav头"></a>wav头</h2><table>
<thead>
<tr>
<th><strong>偏移地址</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>大小</strong></th>
<th><strong>名称</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>00H~03H</td>
<td>char</td>
<td>4</td>
<td>资源交换文件标志 ( RIFF )</td>
<td>52 49 46 46 固定写法</td>
</tr>
<tr>
<td>04H~07H</td>
<td>long int （4）</td>
<td>1</td>
<td>文件大小size</td>
<td>从下个地址 (08) 开始到 WAV 文件结尾的总字节数整个 WAV 文件的大小就是该数值 + 8</td>
</tr>
<tr>
<td>08H~0BH</td>
<td>char</td>
<td>4</td>
<td>WAV文件标志 WAVE</td>
<td>57 41 56 45 , 是 WAVE 四个字母的 ASCII 码，固定写法</td>
</tr>
<tr>
<td>0CH~0FH</td>
<td>char</td>
<td>4</td>
<td>波形格式标志（fmt ）</td>
<td>最后一位0x20 对应的字符是空格</td>
</tr>
<tr>
<td>10H~13H</td>
<td>int</td>
<td>1</td>
<td>过滤字节</td>
<td>一般为00000010H</td>
</tr>
<tr>
<td>14H~15H</td>
<td>short int （2）</td>
<td>1</td>
<td><strong>格式种类audioformat</strong></td>
<td>值为1时，表示数据为线性PCM编码</td>
</tr>
<tr>
<td>16H~17H</td>
<td>short int</td>
<td>1</td>
<td><strong>通道数 channnels</strong></td>
<td>1 表示单声道 , 2 表示立体声</td>
</tr>
<tr>
<td>18H~1BH</td>
<td>long int</td>
<td>1</td>
<td><strong>采样频率 sampleRate</strong></td>
<td>80 BB 00 00 – &gt; 48000 Hz ;</td>
</tr>
<tr>
<td>1CH~1FH</td>
<td>long int</td>
<td>1</td>
<td>波形数据传输速率（每秒平均字节数）</td>
<td>采样率×通道数×采样位数 / 8</td>
</tr>
<tr>
<td>20H~21H</td>
<td>short int</td>
<td>1</td>
<td>DATA数据块调整长度，字节。</td>
<td>通道数×样本数据位数 / 8</td>
</tr>
<tr>
<td>22H~23H</td>
<td>short int</td>
<td>1</td>
<td>PCM位宽</td>
<td>10 00 —-&gt; 16 位, 2 字节</td>
</tr>
<tr>
<td>24H~27H</td>
<td>char</td>
<td>4</td>
<td>数据标记</td>
<td>64 61 74 61 data的ASCII的值</td>
</tr>
<tr>
<td>28H~2BH</td>
<td>long int</td>
<td>1</td>
<td>PCM 数据总长度</td>
<td></td>
</tr>
</tbody></table>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>Q：wave文件的文件头一定是44Bytes吗？</p>
<p>A：不一定！以上格式只是wave文件的标准，属于通用标准。但是将其他格式文件通过ffmpeg转码之后的wav文件头会大于44个字节（115Bytes），在文件头和数据块之间添加了一些ffmpeg的信息，部分表征的意义不同！网上很多格式转换工具都是调用的ffmpeg转码的，导致文件头大小不完全相同。</p>
<blockquote>
<p>​     -map_metadata -1 -fflags +bitexact 可以去除标注信息，使文件头符合标准</p>
<p>​     ffmpeg -y -i music.mp3 -map_metadata -1 -fflags +bitexact -f wav -ac 1 -ar 16000 -ab 16k music.wav</p>
</blockquote>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Ffmpeg不去标准信息转码wave之后的文件格式：</p>
<table>
<thead>
<tr>
<th>偏移地址</th>
<th>字节数</th>
<th>数据类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>00H ~ 23H</td>
<td>36</td>
<td>同上表的00H~23H一致</td>
<td></td>
</tr>
<tr>
<td>24H ~ 27H</td>
<td>4</td>
<td>char</td>
<td>“LIST”, LIST块标志，固定不变</td>
</tr>
<tr>
<td>28H ~ 2BH</td>
<td>4</td>
<td>long</td>
<td>LIST块占用的字节数，在这里为26字节</td>
</tr>
<tr>
<td>2CH ~ 45H</td>
<td>26</td>
<td>char</td>
<td>LIST块内容</td>
</tr>
<tr>
<td>46H ~ 49H</td>
<td>4</td>
<td>char</td>
<td>“data”, data数据块标志，固定不变</td>
</tr>
<tr>
<td>4AH ~ 4DH</td>
<td>4</td>
<td>long</td>
<td>wav文件音频数据所占大小</td>
</tr>
</tbody></table>
<h1 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MP3：Moving Picture Experts Group Audio Layer III, 动态影像专家压缩标准音频层面3</p>
<p>首先科普下部分概念：MPEG（Moving Pictures Experts Group ，动态图像专家组），简单理解就是一些研究音视频的专家发布的相关标准，其命名为MPEG-*（其中*代表数字或字母），例如MPEG-1、MPEG-2.5、MPEG-E等等。</p>
<p>可能有人会想MPEG-3是不是就是MP3呢？MPEG是针对音视频及系统测试的一整套的标准规范，其中对于MPEG1来讲，其part3音频部分规定了3个独立分层的音频编码格式，分别为layer Ⅰ、layer Ⅱ、layer Ⅲ，而layer Ⅲ也就是我们所说的MP3（MEPEG1 Layer Ⅲ），这三层的区别主要在于编码的算法及输出速率的区别。同样纵向来看，MPEG2、MPEG2.5同样有三个独立的layer，区别在于它们所使用的采样率更低了。</p>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>目前大多数标准MP3文件都支持ID3V2标准。具体组成格式为：ID3V2.3标签帧（1个）+ 数据帧（若干）+ ID3V1帧（1个），其中ID3V2.3 = 标签头（1个，必须） + 标签帧（若干，不必须） + 扩展标签头（不必须）</p>
<p>组成部分我画了一张示意图可以参考，每一部分下面将做详细解析</p>
<p>​    <img src="/images/linux/Audio/Audio-remeet-2.png" alt="pic"></p>
<h2 id="ID3标准"><a href="#ID3标准" class="headerlink" title="ID3标准"></a>ID3标准</h2><p>MP3帧头中除了存储一些象private、copyright、original的简单音乐说明信息以外，没有考虑存放歌名、作者、专辑名、年份 等复杂信息，而这些信息在MP3应用中非常必要。1996年，FricKemp在“Studio 3”项目中提出了在MP3文件尾增加一块用于存放歌曲的说明信息，形成了ID3标准</p>
<h2 id="标签头"><a href="#标签头" class="headerlink" title="标签头"></a>标签头</h2><p>标签头是由10Byte组成的，具体含义如下</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char Header[3];</td>
<td>必须为”ID3”否则认为标签不存在，如上图地址00—02部分为”49 44 33”，文本为“ID3”</td>
</tr>
<tr>
<td>char Ver;</td>
<td>版本号 ID3V2.3 就记录 3，如上图地址03处记录为”03”</td>
</tr>
<tr>
<td>char Revision;</td>
<td>副版本号此版本记录为 0</td>
</tr>
<tr>
<td>char Flag;</td>
<td>放标志的字节，一般为00abc00000a – 表示是否使用 Unsynchronisationb – 表示是否有扩展头部,一般没有(至少 Winamp 没有记录),所以一般也不设置c – 表示是否为测试标签(99.99%的标签都不是测试用的，所以一般也不设置)</td>
</tr>
<tr>
<td>char Size[4];</td>
<td>标签大小,包括标签头的 10 个字节和所有的标签帧的大小</td>
</tr>
</tbody></table>
<p>整个标签大小 :</p>
<p>ID3V2_frame_size = (int)(Size[0] &amp; 0x7F) &lt;&lt; 21 | (int)(Size[1] &amp; 0x7F) &lt;&lt; 14 | (int)(Size[2] &amp; 0x7F) &lt;&lt; 7 | (int)(Size[3] &amp; 0x7F) + 10;</p>
<h2 id="标签帧"><a href="#标签帧" class="headerlink" title="标签帧"></a>标签帧</h2><p>每个标签帧都有一个 10 个字节的帧头（虽然都是10字节，但是与标签头不是一个东西。标签头有且只有一个，而标签头每一个标签帧都有一个帧头）和至少一个字节的不固定长度的内容组成。</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char FrameID[4]</td>
<td>用四个字符标识一个帧，说明其内容</td>
</tr>
<tr>
<td>char Size[4]</td>
<td>帧内容的大小，不包括帧头，不得小于1</td>
</tr>
<tr>
<td>char Flags[2]</td>
<td>存放标志，只定义了6 位，此处不再说明</td>
</tr>
</tbody></table>
<p>常用帧标识：</p>
<p>TIT2：标题<br>TPE1：作者<br>TALB：专辑<br>TRCK： 音轨，格式：N/M，N表示专辑中第几首，M为专辑中歌曲总数<br>TYER：年份<br>TCON：类型<br>COMM：备注，格式：“eng\0备注内容”，其中eng表示所使用的语言<br>帧大小为四个字节所表示的整数大小。</p>
<h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p>数据帧由帧头和数据帧组成，对于每一帧数据都有一个帧头。</p>
<p>帧头长4字节，对于固定位率的MP3文件，所有帧的帧头格式一样其数据结构如下</p>
<p>typedef struct frameHeader<br>{<br>unsigned int sync1:8; //同步信息 1<br>unsigned int error_protection:1; //CRC 校验<br>unsigned int layer:2; //层<br>unsigned int version:2; //版本<br>unsigned int sync2:3; //同步信息 2<br>unsigned int extension:1; //版权<br>unsigned int padding:1; //填充空白字<br>unsigned int sample_rate_index:2; //采样率索引<br>unsigned int bit_rate_index:4; //位率索引<br>unsigned int emphasis:2; //强调方式<br>unsigned int original:1; //原始媒体<br>unsigned int copyright:1; //版权标志<br>unsigned int mode_extension:2; //扩展模式,仅用于联合立体声<br>unsigned int channel_mode:2; //声道模式<br>}FHEADER;</p>
<p>比特率为32的整数倍一般就是恒定编码，否则就是可变编码；可变编码帧头一般会有不同</p>
<h2 id="ID3V1标签帧"><a href="#ID3V1标签帧" class="headerlink" title="ID3V1标签帧"></a>ID3V1标签帧</h2><p>标签头是由128Byte组成的，具体含义如下</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char Header[3]</td>
<td>标签头必须是”TAG”否则认为没有标签</td>
</tr>
<tr>
<td>char Title[30]</td>
<td>标题</td>
</tr>
<tr>
<td>char Artist[30]</td>
<td>作者</td>
</tr>
<tr>
<td>char Album[30]</td>
<td>专集</td>
</tr>
<tr>
<td>char Year[4]</td>
<td>出品年代</td>
</tr>
<tr>
<td>char Comment[28]</td>
<td>备注</td>
</tr>
<tr>
<td>char reserve</td>
<td>保留</td>
</tr>
<tr>
<td>char track</td>
<td>音轨</td>
</tr>
<tr>
<td>char Genre;</td>
<td>类型</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
  </entry>
  <entry>
    <title>硬件随机数测试方法</title>
    <url>/2022/11/26/DTRNG_Test/</url>
    <content><![CDATA[<h1 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h1><p>配置芯片DTRNG硬件单元寄存器生成一定数量的数据，保存成二进制文件，使用NIST测试套件进行验证得到是否随机的结论。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol>
<li>DTRNG：Digital True Random Number Generator，数字真随机数发生器</li>
<li>NIST：National Institude of Standards and Technology，国家标准技术研究所</li>
<li>NIST-sts (Statistical Test Suite)，统计测试套件：</li>
</ol>
<ul>
<li><p>源码链接：<a href="https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software%EF%BC%88Download%E5%8D%B3%E5%8F%AF%EF%BC%89">https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software（Download即可）</a></p>
</li>
<li><p>文档链接：<a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf">https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf</a></p>
</li>
<li><p>windows安装</p>
<p>官网的软件包是Linux系统下开发的，Windows系统需要先下一个<a href="https://cygwin.com/install.html">cygwin软件</a>来辅助使用</p>
<p>可以参考博客：<a href="https://blog.csdn.net/weixin_39928192/article/details/89256576">https://blog.csdn.net/weixin_39928192/article/details/89256576</a>?</p>
</li>
<li><p>Linux安装</p>
<p>进入工程文件夹sts-2.1.2直接make即可，得到 assess 可执行程序</p>
</li>
</ul>
<h1 id="随机测试项"><a href="#随机测试项" class="headerlink" title="随机测试项"></a><strong>随机测试项</strong></h1><p>每一个测试项的解读：<a href="https://blog.csdn.net/lafu5137/article/details/79593845">https://blog.csdn.net/lafu5137/article/details/79593845</a></p>
<ol>
<li>The Frequency (Monobit) Test，频率检测。该检验主要是看0和1在整个序列中所占的比例（基础检测）</li>
<li>Frequency Test within a Block，块内频率检测</li>
<li>The Runs Test，游程检测。游程指的是一个没有间断的相同数序列</li>
<li>Tests for the Longest-Run-of-Ones in a Block，块内最长游程检测</li>
<li>The Binary Matrix Rank Test，二元矩阵秩检测</li>
<li>The Discrete Fourier Transform (Spectral) Test，离散傅立叶变换检测</li>
<li>The Non-overlapping Template Matching Test，非重叠模块匹配检测</li>
<li>The Overlapping Template Matching Test，重叠模块匹配检测</li>
<li>Maurer’s “Universal Statistical” Test，Maurer的通用检测统计</li>
<li>The Linear Complexity Test，线性复杂度检测</li>
<li>The Serial Test，序列检测</li>
<li>The Approximate Entropy Test，近似熵检测</li>
<li>The Cumulative Sums (Cusums) Test，累加和检验</li>
<li>The Random Excursions Test，随机游动检测</li>
<li>The Random Excursions Variant Test.，随机游动状态频率检测</li>
</ol>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h1><p>该流程是基于Linux系统进行操作的，使用的数据：sts-2.1.2/data/data.pi</p>
<ol>
<li>启动程序。**./assess ，**stream length译为流的长度。</li>
<li>输入待测文件路径。根据菜单，键入0并输入文件的路径（相对路径和绝对路径都可以）</li>
<li>选择测试项。键入1表示应用全部测试项；输入0表示部分测试项，随后输入一个16位二进制序列选择测试项。</li>
<li>参数调整。可以根据菜单及选项微调部分参数的值，基本选择默认即可。</li>
<li>输入比特流的个数。表示有多少个stream</li>
<li>选择输入文件类型。该类型对应于第二步输入文件的类型，两种类型供选择：ASCII / Binary</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h1><ol>
<li>每一项测试所需的序列的stream length是不一样的，经测试如果选择全部测试项至少保证stream length &gt;= 10000bits，否则会出现错误。而如果单项测试查阅文档满足参数范围即可，比如选择1频率测试只需保证stream length&gt;100bits即可。</li>
<li>必须保证：流长度 × 流个数 &lt;= 文件大小</li>
<li>如果输入的文件是ACSII格式的话，启动程序时所输入的bitstream的单位是byte；而输入文件为Binary的话bitstream单位为bit。例如：第一步键入./assess 10000；第五步键入10 ；此时第六步选择0代表输入了10000×10×8（bits），输入1代表输入了10000×10（bits）。实际输入过程是要反着理解，先确定输入文件类型，进而确认bitstream、number，保证第一个公式</li>
</ol>
<h1 id="检测标准"><a href="#检测标准" class="headerlink" title="检测标准"></a><strong>检测标准</strong></h1><p>测试成功结束则会在 <strong>sts-2.1.2/experiments/AlgorithmTesting/</strong> 目录下生成测试报告，而针对每一个项目的结果会在其子目录下生成测试报告。</p>
<p>最终测试报告finalAnalysisReport.txt中P-value都大于等于0.01即可认为通过了NIST检验，这个数据越大越好。如果该数据为0，可能是由于数据量的问题则可以去每个子项目结果中去查看，会有SUCCESS字样！</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a><strong>Q&amp;A</strong></h1><ol>
<li><p>Q：Segment fault</p>
<p>A： bitstream*num &gt; fileSize即流的长度乘以流的个数超过了文件的大小通常会有error信息</p>
</li>
<li><p>Q：igamc: UNDERFLOW？</p>
<p>A：数据下溢，可能是数据格式的原因或者数据过于不随机</p>
</li>
<li><p>Q：P-value全部是0？</p>
<p>A：导致 <strong>igamc: UNDERFLOW</strong> 的原因都是有可能的，同时也可能是因为数据量不够所导致的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
  </entry>
  <entry>
    <title>GPIO</title>
    <url>/2022/09/22/GPIO/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>GPIO：General Purpose Input Output，通用输入输出，简称为“IO口”，芯片与外围设备交互的硬件接口</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>以下图片来自STM32的GPIO硬件电路图</p>
<p><img src="/images/system/GPIO-1.png" alt="image"></p>
<p>施密特触发器：在正向递增和负向递减两个方向有不同的阈值，有一定的抗干扰能力，外部的小扰动不会导致cpu误判，直至剧烈变化或者真的有电平的变化。</p>
<h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><h2 id="输入（4）"><a href="#输入（4）" class="headerlink" title="输入（4）"></a>输入（4）</h2><ol>
<li>浮空输入：多用于外部按键输入，io状态不确定完全由外部输入决定</li>
<li>上拉输入：IO口输入设定为高电平输入（1），检测低电平或下降沿</li>
<li>下拉输入：IO口输入设定为低电平输入（0）</li>
<li>模拟输入：ADC模拟输入，测量外部电压幅值不通过TTL</li>
</ol>
<h2 id="输出（4）"><a href="#输出（4）" class="headerlink" title="输出（4）"></a>输出（4）</h2><ol>
<li>推挽输出：输出高低电平</li>
<li>开漏输出：只有一个NMOS导通，只能输出低电平+高阻态，不能输出高电平；当NMOS导通输出低电平，截至输出高阻态。用作线与，电平不匹配的场合，外部上拉</li>
<li>复用推挽输出：需要输出高低电平的其他模式，如：spi uart</li>
<li>复用开漏输出：普通i2c处于该模式</li>
</ol>
<h1 id="GPIO寄存器"><a href="#GPIO寄存器" class="headerlink" title="GPIO寄存器"></a>GPIO寄存器</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>以stm32为例</p>
<ul>
<li>GPIO 端口模式寄存器 (GPIOx_MODER) (x = A…I)</li>
<li>GPIO 端口输出类型寄存器 (GPIOx_OTYPER) (x = A…I)</li>
<li>GPIO 端口输出速度寄存器 (GPIOx_OSPEEDR) (x = A…I/)</li>
<li>GPIO 端口上拉/下拉寄存器 (GPIOx_PUPDR) (x = A…I/)</li>
<li>GPIO 端口输入数据寄存器 (GPIOx_IDR) (x = A…I)</li>
<li>GPIO 端口输出数据寄存器 (GPIOx_ODR) (x = A…I)</li>
<li>GPIO 端口置位/复位寄存器 (GPIOx_BSRR) (x = A…I)</li>
</ul>
<h2 id="GPIO-Shadow"><a href="#GPIO-Shadow" class="headerlink" title="GPIO Shadow"></a>GPIO Shadow</h2><p>由于设置某个模式的过程中配置的不只是一个寄存器，配置过程中就可能出现别的状态的产生，导致错误。而使用shadow寄存器，可以先将所有需要配置的寄存器分别设置进去，但不生效，直至全部设置完毕，再指定GPID即要映射的组上去生效！避免了中间非必要状态的产生。</p>
<h1 id="用户层应用"><a href="#用户层应用" class="headerlink" title="用户层应用"></a>用户层应用</h1><h2 id="配置GPIO"><a href="#配置GPIO" class="headerlink" title="配置GPIO"></a>配置GPIO</h2><p>在内核导出 gpio 节点的前提下， 可以操作/sys/class/gpio 节点， 控制 gpio 输入输出</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">导出节点：  echo <span class="number">20</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">export</span></span></span><br><span class="line"><span class="class">设置方向：  <span class="title">echo</span> [<span class="title">out</span> / <span class="title">in</span>] &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio20</span>/<span class="title">direction</span></span></span><br><span class="line"><span class="class">设置值：    <span class="title">echo</span> [0 / 1] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">value</span></span></span><br><span class="line"><span class="class">设置触发模式：<span class="title">echo</span> [<span class="title">none</span> / <span class="title">rising</span> / <span class="title">falling</span> /  <span class="title">both</span>] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">edge</span></span></span><br><span class="line"><span class="class">翻转属性：  <span class="title">echo</span> [0 / 1] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">active_low</span></span></span><br><span class="line"><span class="class">移除节点：  <span class="title">echo</span> 20 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">unexport</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>注意事项</p>
<ul>
<li>direction<br>如果内核不支持改变 GPIO 的方向，或者在导出时内核代码没有明确允许用户空间可以重新配置 GPIO 方向， 那么这个属性将不存在。</li>
<li>value<br>输出时，控制高低电平；输入时，获取高低电平</li>
<li>edge<br>控制中断触发模式，引脚被配置为中断后可以使用poll() 函数监听引脚<br>非中断引脚、上升沿触发、下降沿触发、边沿触发</li>
<li>active_low<br>用于翻转电平，当外部有效信号与GPIO有效信号不一致（即0可能表示有效，1也有可能表示有效）</li>
</ul>
<h2 id="查看GPIO配置"><a href="#查看GPIO配置" class="headerlink" title="查看GPIO配置"></a>查看GPIO配置</h2><p>不同的厂商对于GPIO配置结果的查看方式有所不同，以下以Ingenic-x2000为例对应相关的手册可以确定相应的IO状态</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">/<span class="meta"># cat /sys/devices/platform/apb/10010000.pinctrl/dump_gpio</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下图, 下面会有每一个GPIO状态</span></span><br><span class="line">REG 	|+++GPA++|+++GPB++|+++GPC++|+++GPD++|</span><br><span class="line"></span><br><span class="line">INL 	|<span class="number">0</span>c3fffff|<span class="number">67f</span>6036f|<span class="number">0110f</span>ef4|<span class="number">0f</span>7fffff|</span><br><span class="line">INT 	|<span class="number">02b</span>00000|<span class="number">30440000</span>|<span class="number">00000081</span>|<span class="number">00000100</span>|</span><br><span class="line">MSK 	|<span class="number">194f</span>cfff|ce0a0040|<span class="number">74f</span>f0076|<span class="number">003f</span>feff|</span><br><span class="line">PAT1 	|<span class="number">0265</span>cfff|f6440000|<span class="number">77</span>efc0fb|<span class="number">003f</span>fbff|</span><br><span class="line">PAT0 	|<span class="number">0f</span>8a3000|<span class="number">1033</span>efc0|<span class="number">88100005</span>|<span class="number">00000400</span>|</span><br><span class="line">EDG 	|<span class="number">3f</span>ffff00|f6037f00|<span class="number">10f</span>ff400|<span class="number">7f</span>ffff00|</span><br><span class="line">PLUP 	|<span class="number">14000000</span>|<span class="number">41800000</span>|<span class="number">00200001</span>|<span class="number">00000100</span>|</span><br><span class="line">PLDWN 	|<span class="number">00000000</span>|<span class="number">800000</span>c0|<span class="number">00100002</span>|<span class="number">00000000</span>|</span><br><span class="line">FLAG 	|<span class="number">00000000</span>|<span class="number">00000000</span>|<span class="number">00000000</span>|<span class="number">00000000</span>|</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="相关功能"><a href="#相关功能" class="headerlink" title="相关功能"></a>相关功能</h1><p>在低功耗场景下，系统休眠以后部分硬件时钟可能关闭。但是GPIO不依赖始终，故可以配置IO作为中断源对CPU进行唤醒</p>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>GPIO</category>
      </categories>
  </entry>
  <entry>
    <title>理解c/c++ Volatile关键字</title>
    <url>/2022/11/15/Volatile/</url>
    <content><![CDATA[<p>网络上对于volatile的解读众说纷纭，而且其中较多的是java内存模型。</p>
<p>本篇文章将基于自己的学习和实验，针对C/C++语言嵌入式开发场景进行volatile关键字的分析</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>volatile 关键字是 C /C++ 编程语言的一部分，作为一种类型修饰符。我将其作用总结为<em><strong>告诉编译器禁止优化其所修饰对象的读写访存操作及指令顺序，保证变量的可见性</strong></em></p>
<blockquote>
<p>可见性：当一个线程修改了共享变量后，其他线程能够立即得知这个修改。</p>
<p>有序性：程序执行的顺序按照代码的先后顺序执行。</p>
<p>原子性：一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行。</p>
</blockquote>
<p>在《程序员的自我修养》这本书中讲到，volatile基本可以做到两个事情：</p>
<ol>
<li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回</li>
<li>阻止编译器调整操作volatile变量的指令顺序</li>
</ol>
<p>对于第一个作用volatile是可以很好的做到，而对于第二个作用编译器层面可以保证指令有序但是我们无法阻止cpu动态调整顺序。真正保证有序性是需要通过内存屏障完成的，而volatile并没有内存屏障的功能，gcc 提供了一个内联函数 <em><strong>asm volatile (“” : : : “memory”</strong>)</em> 编译器屏障，具体平台相关内存屏障需要到具体的结构平台去参考</p>
<h1 id="理解volatile"><a href="#理解volatile" class="headerlink" title="理解volatile"></a>理解volatile</h1><blockquote>
<p>Collins对于Volatile释义：A situation that is volatile is <strong>likely</strong> to change <strong>suddenly</strong> and <strong>unexpectedly</strong>.</p>
</blockquote>
<p><strong>volatile</strong> 本身释义为 <strong>易失的、易变的</strong></p>
<p>对于用volatile所修饰的对象，在其自身的含义基础上，有三个副词可以很好的对其性质进行诠释：</p>
<ul>
<li><p>likely   可能地，指对象的状态可能变化、也可能不变保持状态，强调结果；</p>
</li>
<li><p>suddenly:   突然地，指对象状态的瞬时变化，强调过程；</p>
</li>
<li><p>unexpectedly:  不可预期地，指对象变化的时间结果都不可预期；</p>
</li>
</ul>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>根据含义性质，在嵌入式开发中以下三种场景是一定要考虑使用volatile关键字的（大多数情况一定使用！！！）</p>
<ol>
<li>多线程任务读写同一全局变量，</li>
<li>中断服务程序修改的全局变量</li>
<li>内存映射外设寄存器</li>
</ol>
<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h2 id="中断场景"><a href="#中断场景" class="headerlink" title="中断场景"></a>中断场景</h2><p>下面一段代码，我们所期待的结果是主程序运行，直到crtl+c按键按下程序退出，代码编译执行之后并不是我们所预期的样子。如果sig_done变量不通过volatile修饰程序将永远不会退出，而volatile关键字很好的解决了这一个问题</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> sig_done = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//static volatile bool sig_done = false;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(sig == SIGINT)</span><br><span class="line">    ┆   sig_done = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main start, press ctrl+c go on\n"</span>);</span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line">    <span class="keyword">while</span>(!sig_done) {</span><br><span class="line">    }   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main exit\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令</span></span><br><span class="line">gcc main.c <span class="number">-02</span></span><br><span class="line">objdump -d a.out &gt; a.s</span><br></pre></td></tr></tbody></table></figure>

<p>通过反汇编比较两个程序的异同（左侧volatile，右侧无volatile）</p>
<p><img src="/images/coding/meld.png" alt="image"></p>
<p>没有voaltile的while实现方式为：</p>
<ol>
<li>比较rip寄存器+0x2f65地址处的值（sig_done）与 0 是否相等</li>
<li>不相等跳转到main+0x30即上一条指令处</li>
<li>跳转</li>
</ol>
<p>有volatile的while实现方式：</p>
<ol>
<li><p>nopl (%rax) 编译器开启优化后使指令按字对齐,减少取指令的时钟周期。</p>
</li>
<li><p>将 rip寄存器+0x2f65地址处的值放到eax寄存器中</p>
<blockquote>
<p>movzbl指令负责拷贝一个字节，并用0填充其目的操作数中的其余各位，这种扩展方式叫“零扩展”。</p>
<p>movsbl指令负责拷贝一个字节，并用源操作数的最高位填充其目的操作数中的其余各位，这种扩展方式叫“符号扩展”。</p>
</blockquote>
</li>
<li><p>test   %al,%al 对eax寄存器低位逻辑与</p>
<blockquote>
<p>Test命令：将两个操作数进行逻辑与运算，并根据运算结果设置相关的标志位（ze: zero flag）。但是，Test命令的两个操作数不会被改变。运算结果在设置过相关标记位后会被丢弃。</p>
</blockquote>
</li>
<li><p>je   如果ZF（零标志位）=1，零标志位为1（真值）说明结果为0，则转到label所指的指令语句；否则跳过这条语句，执行下条语句</p>
</li>
</ol>
<h2 id="多线程场景"><a href="#多线程场景" class="headerlink" title="多线程场景"></a>多线程场景</h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> mstop = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//static volatile bool mstop = true;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">first_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s start\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">while</span>(mstop) {</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s exit\n"</span>, __func__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">second_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s start\n"</span>, __func__);</span><br><span class="line">    mstop = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s exit\n"</span>, __func__);</span><br><span class="line">}                                                                                                                                                                     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::thread fthread{first_thread};</span><br><span class="line">    std::thread sthread{second_thread};</span><br><span class="line">    fthread.<span class="built_in">join</span>();</span><br><span class="line">	sthread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="外设寄存器"><a href="#外设寄存器" class="headerlink" title="外设寄存器"></a>外设寄存器</h2><p>对于外设通常设置有状态寄存器，我们可以通过循环读取状态寄存器的值来查看对应外设的状态。对于如下示例，如果没有使用volatile关键字，编译器可能生成的代码是读取一个固定地址的值而不会每次都从主存中读取新的值（或者读取n次状态，生成的代码只读取了一次，然后使用n次相同的值）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//设置寄存器</span></span><br><span class="line">*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *) STATUS_BASE_ADDR = <span class="number">1</span> &lt;&lt; <span class="number">24</span>; </span><br><span class="line"><span class="comment">//读寄存器</span></span><br><span class="line"><span class="keyword">while</span>(!(*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *) STATUS_BASE_ADDR)) {</span><br><span class="line">    <span class="comment">// do action</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h1><p>该部分不是volatile的使用，而是对内屏屏障的理解</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mp3decoder.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mp3decoder</span> :</span> public decoderImp </span><br><span class="line">{</span><br><span class="line">    public:</span><br><span class="line">    	<span class="type">static</span> mp3decoder* <span class="title function_">getInstance</span><span class="params">()</span>;</span><br><span class="line">    private:</span><br><span class="line">    	mp3decoder();</span><br><span class="line">    	~mp3decoder();</span><br><span class="line">    	<span class="type">static</span> mp3decoder* mdecoder;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//mp3decoder.cpp</span></span><br><span class="line"><span class="comment">//线程不安全，适用于单线程</span></span><br><span class="line">mp3decoder* mp3decoder::mdecoder = <span class="literal">NULL</span>;</span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全，但锁的代价太高</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全，锁的代价太高</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">    unlock();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Double-Checked Locking Pattern (DCLP 双检查锁)，指令重排序reorder不安全</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">        lock();</span><br><span class="line">    	<span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">       		mdecoder = new mp3decoder();</span><br><span class="line">         unlock();</span><br><span class="line">    	<span class="keyword">return</span> mdecoder;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存屏障</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">    	<span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">            mp3decoder *tmp = new mp3decoder();</span><br><span class="line">            MemoryBarrier();</span><br><span class="line">            mdecoder = tmp;</span><br><span class="line">        }</span><br><span class="line">    	<span class="keyword">return</span> mdecoder;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// mdecoder = new mp3decoder()在cpu层面动作：</span></span><br><span class="line"><span class="comment">// 1. 分配内存</span></span><br><span class="line"><span class="comment">// 2. 调用构造函数</span></span><br><span class="line"><span class="comment">// 3. 将内存地址赋值给mdecoder指针</span></span><br><span class="line"><span class="comment">// 由于2、3对于编译器来讲是有可能进行优化的，即先将指针赋值再调用构造函数，导致线程不安全！！</span></span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>参考文章：</p>
<ul>
<li><a href="https://barrgroup.com/embedded-systems/how-to/c-volatile-keyword">How to Use C’s volatile Keyword</a></li>
<li><a href="https://barrgroup.com/tech-talks/volatile-c">Pro Tips for Using C’s volatile Keyword</a></li>
<li><a href="https://liam.page/2018/01/18/volatile-in-C-and-Cpp/">谈谈 c / c++ 中的volatile</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/2022/08/25/cmake/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>官网 : <a href="https://cmake.org/cmake/help/v3.15/">https://cmake.org/cmake/help/v3.15/</a></p>
</blockquote>
<p>CMake是跨平台的 免费和开源软件，用于使用独立于编译器的方法构建自动化、测试、打包和安装软件。CMake 本身并不是一个构建系统；它生成另一个系统的构建文件。它支持目录层次结构和依赖于多个库的应用程序。它与原生构建环境结合使用，例如Make、Qt Creator、Ninja、Android Studio、Apple 的Xcode和Microsoft Visual Studio。（摘自Wiki）</p>
<h1 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><p>cmake要求最低版本(选择性添加)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.0</span><span class="number">.0</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>编译工程名</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">project(xxx)</span><br><span class="line"><span class="comment">//会自动创建两个变量，PROJECT_SOURCE_DIR和PROJECT_NAME</span></span><br><span class="line"><span class="comment">//${PROJECT_SOURCE_DIR}：本CMakeLists.txt所在的文件夹路径</span></span><br><span class="line"><span class="comment">//${PROJECT_NAME}：本CMakeLists.txt的project名称</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>给部分文件或路径组合起别名, 通过${变量}获取变量内容</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(变量 文件名/路径/...)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置c / c++ 编译编译参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> (CMAKE_C_FLAGS <span class="string">"-Wall -O2"</span>)</span><br><span class="line"><span class="built_in">set</span> (CMAKE_CXX_FLAGS <span class="string">"-Wall -std=C++11"</span>)</span><br><span class="line">add_compile_options( -Wall )				<span class="comment">//该命令译选项是针对所有编译器的(包括c和c++编译器)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>为当前路径以及子目录的源文件加入由-D引入的define flag</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_definitions(-DFOO -DDEBUG ...)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>对子文件夹进行cmake编译</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_subdirectory(子文件夹名) </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>打印信息</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">message() 			<span class="comment">//直接添加打印的内容和变量即可,不需要双引号</span></span><br><span class="line">message(<span class="string">"PROJECT_SOURCE_DIR = ${PROJECT_SOURCE_DIR}"</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>帮助信息 </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 查看cmake默认变量		cmake --help-variable-<span class="built_in">list</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>用法：根据某个宏确定编译内容。比较字符串，相同返回true</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CPU_PLATFORM_BIT STREQUAL <span class="string">"64"</span>)</span><br><span class="line">    add_library(mylib generic_64bit.c)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    add_library(mylib generic_32bit.c)</span><br><span class="line">endif()  </span><br></pre></td></tr></tbody></table></figure>

<h2 id="编译目标"><a href="#编译目标" class="headerlink" title="编译目标"></a>编译目标</h2><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_executable(目标文件名字xxx 源文件)</span><br><span class="line"><span class="comment">//example: add_executable(${PROJECT_NAME} example_person.cpp)</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="动态-x2F-静态库"><a href="#动态-x2F-静态库" class="headerlink" title="动态 / 静态库"></a>动态 / 静态库</h3><p>将指定的源文件生成链接文件，然后添加到工程中去</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_library(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">[EXCLUDE_FROM_ALL]</span><br><span class="line">[source1] [source2] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;name&gt;表示库文件的名字，该库文件会根据命令里列出的源文件来创建。生成的库自动补全,如libxxx.so </span></span><br><span class="line"><span class="comment">//STATIC、SHARED和MODULE的作用是指定生成的库文件的类型。STATIC库是目标文件的归档文件，在链接其它目标的时候使用。SHARED库会被	动态链接（动态链接库），在运行时会被加载。MODULE库是一种不会被链接到其它目标中的插件，但是可能会在运行时使用dlopen-系列的函数	。默认状态下，库文件将会在于源文件目录树的构建目录树的位置被创建，该命令也会在这里被调用。</span></span><br><span class="line"><span class="comment">//source1 source2分别表示各个源文件</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="链接-x2F-路径"><a href="#链接-x2F-路径" class="headerlink" title="链接/路径"></a>链接/路径</h2><h3 id="头文件路径"><a href="#头文件路径" class="headerlink" title="头文件路径"></a>头文件路径</h3><p>添加头文件的查找路径, 相当于命令行的  <em><strong>-l</strong></em> 参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">include_directories(../thirdparty/comm/include)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="链接库路径"><a href="#链接库路径" class="headerlink" title="链接库路径"></a>链接库路径</h3><p>添加需要链接的库文件目录, 相当于命令行 <em><strong>-L</strong></em> 参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">link_directories(<span class="string">"/home/server/third/lib"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a>链接库</h3><p> 将目标文件与库文件进行链接</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">target_link_libraries(&lt;target&gt; [item1] [item2] [...] [[debug|optimized|general] &lt;item&gt;] ...)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//&lt;target&gt;是指通过add_executable()和add_library()指令生成已经创建的目标文件</span></span><br><span class="line"><span class="comment">//[item]表示库文件没有后缀的名字。默认情况下，库依赖项是传递的。当这个目标链接到另一个目标时，链接到这个目标的库也会出现在另一个目标的连接线上。这个传递的接口存储在interface_link_libraries的目标属性中，可以通过设置该属性直接重写传递接口。</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="安装（Install）"><a href="#安装（Install）" class="headerlink" title="安装（Install）"></a>安装（Install）</h2><ul>
<li>详情参考：<a href="https://cmake.org/cmake/help/v3.22/command/install.html">https://cmake.org/cmake/help/v3.22/command/install.html</a></li>
<li>作用：用于定义安装规则，安装内容包括可执行文件，静态库，动态库以及文件，目录，脚本等</li>
<li>使用方法：make install</li>
<li>目标安装路径：${CMAKE_INSTALL_PREFIX}指定，默认/usr/local</li>
</ul>
<h3 id="目标文件安装"><a href="#目标文件安装" class="headerlink" title="目标文件安装"></a>目标文件安装</h3><p>目标文件指的是我们通过 add_executable / add_library 得到的二进制文件或者库，只有这些文件才可以通过该命令装载到相应的位置</p>
<ul>
<li>可执行文件：RUNTIME</li>
<li>动态库：LIBRARY</li>
<li>静态库：ARCHIVE</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(TARGETS targets... [EXPORT &lt;export-name&gt;]</span><br><span class="line">        [RUNTIME_DEPENDENCIES args...|RUNTIME_DEPENDENCY_SET &lt;<span class="built_in">set</span>-name&gt;]</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|BUNDLE|</span><br><span class="line">          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]</span><br><span class="line">         [DESTINATION &lt;dir&gt;]</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">         [OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">         [NAMELINK_ONLY|NAMELINK_SKIP]</span><br><span class="line">        ] [...]</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line"><span class="comment">// example:</span></span><br><span class="line">install(TARGETS mybin mystaiclib mydynamiclib</span><br><span class="line">        RUNTIME DESTINATION bin</span><br><span class="line">        ARCHIVE DESTINATION lib</span><br><span class="line">        LIBRARY DESTINATION lib)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="普通文件安装"><a href="#普通文件安装" class="headerlink" title="普通文件安装"></a>普通文件安装</h3><p>普通文件即需要导出的头文件、依赖的三方库等等，该命令同时可以指定导出文件的权限（默认644）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(&lt;FILES|PROGRAMS&gt; files...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [PERMISSIONS permissions...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [RENAME &lt;name&gt;] [OPTIONAL] [EXCLUDE_FROM_ALL])</span><br><span class="line">        </span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">install(FILES mylib.h DESTINATION include)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="目录安装"><a href="#目录安装" class="headerlink" title="目录安装"></a>目录安装</h3><p>参数介绍：</p>
<ul>
<li>DIRECTORY：后面连接的是所在Source目录的相对路径（结尾是否是”/“对拷贝结果有一定影响）</li>
<li>PATTERN：使用正则表达式进行过滤</li>
<li>PERMISSIONS：指定PATTERN过滤后的文件权限。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(DIRECTORY dirs...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [FILE_PERMISSIONS permissions...]</span><br><span class="line">        [DIRECTORY_PERMISSIONS permissions...]</span><br><span class="line">        [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL]</span><br><span class="line">        [FILES_MATCHING]</span><br><span class="line">        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">         [EXCLUDE] [PERMISSIONS permissions...]] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">install(DIRECTORY src/ DESTINATION include/myproj  FILES_MATCHING PATTERN <span class="string">"*.h"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>Q: 编译参数添加了-lpthread 参数, 但是还是报undefined reference to `pthread_create’ </p>
<p>A : 需要使用target_link_libraries( target thread) 在这里链接thread库</p>
</li>
<li><p>Q: 如果在多级的目录下编译, 始终找不到问题报 undefine的问题 ?</p>
<p>A : 看一下是不是链接的库或目标文件格式不同, 一个c 一个c++ , 这样就会导致找不到符号错误</p>
</li>
<li><p>Q: undefined reference to `typeinfo for xxxBase_class’ ?</p>
<p>A: 基类的构造和析构函数需要加{ };  否则就会报这个问题</p>
</li>
</ol>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table>
<thead>
<tr>
<th>通配符</th>
<th>使用说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配0个或者是任意个字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td>[]</td>
<td>我们可以指定匹配的字符放在 “[]” 中</td>
</tr>
<tr>
<td>%</td>
<td>匹配任意个字符</td>
</tr>
</tbody></table>
<h2 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h2><table>
<thead>
<tr>
<th>自动化变量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>$@</td>
<td align="center">表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td>
</tr>
<tr>
<td>$%</td>
<td align="center">当目标文件是一个静态库文件时，代表静态库的一个成员名。</td>
</tr>
<tr>
<td>$&lt;</td>
<td align="center">规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td>
</tr>
<tr>
<td>$?</td>
<td align="center">所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</td>
</tr>
<tr>
<td>$^</td>
<td align="center">代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量“$”只记录它的第一次引用的情况。就是说变量“$”会去掉重复的依赖文件。</td>
</tr>
<tr>
<td>$+</td>
<td align="center">类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td>
</tr>
<tr>
<td>$*</td>
<td align="center">在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。</td>
</tr>
</tbody></table>
<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><h3 id="添加前缀"><a href="#添加前缀" class="headerlink" title="添加前缀"></a>添加前缀</h3><ul>
<li>函数名：addprefix( )</li>
<li>语法：$(addprefix PREFIX/,${NAME…})</li>
<li>函数功能：为“NAMES…”中的每一个文件名添加前缀“PREFIX”。参数“NAMES…”是空格分割的文件名序列，将“PREFIX”添加到此序列的每一个文件名之前。</li>
<li>返回值：以单空格分割的添加了前缀“PREFIX”的文件名序列。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">$(addprefix src/,foo bar)</span><br><span class="line"><span class="comment">//返回值为“src/foo src/bar”</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ul>
<li>函数名：filter( )</li>
<li>语法：$(filter SUFFIX…,$(SOURCES))</li>
<li>作用：保留字串 “ $(SOURCES)” 中所有符合模式 “ SUFFIX ” 的单词</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sources := main.c AT.txt</span><br><span class="line">foo : $(sources)</span><br><span class="line">    cc $(filter %.c,%.s,$(sources)) -o foo</span><br></pre></td></tr></tbody></table></figure>



<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p>用于Makefile的Debug，打印分为三个等级：info、warning、error</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">$(info SRC = $(SRC))</span><br><span class="line">$(warning INC = $(INC))</span><br><span class="line"><span class="comment">//注意：执行到error会直接stop退出</span></span><br><span class="line">$(error INC = $(INC))</span><br></pre></td></tr></tbody></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>Hello New World</title>
    <url>/2022/08/22/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Be all you can be!</p>
</blockquote>
<p>Hello World 是程序员进入编程世界后看到的第一道风景，我也十分乐意这作为第一篇博文的标题，对我来讲可能是：你好新世界！</p>
<p>笔者是一名嵌入式软件工程师，未来更多的内容将会是关于Linux、Android等相关内容，编程语言方面将会是以C / C++为主。做这个博客有三个目的：</p>
<ol>
<li>记录自己在工作中遇到的问题及相关解决办法。帮助自己积累调试经验同时帮助其他可能遇到同样问题的朋友，避免踩很多坑；</li>
<li>总结自己近期学到的新的知识和内容。这部分不一定是最全面的但对于处于相同阶段的我们一定是最实用的，后面再不断的完善更新；</li>
<li>最后可能就是简单的记录并安利一些实用的工具或者比较好的文章，能够以通俗的语言帮助我们理解某一个点或者看清楚某一个面。</li>
</ol>
<p>目前我只搭建了主页基础模块，后面随着文章的不断输出也会添砖加瓦的。我也希望后续能写一些读书笔记或者生活经验来做记录做分享！博客更新频率暂定1~2周至少一篇内容也一定是和工作生活相关的。如果有错误还请指正共同进步呀<span class="github-emoji" style="display:inline;vertical-align:middle"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>!</p>
<p align="right">2022-8-22/23.38</p>

<p align="right">Lee</p>

]]></content>
      <categories>
        <category>Personal</category>
      </categories>
      <tags>
        <tag>开篇</tag>
      </tags>
  </entry>
  <entry>
    <title>init.rc语法及解析</title>
    <url>/2022/11/16/init.rc/</url>
    <content><![CDATA[<p>在linux设备上输入“pstree”命令我们便会看到一棵进程树，不同状态不同设备树上进程名字进程号可能不完全一致，但进程号pid=1的进程一定是init进程！对于Android系统来讲，其实际是运行于Linux内核之上的一系列“服务进程”，而这些服务进程的“老祖宗”就是init，它是Android中第一个被启动的进程，所有服务都是通过解析init.rc文件得到的（部分可以执行程序通过init.d/文件夹下的脚本启动）</p>
<p>本篇文章将对init.rc文件语法进行解析</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>查看andriod源码：<a href="http://androidxref.com/">http://androidxref.com/</a></p>
</blockquote>
<p>init.rc是系统启动的第一个程序所加载的语法文件。init.rc文件是以“块”(section)为单位服务的，一个“块”(section)可以包含多行，而一行中包含多个tokens(符号)。“块”(section)分成两大类：一类称为”动作(action)”，另一类称为“服务(service)”。而一个init.rc脚本由四个类型的声明组成：</p>
<ol>
<li>动作 ：Actions，以关键字“on”开始</li>
<li>命令 ：Commands，以关键字“start”“restart”“stop”开始</li>
<li>服务 ：Services</li>
<li>选项 ：Options</li>
</ol>
<h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><p>Actions就是响应某个事件的过程。如下所示当满足trigger触发条件时依次执行Commands命令。源码会依次将这些命令添加到“命令执行队列尾部”，系统对这些命令顺序执行。所以服务启动的根本就是on类型的section被执行的过程</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">on &lt;trigger&gt;        //触发条件</span><br><span class="line">    &lt;command1&gt;      //命令1</span><br><span class="line">    &lt;command2&gt;      //命令2</span><br><span class="line">    &lt;command3&gt;      //命令3</span><br></pre></td></tr></tbody></table></figure>

<p>对于trigger（触发器）来讲，常见的有两种形式：</p>
<ol>
<li>单纯的字符串。例如：on boot</li>
<li>键值匹配，格式为“ on property <key> = <value> ”。例如：on property:init.svc.wifi = stopped</value></key></li>
</ol>
<p>此外还有两种形式：</p>
<ol>
<li>device-added/removed-<patch> 当设备节点添加/删除时触发此事件</patch></li>
<li>sevice-exited-<name> 当指定服务<name> 存在时触发</name></name></li>
</ol>
<h2 id="Actions解析后执行顺序"><a href="#Actions解析后执行顺序" class="headerlink" title="Actions解析后执行顺序"></a>Actions解析后执行顺序</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">on early-init           #在初始化早期阶段触发</span><br><span class="line">on init                 #初始化阶段触发。这里会执行完属性服务，接下来就可以设置属性了</span><br><span class="line">on late-init            #在初始化晚期触发。在这里会通过trigger来执行其他的action,以下均是</span><br><span class="line">on early-fs</span><br><span class="line">on fs</span><br><span class="line">on post-fs</span><br><span class="line">on post-fs-data</span><br><span class="line">on firmware_mounts_complete</span><br><span class="line">on early-boot</span><br><span class="line">on boot`</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>start <service></service></td>
<td>启动一个服务，如果它没有处于运行状态的话</td>
</tr>
<tr>
<td>stop <service></service></td>
<td>停止一个服务，如果当前它处于运行状态的话</td>
</tr>
<tr>
<td>restart <service></service></td>
<td></td>
</tr>
<tr>
<td>setprop <name> <value></value></name></td>
<td>设置<name>的属性值为<value></value></name></td>
</tr>
<tr>
<td>trigger <event></event></td>
<td>触发一个事件</td>
</tr>
<tr>
<td>export <name> <value></value></name></td>
<td>设置<name>环境变量的值为<value>，全局有效</value></name></td>
</tr>
<tr>
<td>mount <type> <device> <dir> [<mountoption>]*</mountoption></dir></device></type></td>
<td>尝试在指定路径上挂载一个设备</td>
</tr>
</tbody></table>
<h1 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h1><p>实际上每一个service就是一个可执行程序，它们在特定选项的约束下是被init程序运行或者重启(service可以在配置中指定是否需要退出重启，这样当service出现异常crash时就可以有机会复原)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">        &lt;option&gt;</span><br><span class="line">        &lt;option&gt;</span><br><span class="line">        ...</span><br><span class="line"># &lt;name&gt;       service服务的名字</span><br><span class="line"># &lt;pathname&gt;   service路径，一般对应可执行程序或者脚本</span><br><span class="line"># &lt;argument&gt;   启动pathname下的service所需要的参数</span><br><span class="line"># &lt;option&gt;     service的约束项</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h1><table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>disable</td>
<td>隐式声明，默认不会自动启动该服务，需要显式调用</td>
</tr>
<tr>
<td>oneshot</td>
<td>字面意思一次性，即服务退出时，不要主动重启该服务</td>
</tr>
<tr>
<td>onrestart</td>
<td>当服务重启时，执行某些命令（需要理解）</td>
</tr>
<tr>
<td>class <name></name></td>
<td>指定该服务属于<name>class类，默认class名为default（注：同一个class所有服务必须是同时启动或停止）</name></td>
</tr>
<tr>
<td>socket <name> <type> <perm> [<user> [<group>] ]</group></user></perm></type></name></td>
<td>创建一个名为dev/socket/<name>的 socket，然后将它的fd值传给启动它的进，有效的<type>值包括dgram,stream 和seqpacket。ueser 和group 的默认值为0。</type></name></td>
</tr>
<tr>
<td>critical</td>
<td>表明这是对设备至关重要的服务；如果它在四分钟内退出超过四次，则设备将进入Recovery 模式</td>
</tr>
<tr>
<td>group <groupname> [<groupname>]*</groupname></groupname></td>
<td>在启动服务前将用户组切换至<groupname></groupname></td>
</tr>
<tr>
<td>setenv <name> <value></value></name></td>
<td>设置环境变量<name> 为值<value></value></name></td>
</tr>
</tbody></table>
<h1 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h1><ol>
<li>service和Actions都是有唯一的名字的。如果有重名的情况会作为错误忽略。</li>
<li>无论是动作还是服务，并不是按照文件的编排顺序执行的。</li>
<li>该文件中注释以“#”开始；反斜杠“\”在行尾表示下面一行是同一行</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * copy from http://androidxref.com/6.0.0_r5/xref/bootable/recovery/etc/init.rc</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import /init.recovery.${ro.hardware}.rc</span><br><span class="line"></span><br><span class="line">on early-init</span><br><span class="line">    start ueventd</span><br><span class="line">    start healthd</span><br><span class="line"></span><br><span class="line">on init</span><br><span class="line">    export PATH /sbin:/system/bin</span><br><span class="line">    export ANDROID_ROOT /system</span><br><span class="line">    export ANDROID_DATA /data</span><br><span class="line">    export EXTERNAL_STORAGE /sdcard</span><br><span class="line"></span><br><span class="line">    symlink /system/etc /etc</span><br><span class="line"></span><br><span class="line">    mkdir /sdcard</span><br><span class="line">    mkdir /system</span><br><span class="line">    mkdir /data</span><br><span class="line">    mkdir /cache</span><br><span class="line">    mkdir /sideload</span><br><span class="line">    mount tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line">    chown root shell /tmp</span><br><span class="line">    chmod 0775 /tmp</span><br><span class="line"></span><br><span class="line">    write /proc/sys/kernel/panic_on_oops 1</span><br><span class="line">    write /proc/sys/vm/max_map_count 1000000</span><br><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    mkdir /dev/usb-ffs 0770 shell shell</span><br><span class="line">    mkdir /dev/usb-ffs/adb 0770 shell shell</span><br><span class="line">    mount functionfs adb /dev/usb-ffs/adb uid=2000,gid=2000</span><br><span class="line"></span><br><span class="line">    write /sys/class/android_usb/android0/enable 0</span><br><span class="line">    write /sys/class/android_usb/android0/idVendor 18D1</span><br><span class="line">    write /sys/class/android_usb/android0/idProduct D001</span><br><span class="line">    write /sys/class/android_usb/android0/f_ffs/aliases adb</span><br><span class="line">    write /sys/class/android_usb/android0/functions adb</span><br><span class="line">    write /sys/class/android_usb/android0/iManufacturer ${ro.product.manufacturer}</span><br><span class="line">    write /sys/class/android_usb/android0/iProduct ${ro.product.model}</span><br><span class="line">    write /sys/class/android_usb/android0/iSerial ${ro.serialno}</span><br><span class="line"></span><br><span class="line">on boot</span><br><span class="line">    ifup lo</span><br><span class="line">    hostname localhost</span><br><span class="line">    domainname localdomain</span><br><span class="line"></span><br><span class="line">    class_start default</span><br><span class="line"></span><br><span class="line"># Load properties from /system/ + /factory after fs mount.</span><br><span class="line">on load_all_props_action</span><br><span class="line">    load_all_props</span><br><span class="line"></span><br><span class="line">on firmware_mounts_complete</span><br><span class="line">   rm /dev/.booting</span><br><span class="line"></span><br><span class="line"># Mount filesystems and start core system services.</span><br><span class="line">on late-init</span><br><span class="line">    trigger early-fs</span><br><span class="line">    trigger fs</span><br><span class="line">    trigger post-fs</span><br><span class="line">    trigger post-fs-data</span><br><span class="line"></span><br><span class="line">    # Load properties from /system/ + /factory after fs mount. Place</span><br><span class="line">    # this in another action so that the load will be scheduled after the prior</span><br><span class="line">    # issued fs triggers have completed.</span><br><span class="line">    trigger load_all_props_action</span><br><span class="line"></span><br><span class="line">    # Remove a file to wake up anything waiting for firmware</span><br><span class="line">    trigger firmware_mounts_complete</span><br><span class="line"></span><br><span class="line">    trigger early-boot</span><br><span class="line">    trigger boot</span><br><span class="line"></span><br><span class="line">on property:sys.powerctl=*</span><br><span class="line">   powerctl ${sys.powerctl}</span><br><span class="line"></span><br><span class="line">service ueventd /sbin/ueventd</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:ueventd:s0</span><br><span class="line"></span><br><span class="line">service healthd /sbin/healthd -r</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:healthd:s0</span><br><span class="line"></span><br><span class="line">service recovery /sbin/recovery</span><br><span class="line">    seclabel u:r:recovery:s0</span><br><span class="line"></span><br><span class="line">service adbd /sbin/adbd --root_seclabel=u:r:su:s0 --device_banner=recovery</span><br><span class="line">    disabled</span><br><span class="line">    socket adbd stream 660 system system</span><br><span class="line">    seclabel u:r:adbd:s0</span><br><span class="line"></span><br><span class="line"># Always start adbd on userdebug and eng builds</span><br><span class="line">on property:ro.debuggable=1</span><br><span class="line">    write /sys/class/android_usb/android0/enable 1</span><br><span class="line">    start adbd</span><br><span class="line"></span><br><span class="line"># Restart adbd so it can run as root</span><br><span class="line">on property:service.adb.root=1</span><br><span class="line">    write /sys/class/android_usb/android0/enable 0</span><br><span class="line">    restart adbd</span><br><span class="line">    write /sys/class/android_usb/android0/enable 1</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>Andriod</category>
      </categories>
  </entry>
  <entry>
    <title>搭建Ubuntu虚拟机</title>
    <url>/2022/10/22/ubuntu-create/</url>
    <content><![CDATA[<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><p>linus自传《只是为了好玩》中这样定义：</p>
<ul>
<li><p>类Unix操作系统</p>
</li>
<li><p>开放源代码方式协作开发</p>
</li>
<li><p>采用GPL通用许可证维权</p>
</li>
<li><p>主要用于超级电脑、企业级服务器、嵌入式设备等</p>
</li>
</ul>
<h1 id="Ubuntu-简介"><a href="#Ubuntu-简介" class="headerlink" title="Ubuntu 简介"></a>Ubuntu 简介</h1><ul>
<li>桌面应用为主的Linux操作系统</li>
<li>操作简单、方便使用</li>
<li>系统安全性高，默认user权限登录</li>
<li>Ubuntu中文网站：<a href="http://www.wubantu.co/">http://www.wubantu.co</a></li>
<li>Ubuntu中文社区：<a href="http://www.ubuntu.org.cn/">http://www.ubuntu.org.cn</a></li>
<li>Ubuntu技术：<a href="http://wiki.ubuntu.org.cn/">http://wiki.ubuntu.org.cn</a></li>
</ul>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul>
<li>物理主机</li>
<li>iso镜像</li>
<li>vmware / VirtualBox</li>
</ul>
<p>网盘中我准备了ubuntu20.04.4-iso、ubuntu16.04.7-iso、Vmware-16.2.3安装包及密钥和一份linux命令大全！</p>
<p>密钥对于不同版本可能有差异可以都进行尝试，其只是对于个人学习使用，建议购买正版！</p>
<p>同时附上相关官网链接：</p>
<ul>
<li>ubuntu各版本镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/</a></li>
<li>vmware官网：<a href="https://www.vmware.com/cn/products/workstation-pro.html">https://www.vmware.com/cn/products/workstation-pro.html</a></li>
<li>VirtualBox：<a href="https://www.virtualbox.org/">https://www.virtualbox.org</a></li>
<li>资源网盘链接：<a href="https://pan.baidu.com/s/18vxScuvFp2Vf4g28nRSC5w">https://pan.baidu.com/s/18vxScuvFp2Vf4g28nRSC5w</a><br>提取码：f8uo</li>
</ul>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>参考视频：<a href="https://www.bilibili.com/video/BV1hd4y127HY">https://www.bilibili.com/video/BV1hd4y127HY</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>搭建虚拟机</category>
      </categories>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>理解c/c++ Volatile关键字</title>
    <url>/2022/11/15/Volatile/</url>
    <content><![CDATA[<p>网络上对于volatile的解读众说纷纭，而且其中较多的是java内存模型。</p>
<p>本篇文章将基于自己的学习和实验，针对C/C++语言嵌入式开发场景进行volatile关键字的分析</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>volatile 关键字是 C /C++ 编程语言的一部分，作为一种类型修饰符。我将其作用总结为<em><strong>告诉编译器禁止优化其所修饰对象的读写访存操作及指令顺序，保证变量的可见性</strong></em></p>
<blockquote>
<p>可见性：当一个线程修改了共享变量后，其他线程能够立即得知这个修改。</p>
<p>有序性：程序执行的顺序按照代码的先后顺序执行。</p>
<p>原子性：一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行。</p>
</blockquote>
<p>在《程序员的自我修养》这本书中讲到，volatile基本可以做到两个事情：</p>
<ol>
<li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回</li>
<li>阻止编译器调整操作volatile变量的指令顺序</li>
</ol>
<p>对于第一个作用volatile是可以很好的做到，而对于第二个作用编译器层面可以保证指令有序但是我们无法阻止cpu动态调整顺序。真正保证有序性是需要通过内存屏障完成的，而volatile并没有内存屏障的功能，gcc 提供了一个内联函数 <em><strong>asm volatile (“” : : : “memory”</strong>)</em> 编译器屏障，具体平台相关内存屏障需要到具体的结构平台去参考</p>
<h1 id="理解volatile"><a href="#理解volatile" class="headerlink" title="理解volatile"></a>理解volatile</h1><blockquote>
<p>Collins对于Volatile释义：A situation that is volatile is <strong>likely</strong> to change <strong>suddenly</strong> and <strong>unexpectedly</strong>.</p>
</blockquote>
<p><strong>volatile</strong> 本身释义为 <strong>易失的、易变的</strong></p>
<p>对于用volatile所修饰的对象，在其自身的含义基础上，有三个副词可以很好的对其性质进行诠释：</p>
<ul>
<li><p>likely   可能地，指对象的状态可能变化、也可能不变保持状态，强调结果；</p>
</li>
<li><p>suddenly:   突然地，指对象状态的瞬时变化，强调过程；</p>
</li>
<li><p>unexpectedly:  不可预期地，指对象变化的时间结果都不可预期；</p>
</li>
</ul>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>根据含义性质，在嵌入式开发中以下三种场景是一定要考虑使用volatile关键字的（大多数情况一定使用！！！）</p>
<ol>
<li>多线程任务读写同一全局变量，</li>
<li>中断服务程序修改的全局变量</li>
<li>内存映射外设寄存器</li>
</ol>
<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h2 id="中断场景"><a href="#中断场景" class="headerlink" title="中断场景"></a>中断场景</h2><p>下面一段代码，我们所期待的结果是主程序运行，直到crtl+c按键按下程序退出，代码编译执行之后并不是我们所预期的样子。如果sig_done变量不通过volatile修饰程序将永远不会退出，而volatile关键字很好的解决了这一个问题</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> sig_done = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//static volatile bool sig_done = false;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(sig == SIGINT)</span><br><span class="line">    ┆   sig_done = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main start, press ctrl+c go on\n"</span>);</span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line">    <span class="keyword">while</span>(!sig_done) {</span><br><span class="line">    }   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main exit\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令</span></span><br><span class="line">gcc main.c <span class="number">-02</span></span><br><span class="line">objdump -d a.out &gt; a.s</span><br></pre></td></tr></tbody></table></figure>

<p>通过反汇编比较两个程序的异同（左侧volatile，右侧无volatile）</p>
<p><img src="/images/coding/meld.png" alt="image"></p>
<p>没有voaltile的while实现方式为：</p>
<ol>
<li>比较rip寄存器+0x2f65地址处的值（sig_done）与 0 是否相等</li>
<li>不相等跳转到main+0x30即上一条指令处</li>
<li>跳转</li>
</ol>
<p>有volatile的while实现方式：</p>
<ol>
<li><p>nopl (%rax) 编译器开启优化后使指令按字对齐,减少取指令的时钟周期。</p>
</li>
<li><p>将 rip寄存器+0x2f65地址处的值放到eax寄存器中</p>
<blockquote>
<p>movzbl指令负责拷贝一个字节，并用0填充其目的操作数中的其余各位，这种扩展方式叫“零扩展”。</p>
<p>movsbl指令负责拷贝一个字节，并用源操作数的最高位填充其目的操作数中的其余各位，这种扩展方式叫“符号扩展”。</p>
</blockquote>
</li>
<li><p>test   %al,%al 对eax寄存器低位逻辑与</p>
<blockquote>
<p>Test命令：将两个操作数进行逻辑与运算，并根据运算结果设置相关的标志位（ze: zero flag）。但是，Test命令的两个操作数不会被改变。运算结果在设置过相关标记位后会被丢弃。</p>
</blockquote>
</li>
<li><p>je   如果ZF（零标志位）=1，零标志位为1（真值）说明结果为0，则转到label所指的指令语句；否则跳过这条语句，执行下条语句</p>
</li>
</ol>
<h2 id="多线程场景"><a href="#多线程场景" class="headerlink" title="多线程场景"></a>多线程场景</h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> mstop = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//static volatile bool mstop = true;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">first_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s start\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">while</span>(mstop) {</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s exit\n"</span>, __func__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">second_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s start\n"</span>, __func__);</span><br><span class="line">    mstop = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s exit\n"</span>, __func__);</span><br><span class="line">}                                                                                                                                                                     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::thread fthread{first_thread};</span><br><span class="line">    std::thread sthread{second_thread};</span><br><span class="line">    fthread.<span class="built_in">join</span>();</span><br><span class="line">	sthread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="外设寄存器"><a href="#外设寄存器" class="headerlink" title="外设寄存器"></a>外设寄存器</h2><p>对于外设通常设置有状态寄存器，我们可以通过循环读取状态寄存器的值来查看对应外设的状态。对于如下示例，如果没有使用volatile关键字，编译器可能生成的代码是读取一个固定地址的值而不会每次都从主存中读取新的值（或者读取n次状态，生成的代码只读取了一次，然后使用n次相同的值）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//设置寄存器</span></span><br><span class="line">*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *) STATUS_BASE_ADDR = <span class="number">1</span> &lt;&lt; <span class="number">24</span>; </span><br><span class="line"><span class="comment">//读寄存器</span></span><br><span class="line"><span class="keyword">while</span>(!(*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *) STATUS_BASE_ADDR)) {</span><br><span class="line">    <span class="comment">// do action</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h1><p>该部分不是volatile的使用，而是对内屏屏障的理解</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mp3decoder.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mp3decoder</span> :</span> public decoderImp </span><br><span class="line">{</span><br><span class="line">    public:</span><br><span class="line">    	<span class="type">static</span> mp3decoder* <span class="title function_">getInstance</span><span class="params">()</span>;</span><br><span class="line">    private:</span><br><span class="line">    	mp3decoder();</span><br><span class="line">    	~mp3decoder();</span><br><span class="line">    	<span class="type">static</span> mp3decoder* mdecoder;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//mp3decoder.cpp</span></span><br><span class="line"><span class="comment">//线程不安全，适用于单线程</span></span><br><span class="line">mp3decoder* mp3decoder::mdecoder = <span class="literal">NULL</span>;</span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全，但锁的代价太高</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全，锁的代价太高</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">    unlock();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Double-Checked Locking Pattern (DCLP 双检查锁)，指令重排序reorder不安全</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">        lock();</span><br><span class="line">    	<span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">       		mdecoder = new mp3decoder();</span><br><span class="line">         unlock();</span><br><span class="line">    	<span class="keyword">return</span> mdecoder;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存屏障</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">    	<span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">            mp3decoder *tmp = new mp3decoder();</span><br><span class="line">            MemoryBarrier();</span><br><span class="line">            mdecoder = tmp;</span><br><span class="line">        }</span><br><span class="line">    	<span class="keyword">return</span> mdecoder;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// mdecoder = new mp3decoder()在cpu层面动作：</span></span><br><span class="line"><span class="comment">// 1. 分配内存</span></span><br><span class="line"><span class="comment">// 2. 调用构造函数</span></span><br><span class="line"><span class="comment">// 3. 将内存地址赋值给mdecoder指针</span></span><br><span class="line"><span class="comment">// 由于2、3对于编译器来讲是有可能进行优化的，即先将指针赋值再调用构造函数，导致线程不安全！！</span></span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>参考文章：</p>
<ul>
<li><a href="https://barrgroup.com/embedded-systems/how-to/c-volatile-keyword">How to Use C’s volatile Keyword</a></li>
<li><a href="https://barrgroup.com/tech-talks/volatile-c">Pro Tips for Using C’s volatile Keyword</a></li>
<li><a href="https://liam.page/2018/01/18/volatile-in-C-and-Cpp/">谈谈 c / c++ 中的volatile</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello New World</title>
    <url>/2022/08/22/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Be all you can be!</p>
</blockquote>
<p>Hello World 是程序员进入编程世界后看到的第一道风景，我也十分乐意这作为第一篇博文的标题，对我来讲可能是：你好新世界！</p>
<p>笔者是一名嵌入式软件工程师，未来更多的内容将会是关于Linux、Android等相关内容，编程语言方面将会是以C / C++为主。做这个博客有三个目的：</p>
<ol>
<li>记录自己在工作中遇到的问题及相关解决办法。帮助自己积累调试经验同时帮助其他可能遇到同样问题的朋友，避免踩很多坑；</li>
<li>总结自己近期学到的新的知识和内容。这部分不一定是最全面的但对于处于相同阶段的我们一定是最实用的，后面再不断的完善更新；</li>
<li>最后可能就是简单的记录并安利一些实用的工具或者比较好的文章，能够以通俗的语言帮助我们理解某一个点或者看清楚某一个面。</li>
</ol>
<p>目前我只搭建了主页基础模块，后面随着文章的不断输出也会添砖加瓦的。我也希望后续能写一些读书笔记或者生活经验来做记录做分享！博客更新频率暂定1~2周至少一篇内容也一定是和工作生活相关的。如果有错误还请指正共同进步呀<span class="github-emoji" style="display:inline;vertical-align:middle"><span>😃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>!</p>
<p align="right">2022-8-22/23.38</p>

<p align="right">Lee</p>

]]></content>
      <categories>
        <category>Personal</category>
      </categories>
      <tags>
        <tag>开篇</tag>
      </tags>
  </entry>
  <entry>
    <title>init.rc语法及解析</title>
    <url>/2022/11/16/init.rc/</url>
    <content><![CDATA[<p>在linux设备上输入“pstree”命令我们便会看到一棵进程树，不同状态不同设备树上进程名字进程号可能不完全一致，但进程号pid=1的进程一定是init进程！对于Android系统来讲，其实际是运行于Linux内核之上的一系列“服务进程”，而这些服务进程的“老祖宗”就是init，它是Android中第一个被启动的进程，所有服务都是通过解析init.rc文件得到的（部分可以执行程序通过init.d/文件夹下的脚本启动）</p>
<p>本篇文章将对init.rc文件语法进行解析</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>查看andriod源码：<a href="http://androidxref.com/">http://androidxref.com/</a></p>
</blockquote>
<p>init.rc是系统启动的第一个程序所加载的语法文件。init.rc文件是以“块”(section)为单位服务的，一个“块”(section)可以包含多行，而一行中包含多个tokens(符号)。“块”(section)分成两大类：一类称为”动作(action)”，另一类称为“服务(service)”。而一个init.rc脚本由四个类型的声明组成：</p>
<ol>
<li>动作 ：Actions，以关键字“on”开始</li>
<li>命令 ：Commands，以关键字“start”“restart”“stop”开始</li>
<li>服务 ：Services</li>
<li>选项 ：Options</li>
</ol>
<h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><p>Actions就是响应某个事件的过程。如下所示当满足trigger触发条件时依次执行Commands命令。源码会依次将这些命令添加到“命令执行队列尾部”，系统对这些命令顺序执行。所以服务启动的根本就是on类型的section被执行的过程</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">on &lt;trigger&gt;        //触发条件</span><br><span class="line">    &lt;command1&gt;      //命令1</span><br><span class="line">    &lt;command2&gt;      //命令2</span><br><span class="line">    &lt;command3&gt;      //命令3</span><br></pre></td></tr></tbody></table></figure>

<p>对于trigger（触发器）来讲，常见的有两种形式：</p>
<ol>
<li>单纯的字符串。例如：on boot</li>
<li>键值匹配，格式为“ on property <key> = <value> ”。例如：on property:init.svc.wifi = stopped</value></key></li>
</ol>
<p>此外还有两种形式：</p>
<ol>
<li>device-added/removed-<patch> 当设备节点添加/删除时触发此事件</patch></li>
<li>sevice-exited-<name> 当指定服务<name> 存在时触发</name></name></li>
</ol>
<h2 id="Actions解析后执行顺序"><a href="#Actions解析后执行顺序" class="headerlink" title="Actions解析后执行顺序"></a>Actions解析后执行顺序</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">on early-init           #在初始化早期阶段触发</span><br><span class="line">on init                 #初始化阶段触发。这里会执行完属性服务，接下来就可以设置属性了</span><br><span class="line">on late-init            #在初始化晚期触发。在这里会通过trigger来执行其他的action,以下均是</span><br><span class="line">on early-fs</span><br><span class="line">on fs</span><br><span class="line">on post-fs</span><br><span class="line">on post-fs-data</span><br><span class="line">on firmware_mounts_complete</span><br><span class="line">on early-boot</span><br><span class="line">on boot`</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>start <service></service></td>
<td>启动一个服务，如果它没有处于运行状态的话</td>
</tr>
<tr>
<td>stop <service></service></td>
<td>停止一个服务，如果当前它处于运行状态的话</td>
</tr>
<tr>
<td>restart <service></service></td>
<td></td>
</tr>
<tr>
<td>setprop <name> <value></value></name></td>
<td>设置<name>的属性值为<value></value></name></td>
</tr>
<tr>
<td>trigger <event></event></td>
<td>触发一个事件</td>
</tr>
<tr>
<td>export <name> <value></value></name></td>
<td>设置<name>环境变量的值为<value>，全局有效</value></name></td>
</tr>
<tr>
<td>mount <type> <device> <dir> [<mountoption>]*</mountoption></dir></device></type></td>
<td>尝试在指定路径上挂载一个设备</td>
</tr>
</tbody></table>
<h1 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h1><p>实际上每一个service就是一个可执行程序，它们在特定选项的约束下是被init程序运行或者重启(service可以在配置中指定是否需要退出重启，这样当service出现异常crash时就可以有机会复原)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">        &lt;option&gt;</span><br><span class="line">        &lt;option&gt;</span><br><span class="line">        ...</span><br><span class="line"># &lt;name&gt;       service服务的名字</span><br><span class="line"># &lt;pathname&gt;   service路径，一般对应可执行程序或者脚本</span><br><span class="line"># &lt;argument&gt;   启动pathname下的service所需要的参数</span><br><span class="line"># &lt;option&gt;     service的约束项</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h1><table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>disable</td>
<td>隐式声明，默认不会自动启动该服务，需要显式调用</td>
</tr>
<tr>
<td>oneshot</td>
<td>字面意思一次性，即服务退出时，不要主动重启该服务</td>
</tr>
<tr>
<td>onrestart</td>
<td>当服务重启时，执行某些命令（需要理解）</td>
</tr>
<tr>
<td>class <name></name></td>
<td>指定该服务属于<name>class类，默认class名为default（注：同一个class所有服务必须是同时启动或停止）</name></td>
</tr>
<tr>
<td>socket <name> <type> <perm> [<user> [<group>] ]</group></user></perm></type></name></td>
<td>创建一个名为dev/socket/<name>的 socket，然后将它的fd值传给启动它的进，有效的<type>值包括dgram,stream 和seqpacket。ueser 和group 的默认值为0。</type></name></td>
</tr>
<tr>
<td>critical</td>
<td>表明这是对设备至关重要的服务；如果它在四分钟内退出超过四次，则设备将进入Recovery 模式</td>
</tr>
<tr>
<td>group <groupname> [<groupname>]*</groupname></groupname></td>
<td>在启动服务前将用户组切换至<groupname></groupname></td>
</tr>
<tr>
<td>setenv <name> <value></value></name></td>
<td>设置环境变量<name> 为值<value></value></name></td>
</tr>
</tbody></table>
<h1 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h1><ol>
<li>service和Actions都是有唯一的名字的。如果有重名的情况会作为错误忽略。</li>
<li>无论是动作还是服务，并不是按照文件的编排顺序执行的。</li>
<li>该文件中注释以“#”开始；反斜杠“\”在行尾表示下面一行是同一行</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * copy from http://androidxref.com/6.0.0_r5/xref/bootable/recovery/etc/init.rc</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import /init.recovery.${ro.hardware}.rc</span><br><span class="line"></span><br><span class="line">on early-init</span><br><span class="line">    start ueventd</span><br><span class="line">    start healthd</span><br><span class="line"></span><br><span class="line">on init</span><br><span class="line">    export PATH /sbin:/system/bin</span><br><span class="line">    export ANDROID_ROOT /system</span><br><span class="line">    export ANDROID_DATA /data</span><br><span class="line">    export EXTERNAL_STORAGE /sdcard</span><br><span class="line"></span><br><span class="line">    symlink /system/etc /etc</span><br><span class="line"></span><br><span class="line">    mkdir /sdcard</span><br><span class="line">    mkdir /system</span><br><span class="line">    mkdir /data</span><br><span class="line">    mkdir /cache</span><br><span class="line">    mkdir /sideload</span><br><span class="line">    mount tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line">    chown root shell /tmp</span><br><span class="line">    chmod 0775 /tmp</span><br><span class="line"></span><br><span class="line">    write /proc/sys/kernel/panic_on_oops 1</span><br><span class="line">    write /proc/sys/vm/max_map_count 1000000</span><br><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    mkdir /dev/usb-ffs 0770 shell shell</span><br><span class="line">    mkdir /dev/usb-ffs/adb 0770 shell shell</span><br><span class="line">    mount functionfs adb /dev/usb-ffs/adb uid=2000,gid=2000</span><br><span class="line"></span><br><span class="line">    write /sys/class/android_usb/android0/enable 0</span><br><span class="line">    write /sys/class/android_usb/android0/idVendor 18D1</span><br><span class="line">    write /sys/class/android_usb/android0/idProduct D001</span><br><span class="line">    write /sys/class/android_usb/android0/f_ffs/aliases adb</span><br><span class="line">    write /sys/class/android_usb/android0/functions adb</span><br><span class="line">    write /sys/class/android_usb/android0/iManufacturer ${ro.product.manufacturer}</span><br><span class="line">    write /sys/class/android_usb/android0/iProduct ${ro.product.model}</span><br><span class="line">    write /sys/class/android_usb/android0/iSerial ${ro.serialno}</span><br><span class="line"></span><br><span class="line">on boot</span><br><span class="line">    ifup lo</span><br><span class="line">    hostname localhost</span><br><span class="line">    domainname localdomain</span><br><span class="line"></span><br><span class="line">    class_start default</span><br><span class="line"></span><br><span class="line"># Load properties from /system/ + /factory after fs mount.</span><br><span class="line">on load_all_props_action</span><br><span class="line">    load_all_props</span><br><span class="line"></span><br><span class="line">on firmware_mounts_complete</span><br><span class="line">   rm /dev/.booting</span><br><span class="line"></span><br><span class="line"># Mount filesystems and start core system services.</span><br><span class="line">on late-init</span><br><span class="line">    trigger early-fs</span><br><span class="line">    trigger fs</span><br><span class="line">    trigger post-fs</span><br><span class="line">    trigger post-fs-data</span><br><span class="line"></span><br><span class="line">    # Load properties from /system/ + /factory after fs mount. Place</span><br><span class="line">    # this in another action so that the load will be scheduled after the prior</span><br><span class="line">    # issued fs triggers have completed.</span><br><span class="line">    trigger load_all_props_action</span><br><span class="line"></span><br><span class="line">    # Remove a file to wake up anything waiting for firmware</span><br><span class="line">    trigger firmware_mounts_complete</span><br><span class="line"></span><br><span class="line">    trigger early-boot</span><br><span class="line">    trigger boot</span><br><span class="line"></span><br><span class="line">on property:sys.powerctl=*</span><br><span class="line">   powerctl ${sys.powerctl}</span><br><span class="line"></span><br><span class="line">service ueventd /sbin/ueventd</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:ueventd:s0</span><br><span class="line"></span><br><span class="line">service healthd /sbin/healthd -r</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:healthd:s0</span><br><span class="line"></span><br><span class="line">service recovery /sbin/recovery</span><br><span class="line">    seclabel u:r:recovery:s0</span><br><span class="line"></span><br><span class="line">service adbd /sbin/adbd --root_seclabel=u:r:su:s0 --device_banner=recovery</span><br><span class="line">    disabled</span><br><span class="line">    socket adbd stream 660 system system</span><br><span class="line">    seclabel u:r:adbd:s0</span><br><span class="line"></span><br><span class="line"># Always start adbd on userdebug and eng builds</span><br><span class="line">on property:ro.debuggable=1</span><br><span class="line">    write /sys/class/android_usb/android0/enable 1</span><br><span class="line">    start adbd</span><br><span class="line"></span><br><span class="line"># Restart adbd so it can run as root</span><br><span class="line">on property:service.adb.root=1</span><br><span class="line">    write /sys/class/android_usb/android0/enable 0</span><br><span class="line">    restart adbd</span><br><span class="line">    write /sys/class/android_usb/android0/enable 1</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>Andriod</category>
      </categories>
  </entry>
  <entry>
    <title>搭建Ubuntu虚拟机</title>
    <url>/2022/10/22/ubuntu-create/</url>
    <content><![CDATA[<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><p>linus自传《只是为了好玩》中这样定义：</p>
<ul>
<li><p>类Unix操作系统</p>
</li>
<li><p>开放源代码方式协作开发</p>
</li>
<li><p>采用GPL通用许可证维权</p>
</li>
<li><p>主要用于超级电脑、企业级服务器、嵌入式设备等</p>
</li>
</ul>
<h1 id="Ubuntu-简介"><a href="#Ubuntu-简介" class="headerlink" title="Ubuntu 简介"></a>Ubuntu 简介</h1><ul>
<li>桌面应用为主的Linux操作系统</li>
<li>操作简单、方便使用</li>
<li>系统安全性高，默认user权限登录</li>
<li>Ubuntu中文网站：<a href="http://www.wubantu.co/">http://www.wubantu.co</a></li>
<li>Ubuntu中文社区：<a href="http://www.ubuntu.org.cn/">http://www.ubuntu.org.cn</a></li>
<li>Ubuntu技术：<a href="http://wiki.ubuntu.org.cn/">http://wiki.ubuntu.org.cn</a></li>
</ul>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul>
<li>物理主机</li>
<li>iso镜像</li>
<li>vmware / VirtualBox</li>
</ul>
<p>网盘中我准备了ubuntu20.04.4-iso、ubuntu16.04.7-iso、Vmware-16.2.3安装包及密钥和一份linux命令大全！</p>
<p>密钥对于不同版本可能有差异可以都进行尝试，其只是对于个人学习使用，建议购买正版！</p>
<p>同时附上相关官网链接：</p>
<ul>
<li>ubuntu各版本镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/</a></li>
<li>vmware官网：<a href="https://www.vmware.com/cn/products/workstation-pro.html">https://www.vmware.com/cn/products/workstation-pro.html</a></li>
<li>VirtualBox：<a href="https://www.virtualbox.org/">https://www.virtualbox.org</a></li>
<li>资源网盘链接：<a href="https://pan.baidu.com/s/18vxScuvFp2Vf4g28nRSC5w">https://pan.baidu.com/s/18vxScuvFp2Vf4g28nRSC5w</a><br>提取码：f8uo</li>
</ul>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>参考视频：<a href="https://www.bilibili.com/video/BV1hd4y127HY">https://www.bilibili.com/video/BV1hd4y127HY</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>搭建虚拟机</category>
      </categories>
  </entry>
  <entry>
    <title>《Google工作法》</title>
    <url>/2023/02/06/Reading/Google%E5%B7%A5%E4%BD%9C%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/images/reading/GoogleWork.jpg" alt="img"></p>
<p>《google工作法》作者是彼得·费利克斯·格日瓦奇，针对google的一些工作方法论和个人经验的进行著书。我认为对于这类书籍的正确使用是通读全篇，二次阅读针对部分内容自己进行场景的带入，此类工具书籍可以经常来进行翻看对自己日常生活工作方式的判断</p>
<p>针对每个细分章节，总结并进行自己的思考</p>
<h1 id="Faster（※）"><a href="#Faster（※）" class="headerlink" title="Faster（※）"></a>Faster（※）</h1><h2 id="一次结束，当场做完"><a href="#一次结束，当场做完" class="headerlink" title="一次结束，当场做完"></a>一次结束，当场做完</h2><p>作者认为决定工作效率的关键在于对 现在 的使用方法。对于一件事情如果能够当场做完就不要推迟到以后，对于一项决定如果当场确定就不要推迟到未来。如果当时没有进行就解决或决定就需要做出相应的计划：要想解决这个问题，需要收集哪些必要的资源。具体策略如下：</p>
<p><img src="/images/reading/google-0.jpg" alt="img"></p>
<p>对自己来讲，我曾经负责某个项目，客户在问我一个技术相关的问题的时候，我当时的做法可能就没有很恰当。现在来看我认为正确的流程应该是：将我自己已知的内容对客户进行反馈；将自己不知道的内容如实告诉客户并询问他目前是否有空我去找一下相关负责人来解答他这个问题（<strong>如果现在有必要的话，现在就联系；如果现在应该决定的话，现在就决定</strong>），如果中途遇到其它问题不知道谁是负责人或者负责人不在，也必须做到相关解决方案做到有切实进展（活用身边的人/回来之后第一时间反馈等等），在第一时间内将问题进行解决，不拖延！！！</p>
<h2 id="设置deadline"><a href="#设置deadline" class="headerlink" title="设置deadline"></a>设置deadline</h2><p>能当场解决的问题一定要一次解决，而不能解决的问题一定要设置deadline，要有一种 如果现在不做那要什么时候做 的观念。对于纷杂的工作需要明确优先级、精细程度等因素。将自己的期限提前是提高效率的有效方法。</p>
<p>对于自己来讲，如果领导要求一项工作周五之前完成。那自己的deadline要设置在周三周四做好一个demo给领导查看。在工作进行之前需要明确事情的紧急程度、完成验收的标准、是否有其它注意事项等等</p>
<h2 id="集中精力于此时此刻"><a href="#集中精力于此时此刻" class="headerlink" title="集中精力于此时此刻"></a>集中精力于此时此刻</h2><p>正念（Mindfulness）的意思就是将意识集中于此时此刻，这一词同样被谷歌所采用。大脑就像是一个CPU应尽可能的减少大脑资源的浪费，对于任何一件事情尽可能要提前做准备。比如：前一天晚上就准备好第二天需要穿的衣服；会议前梳理会议的目的成员组织等等；任何一件事情可能发生的后果及相应的解决办法</p>
<p>分析眼前任务的正确方式：搞清楚”为什么需要解决这个问题“，”在什么时间之前必须得出答案“，设定好”目的与目标“之后全力以赴。比如会议之前的准备列表：</p>
<ul>
<li>为什么将大家召集到一起</li>
<li>要做出什么决定</li>
<li>要取得什么成果</li>
<li>通过会议后要得到什么收获</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li><p>增加现在的密度</p>
<p>针对自己来讲可以体现在：通勤路上进行书籍的阅读英语的学习等等，并行一些任务</p>
</li>
<li><p>减少邮件的使用，直接见面最有效率</p>
</li>
<li><p>合理使用工具</p>
<p>时间/时间管理工具（对于notion的使用没有持续）；整理的文档传至云端，随时查看修改</p>
</li>
<li><p>学习英语</p>
<p>目前很多第一手资料都是英文的，为了提高效率必须学会英文。否则内容的准确性排除在外，也是时间和成本的二次浪费</p>
</li>
</ol>
<h1 id="Sense-VS-sensibility"><a href="#Sense-VS-sensibility" class="headerlink" title="Sense VS sensibility"></a>Sense VS sensibility</h1><h2 id="创意思维的产生"><a href="#创意思维的产生" class="headerlink" title="创意思维的产生"></a>创意思维的产生</h2><p>与逻辑和分析相比“ 灵感（创意思维） ”更重要</p>
<p>通过人为地制造混乱，可以使潜意识活性化，从而更容易创造出新的创意。具体方案：准备几个透明文件袋，将各种图片、杂志、报纸剪下来的内容或写在纸上的关键词放在里面，通过任意物品的组合产生新的创意。为了引发这种“突然出现的创意瞬间”，最好的办法就是多准备一些能够激发灵感的资料</p>
<h2 id="直觉-x2F-逻辑场景"><a href="#直觉-x2F-逻辑场景" class="headerlink" title="直觉/逻辑场景"></a>直觉/逻辑场景</h2><p>经验的直觉和逻辑思考本身之间并没有孰优孰劣，两者各自适用于不同的情况，具有不同的作用。对于更重视感性的领域来说，直觉比逻辑更能够发挥作用。</p>
<h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><ol>
<li><p>与逻辑和分析相比”灵感“更重要</p>
</li>
<li><p>一味的模仿不可能实现差异化。</p>
<p>只对竞争对手的商品进行分析无法实现差异化。要想做出与众不同的商品，必须做到其它公司没有做到的事情。</p>
</li>
<li><p>企划会议不需要总结式报告。只确定一个会议议题，然后大家当场讨论</p>
</li>
<li><p>积极听取其它部门或者其它领域的人的意见</p>
</li>
</ol>
<h1 id="Efficiently"><a href="#Efficiently" class="headerlink" title="Efficiently"></a>Efficiently</h1><h2 id="将目标定为原来的10倍"><a href="#将目标定为原来的10倍" class="headerlink" title="将目标定为原来的10倍"></a>将目标定为原来的10倍</h2><p>工作生活中我们对于自己的要求往往是完成任务即可，但是最终的效果往往不尽如人意，可能只完成了七八成。因此在我们设置目标的时候不妨将目标设置的更大一点，既定目标的10倍。这个目标会倒逼自己打破束缚自己的条条框框和固有观念 ，另一方面，要想改变工作方法，必须敢于承担风险、打破规则。最终即使完成七八成也是一个很好的结果了</p>
<h2 id="Think-like-an-owner"><a href="#Think-like-an-owner" class="headerlink" title="Think like an owner"></a>Think like an owner</h2><p>像公司所有者一样思考。针对自己的工作岗位，以我的年收入应该取得多少的成果，想要取得这些成果需要做哪些工作，而每项工作应该有怎样的结果。这个过程中势必要优化自己的工作，着眼于重点工作内容减少工作中的无用功，吸取他人的经验寻求他人的帮助。同样也可以假设自己即将失业，如果没有工作没有了怎么办？想到这里自己的紧迫感油然而生</p>
<h2 id="活用20-原则"><a href="#活用20-原则" class="headerlink" title="活用20%原则"></a>活用20%原则</h2><p>在思考工作的有限顺序的时候，应该优先将时间放在 <strong>能学到很多东西而且影响力比较大</strong>的工作上。而其它类型的工作可以进行分配等等。可以进一步对二八定律进行了解学习</p>
<h2 id="必要的工作素养（※）"><a href="#必要的工作素养（※）" class="headerlink" title="必要的工作素养（※）"></a>必要的工作素养（※）</h2><ol>
<li><p>拥有预见性</p>
<ul>
<li>预见机会与威胁</li>
<li>寻找周期、趋势以及规律</li>
<li>短期、中期与长期思考。考虑<strong>“5/5/5规则”</strong>，即5周以后、5个月以后、5年以后会发生什么事情进行思考</li>
</ul>
</li>
<li><p>换位思考</p>
</li>
<li><p>敢于提出自己的见解</p>
</li>
<li><p>敢说真话（个人认为这一点还是具体情况具体分析）</p>
</li>
<li><p>主动承担责任</p>
</li>
<li><p>积极参与交流</p>
</li>
<li><p>打破常规</p>
</li>
<li><p>不害怕失败</p>
</li>
<li><p>勤于思考、保持质疑</p>
<p>遇到不明白的事情多问一个为什么</p>
</li>
<li><p>改变视角</p>
<p>整体视角；局部视角；反面视角；未来视角；顾客视角；竞争对手视角；特殊视角</p>
</li>
</ol>
<h1 id="Interpersonal-relationship"><a href="#Interpersonal-relationship" class="headerlink" title="Interpersonal relationship"></a>Interpersonal relationship</h1><h2 id="具象化思考"><a href="#具象化思考" class="headerlink" title="具象化思考"></a>具象化思考</h2><p>实物思考我将其总结为具象化思考。工作生活中别人有某项需求时，可以通过某种类比或实物来与对方确认表达是否一致。具体方案：可以是在一张草图上画出来向别人确认“您说的是这种类型吗？”；或者在讨论问题之前将讨论的内容总结到A4纸上，将比较抽象的事情具象化可以实操。这样是可以大幅度的减少交流的成本降低后期的无用功</p>
<h2 id="提升心理安全"><a href="#提升心理安全" class="headerlink" title="提升心理安全"></a>提升心理安全</h2><ul>
<li>心理安全：面对 我可以信赖你吗 或者 我能尊重你吗 这样的问题的时候能够给出肯定的答案</li>
</ul>
<p>得到他人的信赖和尊重也会使自己产生安全感。一旦构筑起信赖关系，交流双方就会像朋友一样，更容易的互相提出意见或建议，工作现场的气氛也会更加活跃。</p>
<h2 id="倾听（※）"><a href="#倾听（※）" class="headerlink" title="倾听（※）"></a>倾听（※）</h2><p>交流Tips：建立信赖关系最重要的一点就是倾听，最好的办法就是让自己对对方产生兴趣并将这种情绪传递给对方。另外，好不容易让对方说出自己的意见，绝对不能将对方的意见完全否定，不能让对方觉得“我说了也没用”的想法！！！</p>
<p>艾米·埃德蒙顿教授指出：不要将问题单纯地看成“需要解决的问题”，而是要将其看作“需要学习的问题”来进行讨论，这样不清楚的部分就会自然而然的浮现，也更容易让团队成员积极思考</p>
<h2 id="建立良好人际关系"><a href="#建立良好人际关系" class="headerlink" title="建立良好人际关系"></a>建立良好人际关系</h2><p>良好的人际关系是快速解决问题的基石</p>
<p>社会各行各业哪怕只要有一点点交集都足可以让对方和自己产生联系。而见到关键的人的时候正确的方式应该是：提前了解设想对方的课题，然后开门见山的根据课题内容进行提问，交流过程中表现出热情、平等的态度就可以心情舒畅的进行交流。在交流过程中还要需要注意 <strong>不要take而要give</strong>，要让别人看到自己的价值</p>
<p><strong>人际关系的优先顺序</strong>：新认识的人 &gt; 熟识的人；新认识并且不断改变自己的人 &gt; 新认识但变化不多的人</p>
<h1 id="Skill"><a href="#Skill" class="headerlink" title="Skill"></a>Skill</h1><h2 id="学习的正确方法"><a href="#学习的正确方法" class="headerlink" title="学习的正确方法"></a>学习的正确方法</h2><p>检索 + 询问专业人士·询问他人·询问同事</p>
<ul>
<li>检索：询问互联网这个老师</li>
<li>询问他人：<ol>
<li>找最擅长这项工作的人询问</li>
<li>询问之前要有自己的思考。带着假设带着思考去提问。具体可以有四要素：具体来说；要在什么地方；改变什么；怎么做才能让工作更顺利</li>
</ol>
</li>
</ul>
<h2 id="前馈与反馈"><a href="#前馈与反馈" class="headerlink" title="前馈与反馈"></a>前馈与反馈</h2><ul>
<li>前馈：找别人询问“我想解决这个问题，应该怎么办才好呢？”</li>
<li>反馈：事后的反思与经验总结</li>
</ul>
<p>要想获取有用的信息，提问的</p>
<p><img src="/images/reading/google-1.jpg" alt="img"></p>
<h2 id="多参加交流会"><a href="#多参加交流会" class="headerlink" title="多参加交流会"></a>多参加交流会</h2><p>为了保证自己的生存，最好多参加交流，不论是非正式聚会、公司外部会议等等，给自己多创造几个立足点。</p>
<p>同行业、同年龄的人呆在一起，谈论的事情都是相似的话题，无法从中获取到跟多有用的信息。在交流过程中，也要时刻思考“我应该给对方提供什么样的信息”，输出自己的价值</p>
<h1 id="Relax-Work"><a href="#Relax-Work" class="headerlink" title="Relax Work"></a>Relax Work</h1><h2 id="一分钟冥想"><a href="#一分钟冥想" class="headerlink" title="一分钟冥想"></a>一分钟冥想</h2><p>关闭电脑，将所有注意力都集中在自己的呼吸上，安静的坐在座位上</p>
<h2 id="并行任务与串行任务分类"><a href="#并行任务与串行任务分类" class="headerlink" title="并行任务与串行任务分类"></a>并行任务与串行任务分类</h2><p>比如通勤过程中进行书籍的阅读、听音频等等</p>
<p>而一旦专注于某项工作就尽可能排除外部的干扰，可以尝试将手机静音、放远一点等等操作</p>
<h2 id="睡午觉、吃零食、放松是自己的责任"><a href="#睡午觉、吃零食、放松是自己的责任" class="headerlink" title="睡午觉、吃零食、放松是自己的责任"></a>睡午觉、吃零食、放松是自己的责任</h2><h1 id="Final-Innovation"><a href="#Final-Innovation" class="headerlink" title="Final Innovation"></a>Final Innovation</h1><ol>
<li>思考如何使用AI替代自己的工作</li>
<li>站在革新一侧不袖手旁观，改变自己坚持但不好的习惯，合理使用现代化工具</li>
<li>就算对技术细节不了解，也要跟上趋势</li>
<li>工作不能和昨天一样</li>
</ol>
<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><ol>
<li><p>不要认为“公司就是自己的办公室”，而要时刻记住“自己在哪哪里就是办公室”</p>
</li>
<li><p>会议的目的不是将所有人召集到一起，而是取得结果，所以只需要召集对取得结果有帮助的成员即可</p>
</li>
<li><p>邮件是“等待文化”，即时通信是“实时文化”</p>
</li>
<li><p>工程项目的冲刺阶段一般都会采用“规定期限，集中精神”的工作方法</p>
</li>
<li><p>明确工作的优先顺序和品质要求是专业人士的基本素养</p>
</li>
<li><p>工作的目的并不是“从早9点到晚6点坐在同一个地方“，而是取得令人满意的成果（舒适的工作环境至关重要）</p>
</li>
<li><p>没有结论的分析毫无意义</p>
</li>
<li><p>创意思维需要的是灵感以及丰富经验的直觉</p>
</li>
<li><p>只有敢于走出舒适区才能取得更大的成果</p>
</li>
<li><p>公司之所以给你高额薪水，是因为你能做到别人无法做到的困难工作</p>
</li>
<li><p>交流最大的目的是构筑信赖关系 </p>
</li>
<li><p>当人感觉到自己受到了尊重或者别人很重视我的时候，就会将自己的内心从防备中解放出来</p>
</li>
<li><p>在好奇心驱使下不断的追求自己感兴趣的东西，这将成为你职场中的通行证</p>
</li>
<li><p>应该学习的不是知识而是经验</p>
</li>
<li><p>人的成长就像斐波那契数列，昨天的自己加上前天的自己才是今天的自己</p>
</li>
<li><p>多次实践不但有助于提高自信，更能加快掌握速度</p>
</li>
<li><p>拥有的“选项”越多，在竞争中生存的可能性就越大</p>
</li>
<li><p>究竟是选择站在革新的一侧还是选择袖手旁观，不同的选择带来的结果可谓是天壤之别 </p>
</li>
<li><p>找到在巨变洪流中发挥自己能力并且赚取利润的方法</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《格局》</title>
    <url>/2023/01/04/Reading/%E6%A0%BC%E5%B1%80/</url>
    <content><![CDATA[<p><img src="/images/reading/GeJu.jpg" alt="img"></p>
<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>《格局》一书是吴军博士2019年出版的。吴军博士头衔可谓众多，“文津图书奖”得主、硅谷投资人、约翰·霍普金斯大学工学院董事、原腾讯副总裁，出版过《数学之美》《浪潮之巅》《文明之光》《硅谷之谜》等等不同品类的书籍。</p>
<p>我自己对于”格局“一词的理解是一个人对于世界认知的边界以及对事物认知的范围。整书通读下来给我的感觉更像是吴军博士对于自己生活经验及基于某些历史事件的规律总结，甚至有些章节的内容前后都没有很关联，对于本书大部分内容无感的本质原因我认为是自己的经历没有那么丰富无法做到感同身受亦或者是自己对于这本书没有完全读懂。那便写下自己感兴趣的部分的心得吧</p>
<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><h2 id="技术是手段-不是目的"><a href="#技术是手段-不是目的" class="headerlink" title="技术是手段 不是目的"></a>技术是手段 不是目的</h2><p>互联网飞速发展，新的技术理论得到迅速且广泛的传播。对于一名技术从业者来讲，要想在职场行业内始终保持竞争力，需要不断的去学习新的内容来保证自己不会被时代所淘汰。但实际上，技术从来都是手段而不是目的，如果搞不清楚这一点，就会为了技术而研发技术。2022年AI、IOT可能是时代的潮流，但10年后一切都未曾可知而可以肯定的是计算机的底层原理及知识仍然不会落伍。可见洞察一件事情的本质并去学习探索才是真正的硬道理。</p>
<h2 id="未来的特征"><a href="#未来的特征" class="headerlink" title="未来的特征"></a>未来的特征</h2><ul>
<li>不对称性。新技术的产生，最早掌握新技术的少数人可以利用新技术颠覆过去在相关领域中占据统治地位的组织或机构；</li>
<li>复杂性。当下的知识体系非常复杂，通常都是跨学科的而不是单一维度的；</li>
<li>不确定性。没有人能够预测未来</li>
</ul>
<ol>
<li>不过度依赖过去的权威</li>
<li>拉力由于推力（主动获取而不是被动接收）</li>
<li>指南针优于地图（改变一直存在，掌握本质，求渔不求鱼）</li>
<li>拥抱风险</li>
<li>叛逆精神（打破规则）</li>
<li>通才胜于专才（前提一定是已经在某一方面已经是专才）</li>
<li>韧性优于力量</li>
<li>强调整体性</li>
</ol>
<h2 id="以正和，以奇胜"><a href="#以正和，以奇胜" class="headerlink" title="以正和，以奇胜"></a>以正和，以奇胜</h2><p>面对不断变化的未来，把握好常态是关键，而正是常态，奇是非常态。《孙子兵法 兵势篇》中写到：凡战者，以正和，以奇胜。这句话的意思是：作战，要先把正面的兵排好，排的不偏斜合乎法则，此为正；如果这时候还有多余的兵力你就赢了，在现代汉语字典中也可以理解为：出奇制胜。”以正和，以奇胜”更应该是一个人做事的准则，在做好正的基础上出奇制胜，不要相信所谓的弯道超车，这一定是不稳定的。</p>
<h2 id="被信息放大的悲观"><a href="#被信息放大的悲观" class="headerlink" title="被信息放大的悲观"></a>被信息放大的悲观</h2><p>我们明显能够感觉到现在的年轻人普遍会更焦虑，他们仿佛对这个世界充满悲观情绪。xxx飞机失事、xxx公司大规模裁员、xxx地区洪水或火山爆发，这些新闻在现在真的是屡见不鲜，也正是这些新闻的广泛传播给我们造成了很大的焦虑情绪。但实际上飞机其实是比汽车更安全、在大范围内就业形式是向好的、火山喷发地正是处于板块交界地带。可以发现真正广泛传播的言论实际上大多是悲观的，从信息论的角度来讲，越是与众不同的说法信息量越大。相反宣传乐观主义的观点论文不仅没有人看甚至是无法发表的。因为没有人会关心一篇”今年经济持续向好“的文章，大家都知道也自然就不会过多关注。面对各种各样的新闻，适当保持忧患意识是必要的，但请不应过度的悲观！</p>
<h2 id="人立于天地之间必有出路"><a href="#人立于天地之间必有出路" class="headerlink" title="人立于天地之间必有出路"></a>人立于天地之间必有出路</h2><p>面对生活、工作、家庭的压力，我们总是使自己处于一个很忙碌的状态之中，面对未来可能发生的问题我们也常说：车到山前必有路、船到桥头自然直。确实，对于未来的不确定性，我们始终要坚信人立与天地之前必有出路。</p>
<h1 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h1><p>自己花了精力做的事情要尽可能的对自己未来有帮助。</p>
<p>过分追求物质可能会成为生活的负担。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《曾国藩传》</title>
    <url>/2022/12/11/Reading/%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BC%A0/</url>
    <content><![CDATA[<p><img src="/images/reading/zengGuoFan.jpg" alt="img"></p>
<p>近几年，曾国藩倍受成功学的推崇，关于他的书也是铺天盖地。偶然间看到老俞（俞敏洪）在推荐这本书，带着浓厚的兴趣开始对这本书的探索。《曾国藩传》是中国知名历史学家张宏杰先生的作品，除了这本《曾国藩传》他还著有《曾国藩的正面与侧面》《饥饿的盛世》《大明王朝的七张面孔》等等。整本书通读下来，作者按照时间顺序，以曾国藩日记及各种历史参考文献为史实基础进行了深度解读，将曾国藩国之重臣的形象立体的展现在了我们的眼前。</p>
<p>本篇也无所谓是读书笔记、读后感亦或者是书评了，便想到哪里写到哪里吧。</p>
<h1 id="故事自述"><a href="#故事自述" class="headerlink" title="故事自述"></a>故事自述</h1><p>曾国藩历任晚清四朝，生于嘉庆、文于道光、武于咸丰、卒于同治，我这里的文、武分别指其京官时代和领导湘军阶段。</p>
<p>老曾家本是一个殷实的小地主家庭，奈何祖坟一直没冒青烟，祖辈上没有一个读书人。在爷爷曾玉屏的影响下，小小的曾子城（该时期曾国藩未改名）开启了他的读书生涯。屡战屡败、屡败屡战，落榜六次之后，院试中秀才、乡试中举人、会试中进士，也就是在此正式更名为曾国藩，寄以“国之藩篱“之意，此时他才二十八岁。在此之后在京十年中，曾国藩立下学做圣人的宏愿并坚韧不拔地沿着这条仕途之道前进，步步升迁到二品官位。十年七迁，连跃十级。直至1852年充任江西乡试正考官才结束了他的京官生涯。</p>
<p>在曾国藩春风得意之际，却突然收到母亲去世的噩耗，致使他不得不改变自己的行程回家守孝。此时太平天国运动轰轰烈烈席卷半个中国，而清军主力八旗和绿营早已腐败不堪，咸丰皇帝不得不颁布兴办团练的诏书。曾国藩起初内心是拒绝的，但是心系国家的他最终还是决定应诏，以团为表，以军为里组建起了湘军，殊不知这支军队成了日后抵抗太平军的主力。没有任何军事经验、初来乍到再加上曾国藩此时直率的性格特征，组建一支像样且有战斗力的军队的难度可想而知，克服重重困难湘军算是建立起来了。抱着首战必胜的心理曾国藩决定出兵靖港，未曾可知迎来一场大败，这也让他的信心跌落谷底一度跳江自杀，幸被救下。随后大大小小战斗经历无数，湘潭大捷、九江大败…… 1857年父亲去世，他向皇帝请求回家奔丧三个月，未曾想再想复出却被皇帝解除了兵权。</p>
<p>塞翁失马焉知非福？也正是接下来两年的蛰伏让曾国藩完成了脱胎换骨的变化，他开始变得通人情世故，适应晚清官场的环境，但面对自己时仍然选择做圣人。趁着太平军内讧石达开的出走，好兄弟胡林翼给曾国藩争取来了再度出山的机会，之后两人联手攻克了安庆，期间何桂清弃城逃跑也成就了曾国藩得到了梦寐以求的两江总督的职位。水到渠成地1864年正月，攻破天京，结束叛乱。</p>
<p>此时曾国藩任两江总督，后面应该就是被大众所熟知的部分——主办洋务。首先他和自己的接班人李鸿章联手剿灭了北方黄淮一带的捻军起义，随后便是兴办洋务，建立安庆军械所、江南制造总局，翻译大量外文书籍等等。1868年升任直隶总督处理完天津教案事件因备受指责再次担任两江总督，四年后中国传统文化最后一个偶像曾国藩去世。</p>
<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><h2 id="越努力越幸运"><a href="#越努力越幸运" class="headerlink" title="越努力越幸运"></a>越努力越幸运</h2><p>曾国藩不能说是天资卓越的人，从他读书、治军经历不难看出这一点。关于这一点还有一个广为流传的小故事，一日黄昏，他在书桌前背诵《岳阳楼记》，一个小偷偷偷潜入他家爬到房梁上，等待这一家人都入睡后偷东西。奈何小偷睡了好几觉，曾国藩还没有背下来，小偷气急败坏跳下房梁说：就你这个笨样读什么书？随后他完完整整背了一遍，甩门而去，留下的曾国藩目瞪口呆一人凌乱。真实性无从考证，但是由此可见他是真挺笨的，而他未来的成就更多来自于努力。他的人生哲学便是”尚拙“，崇尚笨拙。曾国藩曾说：“天下之至拙，能胜天下之之巧”。一味的追求高效率而不择手段、投机取巧终不能成大才。天赋不够，努力来凑，而越努力才会越幸运。</p>
<h2 id="历史总是有迹可循"><a href="#历史总是有迹可循" class="headerlink" title="历史总是有迹可循"></a>历史总是有迹可循</h2><p>在本书中曾有过这样两个片段。</p>
<p>其一，在曾国藩守制期间大彻大悟完成蜕变，他突然意识到所谓”天下之至柔，驰骋天下之志坚“、”大柔非柔，至刚无刚“真正的含义。行事过于方刚者，表面似乎是强者，实际上确是弱者。而他之前看不起的麻木、圆滑、机诈有时候才是解决问题的最好方法。</p>
<p>其二，在攻打安庆期间，胡林翼创造出”围城打援“的战术，给在湖北作战的湘军统帅多隆阿的信中说道，战争的目的不在于一城一池的得失，而在于消灭对方的有生力量。</p>
<p>读到第一个片段，脑海中不由得浮现出老子”以柔克刚“的思想，而曾国藩大彻大悟后的思想何尝不是对先贤思想的进一步阐述和升华。而读到第二个片段时，脑海里浮现的是解放战争期间，毛主席在延安面对胡宗南二十五万大军主动撤离，决定”拿一个延安换取一个全中国“。当时便提出：存地失人，人地皆失；存人失地，人地皆存。这与胡林翼讲述的战争目的可谓是如出一辙。</p>
<h2 id="尽人事，听天命"><a href="#尽人事，听天命" class="headerlink" title="尽人事，听天命"></a>尽人事，听天命</h2><p>在曾国藩赋闲在家为父亲治丧三个月期满之时，他向皇帝申请继续守制三年，太平天国未灭皇帝当然不会批准这个请求。于是曾国藩说出了实情：哭诉了一番自己的委屈和困难，并对皇帝说如果你不给我督抚大权，我就只能在籍终制。这明显是赤裸裸的要挟，出乎曾国藩的预料，咸丰皇帝居然答应了他的守制请求，彻彻底底没收了军权。而在与太平天国的决战当中，何桂清弃城逃跑，曾国藩没有索要皇帝便把何桂清两江总督职位给到了他。</p>
<p>一旦在做一件事情时有了极强的功利心，实现的过程可能将不择手段，目标也可能会背道而驰，最终一定不会达到最完美的状态。而最好的方式则是做到”尽人事听天命“，尽心尽力的去做事情，而能否成功，则需要顺其自然。</p>
<h2 id="脚踏实地，常于反思"><a href="#脚踏实地，常于反思" class="headerlink" title="脚踏实地，常于反思"></a>脚踏实地，常于反思</h2><p>在八旗兵和绿营兵战斗力如此低下的情况下，一介书生曾国藩为什么创建出战斗力满满的湘军呢？答案就是反思的力量，他追根溯源找到八旗绿营真正症结所在并在湘军中及时调整完成功业。而建立起来的湘军在战斗时奉行的时曾国藩”结硬寨，打呆仗“的战术，具体来讲就是”以静制动，反客为主“，把自己的营寨盘结实等待敌人前来进攻，等待他们露出马脚湘军再反攻，这便是整个逻辑。</p>
<p>细细看下来曾国藩的战术一定不是最先进的但一定是最稳妥的。不论走多远的路，但一定要确保走过的每一步路都有自己的脚印。</p>
<h2 id="保持忧患意识"><a href="#保持忧患意识" class="headerlink" title="保持忧患意识"></a>保持忧患意识</h2><p>在太平天国运动被平定之后，湘军无疑成了整个清王朝最强大的战斗力。曾国藩熟读史书，《易传》中讲：日中则昃，月盈则亏。越是辉煌的时候越应该保持清醒的头脑，懂得趋福避祸。他怎么能不明白朝廷的心思呢，为了不让朝廷猜忌决定自剪羽毛裁撤湘军。与此同时，他默默的将部分主力交给李鸿章的淮军当中。这一手”裁湘留淮“的操作可谓真的是粗中有细，这也保证了它后面官场生涯的延续。</p>
<h2 id="读书永远可以保持竞争力"><a href="#读书永远可以保持竞争力" class="headerlink" title="读书永远可以保持竞争力"></a>读书永远可以保持竞争力</h2><p>选士人，领山农。湘军大部分人都是山农即农民出身。但是湘军重视政治教育，罗泽南部则索性白天打仗，晚上把部下召集到一起，教他们读书，学习理学。流氓不可怕，就怕流氓有文化，这句话可能不是很恰当，但是有了知识的农民部队战斗力、战斗素养提升了可不是一个等级。</p>
<h2 id="桃李满天下"><a href="#桃李满天下" class="headerlink" title="桃李满天下"></a>桃李满天下</h2><p>这一项不能算作是感悟，称得上是曾国藩的成就。晚清大多数重臣都多多少少都受到过曾国藩的提点，李鸿章、左宗棠、沈葆桢、彭玉麟、胡林翼等等，尤其是李鸿章可谓是一手提拔起来的。英国一位历史学家说：曾国藩是中国最有势力的人，但他死去的时候，所有的总督（类似于现在的省委书记）都曾做过他的部下，并且都是由他提名的。如果他希冀，他可能已经成为皇帝。真实性无从考证，但由此也可看出他的影响力之大</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>曾国藩这一生是失败的。为天地立心、为生民立命、为往圣继绝学、为万世开太平。曾国藩用他的一生来践行张载的横渠四句，但可惜生不逢时终究是没有完成全部的理想，无奈成为追日的夸父、填海的精卫。在这里引用一下杨耀在”得到“APP解读李鸿章一书中提到的：时势能够造英雄，而英雄也可以改变时势。而显然传统保守的思想让曾国藩注定只能成为时势造的英雄，而不能成为改变时势的英雄。这不是他一个人的失败，而是整个腐朽政权的失败！</p>
<p>曾国藩这一生又是成功的。立功、立德、立言三不朽的境界他全部做到了。立功而言，他从一介书生起家，创建军队，挽狂澜于既倒，扶大厦之将倾，使中国传统文化免遭毁灭之灾，让清朝又可以在历史上浓墨重彩的多写几笔；立德而言，他以圣贤为标准要求自己，道德修养近乎纯粹；立言而言，我一个普通人能在这里写这篇文章感受曾国藩的风采，其影响力便不言而喻，洋洋洒洒数百万字全集让人受益匪浅。</p>
<p>一万个人有一万个哈姆雷特，同样也会有一万个曾国藩，每个人切入角度不同读出的人物自然不同，但带给我们每个人的力量却是永恒且相同的！</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Libmad详解</title>
    <url>/2022/11/05/Audio/Audio-libmad/</url>
    <content><![CDATA[<p>简单来讲，libmad就是一个MP3文件的解码库。如果想要深入理解其中的实现需要对MP3文件格式有详细的了解，关于MP3文件格式的内容在这里我不赘述，之前的文章当中有过详细的讲解 <a href="https://yanglieee.com/2022/09/05/Audio-meet-1/">click here</a></p>
<h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><blockquote>
<p>Libmad 详解：<a href="https://www.underbit.com/products/mad/">https://www.underbit.com/products/mad/</a></p>
</blockquote>
<p> libmad 是一个高质量的 MPEG 音频解码器。目前支持  MPEG-1 和 MPEG-2 对较低采样频率的扩展，以及所谓的 MPEG 2.5 格式，三个音频层都在代码上做了实现。优势：</p>
<ul>
<li>24 位 PCM 输出</li>
<li>100% 定点（整数）计算</li>
<li>基于 ISO/IEC 标准的全新实施</li>
<li>根据 GNU 通用公共许可证 (GPL) 的条款分发</li>
</ul>
<h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p><a href="https://sourceforge.net/projects/mad/files/">https://sourceforge.net/projects/mad/files/</a></p>
<p><a href="https://www.linuxfromscratch.org/blfs/view/svn/multimedia/libmad.html">https://www.linuxfromscratch.org/blfs/view/svn/multimedia/libmad.html</a></p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>&lt; 基于 libmad-0.15.1b 版本&gt;</p>
<table>
<thead>
<tr>
<th>源文件</th>
<th>bit.c</th>
<th>decoder.c</th>
<th>fixed.c</th>
<th>frame.c</th>
<th>huffman.c</th>
<th>layer12.c</th>
<th>layer3.c</th>
<th>stream.c</th>
<th>synth.c</th>
<th>timer.c</th>
<th>version.c</th>
<th>minimad.c(demo)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>头文件</td>
<td>bit.h</td>
<td>decoder.h</td>
<td>fixed.h</td>
<td>frame.h</td>
<td>huffman.h</td>
<td>layer12.h</td>
<td>layer3.h</td>
<td>stream.h</td>
<td>synth.h</td>
<td>timer.h</td>
<td>version.h</td>
<td>global.h</td>
<td>mad.h（API）</td>
</tr>
<tr>
<td>dat文件</td>
<td>sf_table.dat</td>
<td>imdct_s.dat</td>
<td>qc_table.dat</td>
<td>D.dat</td>
<td>rq_table.dat</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>其他文件</td>
<td>Makefile</td>
<td>config</td>
<td>……</td>
<td></td>
<td>大部分内容不参与编译</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>具体使用方法可以参考minimad.c文件，这里面对api的使用有进一步的说明</p>
<p>同时也可以参考我基于Linux libmad写出来的一个音频播放器，源码链接 <a href="https://github.com/yangLieee/audioplayer">click here</a></p>
<h1 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h1><p>&lt; 仅介绍linux环境下编译方法 &gt; </p>
<ol>
<li>手写Makefile / CMakeLists.txt</li>
<li>系统提供的config<ul>
<li>执行 <strong>sed -i ‘/-fforce-mem/d’ configure</strong> ， 这条命令是为了适配高版本的gcc，因为高版本的gcc已经将-fforce-mem去除了</li>
<li>执行 <strong>./configure ,</strong> 文件夹下会生成Makefile</li>
<li>执行 <strong>sudo make; sudo install;</strong> </li>
<li>至此静态库和动态库已经生成，目录在/usr/local/lib</li>
</ul>
</li>
</ol>
<h1 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h1><ol>
<li><p>mad_decoder_init( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mad_decoder_init</span><span class="params">(<span class="keyword">struct</span> mad_decoder *, <span class="type">void</span> *,   </span></span><br><span class="line"><span class="params">           <span class="comment">/* input func  */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* header func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_header <span class="type">const</span> *),                   </span></span><br><span class="line"><span class="params">           <span class="comment">/* filter func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream <span class="type">const</span> *, <span class="keyword">struct</span> mad_frame *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* output func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_header <span class="type">const</span> *, <span class="keyword">struct</span> mad_pcm *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* error func  */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream *, <span class="keyword">struct</span> mad_frame *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* message func*/</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="type">void</span> *, <span class="type">unsigned</span> <span class="type">int</span> *))</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>mad_decoder_init( )是libmad中最终重要的函数之一，其作用是将line3~line8的六个回调函数注册到mad_decoder实例出来的decoder中。</p>
<ul>
<li><p><strong>必须自定义的参数：</strong>参数1：用户自己实例的一个解码器结构体；参数2：用户自定义的结构体指针，这个指针将用于整个解码的过程在回调函数之间进行数据的传输；参数3：输入的回调函数，该回调用于用户自定义将数据输入编码器的逻辑；参数6：输出的回调函数，同input callback func。自定义输出的分辨率吧：24bit / 16bit，可以存成文件亦可以直接通过pcm接口播放。Output回调函数在madlib每解码完成一个帧后被调用，直到全部解码完成或出错。参数8（异步工作模式下必选）：输出信息。</p>
</li>
<li><p><strong>选择性定义参数：</strong>其他参数属于自定义参数比如进行头解析、过滤筛选的回调函数等等，如果自己没有需求置0即可。</p>
</li>
</ul>
</li>
<li><p>mad_decoder_run( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mad_decoder_run</span><span class="params">(<span class="keyword">struct</span> mad_decoder *, <span class="keyword">enum</span> mad_decoder_mode)</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>该函数是解码的主流程函数，即解码器的入口函数，如果要追代码可以从此处开始进行剖析。</p>
<ul>
<li>参数1：用户自定义实例化并初始化的解码器decoder；</li>
<li>参数2：选择解码模式（SYNC / ASYNC）深入代码可以发现这个选择使得解码器进入不同的函数进行工作。</li>
</ul>
<p>所谓同步方式是指解码函数在解码完一帧后才返回并带回出错信息，异步方式是指解码函数在调用后立即返回，通过消息传递解码状态信息。(故异步方式必须定义message回调函数)</p>
</li>
<li><p>mad_decoder_finish( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mad_decoder_finish</span><span class="params">(<span class="keyword">struct</span> mad_decoder *)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>解码结束，用于清理工作，释放与流相关的任何动态内存。</p>
</li>
<li><p>mad_stream_buffer( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mad_stream_buffer</span><span class="params">(<span class="keyword">struct</span> mad_stream *, <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *, <span class="type">unsigned</span> <span class="type">long</span>)</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>该函数是input回调函数中最重要的函数，其作用是按照参数2、参数3即MP3文件在内存映像的起始地址和本次要传递的文件长度与mad_stream进行关联，形成libmad可识别的stream流</p>
<p>需要注意，这里传递多少数据完全是自定义的。如果一次性送入则整个解码过程调用一次input；如果一次性传递若干，output根据传递的数据进行解码，如果没有数据可解继续调用input。所以自己定义好输入逻辑即可。</p>
</li>
</ol>
<h1 id="重点数据结构"><a href="#重点数据结构" class="headerlink" title="重点数据结构"></a>重点数据结构</h1><ol>
<li><p>mad_stream</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h &amp;&amp; stream.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_stream</span> {</span>           </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *buffer;          <span class="comment">/* input bitstream buffer */</span>                                       <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *bufend;          <span class="comment">/* end of buffer */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> skiplen;                <span class="comment">/* bytes to skip before next frame */</span></span><br><span class="line">  <span class="type">int</span> sync;                             <span class="comment">/* stream sync found */</span>        </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> freerate;               <span class="comment">/* free bitrate (fixed) */</span>     </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *this_frame;      <span class="comment">/* start of current frame */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *next_frame;      <span class="comment">/* start of next frame */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mad_bitptr</span> <span class="title">ptr</span>;</span>                <span class="comment">/* current processing bit pointer */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mad_bitptr</span> <span class="title">anc_ptr</span>;</span>            <span class="comment">/* ancillary bits pointer */</span>   </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> anc_bitlen;              <span class="comment">/* number of ancillary bits */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="title function_">char</span> <span class="params">(*main_data)</span>[MAD_BUFFER_MDLEN];                  <span class="comment">/* Layer III main_data() */</span>    </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> md_len;                  <span class="comment">/* bytes in main_data */</span>  </span><br><span class="line">  <span class="type">int</span> options;                          <span class="comment">/* decoding options (see below) */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_error</span> <span class="title">error</span>;</span>                 <span class="comment">/* error code (see above) */</span>   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>该结构体记录了文件的地址、当前所处理的位置和解码前的Bitstream数据</p>
<p>mad_stream.bufend – mad_stream.next_frame就是剩余的未被解码的 MPEG 帧的数据的字节数量（假设此帧在缓冲区中不完整)</p>
</li>
<li><p>mad_header</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_header</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_layer</span> <span class="title">layer</span>;</span>             <span class="comment">/* audio layer (1, 2, or 3) */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_mode</span> <span class="title">mode</span>;</span>               <span class="comment">/* channel mode (see above) */</span></span><br><span class="line">  <span class="type">int</span> mode_extension;               <span class="comment">/* additional mode info */</span>                                             <span class="class"><span class="keyword">enum</span> <span class="title">mad_emphasis</span> <span class="title">emphasis</span>;</span>       <span class="comment">/* de-emphasis to use (see above) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bitrate;            <span class="comment">/* stream bitrate (bps) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> samplerate;          <span class="comment">/* sampling frequency (Hz) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> crc_check;         <span class="comment">/* frame CRC accumulator */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> crc_target;        <span class="comment">/* final target CRC checksum */</span></span><br><span class="line">  <span class="type">int</span> flags;                        <span class="comment">/* flags (see below) */</span></span><br><span class="line">  <span class="type">int</span> private_bits;                 <span class="comment">/* private bits (see below) */</span></span><br><span class="line">  <span class="type">mad_timer_t</span> duration;             <span class="comment">/* audio playing time of frame */</span></span><br><span class="line">};    </span><br></pre></td></tr></tbody></table></figure>

<p>通过注释很容易看出，该结构体记录了MPEG 帧的基本信息，比如MPEG 层数、声道模式、流比特率、采样率、比特率以及某些校验位等等。</p>
<blockquote>
<p>Tips：（bitrate % 32） 如果是整数说明该文件格式是CBR（constant bitrate，恒定比特率），否则是VBR（variable bitrate，可变比特率），这对文件播放时长是有影响的。</p>
</blockquote>
</li>
<li><p>mad_pcm</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_pcm</span> {</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> samplerate;          <span class="comment">/* sampling frequency (Hz) */</span>                                           <span class="type">unsigned</span> <span class="type">short</span> channels;          <span class="comment">/* number of channels */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> length;            <span class="comment">/* number of samples per channel */</span></span><br><span class="line">  <span class="type">mad_fixed_t</span> samples[<span class="number">2</span>][<span class="number">1152</span>];     <span class="comment">/* PCM output samples [ch][sample] */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>madlib解码器是以帧为单位进行解码的，mad_pcm每次最多解码出（1152 * channels）个PCM数据，每个采样点用int（32bit）表征但是只用了其中的24bit，至此可以直接输出数据保存文件或者直接调用音频播放的API进行播放。但目前大多数codec支持的是16bit量化分辨率，所以在输出时将数据饱和到16bit进行输出。</p>
</li>
<li><p>mad_flow</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">mad_flow</span> {</span></span><br><span class="line">  MAD_FLOW_CONTINUE = <span class="number">0x0000</span>,   <span class="comment">/* continue normally */</span>                                                     MAD_FLOW_STOP     = <span class="number">0x0010</span>,   <span class="comment">/* stop decoding normally */</span></span><br><span class="line">  MAD_FLOW_BREAK    = <span class="number">0x0011</span>,   <span class="comment">/* stop decoding and signal an error */</span></span><br><span class="line">  MAD_FLOW_IGNORE   = <span class="number">0x0020</span>    <span class="comment">/* ignore the current frame */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>所有回调函数的返回值均为该枚举类型，在解码的主流程中会通过不断判断解码器所调用的回调函数的状态来确认下一步的动作</p>
</li>
</ol>
<h1 id="相关调试经验"><a href="#相关调试经验" class="headerlink" title="相关调试经验"></a>相关调试经验</h1><ol>
<li><p>配置参数未选择</p>
<p>Q：编译正常通过，流程正确，但是输出的声音能听出是所需要的音频但是整体数据并不正确？</p>
<p>A：在mad.h中有若干的函数是根据平台的不同有不同的实现，由于编译过程中没有注意警告直接将其注释导致没有选择正确函数实现，导致最终的数据都是错误的。编译时添加相应的平台的参数即可，如果手动写cmake，参考给出的Makefile做参数选择！</p>
</li>
<li><p>线程栈空间大小分配不足</p>
<p>Q：在PC上测试正常播放，但是移植到小系统中经常出现stack overflow？</p>
<p>A：由于MP3一帧数据的采样点数为1152，使用 int 类型进行存储，所以核心函数 “ Ⅲ_decode” 至少需要6k的栈空间，如果是单独一个线程的话再加上其他的局部变量、函数跳转等等可能就超过8k。</p>
<p>​	  当时使用c++ 的thread进行的线程创建并不能配置栈空间大小，经过两天左右的debug查到是核心函数栈空间的溢出，最终使用pthread加大栈空间的大小运行即可。</p>
</li>
<li><p>动态解码的实现</p>
<p>Q：刚开始百度libmad的库，很多博客说只能调用一次input回调函数即一次加载所有的源数据，这对于实时控制造成不便？</p>
<p>A： 深入源码可以看出输入的的数据解码完成只要不返回STOP是可以继续填充数据的，这样临时的buffer就小一些并且可以试试控制完成播放器的功能。（需要注意如果一次输入的数据是几帧多一点，而多出来的需要放保存下次再此进行解码）</p>
</li>
<li><p>获得音频参数</p>
<p>Q：能够很快的获得音频信息？</p>
<p>A： 对于wav头很容易的可以找到音频的参数，但是MP3文件的信息保存在帧头中，所以可以进行一步预解码。即读入若干（512即可）byte数据解一帧的头就可以获得全部信息，包括：采样率、比特率、声道、音频时长等等。</p>
</li>
<li><p>获得播放进度 / 时长出现异常</p>
<p>Q：使用公式：当前文件位置 / 文件大小 × 文件总时长，获得当前播放时间出现异常？</p>
<p>A： 对于duration 和 fpos是用int的数据类型进行保存的，但是对于wav文件一般比较大在计算的时候超出了数据类型所能存储的最大长度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
      <tags>
        <tag>libmad</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio-再遇</title>
    <url>/2022/09/05/Audio/Audio-meet-1/</url>
    <content><![CDATA[<p>本篇内容对一节提到的编码进行扩展，将重点对PCM格式、WAVE格式、MP3格式进行详细解析。</p>
<h1 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h1><p>PCM : Pulse-Code Modulation 脉冲调制编码</p>
<p>PCM 本是一种调制方法的名称，进而通过该方法得到的音频数据也称作PCM数据，即裸数据。该数据是我们通过codec得到的最原始的数据！</p>
<p>​    <img src="/images/linux/Audio/Audio-remeet-1.png" alt="pic"></p>
<h1 id="WAVE"><a href="#WAVE" class="headerlink" title="WAVE"></a>WAVE</h1><p>WAVE : Waveform Audio File Format 波形音频文件格式, 即我们平时所说的wave文件</p>
<p>很简单，WAV文件格式结构体通常是用来保存PCM格式的原始数据，基于此添加一个文件头构成了WAV文件，即wave = wave头 + PCM数据。因此它通常也被称为无损音频，但是严格意义上来讲，WAV也可以存储其它压缩格式的音频数据。</p>
<h2 id="wav头"><a href="#wav头" class="headerlink" title="wav头"></a>wav头</h2><table>
<thead>
<tr>
<th><strong>偏移地址</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>大小</strong></th>
<th><strong>名称</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>00H~03H</td>
<td>char</td>
<td>4</td>
<td>资源交换文件标志 ( RIFF )</td>
<td>52 49 46 46 固定写法</td>
</tr>
<tr>
<td>04H~07H</td>
<td>long int （4）</td>
<td>1</td>
<td>文件大小size</td>
<td>从下个地址 (08) 开始到 WAV 文件结尾的总字节数整个 WAV 文件的大小就是该数值 + 8</td>
</tr>
<tr>
<td>08H~0BH</td>
<td>char</td>
<td>4</td>
<td>WAV文件标志 WAVE</td>
<td>57 41 56 45 , 是 WAVE 四个字母的 ASCII 码，固定写法</td>
</tr>
<tr>
<td>0CH~0FH</td>
<td>char</td>
<td>4</td>
<td>波形格式标志（fmt ）</td>
<td>最后一位0x20 对应的字符是空格</td>
</tr>
<tr>
<td>10H~13H</td>
<td>int</td>
<td>1</td>
<td>过滤字节</td>
<td>一般为00000010H</td>
</tr>
<tr>
<td>14H~15H</td>
<td>short int （2）</td>
<td>1</td>
<td><strong>格式种类audioformat</strong></td>
<td>值为1时，表示数据为线性PCM编码</td>
</tr>
<tr>
<td>16H~17H</td>
<td>short int</td>
<td>1</td>
<td><strong>通道数 channnels</strong></td>
<td>1 表示单声道 , 2 表示立体声</td>
</tr>
<tr>
<td>18H~1BH</td>
<td>long int</td>
<td>1</td>
<td><strong>采样频率 sampleRate</strong></td>
<td>80 BB 00 00 – &gt; 48000 Hz ;</td>
</tr>
<tr>
<td>1CH~1FH</td>
<td>long int</td>
<td>1</td>
<td>波形数据传输速率（每秒平均字节数）</td>
<td>采样率×通道数×采样位数 / 8</td>
</tr>
<tr>
<td>20H~21H</td>
<td>short int</td>
<td>1</td>
<td>DATA数据块调整长度，字节。</td>
<td>通道数×样本数据位数 / 8</td>
</tr>
<tr>
<td>22H~23H</td>
<td>short int</td>
<td>1</td>
<td>PCM位宽</td>
<td>10 00 —-&gt; 16 位, 2 字节</td>
</tr>
<tr>
<td>24H~27H</td>
<td>char</td>
<td>4</td>
<td>数据标记</td>
<td>64 61 74 61 data的ASCII的值</td>
</tr>
<tr>
<td>28H~2BH</td>
<td>long int</td>
<td>1</td>
<td>PCM 数据总长度</td>
<td></td>
</tr>
</tbody></table>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>Q：wave文件的文件头一定是44Bytes吗？</p>
<p>A：不一定！以上格式只是wave文件的标准，属于通用标准。但是将其他格式文件通过ffmpeg转码之后的wav文件头会大于44个字节（115Bytes），在文件头和数据块之间添加了一些ffmpeg的信息，部分表征的意义不同！网上很多格式转换工具都是调用的ffmpeg转码的，导致文件头大小不完全相同。</p>
<blockquote>
<p>​     -map_metadata -1 -fflags +bitexact 可以去除标注信息，使文件头符合标准</p>
<p>​     ffmpeg -y -i music.mp3 -map_metadata -1 -fflags +bitexact -f wav -ac 1 -ar 16000 -ab 16k music.wav</p>
</blockquote>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Ffmpeg不去标准信息转码wave之后的文件格式：</p>
<table>
<thead>
<tr>
<th>偏移地址</th>
<th>字节数</th>
<th>数据类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>00H ~ 23H</td>
<td>36</td>
<td>同上表的00H~23H一致</td>
<td></td>
</tr>
<tr>
<td>24H ~ 27H</td>
<td>4</td>
<td>char</td>
<td>“LIST”, LIST块标志，固定不变</td>
</tr>
<tr>
<td>28H ~ 2BH</td>
<td>4</td>
<td>long</td>
<td>LIST块占用的字节数，在这里为26字节</td>
</tr>
<tr>
<td>2CH ~ 45H</td>
<td>26</td>
<td>char</td>
<td>LIST块内容</td>
</tr>
<tr>
<td>46H ~ 49H</td>
<td>4</td>
<td>char</td>
<td>“data”, data数据块标志，固定不变</td>
</tr>
<tr>
<td>4AH ~ 4DH</td>
<td>4</td>
<td>long</td>
<td>wav文件音频数据所占大小</td>
</tr>
</tbody></table>
<h1 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MP3：Moving Picture Experts Group Audio Layer III, 动态影像专家压缩标准音频层面3</p>
<p>首先科普下部分概念：MPEG（Moving Pictures Experts Group ，动态图像专家组），简单理解就是一些研究音视频的专家发布的相关标准，其命名为MPEG-*（其中*代表数字或字母），例如MPEG-1、MPEG-2.5、MPEG-E等等。</p>
<p>可能有人会想MPEG-3是不是就是MP3呢？MPEG是针对音视频及系统测试的一整套的标准规范，其中对于MPEG1来讲，其part3音频部分规定了3个独立分层的音频编码格式，分别为layer Ⅰ、layer Ⅱ、layer Ⅲ，而layer Ⅲ也就是我们所说的MP3（MEPEG1 Layer Ⅲ），这三层的区别主要在于编码的算法及输出速率的区别。同样纵向来看，MPEG2、MPEG2.5同样有三个独立的layer，区别在于它们所使用的采样率更低了。</p>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>目前大多数标准MP3文件都支持ID3V2标准。具体组成格式为：ID3V2.3标签帧（1个）+ 数据帧（若干）+ ID3V1帧（1个），其中ID3V2.3 = 标签头（1个，必须） + 标签帧（若干，不必须） + 扩展标签头（不必须）</p>
<p>组成部分我画了一张示意图可以参考，每一部分下面将做详细解析</p>
<p>​    <img src="/images/linux/Audio/Audio-remeet-2.png" alt="pic"></p>
<h2 id="ID3标准"><a href="#ID3标准" class="headerlink" title="ID3标准"></a>ID3标准</h2><p>MP3帧头中除了存储一些象private、copyright、original的简单音乐说明信息以外，没有考虑存放歌名、作者、专辑名、年份 等复杂信息，而这些信息在MP3应用中非常必要。1996年，FricKemp在“Studio 3”项目中提出了在MP3文件尾增加一块用于存放歌曲的说明信息，形成了ID3标准</p>
<h2 id="标签头"><a href="#标签头" class="headerlink" title="标签头"></a>标签头</h2><p>标签头是由10Byte组成的，具体含义如下</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char Header[3];</td>
<td>必须为”ID3”否则认为标签不存在，如上图地址00—02部分为”49 44 33”，文本为“ID3”</td>
</tr>
<tr>
<td>char Ver;</td>
<td>版本号 ID3V2.3 就记录 3，如上图地址03处记录为”03”</td>
</tr>
<tr>
<td>char Revision;</td>
<td>副版本号此版本记录为 0</td>
</tr>
<tr>
<td>char Flag;</td>
<td>放标志的字节，一般为00abc00000a – 表示是否使用 Unsynchronisationb – 表示是否有扩展头部,一般没有(至少 Winamp 没有记录),所以一般也不设置c – 表示是否为测试标签(99.99%的标签都不是测试用的，所以一般也不设置)</td>
</tr>
<tr>
<td>char Size[4];</td>
<td>标签大小,包括标签头的 10 个字节和所有的标签帧的大小</td>
</tr>
</tbody></table>
<p>整个标签大小 :</p>
<p>ID3V2_frame_size = (int)(Size[0] &amp; 0x7F) &lt;&lt; 21 | (int)(Size[1] &amp; 0x7F) &lt;&lt; 14 | (int)(Size[2] &amp; 0x7F) &lt;&lt; 7 | (int)(Size[3] &amp; 0x7F) + 10;</p>
<h2 id="标签帧"><a href="#标签帧" class="headerlink" title="标签帧"></a>标签帧</h2><p>每个标签帧都有一个 10 个字节的帧头（虽然都是10字节，但是与标签头不是一个东西。标签头有且只有一个，而标签头每一个标签帧都有一个帧头）和至少一个字节的不固定长度的内容组成。</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char FrameID[4]</td>
<td>用四个字符标识一个帧，说明其内容</td>
</tr>
<tr>
<td>char Size[4]</td>
<td>帧内容的大小，不包括帧头，不得小于1</td>
</tr>
<tr>
<td>char Flags[2]</td>
<td>存放标志，只定义了6 位，此处不再说明</td>
</tr>
</tbody></table>
<p>常用帧标识：</p>
<p>TIT2：标题<br>TPE1：作者<br>TALB：专辑<br>TRCK： 音轨，格式：N/M，N表示专辑中第几首，M为专辑中歌曲总数<br>TYER：年份<br>TCON：类型<br>COMM：备注，格式：“eng\0备注内容”，其中eng表示所使用的语言<br>帧大小为四个字节所表示的整数大小。</p>
<h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p>数据帧由帧头和数据帧组成，对于每一帧数据都有一个帧头。</p>
<p>帧头长4字节，对于固定位率的MP3文件，所有帧的帧头格式一样其数据结构如下</p>
<p>typedef struct frameHeader<br>{<br>unsigned int sync1:8; //同步信息 1<br>unsigned int error_protection:1; //CRC 校验<br>unsigned int layer:2; //层<br>unsigned int version:2; //版本<br>unsigned int sync2:3; //同步信息 2<br>unsigned int extension:1; //版权<br>unsigned int padding:1; //填充空白字<br>unsigned int sample_rate_index:2; //采样率索引<br>unsigned int bit_rate_index:4; //位率索引<br>unsigned int emphasis:2; //强调方式<br>unsigned int original:1; //原始媒体<br>unsigned int copyright:1; //版权标志<br>unsigned int mode_extension:2; //扩展模式,仅用于联合立体声<br>unsigned int channel_mode:2; //声道模式<br>}FHEADER;</p>
<p>比特率为32的整数倍一般就是恒定编码，否则就是可变编码；可变编码帧头一般会有不同</p>
<h2 id="ID3V1标签帧"><a href="#ID3V1标签帧" class="headerlink" title="ID3V1标签帧"></a>ID3V1标签帧</h2><p>标签头是由128Byte组成的，具体含义如下</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char Header[3]</td>
<td>标签头必须是”TAG”否则认为没有标签</td>
</tr>
<tr>
<td>char Title[30]</td>
<td>标题</td>
</tr>
<tr>
<td>char Artist[30]</td>
<td>作者</td>
</tr>
<tr>
<td>char Album[30]</td>
<td>专集</td>
</tr>
<tr>
<td>char Year[4]</td>
<td>出品年代</td>
</tr>
<tr>
<td>char Comment[28]</td>
<td>备注</td>
</tr>
<tr>
<td>char reserve</td>
<td>保留</td>
</tr>
<tr>
<td>char track</td>
<td>音轨</td>
</tr>
<tr>
<td>char Genre;</td>
<td>类型</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
  </entry>
  <entry>
    <title>Opus Ogg详解</title>
    <url>/2023/01/04/Audio/Audio-opus/</url>
    <content><![CDATA[<h1 id="opus是什么"><a href="#opus是什么" class="headerlink" title="opus是什么"></a>opus是什么</h1><blockquote>
<p>以下内容取自opus官网：<a href="https://www.opus-codec.org/">https://www.opus-codec.org</a></p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Opus 是一种完全开放、免版税、用途广泛的音频编解码器。 Opus 在 Internet 上的交互式语音和音乐传输方面无与伦比，但也适用于存储和流媒体应用。它被互联网工程任务组 (IETF) 标准化为 RFC 6716，它结合了 Skype 的 SILK 编解码器和 Xiph.Org 的 CELT 编解码器的技术。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Opus 可以处理范围广泛的音频应用，包括 IP 语音、视频会议、游戏内聊天，甚至远程现场音乐表演。它可以从低比特率窄带语音扩展到非常高质量的立体声音乐。支持的功能有：</p>
<ul>
<li>比特率从 6 kb/s 到 510 kb/s</li>
<li>采样率从 8 kHz（窄带）到 48 kHz（全带）</li>
<li>帧大小从 2.5 ms 到 60 ms</li>
<li>支持恒定比特率 (CBR) 和可变比特率 (VBR)</li>
<li>从窄带到全带的音频带宽</li>
<li>支持语音和音乐</li>
<li>支持单声道和立体声</li>
<li>支持多达 255 个通道（多流帧）</li>
<li>动态可调比特率、音频带宽和帧大小</li>
<li>良好的丢包鲁棒性和丢包隐藏 (PLC)</li>
<li>浮点和定点实现</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>音频带宽。Opus编码器覆盖了低频段到高频段的全带音频</p>
</li>
<li><p>低延迟。延迟依赖于帧规格，Opus最低帧规格2.5ms，非常适合实时音视频场景</p>
</li>
</ul>
<h1 id="opus库"><a href="#opus库" class="headerlink" title="opus库"></a>opus库</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>编解码器libopus: <a href="https://www.opus-codec.org/docs/opus_api-1.2/index.html">https://www.opus-codec.org/docs/opus_api-1.2/index.html</a></p>
<p>封装器opusfile：<a href="https://www.opus-codec.org/docs/opusfile_api-0.7/index.html">https://www.opus-codec.org/docs/opusfile_api-0.7/index.html</a></p>
</blockquote>
<p>opus库包括三部分：libopus、opus-tools、opusfile</p>
<ul>
<li>libopus：opus编解码的源码和可执行文件（注意：这里编码出来的opus文件是播放不了的，并且解码也必须用那种播放不了的opus文件,后面解释为什么）</li>
<li>opus-tools：工具包，其中包含了libogg（.wav2.opus  /  .opus2.wav）</li>
<li>opusfile：将可播放的opus文件解码成wav的工具，可分析出这个可播放的opus文件的信息，其中包含了libogg</li>
</ul>
<h2 id="可播放opus与不可播放opus文件"><a href="#可播放opus与不可播放opus文件" class="headerlink" title="可播放opus与不可播放opus文件"></a>可播放opus与不可播放opus文件</h2><p>ogg文件里面包含了opus编码的音频，相当于MP4文件中包含了aac</p>
<ul>
<li>不可播放opus：只有编码层opus数据的音频（没有ogg的封装只经过libopus编码），后缀名是.opus</li>
<li>可播放的opus：opus编码的音频外部套用了一层ogg的封装（经过ogg的封装，opus-tools编码的文件），后缀名可以是.opus也可以是.ogg</li>
</ul>
<h1 id="opus结构"><a href="#opus结构" class="headerlink" title="opus结构"></a>opus结构</h1><p>每个 Opus 包以一个 TOC （Table of Contents）字节开头</p>
<table>
<thead>
<tr>
<th>配置数（config）</th>
<th>编码模式</th>
<th>音频带宽</th>
<th>帧长度</th>
</tr>
</thead>
<tbody><tr>
<td>0…3</td>
<td>SILK-only</td>
<td>NB</td>
<td>10, 20, 40, 60 ms</td>
</tr>
<tr>
<td>4…7</td>
<td>SILK-only</td>
<td>MB</td>
<td>10, 20, 40, 60 ms</td>
</tr>
<tr>
<td>8…11</td>
<td>SILK-only</td>
<td>WB</td>
<td>10, 20, 40, 60 ms</td>
</tr>
<tr>
<td>12…13</td>
<td>Hybrid</td>
<td>SWB</td>
<td>10, 20 ms</td>
</tr>
<tr>
<td>14…15</td>
<td>Hybrid</td>
<td>FB</td>
<td>10, 20 ms</td>
</tr>
<tr>
<td>16…19</td>
<td>CELT-only</td>
<td>NB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
<tr>
<td>20…23</td>
<td>CELT-only</td>
<td>WB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
<tr>
<td>24…27</td>
<td>CELT-only</td>
<td>SWB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
<tr>
<td>28…31</td>
<td>CELT-only</td>
<td>FB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
</tbody></table>
<p>立体声标志位（s）取值 0 表示单声道，1 表示多声道立体声。</p>
<p>TOC 中最后两位（c）表示：</p>
<ul>
<li>0：一个包中只有一帧音频。</li>
<li>1：一个包中有两帧音频，并且大小相同。</li>
<li>2：一个包中有两帧音频，但是大小不同。</li>
</ul>
<h1 id="opusfile-API"><a href="#opusfile-API" class="headerlink" title="opusfile API"></a>opusfile API</h1><blockquote>
<p>opusfile高级API官方文档：<a href="https://opus-codec.org/docs/opusfile_api-0.12/">https://opus-codec.org/docs/opusfile_api-0.12/</a></p>
<p>参考文档：</p>
<p>​	<a href="https://juejin.cn/post/6844903998831460360">https://juejin.cn/post/6844903998831460360</a></p>
<p>​	<a href="https://chenliang.org/2020/04/17/ogg-encapsulation-for-opus/">https://chenliang.org/2020/04/17/ogg-encapsulation-for-opus/</a></p>
</blockquote>
<ol>
<li><p><strong>op_open_file() / op_free()</strong></p>
<p>打开/关闭一个解码器</p>
</li>
<li><p><strong>op_head() / op_tags()</strong></p>
</li>
</ol>
<ul>
<li><p>op_head函数可用于获取channels、samplerate等参数</p>
</li>
<li><p>op_tags函数可获得用户自定义参数，例如：标题、歌手、编码方式标准等等，其中tags-&gt;user_comments[i]可获取用户自定义的信息</p>
</li>
</ul>
<ol start="3">
<li><strong>op_pcm_total() / op_pcm_tell() / op_pcm_seek()</strong></li>
</ol>
<ul>
<li>op_pcm_total 可以返回该opus文件转换成pcm文件后的总的pcm长度</li>
<li>op_pcm_tell 可以放回目前文件已经播放的pcm的长度</li>
<li>op_pcm_seek 可以通过参数指定让音频进行跳转播放</li>
</ul>
<ol start="4">
<li><strong>op_pcm_read()</strong></li>
</ol>
<p>   从op_open_file打开的文件流中读取pcm数据进行播放。注意解码的数量并不等于传入buffer的大小，需要使用到该函数的返回值</p>
<h1 id="Ogg"><a href="#Ogg" class="headerlink" title="Ogg"></a>Ogg</h1><blockquote>
<p> 参考 : <a href="https://juejin.cn/post/6844904016254599175">https://juejin.cn/post/6844904016254599175</a></p>
</blockquote>
<p>全称：OGGVobis(oggVorbis) 一个自由且开放标准的容器格式，“.ogg”结尾命名</p>
<p>OGG是以页（page）为单位将逻辑流组织链接起来，每个页都有pageheader和pagedata。</p>
<ol>
<li>capture_pattern页标识：ASCII字符，0x4f ‘O’ 0x67 ‘g’ 0x67 ‘g’ 0x53 ‘S’，4个字节大小，它标识着一个页的开始。</li>
<li>stream_structure_version版本id：一般当前版本默认为0，1个字节。</li>
<li>header_type_flag类型标识：标识当前的页的类型，1个字节， - 0x01：本页媒体编码数据与前一页属于同一个逻辑流的同一个packet，若此位没有设，表示本页是以一个新的packet开始的； - 0x02：表示该页为逻辑流的第一页，bos标识，如果此位未设置，那表示不是第一页； - 0x04：表示该页位逻辑流的最后一页，eos标识，如果此位未设置，那表示本页不是最后一页。</li>
<li>granule_position：媒体编码相关的参数信息，8个字节，对于音频流来说，它存储着到本页为止逻辑流在PCM输出中采样码的数目，可以由它来算得时间戳。对于视频流来说，它存储着到本页为止视频帧编码的数目。若此值为-1，那表示截止到本页，逻辑流的packet未结束。(小端)</li>
<li>serial_number：当前页中的流的id，4个字节，它是区分本页所属逻辑流与其他逻辑流的序号，我们可以通过这个值来划分流。(小端)</li>
<li>page_seguence_number：本页在逻辑流的序号，4个字节。</li>
<li>CRC_cbecksum：循环冗余效验码效验，4个字节，用来效验每页的有效性。</li>
<li>number_page_segments：给定本页在segment_table域中出现的segement个数，1个字节。</li>
<li>segment_table：从字面看它就是一个表，表示着每个segment的长度，取值范围是0~255。由segment（1个segment就是1个字节）可以得到packet的值，每个packet的大小是以最后一个不等于255的segment结束的，从页头中的segment_table可以得到每个packet长度，举例：如果一组segment依次顺序为FF 45 FF FF FF 40FF 05FF FF FF 66（共4个packet，含12个segment，每个packet的长度是：FF 45【324】；FF FF FF 40【829】；FF 05【260】；FF FF FF 66【847】），那么第一个packet的长度为255+69 = 324,第二个packet大小829，同理。</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
      <tags>
        <tag>opus</tag>
      </tags>
  </entry>
  <entry>
    <title>51job爬虫项目</title>
    <url>/2022/12/03/item/51job/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>紧接着豆瓣爬虫的项目，该项目作为其后的练习和扩展，算是一个较为不错的上手练习。本文所涉及的是对于51job数据的爬取、解析和保存。对于数据可视化操作，在后续会持续更新，请关注！<br>在下面代码中有些函数内部调用了其他函数，需要补全各个部分的函数。如果需要源码请私信或者评论。</p>
<blockquote>
<p>具体关于库的操作我选择了一些官方文档和较好理解的解读文章做链接，知识点比较全面请参考下列表。</p>
</blockquote>
<ul>
<li><p><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/">详情页URL获取模块：selenium</a></p>
</li>
<li><p><a href="https://requests.readthedocs.io/zh_CN/latest/">URL处理第三方模块：requests</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/9135d7833d6d">数据提取etree模块：lxml</a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.7/library/sqlite3.html">数据库保存模块：sqlite3</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/python-robot/p/9958352.html">本地文件保存模块：xlwt</a></p>
</li>
</ul>
<h1 id="数据爬取与解析"><a href="#数据爬取与解析" class="headerlink" title="数据爬取与解析"></a>数据爬取与解析</h1><h2 id="详情页链接的获取：selenium"><a href="#详情页链接的获取：selenium" class="headerlink" title="详情页链接的获取：selenium"></a>详情页链接的获取：selenium</h2><p>selenium作为web自动化测试工具，目前在python爬虫中应用也越来越广泛。其主要应用原理是：通过完全模拟浏览器的操作，比如输入框输入、点击超链接元素、下拉滚动条等等来拿到js渲染之后的代码。<br>必要性：之前用的requests是对一个页面发送请求，只能获得当前加载出来的部分页面即最初的源代码，动态加载的数据是获取不到的，比如js渲染后的代码、下拉滚轮得到的数据和一些框内隐藏元素等等。<br>对于selenium的解读，<a href="https://blog.csdn.net/heartbeat196/article/details/113831482">请点击click</a>！</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#获得所有网页详情页链接</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_link</span>():</span><br><span class="line">    linklist = []</span><br><span class="line">    <span class="comment">#创建驱动器对象</span></span><br><span class="line">    wd = webdriver.Chrome(<span class="string">r'C:\Program Files\Google\Chrome\Application\chromedriver.exe'</span>)</span><br><span class="line">    wd.implicitly_wait(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">#访问51job网站</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">        wd.get(<span class="string">f"https://search.51job.com/list/010000,000000,0000,00,9,99,keyword,2,<span class="subst">{i}</span>.html?"</span>)</span><br><span class="line">        <span class="comment">#查找每每一条信息链接进入详情页</span></span><br><span class="line">        joblists = wd.find_elements_by_xpath(<span class="string">'//div[@class="j_joblist"]/div/a'</span>)</span><br><span class="line">        <span class="keyword">for</span> joblist <span class="keyword">in</span> joblists:</span><br><span class="line">            con_link = joblist.get_attribute(<span class="string">"href"</span>)</span><br><span class="line">            linklist.append(con_link)</span><br><span class="line">    wd.quit()</span><br><span class="line">    <span class="keyword">return</span> linklist</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注释：</p>
<ol>
<li>代码中的 webdriver.Chrome，后面是自己所用的驱动器的本地地址。</li>
<li>webdriver对象wd，调用 get方法，后面括号内为自己所要访问的网页链接地址。</li>
</ol>
</blockquote>
<h2 id="数据爬取与解析：xpath"><a href="#数据爬取与解析：xpath" class="headerlink" title="数据爬取与解析：xpath"></a>数据爬取与解析：xpath</h2><p>由于自己习惯于使用xpath方法解析，在此只做xpath解析的方法，如果需要re正则表达式或者BeautifulSoup解析，评论后续会更新。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>():</span><br><span class="line">    job_information = []</span><br><span class="line">    url_lists = get_link()</span><br><span class="line">    <span class="keyword">for</span> i,url <span class="keyword">in</span> <span class="built_in">enumerate</span>(url_lists):</span><br><span class="line">        datalist=[]</span><br><span class="line">        header = {</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0(Windows NT 10.0;Win64;x64)AppleWebKit/537.36(KHTML,likeGecko)Chrome/88.0.4324.150Safari/537.36"</span></span><br><span class="line">        }</span><br><span class="line">        response = requests.get(url, headers=header)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            html = response.content.decode(<span class="string">"gbk"</span>)</span><br><span class="line">            data = etree.HTML(html)</span><br><span class="line">            link = url</span><br><span class="line">            datalist.append(link)		<span class="comment">#存入岗位链接</span></span><br><span class="line">            title = data.xpath(<span class="string">r'//div[@class="cn"]/h1/@title'</span>)[<span class="number">0</span>]</span><br><span class="line">            datalist.append(title)		<span class="comment">#存入岗位名称</span></span><br><span class="line">            salary = data.xpath(<span class="string">r'//div[@class="cn"]/strong/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">            datalist.append(salary)</span><br><span class="line">            information = data.xpath(<span class="string">r'//p[@class="msg ltype"]/@title'</span>)[<span class="number">0</span>]</span><br><span class="line">            information = re.sub(<span class="string">r"\s+"</span>, <span class="string">""</span>, information)  <span class="comment"># 去除空白格</span></span><br><span class="line">            experience = information.split(<span class="string">"|"</span>)[<span class="number">1</span>]</span><br><span class="line">            datalist.append(experience)</span><br><span class="line">            education = information.split(<span class="string">"|"</span>)[<span class="number">2</span>]</span><br><span class="line">            datalist.append(education)</span><br><span class="line">            num = information.split(<span class="string">"|"</span>)[<span class="number">3</span>]</span><br><span class="line">            datalist.append(num)</span><br><span class="line">            place = data.xpath(<span class="string">r'//p[@class="fp"]/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">            datalist.append(place)</span><br><span class="line">            treatment = data.xpath(<span class="string">r'//span[@class="sp4"]/text()'</span>)</span><br><span class="line">            treatment = <span class="string">" "</span>.join(treatment)</span><br><span class="line">            datalist.append(treatment)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"-----第{}条------"</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            job_information.append(datalist)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"-----第{}条出错，原因是{}------"</span>.<span class="built_in">format</span>(i,e))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">#print(job_information)		#测试</span></span><br><span class="line">    <span class="keyword">return</span> job_information</span><br></pre></td></tr></tbody></table></figure>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="Excel本地保存"><a href="#Excel本地保存" class="headerlink" title="Excel本地保存"></a>Excel本地保存</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_data_excel</span>(<span class="params">datalist</span>):</span><br><span class="line">    workbook = xlwt.Workbook(encoding=<span class="string">"gbk"</span>, style_compression=<span class="number">0</span>)</span><br><span class="line">    worksheet = workbook.add_sheet(<span class="string">"python"</span>)</span><br><span class="line">    col = [<span class="string">"链接"</span>, <span class="string">"岗位名称"</span>, <span class="string">"薪资"</span>, <span class="string">"工作经验"</span>, <span class="string">"学历"</span>, <span class="string">"招聘人数"</span>, <span class="string">"工作地点"</span>, <span class="string">"福利"</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">        worksheet.write(<span class="number">0</span>, i, col[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(datalist)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">            worksheet.write(i+<span class="number">1</span>,j,datalist[i][j])</span><br><span class="line">    workbook.save(<span class="string">"北京-python工作.xls"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Excel数据保存结果展示"><a href="#Excel数据保存结果展示" class="headerlink" title="Excel数据保存结果展示"></a>Excel数据保存结果展示</h2><p><img src="/images/item/51job-1.png" alt="在这里插入图片描述"></p>
<h2 id="sqlite数据库保存"><a href="#sqlite数据库保存" class="headerlink" title="sqlite数据库保存"></a>sqlite数据库保存</h2><p>在此部分只写了数据库保存的工作，数据库的初始化创建需函数sql_init需要添加即可使用。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_data_sql</span>(<span class="params">datalist,dbpath</span>):</span><br><span class="line">    sql_init(dbpath)</span><br><span class="line">    conn = sqlite3.connect(dbpath)</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datalist:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            data[index] = <span class="string">'"'</span> + data[index] + <span class="string">'"'</span></span><br><span class="line">        sql = <span class="string">'''</span></span><br><span class="line"><span class="string">        insert into job_information(</span></span><br><span class="line"><span class="string">            link,title,salary,experience,education,num,place,treatment)</span></span><br><span class="line"><span class="string">            values(%s)'''</span>%<span class="string">","</span>.join(data)</span><br><span class="line">        <span class="comment">#print(sql)     #测试sql语句是否正确</span></span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        conn.commit()</span><br><span class="line">    cur.close()</span><br><span class="line">    conn.close()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="sqlite数据库保存结果展示"><a href="#sqlite数据库保存结果展示" class="headerlink" title="sqlite数据库保存结果展示"></a>sqlite数据库保存结果展示</h2><p><img src="/images/item/51job-2.png" alt="在这里插入图片描述"></p>
<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p>null</p>
]]></content>
      <categories>
        <category>Item</category>
      </categories>
  </entry>
  <entry>
    <title>Audio-初识</title>
    <url>/2022/08/31/Audio/Audio-meet/</url>
    <content><![CDATA[<p>跳动的音符，婉转的节奏，悠扬的歌声……</p>
<p>音乐无疑是最能愉悦身心的方式之一，那么歌手的音调、音色是如何存储到手机中，又是如何通过喇叭播放出来的呢？</p>
<p>下面我将通过几篇博客阐述我对音频的理解及部分调试经验，本章主要介绍音频的的基础知识</p>
<h1 id="信号分类"><a href="#信号分类" class="headerlink" title="信号分类"></a>信号分类</h1><p>声音严格意义来讲应该被叫做声音信号，而在维基百科中对于<strong>信号</strong>的定义是<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E9%87%8F/9984692">表示消息的物理量</a>，这样就很好理解了声音信号就是以声音为载体的一个物理量。而自然界中信号可以有如下的分类</p>
<p><img src="/images/linux/Audio/Audio-meet-1.png" alt="signal"></p>
<p>因此，按照信号变化分类声音信号属于随机信号；按照信号特征分类声音信号属于模拟信号</p>
<h1 id="模数转换"><a href="#模数转换" class="headerlink" title="模数转换"></a>模数转换</h1><p>上一部分了解到声音是模拟信号，而对于计算机来讲其只能处理数字信号即0和1，所以必须需要将声音模拟信号转换成数字信号，而这个过程叫做模数转换（Analog Digital Conversion），相应的完成该功能的硬件单元就叫做模数转换器(ADC)</p>
<p>完成该过程需要三部曲分别是：采样、量化、编码，整体过程如下图：</p>
<p><img src="/images/linux/Audio/Audio-meet-2.png" alt="ADC"></p>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p><em>重要参数：采样率</em></p>
<ul>
<li>定义：在时间轴上对信号进行离散化</li>
<li>原理：按照一定的频率对模拟信号的瞬时时刻进行样本采集</li>
</ul>
<p>其实采样作用通俗理解就是是采集样本。由于模拟信号是连续的，理论上我们需要采集无数个点才能完整的还原该信号，但是一来无穷的概念是不可能满足的，二来我们其实并不需要这么高的采样率。我们听觉是有延迟的就和视频帧不停的刷新欺骗我们的眼睛是画面连续的是一个道理。</p>
<p>所以采样率越高，声音的还原就越真实越自然，人对频率的识别范围是 20HZ - 22000HZ, 如果每秒钟能对声音做 22000 个采样, 回放时就足可以满足人耳的需求. 所以 22050 的采样频率是常用的, 44100已是CD音质, 超过48000的采样对人耳已经没有意义。这和电影的每秒 24 帧图片的道理差不多。</p>
<h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p><em>相关参数：采样位数</em></p>
<ul>
<li><p>定义：在幅度轴上对信号进行数字化</p>
</li>
<li><p>原理：对采样点的幅度赋予具体的数值，该数值由n位二进制表征（n = 8 / 16 / 32）</p>
</li>
</ul>
<p>采样位数越高说明划分的等级越精细。较低的采样位数损失精度，较高的采样位数可能造成软硬件资源的浪费</p>
<blockquote>
<p>小常识：标准CD音乐的质量就是16bit、44.1KHz采样</p>
</blockquote>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>定义：按照一定的格式记录 采样 和 量化 后的数据。后续会对部分格式的存储格式进行分析</p>
<h3 id="编码分类"><a href="#编码分类" class="headerlink" title="编码分类"></a>编码分类</h3><blockquote>
<p> 该部分内容转自 <a href="https://www.jianshu.com/p/28d3f108ef63">https://www.jianshu.com/p/28d3f108ef63</a></p>
</blockquote>
<h4 id="波形编码"><a href="#波形编码" class="headerlink" title="波形编码"></a>波形编码</h4><ul>
<li>定义：不利用生成音频信号的任何参数，直接将 <strong>时间域信号</strong> 变换为 <strong>数字代码</strong>，使重构的语音波形尽可能地与原始语音信号的 波形形状 保持一致。</li>
<li>原理：在 <strong>时间轴</strong> 上对模拟语音信号按一定的速率抽样，然后将幅度样本分层量化，并用代码表示。</li>
</ul>
<h4 id="参数编码"><a href="#参数编码" class="headerlink" title="参数编码"></a>参数编码</h4><p>从语音 <strong>波形信号</strong> 中提取生成语音的参数，使用这些参数通过语音生成模型重构出语音，使重构的语音信号尽可能地保持原始语音信号的语意。也就是说，参数编码是把语音信号产生的数字模型作为基础，然后求出数字模型的模型参数，再按照这些参数还原数字模型，进而合成语音。</p>
<h4 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h4><p>混合编码是指同时使用两种或两种以上的编码方法进行编码。这种编码方法克服了波形编码和参数编码的弱点，并结合了波形编码高质量和参数编码的低编码率，能够取得比较好的效果。</p>
<ul>
<li><p>WAV编码（波形编码）</p>
<p>WAV是编码的一种实现方式（其实它有非常多实现方式，但都是不会进行压缩操作）。就是在源 <strong>PCM</strong> 数据格式的前面加上44个字节。分别用来描述 <strong>PCM</strong> 的采样率、声道数、数据格式等信息。</p>
</li>
<li><p>MP3编码</p>
<p>MP3编码具有不错的压缩比，而且听感也接近于WAV文件，当然在不同的环境下，应该调整合适的参数来达到更好的效果。</p>
</li>
<li><p>AAC编码</p>
</li>
</ul>
<p>  AAC是目前比较热门的有损压缩编码技术，并且衍生了LC-AAC、HE-AAC、HE-AAC v2 三种主要编码格式。</p>
<p>  <strong>LC-AAC：</strong>是比较传统的AAC,主要应用于中高码率的场景编码(&gt;= 80Kbit/s)<br>   <strong>HE-AAC：</strong> 主要应用于低码率场景的编码(&lt;= 48Kbit/s)</p>
<ul>
<li><p>Ogg编码（有损）</p>
<p>Ogg编码是一种非常有潜力的编码，在各种码率下都有比较优秀的表现。尤其在低码率场景下。Ogg除了音质好之外，Ogg的编码算法也是非常出色。可以用更小的码率达到更好的音质。128Kbit/s的Ogg比192Kbit/s甚至更高码率的MP3更优质.但目前由软件还是硬件支持问题,都没法达到与MP3的使用广度.</p>
</li>
</ul>
<h1 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h1><p>一段悠扬的音乐经过采样、量化、编码就保存数字信号文件，而我们最终的目的一定不是只存成文件而是通过文件形式传播让更多人听到该音乐，因此一定存在DA转换，即还原数字信号为模拟信号的过程。那么在整个过程中有哪些参数表征了音频重要的信息呢？</p>
<p>不仅限于webrtc、ffmpeg、libmad等等音频编解码库，对于所有编解码器和codec来讲，音频源数据的三个参数至关重要：<strong>声道channel、采样率sampleRate、采样位数sampleBit</strong>。这三个参数之所以重要是因为有这几个参数就可以准确的知道一个裸的音频数据（PCM）的全部信息了。</p>
<h2 id="声道"><a href="#声道" class="headerlink" title="声道"></a>声道</h2><p>声道是指音频文件在录制时音源的数量位置和播放时相应的扬声器的数量（百度百科）。所以可想而知，其他参数相同的情况下，声道数越多定位越精准，同样所需扬声器和功放组件越多。</p>
<ul>
<li>单声道（mono）</li>
<li>双声道（stereo 立体声）：左声道 + 右声道，低音不分离，应用于音乐播放较多</li>
<li>2.1声道 ：左声道 + 右声道， 低音分离</li>
<li>5.1声道 ：左声道 + 右声道 + 低音声道 + 中央声道 + 左环绕 + 右环绕，应用于类传统影院和家庭影院中</li>
<li>7.1声道 ：左声道 + 右声道 + 低音声道 + 中央声道 + 左环绕 + 右环绕 + 左后环 + 右后环，常见的包括：Dolby Surround 7.1杜比7.1环绕声</li>
</ul>
<h2 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h2><p>采样率可以理解为采集样本的速率（故也可以称为采样速度或者采样频率），它定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。</p>
<p>例如：采样率为44100，意味着每秒钟对连续的声音信号采集44100次，同样对应得到的数字信号每秒的样本数量（具体可以参考采样过程）</p>
<h2 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h2><p>采样位数就是指某一瞬时时刻，量化声音大小（精细程度）的计量单位</p>
<ul>
<li>8bit ( 1Byte ) 对应0~255，将振幅划分为256个等级</li>
<li>16bit (2Byte) 对应0~65535，将振幅划分为65536个等级</li>
</ul>
<h2 id="样本格式"><a href="#样本格式" class="headerlink" title="样本格式"></a>样本格式</h2><h3 id="样本组合形式"><a href="#样本组合形式" class="headerlink" title="样本组合形式"></a>样本组合形式</h3><ul>
<li>交错模式：每个声道的样本数据交错存储排布</li>
<li>平面模式：每个声道的样本数据分开存储</li>
</ul>
<p>下面以stereo模式进行图示解释（C代表Channel）：</p>
<p>​    <img src="/images/linux/Audio/Audio-meet-3.png" alt="sample"></p>
<h3 id="FFmpeg-样本组织形式介绍"><a href="#FFmpeg-样本组织形式介绍" class="headerlink" title="FFmpeg 样本组织形式介绍"></a>FFmpeg 样本组织形式介绍</h3><ul>
<li>Packed格式，frame.data[0]包含所有的音频数据。</li>
<li>Planar格式，frame.data[i]表示第i个声道的数据（假设声道0是第一个）</li>
</ul>
<h3 id="FFmpeg-主要样本格式"><a href="#FFmpeg-主要样本格式" class="headerlink" title="FFmpeg 主要样本格式"></a>FFmpeg 主要样本格式</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AVSampleFormat</span> {</span></span><br><span class="line">    AV_SAMPLE_FMT_NONE = <span class="number">-1</span>,</span><br><span class="line">    AV_SAMPLE_FMT_U8,          <span class="comment">///&lt; unsigned 8 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S16,         <span class="comment">///&lt; signed 16 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S32,         <span class="comment">///&lt; signed 32 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_FLT,         <span class="comment">///&lt; float</span></span><br><span class="line">    AV_SAMPLE_FMT_DBL,         <span class="comment">///&lt; double</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_U8P,         <span class="comment">///&lt; unsigned 8 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S16P,        <span class="comment">///&lt; signed 16 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S32P,        <span class="comment">///&lt; signed 32 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_FLTP,        <span class="comment">///&lt; float, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_DBLP,        <span class="comment">///&lt; double, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S64,         <span class="comment">///&lt; signed 64 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S64P,        <span class="comment">///&lt; signed 64 bits, planar</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_NB           <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>说明：以P为结尾的是planar结构；Planar模式是FFmpeg内部存储模式，我们实际使用的音频文件都是Packed模式的。</p>
<h2 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h2><p>比特率指的是单位时间播放连续的媒体如压缩后的音频或视频的比特数量，在这个意义上讲，它相当于术语数字带宽消耗量，或吞吐量。单位bps / Kbps（bit per second）这里是bit而不是Byte（1Byte = 8bit）</p>
<p>虽然经常作为“速度”的参考，比特率并不测量“‘距离’/时间”，而是被传输或者被处理的“‘二进制码数量’/时间”，所以应该把它和传播速度区分开来，传播速度依赖于传输的介质并且有通常的物理意义。（来自维基百科）</p>
<h2 id="参数关系"><a href="#参数关系" class="headerlink" title="参数关系"></a>参数关系</h2><p>对于PCM裸数据： 文件时长 ≈（文件总大小 - 头信息）/ (采样率 * 采样位数 * 通道数 / 8) [也就是比特率]</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Audio</category>
      </categories>
  </entry>
  <entry>
    <title>计算机存储体系</title>
    <url>/2023/02/07/computerSystem/%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>作为计算机五大核心功能（运算、存储、控制、输入、输出）之一的存储，无疑在整个计算机体系结构中有着举足轻重的地位。</p>
<p>存储器属于计算机的记忆装置，用于存放程序和数据。在我看来程序是作为计算机的灵魂而存在的，它指导了计算机的一切行为，而数据则是这一切行为的基石。</p>
<p>本文将基于存储器对计算机的存储系统做简要介绍</p>
<h1 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h1><p><img src="/images/computerSystem/storage/storage-0.png" alt="image"></p>
<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="/images/computerSystem/storage/storage-1.png" alt="image"></p>
<h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>通过存储器分类图不难看出存储器的种类繁多，而如何合理的使用每一种存储器组成庞大的存储体系结构无不体现着工程师们的智慧。</p>
<p>存储系统设计的核心问题在于：<strong>成本（存储1bit）、容量、速度三者平衡</strong>。恰好这三者之间又是相互矛盾的，主要体现在：容量越高，成本越低，而速度越慢；速度越块，成本就越高（其它情况可根据 2.2金字塔章节 理解），因此平衡成了关键。因此存储体系结构设计目的可总结为：将各种不同的器件组合成一个体系，让各种器件扬长避短，从而形成一种快速、大容量、低成本的内存系统</p>
<p>通过优化存储系统的组织来使得针对典型应用平均访存时间最短</p>
<h2 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h2><p><img src="/images/computerSystem/storage/storage-2.png" alt="image"></p>
<p>越靠近金字塔顶，距离处理器越近，访问速度就越快，造价也就越高，同时容量也会更小</p>
<table>
<thead>
<tr>
<th></th>
<th>存储器种类</th>
<th>硬件（存储1bit）</th>
<th>速度</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>触发器</td>
<td>十几个晶体管</td>
<td>300ps</td>
</tr>
<tr>
<td>缓存</td>
<td>sram</td>
<td>6个晶体管</td>
<td>L1-1ns；L2-10ns</td>
</tr>
<tr>
<td>内存</td>
<td>dram</td>
<td>1个mos管+1个电容</td>
<td>100ns</td>
</tr>
<tr>
<td>硬盘</td>
<td>flash/磁性存储…</td>
<td>/</td>
<td>SSD-25us；HDD-5ms</td>
</tr>
</tbody></table>
<p>通过表格可以发现内存的组成有电容的存在，因此不再是单纯的逻辑电路更不能用CMOS工艺制造，而SRAM却可以。这也就是为什么缓存可以集成到芯片内部，而内存是和芯片分开制造的。</p>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>storage system</tag>
      </tags>
  </entry>
  <entry>
    <title>豆瓣电影Top250数据爬取、数据分析及数据可视化</title>
    <url>/2022/12/03/item/doubanTop250Spider/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在爬虫学习中，一套完整的项目实战对于代码和计算机思维能力有很大的提升。本文基于B站视频<a href="https://www.bilibili.com/video/BV12E411A7ZQ?from=search&amp;seid=4741588992451392787">《Python爬虫基础5天速成（2021全新合集）Python入门+数据可视化》</a>关于 “豆瓣电影Top250” 项目做出的总结、拓展与分享。<br>在本文中，只展示数据爬取到数据保存的工作，数据可视化部分只做部分分析和结果展示。具体关于库的操作我选择了一些官方文档做链接，知识点比较全面请参考下列表。如果想要项目源代码，请评论或私信。</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.7/library/urllib.html?highlight=urllib">URL处理系统模块：urllib</a></li>
<li><a href="https://requests.readthedocs.io/zh_CN/latest/">URL处理第三方模块：requests</a></li>
<li><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/">数据提取bs4模块：BeautifulSoup</a></li>
<li><a href="https://docs.python.org/zh-cn/3.7/library/re.html">数据提取正则表达式模块：re</a></li>
<li><a href="https://www.jianshu.com/p/9135d7833d6d">数据提取模块 ：lxml</a></li>
<li><a href="https://docs.python.org/zh-cn/3.7/library/sqlite3.html">数据库保存模块：sqlite3</a></li>
<li><a href="https://www.cnblogs.com/python-robot/p/9958352.html">本地文件保存模块：xlwt</a></li>
</ul>
<h1 id="数据爬取与解析"><a href="#数据爬取与解析" class="headerlink" title="数据爬取与解析"></a>数据爬取与解析</h1><h2 id="数据爬取"><a href="#数据爬取" class="headerlink" title="数据爬取"></a>数据爬取</h2><p>数据爬取工作是整个工程的第一步，这一阶段所要做的工作是将网页上带有我们需要的信息的网页源码抓取下来。<strong>建议在此步骤时，如果数据量不大全部抓取保存到本地；如果数据量很大，则先保存一组到多组数据到本地</strong>。在接下的数据解析时通过本地文件解析，这样做会避免后面多次访问网站而被封ip，当然针对被封ip有相应的解决办法，但是这些内容涉及到网络知识，建议后面再学。</p>
<h3 id="urllib方法"><a href="#urllib方法" class="headerlink" title="urllib方法"></a>urllib方法</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">base_url = <span class="string">"https://movie.douban.com/top250?start="</span></span><br><span class="line">header = {</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">#构建请求</span></span><br><span class="line">req = urllib.request.Request(url=base_url,headers=header)</span><br><span class="line"><span class="comment">#得到响应</span></span><br><span class="line">response = urllib.request.urlopen(req)</span><br><span class="line">html = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="requests方法"><a href="#requests方法" class="headerlink" title="requests方法"></a>requests方法</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">base_url = <span class="string">"https://movie.douban.com/top250?start="</span></span><br><span class="line">header = {</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"</span></span><br><span class="line">}</span><br><span class="line">response = requests.get(url=base_url,headers=header)</span><br><span class="line">data = response.content.decode()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h2><p>数据解析作为第二步是整个工程的核心，这一步直接决定了 我们是否能够在海量的数据中只得到我们想要的数据。爬虫中三种重要的数据解析的方法分别是：BeautifulSoup、re正则表达式和xpath，三种方法没有优劣好坏，按照我前面给出的文档，自己用好一种即可满足需求，当然三种方法根据场景使用是最高效的，如果你是大佬的话👍。<br>我自己常用的是xpath方法。第一，xpath路径可以直接在网页上进行复制；第二，可以通过<a href="https://blog.csdn.net/heartbeat196/article/details/113790232">XPath Helper工具</a>进行更好的测试，我在之前的博客有提到可以<a href="https://blog.csdn.net/heartbeat196/article/details/113790232">点击</a>查看。下面我用三种不同的方法对保存到本地的一页上的数据进行了解析。</p>
<h3 id="BeaufifulSoup"><a href="#BeaufifulSoup" class="headerlink" title="BeaufifulSoup"></a>BeaufifulSoup</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#将要解析的网站打开</span></span><br><span class="line">html = <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"rb"</span>)</span><br><span class="line"><span class="comment">#构建BeautifulSoup对象</span></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">"html.parser"</span>)</span><br><span class="line"><span class="comment">#得到每一块的内容</span></span><br><span class="line">blocks = soup.select(<span class="string">".grid_view .item"</span>)</span><br><span class="line"><span class="comment">#构建电影列表</span></span><br><span class="line">movie_list = []</span><br><span class="line"><span class="comment">#电影链接和电影图片链接</span></span><br><span class="line"><span class="keyword">for</span> index,block <span class="keyword">in</span> <span class="built_in">enumerate</span>(blocks):</span><br><span class="line">    movie_dict = {}</span><br><span class="line">    movie_dict[<span class="string">"movie_href"</span>] = block.select(<span class="string">"a"</span>)[<span class="number">0</span>].get(<span class="string">"href"</span>)       <span class="comment">#电影详情页链接</span></span><br><span class="line">    movie_dict[<span class="string">"pic_href"</span>] = block.select(<span class="string">"img"</span>)[<span class="number">0</span>].get(<span class="string">"src"</span>)        <span class="comment">#电影链接</span></span><br><span class="line">    title = block.select(<span class="string">".title"</span>)                      <span class="comment">#电影名字</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(title)==<span class="number">2</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = block.select(<span class="string">".title"</span>)[<span class="number">0</span>].text            <span class="comment">#电影中文名字</span></span><br><span class="line">        o_title = block.select(<span class="string">".title"</span>)[<span class="number">1</span>].text            <span class="comment"># 电影中文名字</span></span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = o_title.replace(<span class="string">"/"</span>,<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = block.select(<span class="string">".title"</span>)[<span class="number">0</span>].text            <span class="comment">#电影中文名字</span></span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = <span class="string">" "</span>                                       <span class="comment">#电影外文名字</span></span><br><span class="line">    movie_dict[<span class="string">"rate"</span>] = block.select(<span class="string">".star .rating_num"</span>)[<span class="number">0</span>].text        <span class="comment">#电影评分</span></span><br><span class="line">    movie_dict[<span class="string">"judge"</span>] = block.select(<span class="string">".star span"</span>)[<span class="number">3</span>].text[:-<span class="number">3</span>]         <span class="comment">#评分人数</span></span><br><span class="line">    bd = block.select(<span class="string">".bd p"</span>)[<span class="number">0</span>].text</span><br><span class="line">    movie_dict[<span class="string">"bd"</span>] = re.sub(<span class="string">" "</span>,<span class="string">""</span>,bd)</span><br><span class="line">    movie_dict[<span class="string">"inq"</span>] = block.select(<span class="string">".quote .inq"</span>)[<span class="number">0</span>].text.replace(<span class="string">"。"</span>,<span class="string">""</span>)</span><br><span class="line">    movie_list.append(movie_dict)</span><br><span class="line"><span class="comment">#打印测试</span></span><br><span class="line"><span class="built_in">print</span>(movie_list)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#将要解析的网站打开</span></span><br><span class="line">html = <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"rb"</span>)</span><br><span class="line">content = html.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment">#构建etree对象</span></span><br><span class="line">data = etree.HTML(content)</span><br><span class="line"><span class="comment">#获取多个电影信息列表</span></span><br><span class="line">divs = data.xpath(<span class="string">'//div[@class="item"]'</span>)</span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    movie_dict = { }</span><br><span class="line">    movie_dict[<span class="string">"movie_href"</span>] = div.xpath(<span class="string">'div[@class="pic"]/a/@href'</span>)</span><br><span class="line">    <span class="comment">#print(movie_href)          #测试</span></span><br><span class="line">    movie_dict[<span class="string">"pic_href"</span>] = div.xpath(<span class="string">'div[@class="pic"]//img/@src'</span>)</span><br><span class="line">    <span class="comment">#print(pic_href)           #测试</span></span><br><span class="line">    title = div.xpath(<span class="string">'div[@class="info"]//a/span[@class="title"]/text()'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(title)==<span class="number">2</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = title[<span class="number">0</span>]</span><br><span class="line">        o_title = title[<span class="number">1</span>].replace(<span class="string">"/"</span>,<span class="string">""</span>)</span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = <span class="string">""</span>.join(o_title.split())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = title[<span class="number">0</span>]</span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = <span class="string">" "</span></span><br><span class="line">    <span class="comment">#print(c_title,o_title)      #测试</span></span><br><span class="line">    movie_dict[<span class="string">"rate"</span>] = div.xpath(<span class="string">'div//div[2]/div/span[2]/text()'</span>)</span><br><span class="line">    <span class="comment">#print(rate)                #测试</span></span><br><span class="line">    judge = div.xpath(<span class="string">'div//div[2]/div/span[4]/text()'</span>)</span><br><span class="line">    movie_dict[<span class="string">"judge"</span>] = (<span class="built_in">str</span>(judge))[<span class="number">2</span>:-<span class="number">5</span>]</span><br><span class="line">    <span class="comment">#print(judge)                #测试</span></span><br><span class="line">    bd = <span class="built_in">str</span>(div.xpath(<span class="string">'div//div[@class="bd"]/p[1]/text()'</span>))</span><br><span class="line">    movie_dict[<span class="string">"bd"</span>] = bd.replace(<span class="string">" "</span>,<span class="string">""</span>).replace(<span class="string">r"\xa0"</span>,<span class="string">""</span>).replace(<span class="string">r"\r"</span>,<span class="string">""</span>).replace(<span class="string">r"\n"</span>,<span class="string">""</span>)</span><br><span class="line">    <span class="comment">#print(bd)                   #测试</span></span><br><span class="line">    <span class="built_in">print</span>(movie_dict)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="re正则表达式"><a href="#re正则表达式" class="headerlink" title="re正则表达式"></a>re正则表达式</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment">#影片详情链接规则</span></span><br><span class="line">findLink = re.<span class="built_in">compile</span>(<span class="string">r'&lt;a href="(.*?)"&gt;'</span>)        <span class="comment">#创建正则表达式对象，表示规则（字符串的模式）</span></span><br><span class="line"><span class="comment">#影片图片规则</span></span><br><span class="line">findSrclink = re.<span class="built_in">compile</span>(<span class="string">r'&lt;img.*src="(.*?)"'</span>,re.S)</span><br><span class="line"><span class="comment">#影片片名规则</span></span><br><span class="line">findTitle = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span class="title"&gt;(.*)&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#影片的评分规则</span></span><br><span class="line">findGrade = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span class="rating_num" property="v:average"&gt;(.*)&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#评价人数规则</span></span><br><span class="line">findJud = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span&gt;(.*)人评价&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#找到概况</span></span><br><span class="line">findInq = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span class="inq"&gt;(.*)&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#影片相关内容</span></span><br><span class="line">findBd = re.<span class="built_in">compile</span>(<span class="string">r'&lt;p class=""&gt;(.*?)&lt;/p&gt;'</span>,re.S)</span><br><span class="line"><span class="comment">#将要解析的网站打开</span></span><br><span class="line">html = <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"rb"</span>)</span><br><span class="line">content = html.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">datalist = []</span><br><span class="line">soup = BeautifulSoup(content, <span class="string">"html.parser"</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> soup.find_all(<span class="string">"div"</span>,class_ = <span class="string">"item"</span>):</span><br><span class="line">    item = <span class="built_in">str</span>(item)</span><br><span class="line">    <span class="comment">#print(html)                                             #测试电影信息的一小段有没有内解析拿到</span></span><br><span class="line">    data = [ ]</span><br><span class="line">    title = re.findall(findTitle,item)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(title)==<span class="number">2</span>):</span><br><span class="line">        Ctitle = title[<span class="number">0</span>]</span><br><span class="line">        data.append(Ctitle)</span><br><span class="line">        Ftitle = title[<span class="number">1</span>]</span><br><span class="line">        Ftitle = title[<span class="number">1</span>].replace(<span class="string">"/"</span>, <span class="string">""</span>)</span><br><span class="line">        Ftitle = <span class="string">""</span>.join(Ftitle.split())</span><br><span class="line">        data.append(Ftitle)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Ctitle = title[<span class="number">0</span>]</span><br><span class="line">        data.append(Ctitle)</span><br><span class="line">        Ftitle = <span class="string">" "</span></span><br><span class="line">        data.append(Ftitle)</span><br><span class="line">    link = re.findall(findLink,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(link)</span><br><span class="line">    srclink = re.findall(findSrclink,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(srclink)</span><br><span class="line">    grade = re.findall(findGrade,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(grade)</span><br><span class="line">    judge = re.findall(findJud,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(judge)</span><br><span class="line">    inq = re.findall(findInq,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(inq)</span><br><span class="line">    bd = re.findall(findBd,item)[<span class="number">0</span>]</span><br><span class="line">    bd = re.sub(<span class="string">'&lt;br(\s+)?/&gt;(\s+)?'</span>,<span class="string">" "</span>,bd)</span><br><span class="line">    bd = re.sub(<span class="string">"/"</span>,<span class="string">" "</span>,bd)</span><br><span class="line">    bd = <span class="string">""</span>.join(bd.split())</span><br><span class="line">    data.append(bd)</span><br><span class="line">    datalist.append(data)</span><br><span class="line"><span class="built_in">print</span>(datalist)            <span class="comment">#测试所有列表是否被打印</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="本地excel保存"><a href="#本地excel保存" class="headerlink" title="本地excel保存"></a>本地excel保存</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line">workbook = xlwt.Workbook(encoding=<span class="string">"utf-8"</span>, style_compression=<span class="number">0</span>)</span><br><span class="line">worksheet = workbook.add_sheet(<span class="string">"豆瓣电影250"</span>)</span><br><span class="line">col = [<span class="string">"中文名"</span>, <span class="string">"外文名"</span>, <span class="string">"电影链接"</span>, <span class="string">"图片链接"</span>, <span class="string">"评分"</span>, <span class="string">"评价人数"</span>, <span class="string">"概评"</span>, <span class="string">"概述"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">    worksheet.write(<span class="number">0</span>, i, col[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(datalist)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">        worksheet.write(i + <span class="number">1</span>, j, datalist[i][j])</span><br><span class="line">workbook.save(<span class="string">"豆瓣top250_firstPage.xls"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="sqlite数据库保存"><a href="#sqlite数据库保存" class="headerlink" title="sqlite数据库保存"></a>sqlite数据库保存</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_db</span>(<span class="params">dbpath</span>):</span><br><span class="line">    sql = <span class="string">'''</span></span><br><span class="line"><span class="string">        create table movie250 </span></span><br><span class="line"><span class="string">        (</span></span><br><span class="line"><span class="string">        id integer primary key autoincrement,</span></span><br><span class="line"><span class="string">        info_link text,</span></span><br><span class="line"><span class="string">        pic_link text,</span></span><br><span class="line"><span class="string">        cname varchar,</span></span><br><span class="line"><span class="string">        ename varchar,</span></span><br><span class="line"><span class="string">        score numeric ,</span></span><br><span class="line"><span class="string">        rated numeric ,</span></span><br><span class="line"><span class="string">        instroduction text,</span></span><br><span class="line"><span class="string">        info text</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    '''</span>  <span class="comment"># 创建数据表</span></span><br><span class="line">    conn = sqlite3.connect(dbpath)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    conn.commit()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">saveData2DB</span>(<span class="params">datalist, dbpath</span>):</span><br><span class="line">    <span class="comment">#init_db(dbpath)</span></span><br><span class="line">    conn = sqlite3.connect(dbpath)</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datalist:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        	data[index] = <span class="string">'"'</span> + data[index] + <span class="string">'"'</span></span><br><span class="line">        sql = <span class="string">'''</span></span><br><span class="line"><span class="string">                insert into movie250 (</span></span><br><span class="line"><span class="string">                info_link,pic_link,cname,ename,score,rated,instroduction,info) </span></span><br><span class="line"><span class="string">                values(%s)'''</span> % <span class="string">","</span>.join(data)</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        conn.commit()</span><br><span class="line">    cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line">saveData2DB(datalist,<span class="string">"movie.db"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="/images/item/douban-1.png" alt="在这里插入图片描述"><br><img src="/images/item/douban-2.png" alt="在这里插入图片描述"></p>
<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a><a href="https://dormousehole.readthedocs.io/en/latest/">Flask</a></h2><p>Flask 是一个微型的 Python 开发的 Web 框架，基于Werkzeug WSGI工具箱和Jinja2 模板引擎。 Flask使用BSD授权。 Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数据库、窗体验证工具。<br>简单来说在此项目中，Flask框架给我们提供了一个本地网页平台展示数据。我们根据不同的路由地址进行到不同的页面访问。如下图是首界面，通过不同的链接地址可以实现页面跳转，当然只是本地！<br><img src="/images/item/douban-3.png" alt="在这里插入图片描述"></p>
<h2 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a><a href="https://echarts.apache.org/en/index.html">Echarts</a></h2><p>Echarts是一个纯基于js的图表库，可以流畅的运行在 PC 和移动设备上。在本项目中可以将数据进行统计分类从而用不同的展示方法进行展现。在Echarts中可以支持的图表类型有很多，同时其有一个很好的点在于它能满足我们实时修改查看，最终形成自己想要的图，便将js代码复制粘贴到我们所需要的网页代码的地方。<br>由于在页面内有动态显示，所以不在进行展示。</p>
<h2 id="WordCloud"><a href="#WordCloud" class="headerlink" title="WordCloud"></a>WordCloud</h2><p>词云展示方法是近些年来较为常用的数据可视化方法。其主要是通过分词技术将一篇文章或者一段话分成若干单词，然后统计这些词出现的频率，我们根据自定义化设置画布和这些词出现的颜色大小等等来得到某个词云。词云中重要的是画布的配置、自己所要定义的形式是什么样子，其他更多的是某些固定的方法。下图为我通过爬取毛不易的歌词内容获得毛不易的歌词词云图，如果需要此项目源码或者方法请私信。<br><img src="/images/item/douban-4.png" alt="在这里插入图片描述"></p>
<h1 id="新手问题总结与解决方法"><a href="#新手问题总结与解决方法" class="headerlink" title="新手问题总结与解决方法"></a>新手问题总结与解决方法</h1><h2 id="ip被封"><a href="#ip被封" class="headerlink" title="ip被封"></a>ip被封</h2><p>ip被封可能是新手在爬虫学习阶段遇到的最大的问题。首先如果是初学想要尽快实现一些成果时，建议在合理范围内减少爬取次数，如果我们能获得网页内容了首先将其存到本地文件夹下进行后续的测试和解析。俗话说：上有政策下有对策，面对ip被封：基础阶段我们可以添加请求头，尽可能的进行伪装像一个浏览器在访问；再进一步我们可以自己构建代理ip函数，仿照源码添加免费ip，构建handler处理器使用opener方法也可以；如果有能力的话，可以学习代理ip池的方法来解决该问题。<br>当然，爬虫我们是要在合法范围内进行抓取，如果某些数据是机密或者不能访问的，我们还一直访问可能就很快有自己的小手镯子了🔓。我们只爬取我们可以访问到的，爬虫只是提高效率，不是翻过禁墙。</p>
<h2 id="查看网页源码和”F12-Elements”后不一致"><a href="#查看网页源码和”F12-Elements”后不一致" class="headerlink" title="查看网页源码和”F12 Elements”后不一致"></a>查看网页源码和”F12 Elements”后不一致</h2><p>该问题可以总结为用一般方法有些需要的元素抓取不到。在本次项目中我们爬取的页面是静态网页所以可以直接抓取，但是对于动态网页就会无能为力。<br>查看网页源码：最原始的代码，指的是服务器直接发送到浏览器的代码。<br>F12检查元素：js渲染后的代码。而确实的部分就是js所渲染的。<br>如果我们想要抓取这部分代码可以采取以下两种方法：</p>
<ol>
<li>在页面上进行抓包，获取表单的元素和js链接提交请求</li>
<li>通过selenium技术，模拟用户打开网页，进行自动化的抓取。</li>
</ol>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>以上两个问题是我在这个项目中所遇到的，当然在面对更复杂的爬虫工作时，会有更加繁琐的问题出现。还有一些其他问题，我将其总结为基础知识问题。在很多初学的时候，我们获得的数据往往以不同的格式进行存储，但是某些方法只能针对某些固定数据格式，这些需要我们提起注意；还有就是我们不可避免的马虎问题，关键词拼写错误，变量书写错误等等，这些最好的解决办法就是孰能生巧。<br>最后就是建议大家在完成一个项目时选择分块按照不同的模块去练习测试，最终完成项目。</p>
]]></content>
      <categories>
        <category>Item</category>
      </categories>
  </entry>
  <entry>
    <title>硬件随机数测试方法</title>
    <url>/2022/11/26/third-party/DTRNG_Test/</url>
    <content><![CDATA[<h1 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h1><p>配置芯片DTRNG硬件单元寄存器生成一定数量的数据，保存成二进制文件，使用NIST测试套件进行验证得到是否随机的结论。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol>
<li>DTRNG：Digital True Random Number Generator，数字真随机数发生器</li>
<li>NIST：National Institude of Standards and Technology，国家标准技术研究所</li>
<li>NIST-sts (Statistical Test Suite)，统计测试套件：</li>
</ol>
<ul>
<li><p>源码链接：<a href="https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software%EF%BC%88Download%E5%8D%B3%E5%8F%AF%EF%BC%89">https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software（Download即可）</a></p>
</li>
<li><p>文档链接：<a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf">https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf</a></p>
</li>
<li><p>windows安装</p>
<p>官网的软件包是Linux系统下开发的，Windows系统需要先下一个<a href="https://cygwin.com/install.html">cygwin软件</a>来辅助使用</p>
<p>可以参考博客：<a href="https://blog.csdn.net/weixin_39928192/article/details/89256576">https://blog.csdn.net/weixin_39928192/article/details/89256576</a>?</p>
</li>
<li><p>Linux安装</p>
<p>进入工程文件夹sts-2.1.2直接make即可，得到 assess 可执行程序</p>
</li>
</ul>
<h1 id="随机测试项"><a href="#随机测试项" class="headerlink" title="随机测试项"></a><strong>随机测试项</strong></h1><p>每一个测试项的解读：<a href="https://blog.csdn.net/lafu5137/article/details/79593845">https://blog.csdn.net/lafu5137/article/details/79593845</a></p>
<ol>
<li>The Frequency (Monobit) Test，频率检测。该检验主要是看0和1在整个序列中所占的比例（基础检测）</li>
<li>Frequency Test within a Block，块内频率检测</li>
<li>The Runs Test，游程检测。游程指的是一个没有间断的相同数序列</li>
<li>Tests for the Longest-Run-of-Ones in a Block，块内最长游程检测</li>
<li>The Binary Matrix Rank Test，二元矩阵秩检测</li>
<li>The Discrete Fourier Transform (Spectral) Test，离散傅立叶变换检测</li>
<li>The Non-overlapping Template Matching Test，非重叠模块匹配检测</li>
<li>The Overlapping Template Matching Test，重叠模块匹配检测</li>
<li>Maurer’s “Universal Statistical” Test，Maurer的通用检测统计</li>
<li>The Linear Complexity Test，线性复杂度检测</li>
<li>The Serial Test，序列检测</li>
<li>The Approximate Entropy Test，近似熵检测</li>
<li>The Cumulative Sums (Cusums) Test，累加和检验</li>
<li>The Random Excursions Test，随机游动检测</li>
<li>The Random Excursions Variant Test.，随机游动状态频率检测</li>
</ol>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h1><p>该流程是基于Linux系统进行操作的，使用的数据：sts-2.1.2/data/data.pi</p>
<ol>
<li>启动程序。**./assess ，**stream length译为流的长度。</li>
<li>输入待测文件路径。根据菜单，键入0并输入文件的路径（相对路径和绝对路径都可以）</li>
<li>选择测试项。键入1表示应用全部测试项；输入0表示部分测试项，随后输入一个16位二进制序列选择测试项。</li>
<li>参数调整。可以根据菜单及选项微调部分参数的值，基本选择默认即可。</li>
<li>输入比特流的个数。表示有多少个stream</li>
<li>选择输入文件类型。该类型对应于第二步输入文件的类型，两种类型供选择：ASCII / Binary</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h1><ol>
<li>每一项测试所需的序列的stream length是不一样的，经测试如果选择全部测试项至少保证stream length &gt;= 10000bits，否则会出现错误。而如果单项测试查阅文档满足参数范围即可，比如选择1频率测试只需保证stream length&gt;100bits即可。</li>
<li>必须保证：流长度 × 流个数 &lt;= 文件大小</li>
<li>如果输入的文件是ACSII格式的话，启动程序时所输入的bitstream的单位是byte；而输入文件为Binary的话bitstream单位为bit。例如：第一步键入./assess 10000；第五步键入10 ；此时第六步选择0代表输入了10000×10×8（bits），输入1代表输入了10000×10（bits）。实际输入过程是要反着理解，先确定输入文件类型，进而确认bitstream、number，保证第一个公式</li>
</ol>
<h1 id="检测标准"><a href="#检测标准" class="headerlink" title="检测标准"></a><strong>检测标准</strong></h1><p>测试成功结束则会在 <strong>sts-2.1.2/experiments/AlgorithmTesting/</strong> 目录下生成测试报告，而针对每一个项目的结果会在其子目录下生成测试报告。</p>
<p>最终测试报告finalAnalysisReport.txt中P-value都大于等于0.01即可认为通过了NIST检验，这个数据越大越好。如果该数据为0，可能是由于数据量的问题则可以去每个子项目结果中去查看，会有SUCCESS字样！</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a><strong>Q&amp;A</strong></h1><ol>
<li><p>Q：Segment fault</p>
<p>A： bitstream*num &gt; fileSize即流的长度乘以流的个数超过了文件的大小通常会有error信息</p>
</li>
<li><p>Q：igamc: UNDERFLOW？</p>
<p>A：数据下溢，可能是数据格式的原因或者数据过于不随机</p>
</li>
<li><p>Q：P-value全部是0？</p>
<p>A：导致 <strong>igamc: UNDERFLOW</strong> 的原因都是有可能的，同时也可能是因为数据量不够所导致的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
  </entry>
  <entry>
    <title>智能家居模型设计</title>
    <url>/2022/12/03/item/smartHome/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>伴随着通信技术的不断发展和社会环境的进步，人们对更智能化的生活有了更高的追求。物联网智能家居已经不能算是新鲜的名词了，其单品及互联应用也都已经非常广泛了。本设计基于STM32单片机，通过ESP8266无线通信模块以及连接相应的传感器及外设对智能家居的场景进行模拟。本文最初写于今年6月，现在从事嵌入式工作一段时间后现在再次将我的毕业设计重新进行整理和思考，希望能对读者有所帮助！</p>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>对于任何一个项目或者工程的开始第一步永远是先明确需求，知道自己做成什么样子的东西。在我参考了一些资料并阅读了几篇文献后，对其有了初认识。我理解的智能家居就是从感知层出发对环境进行监测，通过传输层遵从一定的网络协议对数据进行传输同时通过软件对数据进行整理分析，并在应用层（家具状态）做出相应的动作。最终我将该流程整理成下图所示的实物模拟，进而对其进行模块的抽象。基于此，进行下面的硬件设计选型及软件实现等等。<br><img src="/images/item/smarthome-1.png"></p>
<h1 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h1><h2 id="硬件选型原则"><a href="#硬件选型原则" class="headerlink" title="硬件选型原则"></a>硬件选型原则</h2><p>由于该项目是模型设计，对于硬件的选型整体上是以==低成本、低功耗、高集成、高仿真度==为原则的。</p>
<ul>
<li>满足功能及性能需求。本设计的侧重点不在于数据的精确和控制的灵敏，故没有严格参数要求。</li>
<li>易上手的“大众”产品。对于这些元件我们可以很容易的找到相关资料，而且避免踩坑。</li>
<li>兼容性。由于是模块化设计，对于部分模块的兼容性是要有一定的要求的。</li>
</ul>
<h2 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h2><p>如下是对于硬件的选型及相关介绍，最后附有一张所有用到的硬件的图片。</p>
<p><em><strong>1. 主控模块—-STM32F103C8T6</strong></em></p>
<p>   我相信51应该是大部分电子同学入手的第一款单片机。诚然，51有其灵活轻巧之处，但是stm32具有强大外设接口和较高的运行速度（STM32F103的CPU最高速度达72 MHz，具有16KB ~ 1MB Flash、多种控制外设、USB全速接口和CAN；多达112个快速I/O口、11个定时器和13个通信接口） 此外STM32还提供了三种省电模式和两种调试方式。其灵活的调试方法、多样的功能特点和较优的性能参数同样也是选择STM32作为主控芯片的原因。  </p>
<p><em><strong>2. 无线通信模块—-ESP01S无线通信模块</strong></em></p>
<p>   基于此模块首先考虑的是通信方式，如果不谈应用场景，比较传输速度、传输距离和安全性，zigbee和蓝牙会是更好的选择。但是在智能家居的场景下，wifi无疑会是更优选，因为当下wifi已经基本普及到了每个家庭，模拟还原度会更高。接下来是具体芯片的选择，安信可的ESP8266模组很多都可以在该场景下应用，其具体的区分主要体现在封装方式、硬件配置、资源引脚等等方面。具体的区分可以参考安信可官网给出的文档说明，<a href="https://www.ai-thinker.com/product/esp8266">please click</a>！</p>
<p><em><strong>3. 环境监测模块</strong></em></p>
<ul>
<li><p>温湿度监测—-DHT11</p>
<blockquote>
<p>  DHT11是一款有已校准数字信号输出的温湿度传感器。此传感器使用起来简单，精度和性能参数足够满足环境监测的场景。其遵从单总线协议，有严格的时序要求。主机先要发送一个至少18ms的低电平，在这个过程中，DHT11内部完成AD转换等操作，当主机拉高后，有20-40us时间，这个时间用于主机做输入输出切换，当主机释放总线控制权（此时主机为输入状态，总线被上拉电阻拉高），DHT11尝试将总线拉低，成功拉低后就开始准备发送数据了，再拉高一次就开始传输数据了。</p>
</blockquote>
</li>
<li><p>空气质量监测—-MQ135<br> &gt; MQ系列传感器是监测空气环境最常用的传感器，大概十几个都是针对不同污染物进行检测的，本次实验我们采用的是MQ135，主要针对氨气、苯、酒精、烟雾颗粒进行空气质量检测，同样根据自己的需求可以选择其他型号的传感器吧，比如烟雾、酒精、一氧化碳等等。</p>
</li>
<li><p>光照监测—-BH1750</p>
<blockquote>
<p> BH1750传感器有接近视觉灵敏度的光谱灵敏度特性，它支持I2CBUS接口，支持1.8v逻辑输入接口。传感器有两种可选的I2Cslave地址，无需其他外部件。光源依赖性弱，受红外线影响很小。传感器通过降低功率功能，实现低电流化。</p>
</blockquote>
</li>
</ul>
<p><em><strong>4. 数据展示模块—-OLED</strong></em></p>
<p>   数据显示无非就是OLED、LCD、TFT屏幕等等。该模块的作用是对监测到的环境数据及家具的状态进行实时显示。OLED相较于LCD屏幕则不需要背光层，同样也不需要发出光亮的液晶层；而相较于TFT有更高的性价比，最终选择了0.96寸OLED屏幕。</p>
<p><em><strong>5. 家具模拟模块</strong></em></p>
<p>   家具模拟模块主要是模拟到了门、窗、灯和风扇。具体是通过步进电机、舵机、LED灯和风扇模块实现的。而应用也很简单，配置IO口的工作模式，控制GPIO口输出的高低电平即可。<br>   <img src="/images/item/smarthome-2.png"></p>
<h2 id="PCB设计"><a href="#PCB设计" class="headerlink" title="PCB设计"></a>PCB设计</h2><p>对于以上众多元件和模块，如果用导线直接连接起来的话，我只能想到一个词形容：一团乱麻！因此设计PCB板就成了解决该问题的最好方法。可能有的同学在大学期间学习过如何画板打板，有些同学没有接触过，以我自己的经验来讲，学习一两周时间对于绘制该项目PCB已经绰绰有余。该项目并不需要在板子上有各个电路的设计（有能力的同学可以设计一个电源电路），因此只需要布局布线即可还是比较简单的，以下是我所设计的板子 。</p>
<p>该部分的设计让自己对于整个硬件资源的了解及使用有一个新的认识。在主控芯片有限的硬件资源、有限空间的电路板上，如何能充分利用每个元件的形状大小和性能特点来做到彼此之间的交互是该部分的重难点。<br>==Tips：阅读每根pin的功能，分配好主控芯片的各个管脚资源==</p>
<p><img src="/images/item/smarthome-3.png"></p>
<h1 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h1><p>整个代码工程内容相对较大，在此就不进行详细的展示了如果有需要可以私信我。在此只展示部分主函数代码和相关头文件等，除此之外，数据上云格式定义、命令下发、各个模块的驱动函数同样重要！</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"math.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"string.h"</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"dht11.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"BH1750.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED_I2C.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"usart.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"timer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"exti.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"door_bsp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fan.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"esp8266.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MqttKit.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"onenet.h"</span></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span>					<span class="comment">//定义结构体</span></span><br><span class="line">	<span class="type">uint8_t</span> temp;				<span class="comment">//温度</span></span><br><span class="line">	<span class="type">uint8_t</span> humi;				<span class="comment">//湿度</span></span><br><span class="line">	<span class="type">float</span> mq;					<span class="comment">//MQ135传感器</span></span><br><span class="line">	<span class="type">float</span> sun;					<span class="comment">//光照强度传感器</span></span><br><span class="line">	<span class="type">uint8_t</span> LED_FLAG;			<span class="comment">//LED</span></span><br><span class="line">	<span class="type">uint8_t</span> FAN_FLAG;			<span class="comment">//风扇</span></span><br><span class="line">	<span class="type">uint8_t</span> DOOR_FLAG;			<span class="comment">//步进电机</span></span><br><span class="line">	<span class="type">uint8_t</span> WARNING_FLAG;		<span class="comment">//步进电机</span></span><br><span class="line">}SendData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> SendData send_data;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> cmd_rev_flag;</span><br><span class="line">SendData send_data = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> ,<span class="number">0</span>};	<span class="comment">//初始化</span></span><br><span class="line"><span class="type">uint8_t</span> cmd_rev_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *data_ptr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> timeCount = <span class="number">0</span>;	<span class="comment">//发送间隔变量</span></span><br><span class="line">	Hardware_Init();</span><br><span class="line">	Net_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{  		</span><br><span class="line">		<span class="keyword">if</span>(++timeCount &gt;= <span class="number">200</span> || (cmd_rev_flag == <span class="number">1</span>))	</span><br><span class="line">{	</span><br><span class="line">			DHT11_Read_Data(&amp;send_data.temp,&amp;send_data.humi);</span><br><span class="line">			send_data.mq=(<span class="type">float</span>)(Get_Adc_Average(ADC_Channel_1,<span class="number">10</span>))*(<span class="number">3.3</span>/<span class="number">4096</span>);	</span><br><span class="line">			send_data.sun = LIght_Intensity();										 </span><br><span class="line">			OneNet_SendData();	<span class="comment">//发送数据</span></span><br><span class="line">			timeCount = <span class="number">0</span>;</span><br><span class="line">			cmd_rev_flag=<span class="number">0</span>;</span><br><span class="line">			ESP8266_Clear();</span><br><span class="line">		}</span><br><span class="line">		data_ptr = ESP8266_GetIPD(<span class="number">0</span>);		<span class="comment">//检查是否有下发指定</span></span><br><span class="line">		<span class="keyword">if</span>(data_ptr != <span class="literal">NULL</span>)</span><br><span class="line">			OneNet_RevPro(data_ptr);</span><br><span class="line">		delay_ms(<span class="number">10</span>);</span><br><span class="line">	}		 </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="硬件初始化"><a href="#硬件初始化" class="headerlink" title="硬件初始化"></a>硬件初始化</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Hardware_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	delay_init();	    		<span class="comment">//延时函数初始化</span></span><br><span class="line">	TIM2_Int_Init(<span class="number">4999</span>,<span class="number">7199</span>);  	<span class="comment">//用于OLED显示</span></span><br><span class="line">	Usart1_Init(<span class="number">115200</span>);		<span class="comment">//串口调试</span></span><br><span class="line">	Usart2_Init(<span class="number">115200</span>);		<span class="comment">//esp8266--stm32通信</span></span><br><span class="line">	OLED_Init();				<span class="comment">//OLED初始化</span></span><br><span class="line">	OLED_CLS();</span><br><span class="line">	KEY_Init();					<span class="comment">//按键初始化</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">								<span class="comment">//设置中断优先级分组2，为后面外部中断做基础</span></span><br><span class="line">	EXTIX_Init();				<span class="comment">//判断键值执行操作</span></span><br><span class="line">	DHT11_Init();				<span class="comment">//温湿度传感器初始化</span></span><br><span class="line">	Adc_Init();					<span class="comment">//空气检测初始化</span></span><br><span class="line">	BH1750_Init();				<span class="comment">//光照</span></span><br><span class="line">	TIM3_Int_Init(<span class="number">4999</span>,<span class="number">7199</span>);  	<span class="comment">//报警显示</span></span><br><span class="line">	ESP8266_Init();				<span class="comment">//初始化ESP8266</span></span><br><span class="line">	<span class="keyword">while</span>(OneNet_DevLink())		<span class="comment">//接入OneNET</span></span><br><span class="line">	delay_ms(<span class="number">500</span>);</span><br><span class="line">}	</span><br></pre></td></tr></tbody></table></figure>

<h1 id="云平台选择"><a href="#云平台选择" class="headerlink" title="云平台选择"></a>云平台选择</h1><p>本设计还有一个重要的部分就是对于云平台的选择，本项目选择的是中国移动物联网云平台OneNET。当然，如果有能力的同学自己做个app更好。</p>
<p>目前很多云平台厂商都支持了对于个人开发者的物联网应用的需求，我见到用到最多的包括阿里云、腾讯云、机智云、OneNET等等。这些平台对对于个人开发者还是很有好的，有着比较完善的流程。我个人使用过机智云和OneNET，对此做出以下建议。</p>
<ul>
<li>OneNET：更适合已有工程文件，在此基础之上进行通信部分的开发。其对于最终的界面设计很开放，可以自行设计图标及显示方式等；</li>
<li>机智云：适合没有工程文件，从刚开始就选择使用该物联网云平台。可以在平台上生成代码包进行开发；</li>
</ul>
<h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><h2 id="实物图与手机界面"><a href="#实物图与手机界面" class="headerlink" title="实物图与手机界面"></a>实物图与手机界面</h2><p><img src="/images/item/smarthome-4.png"></p>
<h2 id="云平台数据可视化界面"><a href="#云平台数据可视化界面" class="headerlink" title="云平台数据可视化界面"></a>云平台数据可视化界面</h2><p><img src="/images/item/smarthome-5.png"></p>
<h2 id="云平台控制界面"><a href="#云平台控制界面" class="headerlink" title="云平台控制界面"></a>云平台控制界面</h2><p><img src="/images/item/smarthome-6.png"></p>
<h1 id="实现功能及扩展"><a href="#实现功能及扩展" class="headerlink" title="实现功能及扩展"></a>实现功能及扩展</h1><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ul>
<li><p>监测：空气中温度、湿度、光照和空气质量等环境因素；</p>
</li>
<li><p>控制：模拟的“家居”：门、灯、窗帘、风扇；</p>
</li>
<li><p>显示：OLED显示、手机显示、电脑显示；</p>
</li>
<li><p>控制方式：按键控制、手机控制、电脑控制；</p>
</li>
<li><p>报警：设置环境因素阈值，超标开发板的灯亮起（可改成蜂鸣器）</p>
</li>
<li><p>以上所有环境及家具状态都可以可视化显示</p>
</li>
</ul>
<h2 id="可扩展功能"><a href="#可扩展功能" class="headerlink" title="可扩展功能"></a>可扩展功能</h2><p>该系统具有很高的扩展性，做出基础模型之后可以进行二次开发。需要注意的是将硬件资源分配好。</p>
<ul>
<li>语音模块。语音控制智能家居的状态。</li>
<li>安防系统。添加指纹、RFID、面部识别等开门方式。</li>
<li>告警系统。目前只是遇到告警平台自动提醒，可以添加短信通知功能。</li>
<li>模式选择。居家多种模式自动切换，娱乐模式、休息模式、离家模式等等，家具可以对应着不同状态。</li>
<li>……</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本设计对于智能家居控制系统的模拟从传统到智能、从前端到后端，覆盖面、还原度还是比较高的；其次，系统的兼容性和可扩展移植性较高，基于此可以进行二次开发，可以扩展的内容我在上面也有总结。我认为相对容易上手的就是对于监测到的数据进行进一步分析应用。最后就是其应用性，当自己设计好电源模块可以独立供电后就可以直接应用到生活中，即使不做毕设diy一个环境监测的系统也是不错的。整体来说，本设计实现的功能是：四测三显两控一平台，基本实现了智能家居模拟的基本的要求。同样该项目还可以应用到环境监测等方面的，但是其侧重点更要偏向数据的分析和处理。</p>
<p>行文至此就结束啦，如果有不足之处或者更好的想法可以一起交流 ~</p>
]]></content>
      <categories>
        <category>Item</category>
      </categories>
      <tags>
        <tag>毕业设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Mplayer编译及使用说明</title>
    <url>/2023/03/07/third-party/mplayer/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>官网：<a href="http://www.mplayerhq.hu/design7/news.html">http://www.mplayerhq.hu/design7/news.html</a></p>
</blockquote>
<p><strong>MPlayer</strong>是一款开源的多媒体播放器，以GNU通用公共许可证发布。此款软件可在各主流操作系统使用，例如Linux和其他类Unix操作系统、微软Windows系统及苹果电脑的Mac OS 系统。MPlayer是建基于命令行界面，在各操作系统可选择安装不同的图形界面。</p>
<h1 id="ubuntu下编译过程"><a href="#ubuntu下编译过程" class="headerlink" title="ubuntu下编译过程"></a>ubuntu下编译过程</h1><ol>
<li><p>下载并解压源码文件<a href="http://www.mplayerhq.hu/design7/news.html">click here</a></p>
</li>
<li><p>生成配置文件（目前直接走默认参数选项）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接执行./configure错误，--yasm=<span class="string">''</span>参数是根据提示没有找到yasm，可通过该命令直接执行</span></span><br><span class="line">./configure --yasm=''</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make完成既可看到文件夹下存在mplayer可执行文件</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>安装</p>
</li>
</ol>
   <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将mplayer及依赖的库文件进行安装, 不安装也可以进行使用</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure>

<h1 id="源码文件"><a href="#源码文件" class="headerlink" title="源码文件"></a>源码文件</h1><ul>
<li><p>vd__*	</p>
<p><strong>video decode</strong>  与解码相关的,解码器只是负责把解码完成的帧传输给vo，如何显示是vo的函数实现;</p>
</li>
<li><p>vf__*  </p>
<p><strong>video filter</strong>  所有过滤器的定义，当命令行输入-vf的参数，规则会去相应的filter函数解析。例如： -vf rotate=2,vf_rotate.c的函数进行进行rotate函数的解析。</p>
</li>
<li><p>vo_*</p>
<p><strong>video output</strong>   输出的函数定义，每一个函数对应实现一种或几种的功能。例如：vo_md5sum.c得到md5的一个值</p>
</li>
<li><p>DOCS 文档</p>
</li>
</ul>
<h1 id="mplayer流程"><a href="#mplayer流程" class="headerlink" title="mplayer流程"></a>mplayer流程</h1><ol>
<li><p>调用 AddExcept（）注册异常处理函数</p>
</li>
<li><p>initmplayer();   //初始化，创建快进和暂停的信号量</p>
</li>
<li><p>InitTimer();初始化计时器</p>
</li>
<li><p>mp_msg_init();初始化消息系统</p>
</li>
<li><p>set_path_env();设置路径、环境</p>
</li>
<li><p>ipu_image_start();ipu初始化</p>
</li>
<li><p>mplayer_showmode(1);设置显示模式</p>
</li>
<li><p>parse_codec_cfg(NULL);解析codec配置寄存器</p>
</li>
<li><p>打开数据流</p>
</li>
<li><p>分析播放树</p>
</li>
<li><p>添加播放树列表</p>
</li>
<li><p>初始化预填充缓存</p>
</li>
<li><p>打开播放的文件</p>
</li>
<li><p>创建buffer</p>
</li>
<li><p>打开数据流</p>
</li>
<li><p>检测数据流类型（音频格式和视频格式）</p>
</li>
<li><p>分析音频流视频流的信息（原始视频尺寸、分辨率、帧频率、码流大小）</p>
</li>
<li><p>启动相应的分离器</p>
</li>
<li><p>分析剪辑信息</p>
</li>
<li><p>初始化codec（多媒体数字信号编解码器）</p>
</li>
<li><p>选择打开相应的视频解码器</p>
</li>
<li><p>初始化视频解码器，分析视频流信息</p>
</li>
<li><p>选择打开相应的音频解码器</p>
</li>
<li><p>初始化音频解码器、PCM，分析音频信息</p>
</li>
<li><p>同步音频视频输出</p>
</li>
<li><p>开始播放</p>
</li>
</ol>
<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><ul>
<li><p>-list-options 打 印 所有 可 用 的 选 项</p>
</li>
<li><p>-vf   选择视频相关参数</p>
<ul>
<li><p>format 选择解码之后的格式输出</p>
</li>
<li><ul>
<li>NV12  /  NV21</li>
<li>BGRA</li>
<li>RGB</li>
</ul>
</li>
<li><p>rotate  选择旋转的角度输出</p>
</li>
<li><ul>
<li>1  顺时针旋转90</li>
<li>2  顺时针旋转270</li>
<li>4  旋转0度</li>
</ul>
</li>
</ul>
</li>
<li><p>-slave  从模式，mplayer会从标准输入读一个换行符（/n）分隔开的命令。</p>
</li>
<li><p>-quiet   去除杂项信息, 使 控制屏幕输出简略；尤其是阻止显示状态行（即 A: 0.7 V: 0.6 A-V: 0.068 …）</p>
</li>
<li><p>-speed &lt;0.01 - 100&gt;选择播放速率</p>
</li>
<li><p>-vo 指定视频输出驱动的优先级列表</p>
</li>
<li><p>-vc  选择编解码器，  -vc help 可以列出所有视频解码器，其中中括号里面是.dll的是我们无法使用的</p>
</li>
<li><ul>
<li>ffm264   264软解码</li>
<li>ffh264v4l2m2m  264硬解码</li>
</ul>
</li>
<li><p>-ao 指定音频输出驱动的优先级列表</p>
</li>
<li><p>-ac 指定音频解码器优先级列表</p>
</li>
<li><p>-zoom -x 800 -y 400 指令播放窗体的大小</p>
</li>
<li><p>-input  输入</p>
</li>
<li><ul>
<li>cmdlist  列出所有可绑定按键的命令</li>
<li>file 命令输入通道。制定输入fifo的名字，写入控制命令，与slave参数一起使用</li>
</ul>
</li>
</ul>
<h1 id="slave模式"><a href="#slave模式" class="headerlink" title="slave模式"></a>slave模式</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>MPlayer为后台运行其他程序，不再截获键盘事件，MPlayer会从标准输入读一个换行符（/n）分隔开的命令。</p>
<p>大多数slave模式命令相当于命令行选项。</p>
<ul>
<li><p>命令行播放通过 -input file= 参数监听某个管道</p>
</li>
<li><p>另起一个线程，创建同名管道并输入6.2所示控制参数即可达到控制mplayer的效果</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> /tmp/fifofile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mplayer -slave -input file=/tmp/fifofile &lt;movie&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>具体使用说明可以参考源文件下DOCS/tech/slave.txt</p>
<h2 id="控制参数"><a href="#控制参数" class="headerlink" title="控制参数"></a>控制参数</h2><p><strong>mplayer -input cmdlist</strong> 命令可以打印出一份可以输入清单</p>
<ul>
<li>get_file_name  打印当前文件名</li>
<li>get_percent_pos   打印出文件中的当前位置为整数百分比(0-100）</li>
<li>get_time_length   打印当前文件长度用秒表示</li>
<li>get_time_pos   打印文件当前位置用秒表示</li>
<li>seek  定位电影的某些地方<ul>
<li>0 是一个相对定位+/- （默认值）</li>
<li>1 是定位％在电影里</li>
<li>2 是寻求一个绝对位置的秒。</li>
</ul>
</li>
<li>quit   推出mplayer进程</li>
<li>stop   停止播放</li>
<li>exit   从OSD菜单退出控制台。不像’quit’，不退出MPlayer的</li>
</ul>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>针对slave使用方法，简单写了几个函数作为参考示例</p>
<p>github仓库（mplayerInterface文件夹）：<a href="https://github.com/yangLieee/codebackup.git">click here</a></p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>MPlayer interrupted by signal 13 in module: key_events ？</p>
<p>因为Mplayer是通过换行符(“\n”)来分隔不同的命令，所以我们在编程中不管是写入到管道文件还是写入到QT的进程中在命令后面一定要加入换行符(“\n”),这样Mplayer才能辨别。</p>
</li>
<li><p>只有在串口有输出，adb shell没有输出 </p>
<p>错误信息：Cannot find HOME directory.</p>
<p>解决方法：setenv(“HOME”，“/”，“1”)</p>
</li>
<li><p>在vo部分添加 rotate功能 之后, 只有一个方向可以正常显示?</p>
</li>
</ol>
<p>   对于nv12格式的图片和数据, uv_stride和stride这两个参数影响LCD最终显示的效果. 在旋转之后需要将对应的宽高对应到相应的stride中, 最终可以正常显示</p>
<ol start="4">
<li><p>mpi被mplayer用来存储解码之后的图像（mp_image.h中定义），得到mpi之后，vf被调用，整个filter链上钉filter都被调用了一遍包括最后的vo; 在vo的put_image里把图像输出到显示器上。这个时候需要考虑图像的存储方法，即用哪种颜色空间。</p>
</li>
<li><p><a href="https://blog.csdn.net/willand1981/article/details/5783107">https://blog.csdn.net/willand1981/article/details/5783107</a></p>
</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><a href="http://www.mplayerhq.hu/DOCS/man/zh_CN/mplayer.1.html">Mplayer和mencoder使用文档简介</a></p>
</li>
<li><p><a href="http://www.mplayerhq.hu/DOCS/HTML/zh_CN/index.html">Mplayer使用文档</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qizheguang/article/details/50552810">mplayer流程及相关函数说明</a></p>
</li>
<li><p><a href="https://blog.csdn.net/liangkaiming/article/details/5790893">slave 模式文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/2022/08/25/third-party/cmake/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>官网 : <a href="https://cmake.org/cmake/help/v3.15/">https://cmake.org/cmake/help/v3.15/</a></p>
</blockquote>
<p>CMake是跨平台的 免费和开源软件，用于使用独立于编译器的方法构建自动化、测试、打包和安装软件。CMake 本身并不是一个构建系统；它生成另一个系统的构建文件。它支持目录层次结构和依赖于多个库的应用程序。它与原生构建环境结合使用，例如Make、Qt Creator、Ninja、Android Studio、Apple 的Xcode和Microsoft Visual Studio。（摘自Wiki）</p>
<h1 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><p>cmake要求最低版本(选择性添加)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.0</span><span class="number">.0</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>编译工程名</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">project(xxx)</span><br><span class="line"><span class="comment">//会自动创建两个变量，PROJECT_SOURCE_DIR和PROJECT_NAME</span></span><br><span class="line"><span class="comment">//${PROJECT_SOURCE_DIR}：本CMakeLists.txt所在的文件夹路径</span></span><br><span class="line"><span class="comment">//${PROJECT_NAME}：本CMakeLists.txt的project名称</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>给部分文件或路径组合起别名, 通过${变量}获取变量内容</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(变量 文件名/路径/...)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置c / c++ 编译编译参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> (CMAKE_C_FLAGS <span class="string">"-Wall -O2"</span>)</span><br><span class="line"><span class="built_in">set</span> (CMAKE_CXX_FLAGS <span class="string">"-Wall -std=C++11"</span>)</span><br><span class="line">add_compile_options( -Wall )				<span class="comment">//该命令译选项是针对所有编译器的(包括c和c++编译器)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>为当前路径以及子目录的源文件加入由-D引入的define flag</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_definitions(-DFOO -DDEBUG ...)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>对子文件夹进行cmake编译</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_subdirectory(子文件夹名) </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>打印信息</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">message() 			<span class="comment">//直接添加打印的内容和变量即可,不需要双引号</span></span><br><span class="line">message(<span class="string">"PROJECT_SOURCE_DIR = ${PROJECT_SOURCE_DIR}"</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>帮助信息 </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 查看cmake默认变量		cmake --help-variable-<span class="built_in">list</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>用法：根据某个宏确定编译内容。比较字符串，相同返回true</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CPU_PLATFORM_BIT STREQUAL <span class="string">"64"</span>)</span><br><span class="line">    add_library(mylib generic_64bit.c)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    add_library(mylib generic_32bit.c)</span><br><span class="line">endif()  </span><br></pre></td></tr></tbody></table></figure>

<h2 id="编译目标"><a href="#编译目标" class="headerlink" title="编译目标"></a>编译目标</h2><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_executable(目标文件名字xxx 源文件)</span><br><span class="line"><span class="comment">//example: add_executable(${PROJECT_NAME} example_person.cpp)</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="动态-x2F-静态库"><a href="#动态-x2F-静态库" class="headerlink" title="动态 / 静态库"></a>动态 / 静态库</h3><p>将指定的源文件生成链接文件，然后添加到工程中去</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_library(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">[EXCLUDE_FROM_ALL]</span><br><span class="line">[source1] [source2] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;name&gt;表示库文件的名字，该库文件会根据命令里列出的源文件来创建。生成的库自动补全,如libxxx.so </span></span><br><span class="line"><span class="comment">//STATIC、SHARED和MODULE的作用是指定生成的库文件的类型。STATIC库是目标文件的归档文件，在链接其它目标的时候使用。SHARED库会被	动态链接（动态链接库），在运行时会被加载。MODULE库是一种不会被链接到其它目标中的插件，但是可能会在运行时使用dlopen-系列的函数	。默认状态下，库文件将会在于源文件目录树的构建目录树的位置被创建，该命令也会在这里被调用。</span></span><br><span class="line"><span class="comment">//source1 source2分别表示各个源文件</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="链接-x2F-路径"><a href="#链接-x2F-路径" class="headerlink" title="链接/路径"></a>链接/路径</h2><h3 id="头文件路径"><a href="#头文件路径" class="headerlink" title="头文件路径"></a>头文件路径</h3><p>添加头文件的查找路径, 相当于命令行的  <em><strong>-l</strong></em> 参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">include_directories(../thirdparty/comm/include)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="链接库路径"><a href="#链接库路径" class="headerlink" title="链接库路径"></a>链接库路径</h3><p>添加需要链接的库文件目录, 相当于命令行 <em><strong>-L</strong></em> 参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">link_directories(<span class="string">"/home/server/third/lib"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a>链接库</h3><p> 将目标文件与库文件进行链接</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">target_link_libraries(&lt;target&gt; [item1] [item2] [...] [[debug|optimized|general] &lt;item&gt;] ...)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//&lt;target&gt;是指通过add_executable()和add_library()指令生成已经创建的目标文件</span></span><br><span class="line"><span class="comment">//[item]表示库文件没有后缀的名字。默认情况下，库依赖项是传递的。当这个目标链接到另一个目标时，链接到这个目标的库也会出现在另一个目标的连接线上。这个传递的接口存储在interface_link_libraries的目标属性中，可以通过设置该属性直接重写传递接口。</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="安装（Install）"><a href="#安装（Install）" class="headerlink" title="安装（Install）"></a>安装（Install）</h2><ul>
<li>详情参考：<a href="https://cmake.org/cmake/help/v3.22/command/install.html">https://cmake.org/cmake/help/v3.22/command/install.html</a></li>
<li>作用：用于定义安装规则，安装内容包括可执行文件，静态库，动态库以及文件，目录，脚本等</li>
<li>使用方法：make install</li>
<li>目标安装路径：${CMAKE_INSTALL_PREFIX}指定，默认/usr/local</li>
</ul>
<h3 id="目标文件安装"><a href="#目标文件安装" class="headerlink" title="目标文件安装"></a>目标文件安装</h3><p>目标文件指的是我们通过 add_executable / add_library 得到的二进制文件或者库，只有这些文件才可以通过该命令装载到相应的位置</p>
<ul>
<li>可执行文件：RUNTIME</li>
<li>动态库：LIBRARY</li>
<li>静态库：ARCHIVE</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(TARGETS targets... [EXPORT &lt;export-name&gt;]</span><br><span class="line">        [RUNTIME_DEPENDENCIES args...|RUNTIME_DEPENDENCY_SET &lt;<span class="built_in">set</span>-name&gt;]</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|BUNDLE|</span><br><span class="line">          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]</span><br><span class="line">         [DESTINATION &lt;dir&gt;]</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">         [OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">         [NAMELINK_ONLY|NAMELINK_SKIP]</span><br><span class="line">        ] [...]</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line"><span class="comment">// example:</span></span><br><span class="line">install(TARGETS mybin mystaiclib mydynamiclib</span><br><span class="line">        RUNTIME DESTINATION bin</span><br><span class="line">        ARCHIVE DESTINATION lib</span><br><span class="line">        LIBRARY DESTINATION lib)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="普通文件安装"><a href="#普通文件安装" class="headerlink" title="普通文件安装"></a>普通文件安装</h3><p>普通文件即需要导出的头文件、依赖的三方库等等，该命令同时可以指定导出文件的权限（默认644）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(&lt;FILES|PROGRAMS&gt; files...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [PERMISSIONS permissions...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [RENAME &lt;name&gt;] [OPTIONAL] [EXCLUDE_FROM_ALL])</span><br><span class="line">        </span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">install(FILES mylib.h DESTINATION include)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="目录安装"><a href="#目录安装" class="headerlink" title="目录安装"></a>目录安装</h3><p>参数介绍：</p>
<ul>
<li>DIRECTORY：后面连接的是所在Source目录的相对路径（结尾是否是”/“对拷贝结果有一定影响）</li>
<li>PATTERN：使用正则表达式进行过滤</li>
<li>PERMISSIONS：指定PATTERN过滤后的文件权限。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(DIRECTORY dirs...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [FILE_PERMISSIONS permissions...]</span><br><span class="line">        [DIRECTORY_PERMISSIONS permissions...]</span><br><span class="line">        [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL]</span><br><span class="line">        [FILES_MATCHING]</span><br><span class="line">        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">         [EXCLUDE] [PERMISSIONS permissions...]] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">install(DIRECTORY src/ DESTINATION include/myproj  FILES_MATCHING PATTERN <span class="string">"*.h"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>Q: 编译参数添加了-lpthread 参数, 但是还是报undefined reference to `pthread_create’ </p>
<p>A : 需要使用target_link_libraries( target thread) 在这里链接thread库</p>
</li>
<li><p>Q: 如果在多级的目录下编译, 始终找不到问题报 undefine的问题 ?</p>
<p>A : 看一下是不是链接的库或目标文件格式不同, 一个c 一个c++ , 这样就会导致找不到符号错误</p>
</li>
<li><p>Q: undefined reference to `typeinfo for xxxBase_class’ ?</p>
<p>A: 基类的构造和析构函数需要加{ };  否则就会报这个问题</p>
</li>
</ol>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table>
<thead>
<tr>
<th>通配符</th>
<th>使用说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配0个或者是任意个字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td>[]</td>
<td>我们可以指定匹配的字符放在 “[]” 中</td>
</tr>
<tr>
<td>%</td>
<td>匹配任意个字符</td>
</tr>
</tbody></table>
<h2 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h2><table>
<thead>
<tr>
<th>自动化变量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>$@</td>
<td align="center">表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td>
</tr>
<tr>
<td>$%</td>
<td align="center">当目标文件是一个静态库文件时，代表静态库的一个成员名。</td>
</tr>
<tr>
<td>$&lt;</td>
<td align="center">规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td>
</tr>
<tr>
<td>$?</td>
<td align="center">所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</td>
</tr>
<tr>
<td>$^</td>
<td align="center">代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量“$”只记录它的第一次引用的情况。就是说变量“$”会去掉重复的依赖文件。</td>
</tr>
<tr>
<td>$+</td>
<td align="center">类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td>
</tr>
<tr>
<td>$*</td>
<td align="center">在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。</td>
</tr>
</tbody></table>
<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><h3 id="添加前缀"><a href="#添加前缀" class="headerlink" title="添加前缀"></a>添加前缀</h3><ul>
<li>函数名：addprefix( )</li>
<li>语法：$(addprefix PREFIX/,${NAME…})</li>
<li>函数功能：为“NAMES…”中的每一个文件名添加前缀“PREFIX”。参数“NAMES…”是空格分割的文件名序列，将“PREFIX”添加到此序列的每一个文件名之前。</li>
<li>返回值：以单空格分割的添加了前缀“PREFIX”的文件名序列。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">$(addprefix src/,foo bar)</span><br><span class="line"><span class="comment">//返回值为“src/foo src/bar”</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ul>
<li>函数名：filter( )</li>
<li>语法：$(filter SUFFIX…,$(SOURCES))</li>
<li>作用：保留字串 “ $(SOURCES)” 中所有符合模式 “ SUFFIX ” 的单词</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sources := main.c AT.txt</span><br><span class="line">foo : $(sources)</span><br><span class="line">    cc $(filter %.c,%.s,$(sources)) -o foo</span><br></pre></td></tr></tbody></table></figure>



<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p>用于Makefile的Debug，打印分为三个等级：info、warning、error</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">$(info SRC = $(SRC))</span><br><span class="line">$(warning INC = $(INC))</span><br><span class="line"><span class="comment">//注意：执行到error会直接stop退出</span></span><br><span class="line">$(error INC = $(INC))</span><br></pre></td></tr></tbody></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
        <tag>CmakeLists.txt</tag>
      </tags>
  </entry>
  <entry>
    <title>LwIP协议栈</title>
    <url>/2022/11/30/third-party/lwip/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>Lwip官网：<a href="https://savannah.nongnu.org/projects/lwip/">https://savannah.nongnu.org/projects/lwip/</a></p>
</blockquote>
<p>LWIP（light weight ip）轻型IP协议，有无操作系统的支持都可以运行。LwIP实现的重点是在保持TCP协议主要功能的基础上减少对RAM 的占用，它只需十几KB的RAM和40K左右的ROM就可以运行，这使LwIP协议栈适合在低端的嵌入式系统中使用。</p>
<p>LWIP支持的协议种类：</p>
<ul>
<li>DNS，域名解析；</li>
<li>SNMP，简单网络管理协议；</li>
<li>DHCP，动态主机配置协议；</li>
<li>UDP 协议，用户数据报协议；</li>
<li>TCP 协议，支持 TCP 拥塞控制， RTT 估计，快速恢复与重传等；</li>
<li>IP 协议，包括 IPv4 和 IPv6，支持 IP 分片与重装，支持多网络接口下数据转发；</li>
<li>AUTOIP， IP 地址自动配置；</li>
<li>ICMP 协议，用于网络调试与维护；</li>
<li>IGMP 协议，用于网络组管理，可以实现多播数据的接收；</li>
<li>ARP 协议，以太网地址解析协议；</li>
<li>PPP，点对点协议，支持 PPPoE</li>
</ul>
<h1 id="LwIP架构"><a href="#LwIP架构" class="headerlink" title="LwIP架构"></a>LwIP架构</h1><p>LwIP 符合 TCP/IP 模型架构，规定了数据的格式、传输、路由和接收，以实现端到端的通信。 此模型包括四个抽象层，用于根据涉及的网络范围，对所有相关协议排序。这几 层从低到高依次为：</p>
<ul>
<li><p>链路层包含了局域网的单网段 （链路）通信技术</p>
</li>
<li><p>网际层 （IP）将独立的网络连接起来，建立互联</p>
</li>
<li><p>传输层处理主机端口到主机端口的通信</p>
</li>
<li><p>应用层在实现多个应用进程相互通信的同时，完成应用所需的服务 （例如：数据处理）</p>
<p><img src="/images/third-party/lwip.png"></p>
</li>
</ul>
<h1 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h1><h2 id="RAW-API"><a href="#RAW-API" class="headerlink" title="RAW API"></a>RAW API</h2><p>内核回调型API，当初始化应用时，用户需要为不同内核事件注册所需的回调函数 （例如 TCP_Sent、 TCP_error…）。当相应事件发生时， LwIP 会自发地调用相关的回调函数。<em>没有操作系统支持中，只能使用RAW API开发</em></p>
<table>
<thead>
<tr>
<th></th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TCP连接建立</td>
<td>tcp_new</td>
<td>建立一个新的 TCP PCB （协议控制块）。</td>
</tr>
<tr>
<td></td>
<td>tcp_bind</td>
<td>将 TCP PCB 绑定到本地 IP 地址和端口。</td>
</tr>
<tr>
<td></td>
<td>tcp_listen</td>
<td>启动 TCP PCB 上的监听进程。</td>
</tr>
<tr>
<td></td>
<td>tcp_accept</td>
<td>注册回调函数，连接成功建立后调用。</td>
</tr>
<tr>
<td></td>
<td>tcp_connect</td>
<td>发送连接建立请求。</td>
</tr>
<tr>
<td>发送TCP数据</td>
<td>tcp_write</td>
<td>将发送数据写入 TCP 缓冲区中。</td>
</tr>
<tr>
<td></td>
<td>tcp_sent</td>
<td>注册回调函数，数据发送成功后调用。</td>
</tr>
<tr>
<td></td>
<td>tcp_output</td>
<td>发送 TCP 缓冲区中的数据</td>
</tr>
<tr>
<td>接收TCP数据</td>
<td>tcp_recv</td>
<td>注册回调函数， TCP 接收到数据后调用</td>
</tr>
<tr>
<td>应用轮询</td>
<td>tcp_poll</td>
<td>注册回调函数，TCP慢定时器调用（500ms一次）。</td>
</tr>
<tr>
<td>关闭并终止连接</td>
<td>tcp_close</td>
<td>主动关闭。</td>
</tr>
<tr>
<td></td>
<td>tcp_err</td>
<td>注册回调函数，出错时调用。</td>
</tr>
<tr>
<td></td>
<td>tcp_abort</td>
<td>中止连接，向远程主机发送 RST。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>udp_new</td>
<td>创建新的 UDP PCB。</td>
</tr>
<tr>
<td></td>
<td>udp_remove</td>
<td>移除 UDP PCB 并释放相关资源。</td>
</tr>
<tr>
<td></td>
<td>udp_bind</td>
<td>将 UDP PCB 与本地 IP 地址和端口绑定。</td>
</tr>
<tr>
<td></td>
<td>udp_connect</td>
<td>建立 UDP PCB 远程 IP 地址和端口。</td>
</tr>
<tr>
<td></td>
<td>udp_disconnect</td>
<td>移除 UDP PCB 远程 IP 和端口。</td>
</tr>
<tr>
<td></td>
<td>udp_send</td>
<td>发送 UDP 数据</td>
</tr>
<tr>
<td></td>
<td>udp_recv</td>
<td>注册回调函数，当收到新数据报时即对其调用。</td>
</tr>
</tbody></table>
<h2 id="Netconn-API"><a href="#Netconn-API" class="headerlink" title="Netconn API"></a>Netconn API</h2><p>Netconn API 为高层有序 API，其执行模型基于典型的阻塞式打开 - 读 - 写 - 关闭机制。 若要正常工作，此 API 必须处于多线程工作模式，该模式需为 LwIP TCP/IP 栈实现专用线程， 并 / 或为应用实现多个线程。</p>
<p>基于操作系统的IPC机制（即信号量和邮箱机制）实现的，将LWIP内核代码和网络应用程序分离成了独立的线程，因此LWIP内核线程就只负责数据包的TCP/IP封装和拆封，而不用进行数据的应用层处理，大大提高了系统对网络数据包的处理效率</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>netconn_new</td>
<td>创建一个新连接。</td>
</tr>
<tr>
<td>netconn_delete</td>
<td>删除一个已有连接。</td>
</tr>
<tr>
<td>netconn_bind</td>
<td>将连接绑定到本地 IP 地址和端口。</td>
</tr>
<tr>
<td>netconn_connect</td>
<td>连接远程 IP 地址和端口。</td>
</tr>
<tr>
<td>netconn_send</td>
<td>通过 UDP 发送数据。</td>
</tr>
<tr>
<td>netconn_recv</td>
<td>接收数据。</td>
</tr>
<tr>
<td>netconn_listen</td>
<td>置 TCP netconn 处于监听模式。</td>
</tr>
<tr>
<td>netconn_accept</td>
<td>接受正在监听状态的 TCP 连接上的传入连接。</td>
</tr>
<tr>
<td>netconn_write</td>
<td>通过 TCP 数据 （将数据写入 TCP 缓冲区）。</td>
</tr>
<tr>
<td>netconn_close</td>
<td>主动关闭 TCP netconn。</td>
</tr>
</tbody></table>
<h2 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h2><p>了标准 BSD 套接字 API。它是有序 API，在内部构建于 Netconn API 之上，对网络连接进行了高级的抽象，使得用户可以像操作文件一样操作网络连接	</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>socket</td>
<td>创建一个新套接字。</td>
</tr>
<tr>
<td>bind</td>
<td>将套接字绑定到 IP 地址和端口。</td>
</tr>
<tr>
<td>listen</td>
<td>监听套接字连接。</td>
</tr>
<tr>
<td>connect</td>
<td>将套接字连接到远程主机 IP 地址和端口。</td>
</tr>
<tr>
<td>accept</td>
<td>在套接字上接受新连接。</td>
</tr>
<tr>
<td>read</td>
<td>从套接字读取数据。</td>
</tr>
<tr>
<td>write</td>
<td>向套接字写入数据。</td>
</tr>
<tr>
<td>close</td>
<td>关闭套接字 （删除套接字）。</td>
</tr>
</tbody></table>
<h1 id="LwIP配置"><a href="#LwIP配置" class="headerlink" title="LwIP配置"></a>LwIP配置</h1><p>lwipopts.h 文件允许用户充分配置栈及其所有模块。用户不需要定义 所有 LwIP 选项：如果未定义某选项，则使用 opt.h 文件中定义的默认值。因此， lwipopts.h 提供了覆盖许多 lwIP 行为的方法。</p>
<table>
<thead>
<tr>
<th><strong>Lwip 内存选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MEM_SIZE</td>
<td>LwIP 堆内存大小：用于所有 LwIP 动态内存分配</td>
</tr>
<tr>
<td>MEMP_NUM_PBUF</td>
<td>MEM_REF 和 MEM_ROM pbuf 总数</td>
</tr>
<tr>
<td>MEMP_NUM_UDP_PCB</td>
<td>UDP PCB 结构体的总数</td>
</tr>
<tr>
<td>MEMP_NUM_TCP_PCB</td>
<td>TCP PCB 结构体的总数</td>
</tr>
<tr>
<td>MEMP_NUM_TCP_PCB_LISTEN</td>
<td>处于监听状态的 TCP PCB 总数</td>
</tr>
<tr>
<td>MEMP_NUM_TCP_SEG</td>
<td>最多同时在 TCP 缓冲队列中的报文段数量</td>
</tr>
<tr>
<td>PBUF_POOL_SIZE</td>
<td>PBUF_POOL 类型的 pbuf 总数</td>
</tr>
<tr>
<td>PBUF_POOL_BUFSIZE</td>
<td>PBUF_POOL 类型 pbuf 的大小</td>
</tr>
<tr>
<td>TCP_MSS</td>
<td>最大 TCP 报文段 （MTU - IP 报头大小 - TCP 报头大小）</td>
</tr>
<tr>
<td>TCP_SND_BUF</td>
<td>对于一个连接， TCP 的发送缓冲空间</td>
</tr>
<tr>
<td>TCP_SND_QUEUELEN</td>
<td>TCP 发送队列中 pbuf 的最大数</td>
</tr>
<tr>
<td>TCP_WND</td>
<td>TCP 接收窗大小</td>
</tr>
</tbody></table>
<h1 id="LwIP内存管理"><a href="#LwIP内存管理" class="headerlink" title="LwIP内存管理"></a>LwIP内存管理</h1><p>LwIP有两种内存管理方式：内存池、内存堆</p>
<p>参考链接：<a href="https://blog.csdn.net/jiangjunjie_2005/article/details/26051399#t9">https://blog.csdn.net/jiangjunjie_2005/article/details/26051399#t9</a></p>
<h1 id="实现TCP服务器"><a href="#实现TCP服务器" class="headerlink" title="实现TCP服务器"></a>实现TCP服务器</h1><blockquote>
<p>echoserver实现：<a href="https://github.com/yangLieee/codebackup/tree/master/iperf">https://github.com/yangLieee/codebackup/tree/master/iperf</a></p>
</blockquote>
<ol>
<li><p>新建控制块 </p>
<p>使用tcp_new()函数建立一个TCP控制块。</p>
</li>
<li><p>绑定控制块</p>
<p>对于服务器来说，新建一个控制快后，需要在控制块上绑定本地IP和端口，以方便客户端的连接。</p>
</li>
<li><p>控制块侦听</p>
<p>使用tcp_listen函数，对于服务器来说，需要显性调用tcp_listen函数以使控制块进入监听状态，等待客户端的连接请求。</p>
</li>
<li><p>建立连接</p>
<p>在tcp_listen函数进入服务器监听状态后，需要马上使用tcp_accept函数来注册一个接收处理函数，因为一旦有客户端连接请求被成功建立后，服务器就会调用这个处理函数。</p>
</li>
<li><p>接受并处理数据</p>
<p>一旦连接成功，accept回调函数会调用tcp_recv函数注册一个接收完成的处理函数。对于服务器来说，接收到了客户端的数据或操作要求，就会调用这一回调函数进行处理。这其实是一个复杂的过程：接收到数据后，首先通知更新接受窗口（使用tcp_recved函数），处理并发送数据（使用tcp_write函数），数据发送成功则清除已发送的数据（使用tcp_sent函数），最后关闭连接（使用函数tcp_close）。</p>
</li>
</ol>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：<a href="https://blog.csdn.net/tanmx219/article/details/105930028">tcp_recvd正确调用方法</a>？</p>
<p>A：很多源码是在tcp_server_sent发送函数中调tcp_recvd，如果用户不是用来echo（立即发回相同的报文），而是真正要处理事务的时候，这种用法是错误的：此时，接收窗口大小由发送窗口决定，如果没有发送新数据，接收窗口就会越来越小，直到最后无法接收数据。<strong>正确的用法是：在收到数据后，应用层调用tcp_recved函数恢复原来的窗口大小；而在发送函数中，不用管窗口的事！</strong></p>
</li>
<li><p>Q：调用lwip iperf接口，无法关闭server?</p>
<p>A：lwip iperf只是实现当client断开连接删除掉其相关pcb结构体，而没有断开tcp连接没有释放监听端口，仿照lwiperf_tcp_close函数实现一个新的针对server关闭的接口即可</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.kancloud.cn/jiejietop/tcpip/988613">LwIP应用开发指南</a></li>
<li><a href="https://blog.csdn.net/weixin_54217950/article/details/121344759">网络基础之协议栈</a></li>
<li><a href="https://www.st.com/resource/zh/user_manual/um1713-developing-applications-on-stm32cube-with-lwip-tcpip-stack-stmicroelectronics.pdf">使用 LwIP TCP/IP 栈在 STM32Cube 上开发应用</a></li>
<li><a href="https://blog.51cto.com/u_15262460/2883223">LwIP使用经验</a></li>
<li><a href="https://blog.csdn.net/zhzht19861011/article/details/125322654">TCP回调函数是何时调用的</a></li>
<li><a href="https://blog.csdn.net/zhzht19861011/article/details/125278742">协议栈什么情况下发送 RST 标志</a></li>
</ol>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
      <tags>
        <tag>lwip</tag>
      </tags>
  </entry>
  <entry>
    <title>XPath Helper安装及使用</title>
    <url>/2022/12/03/third-party/xpath/</url>
    <content><![CDATA[<h1 id="引语"><a href="#引语" class="headerlink" title="引语"></a>引语</h1><p><em>在爬虫各个应用场景下，数据解析为其中重要的一环。而在数据解析中，BeautifulSoup、Xpath以及正则表达式等多种方法均为利器，在实际应用中根据不同场景选择不同的方法是最高效的，但是对各个方法的掌握程度要求很高。事实上，精通一种方法就已经满足需要了，再此基础之上，用辅助工具帮助理解提高效率。<br>本文将提供给“爬虫大师们”使用xpath方法的辅助工具XPath Helper插件。</em></p>
<h1 id="XPath-Helper简介"><a href="#XPath-Helper简介" class="headerlink" title="XPath Helper简介"></a>XPath Helper简介</h1><p>XPath即为XML路径语言，它是一种用来确定XML(标准通用标记语言的子集)文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。起初XPath的提出的初衷是将其作为一个通用的、介于XPointer与XSL间的语法模型。<br>XPath Helper是一款专用于chrome内核浏览器的实用型爬虫网页解析工具。XPath Helper插件功能强劲，支持进行XPath查询功能。XPath Help插件可以帮助用户在各类网站上通过按shift键选择想要查看的页面元素来提取查询其代码，同时还支持用户对查询出来的代码进行编辑，而编辑出的结果将立即显示在旁边的结果框中。</p>
<h1 id="XPath-Helper安装方法"><a href="#XPath-Helper安装方法" class="headerlink" title="XPath Helper安装方法"></a>XPath Helper安装方法</h1><ol>
<li>根据下面的链接将文件下载到本地。<br>链接：<a href="https://pan.baidu.com/s/18_Ws5qjHW9skhE1cb1jtYA">https://pan.baidu.com/s/18_Ws5qjHW9skhE1cb1jtYA</a><br>提取码：x0no</li>
<li>下载完成后，将文件的后缀名改为“.zip”，并进行解压。</li>
<li>解压之后有两个文件，将文件名为“2.0.2_0.crx”后缀名改为“.zip”，并对其进行二次解压。<br>==至此，所有弹出的提示语句全部选择  是==</li>
<li>二次解压完成，获得如下图所示的文件夹。如果红色框内文件夹如图所示，将“_metadata”改为“metadata”。如果默认就是“metadata”则不需要做任何操作。<br><img src="/images/third-party/xpath-1.png"></li>
<li>进入自己对应的浏览器。在此，我以Google浏览器为基础操作。<br><strong>点击谷歌右上角的三个点的按钮<br>选择更多工具——&gt;选择扩展程序<br>进入，打开开发者模式，加载已解压的扩展程序，选择相应的已解压的文件，确认！<br>重启浏览器，确认可以正常使用</strong></li>
<li>如下图表示创建成功。<img src="/images/third-party/xpath-2.png" alt="在这里插入图片描述"></li>
</ol>
<h1 id="XPath-Helper简单使用方法"><a href="#XPath-Helper简单使用方法" class="headerlink" title="XPath Helper简单使用方法"></a>XPath Helper简单使用方法</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>获取页面元素的xpath地址。</li>
<li>验证用户自己写的xpath地址是否正确。</li>
</ol>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>打开/关闭XPath Helper快捷键：Ctrl+Shift+x</li>
<li>打开Xpath Helper后的结果如下图所示<br> <img src="/images/third-party/xpath-3.png" alt="在这里插入图片描述"></li>
<li>打开该插件的情况下，按住Shift在页面内进行移动，鼠标所经过之处会有黄色方框显示，下图为在CSDN首页，选中标题引导框的结果。左侧的query框内即为选中内容的xpath地址。<br><img src="/images/third-party/xpath-4.png" alt="在这里插入图片描述"></li>
<li>如果作为验证的方法，在query框内写入自己写入xpath地址，看result框内是否是自己想要抓取的元素，如果不正确，可以实时在query内进行修改，直至获得正确xpath地址。<br><img src="/images/third-party/xpath-5.png" alt="在这里插入图片描述"></li>
</ul>
]]></content>
      <categories>
        <category>Third Party</category>
      </categories>
  </entry>
  <entry>
    <title>电池电量检测</title>
    <url>/2023/03/06/work-expericence/%E7%94%B5%E6%B1%A0%E7%94%B5%E9%87%8F%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>近期在做关于电池电量检测的工作，而硬件电路并没有使用库仑计（在部分嵌入式场景下成本太高），而是使用分压电路ADC采样。基于此对相关学习到的内容做总结和分享</p>
<h1 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h1><ul>
<li>锂电池的放电非线性；</li>
<li>充放电瞬间，电压值是突变的</li>
<li>锂电池随着使用电量减少，需要实现自动校准</li>
<li>……</li>
</ul>
<h1 id="充电IC基础原理"><a href="#充电IC基础原理" class="headerlink" title="充电IC基础原理"></a>充电IC基础原理</h1><h2 id="IC充电阶段"><a href="#IC充电阶段" class="headerlink" title="IC充电阶段"></a>IC充电阶段</h2><ul>
<li><p>涓流充电（Trickle Charge）</p>
<p>涓流充电阶段通常只在电池电压低于一个极低水平时采用。</p>
<p>在这种状态下，电池组的内部保护 IC 可能由于深度放电或发生过流事件已经断开了电池。充电器 IC 提供一个小电流（通常为 50mA）为电池组的电容充电，以触发保护 IC ，合上其 FET重新连接电池。虽然涓流充电通常只持续几秒钟，但充电器 IC 仍然需要集成一个定时器。如果电池组在一定时间内未重新连接，则定时器停止充电，因为这表明电池已损坏。</p>
</li>
<li><p>预充电（PreCharge）</p>
<p>一旦电池组重新连接或处于放电状态，就进入预充电阶段。</p>
<p>预充电期间，充电IC开始以一个较低的电流水平为耗尽的电池安全充电，该电流通常为 C / 10（C 为容量，以 mAh 为单位）。预充电使电池电压缓慢上升。其目的是在低电流水平下对电池进行安全的充电，以防止损坏电池，直到其电压达到一个较高的水平。</p>
</li>
<li><p>恒流充电（Constant Current Charge）</p>
<p>恒流（CC）充电也被称作快速充电阶段，恒流充电在预充电之后开始。</p>
<p>在恒流充电阶段，电池可以安全地处理 0.5C 至3C 之间的较高充电电流。恒流充电会持续到电池电压达到“满电”或浮动电压水平，然后进入恒压充电阶段。</p>
</li>
<li><p>恒压充电（Constant voltage Charge）</p>
<p>充电器 IC 会在恒流充电期间监测电池电压。一旦电池达到恒压充电阈值，充电器IC就会从恒流转换至恒压调节阶段。当充电器 IC 监测到外部电池组电压超过了电池组中的实际电池电压，就开始执行恒压充电。这是由于存在内部电池电阻、PCB 电阻和来自保护 FET 和单电池的等效串联电阻 (ESR)。充电器 IC 不应允许电池电压超过其最大浮动电压，以保证安全的运行。</p>
</li>
<li><p>截止阶段</p>
<p>对于浮充型充电芯片，当达到浮充阈值，输出恒定电压</p>
<p>对于关断型充电芯片，当充电充满，芯片处于关断待机状态，无充电电流</p>
</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li>对于IC各个充电阶段需要参考IC的手册最终确定有哪些阶段，有些将涓流充电和预充电合成一个阶段处理，所以需要具体分析。</li>
<li>有些充电IC提供了可编程配置阈值的功能，即通过连接不同的阻值来对其进行设置，如果没有需要参考手册确定每个阶段的阈值分别是多少。配置的阈值能够提供一层额外的安全保护，保护电池免受过压、过热条件以及过载的影响，从而避免电池的永久损坏或容量降级。</li>
</ol>
<h1 id="流程整理"><a href="#流程整理" class="headerlink" title="流程整理"></a>流程整理</h1><ol>
<li><p>配置 ADC</p>
<p>中断模式、设置重复采样时间、设置采样次数</p>
<ul>
<li>Vadc = adcNumer(ADC采样数据) x Vref（ADC基准电压）/  （2^ADC量化位数）</li>
<li>Vbat = k（电阻分压系数比） ×  Vadc</li>
</ul>
</li>
<li><p>配置 Timer</p>
<p>配置ADC采样的时间即多久进行一次电池电量检测</p>
</li>
<li><p>启动电池电量检测主线程</p>
</li>
<li><p>等待USB插拔事件中断或者Timer时间触发电池检测</p>
<ul>
<li>打开ADC采样通道</li>
<li>获取ADC数据</li>
<li>关闭ADC采样通道</li>
<li>计算最终输出的电池电量</li>
</ul>
</li>
</ol>
<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/************************************   ADC    *******************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">adc_interrupt_cb</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// calculate adc voltage</span></span><br><span class="line">    <span class="comment">// 校准：采集多次去掉一个最小值、去掉一个最大值，取平均值</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">adc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// config adc interrupt mode and callback</span></span><br><span class="line">    <span class="comment">// config adc sampling times</span></span><br><span class="line">    <span class="comment">// enable adc channels</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/************************************   USB    *******************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_interrupt_callback</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// get usb charging / discharging state</span></span><br><span class="line">    <span class="comment">// put battery detect time to default</span></span><br><span class="line">    <span class="comment">// enable adc sampling(enter adc_interrupt_cb)</span></span><br><span class="line">}   </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// request drv_bus gpio</span></span><br><span class="line">    <span class="comment">// config  drv_bus interrupt and trigger mode</span></span><br><span class="line">    <span class="comment">// config  interrupt callback</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/***********************************    TIMER     ***************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_interrupt_cb</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// enable adc sampling(enter adc_interrupt_cb)</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// config timer</span></span><br><span class="line">    <span class="comment">// config default battery detect time to timer</span></span><br><span class="line">    <span class="comment">// config timer interrupt callback</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/***********************************   BATTERY    ***************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_battery_voltage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// enable channels</span></span><br><span class="line">    <span class="comment">// get battery voltage</span></span><br><span class="line">    <span class="comment">// disable channels</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adjust_battery_voltage</span><span class="params">(<span class="type">int</span> vbat)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// record pre_percent pre_voltage</span></span><br><span class="line">    <span class="comment">// record voltage and timestamp, calculate new battery detect time</span></span><br><span class="line">    <span class="comment">// other optimize ways</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">calculate_battery_percent</span><span class="params">(<span class="type">int</span> vbat)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 需要厂家提供电池充放电电池容量百分比对应的电压</span></span><br><span class="line">    <span class="comment">// 查表===&gt;计算出百分比</span></span><br><span class="line">    <span class="comment">// 策略：</span></span><br><span class="line">    <span class="comment">//   最终的百分比相较于上一次是否有跳变，+-1；</span></span><br><span class="line">    <span class="comment">//   充电百分比减少，放电百分比增加。不被允许，需要对这两种情况处理掉</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//电池电量检测函数可以进一步优化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">battery_detect_thread</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    adc_init();</span><br><span class="line">    usb_init();</span><br><span class="line">    timer_init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// calculate battery percent</span></span><br><span class="line">        <span class="type">int</span> vbat = get_battery_voltage();</span><br><span class="line">        vbat = adjust_battery_voltage(vbat);</span><br><span class="line">        <span class="type">int</span> percent = calculate_battery_percent(vbat);</span><br><span class="line">    }</span><br><span class="line">    adc_deinit();</span><br><span class="line">    usb_deinit();</span><br><span class="line">    timer_deinit();</span><br><span class="line">}   </span><br></pre></td></tr></tbody></table></figure>

<h1 id="误差来源"><a href="#误差来源" class="headerlink" title="误差来源"></a>误差来源</h1><ol>
<li>ADC量化误差</li>
<li>分压电阻值不准确，导致分压比不确定带来的误差</li>
<li>OCV表格内记录的是阶段性的电压与容量比，每一格实际上不是线性变化的，但在实际处理过程中按照线性来处理</li>
</ol>
<h1 id="校准误差及优化策略"><a href="#校准误差及优化策略" class="headerlink" title="校准误差及优化策略"></a>校准误差及优化策略</h1><ol>
<li><p>ADC采样</p>
<p>平均值滤波。取十次adc数据，去掉最大值、最小值取平均值</p>
</li>
<li><p>插入usb / 拔出usb瞬间触发电池检测</p>
</li>
<li><p>记录最近十次采样的结果及sysTime，计算掉电或上电1%容量所消耗的时间，从而可以计算出下一次检测的时间间隔</p>
</li>
<li><p>在最终电池电量的显示上，需要逐步递增逼近采集的值不能突变</p>
</li>
<li><p>校准：根据一个确定状态下，确定的电压值和我们采集到的电压值，计算出偏差，校准</p>
</li>
</ol>
<h1 id="缩写表"><a href="#缩写表" class="headerlink" title="缩写表"></a>缩写表</h1><ul>
<li><p>OCV：Open Circuitt Voltage  开路电压</p>
</li>
<li><p>CV：Cyclic Voltammetry 循环伏安法（改变电位以得到氧化还原电流方向之方法）</p>
</li>
<li><p>UVLO：Under Voltage Lock Out 欠压锁定（输入电压低于某一值时，电源芯片不工作，处于保护状态）</p>
</li>
<li><p>OVP：Over Voltage Protection  过压保护</p>
</li>
<li><p>UVP：Under voltage Protection  欠压保护</p>
</li>
<li><p>ASOC：Absolute State-Of-Charge  绝对电荷状态 （绝对荷电状态则是一个当电池制造完成时，根据所设计的固定容量值所计算出来的的参考值）</p>
</li>
<li><p>RSOC： Relative State-Of-Charge 相对电荷状态（相对荷电状态的范围是 0% - 100%）</p>
</li>
</ul>
<p>一个全新完全充电电池的绝对荷电状态是100%；而老化的电池即便完全充电，在不同充放电情况中也无法到100%。</p>
<h1 id="IC原理图及其它参考资料"><a href="#IC原理图及其它参考资料" class="headerlink" title="IC原理图及其它参考资料"></a>IC原理图及其它参考资料</h1><ol>
<li><a href="https://www.dioo.com/uploads/product/20210521/77eaa63f9de5e6b03018958741f47a52.pdf">DIO58056</a></li>
<li><a href="https://www.docin.com/p-2290652672.html">SY8602</a></li>
<li><a href="https://www.ti.com.cn/cn/lit/an/zhcaaf7/zhcaaf7.pdf">TI电量计设计指导</a></li>
<li><a href="https://blog.csdn.net/Linux_LR/article/details/119787382">ADC电量检测与校准</a></li>
</ol>
]]></content>
      <categories>
        <category>Work Experience</category>
      </categories>
  </entry>
  <entry>
    <title>GPIO</title>
    <url>/2022/09/22/computerSystem/Peripherals/GPIO/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>GPIO：General Purpose Input Output，通用输入输出，简称为“IO口”，芯片与外围设备交互的硬件接口</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>以下图片来自STM32的GPIO硬件电路图</p>
<p><img src="/images/computerSystem/Peripherals/GPIO-1.png" alt="image"></p>
<p>施密特触发器：在正向递增和负向递减两个方向有不同的阈值，有一定的抗干扰能力，外部的小扰动不会导致cpu误判，直至剧烈变化或者真的有电平的变化。</p>
<h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><h2 id="输入（4）"><a href="#输入（4）" class="headerlink" title="输入（4）"></a>输入（4）</h2><ol>
<li>浮空输入：多用于外部按键输入，io状态不确定完全由外部输入决定</li>
<li>上拉输入：IO口输入设定为高电平输入（1），检测低电平或下降沿</li>
<li>下拉输入：IO口输入设定为低电平输入（0）</li>
<li>模拟输入：ADC模拟输入，测量外部电压幅值不通过TTL</li>
</ol>
<h2 id="输出（4）"><a href="#输出（4）" class="headerlink" title="输出（4）"></a>输出（4）</h2><ol>
<li>推挽输出：输出高低电平</li>
<li>开漏输出：只有一个NMOS导通，只能输出低电平+高阻态，不能输出高电平；当NMOS导通输出低电平，截至输出高阻态。用作线与，电平不匹配的场合，外部上拉</li>
<li>复用推挽输出：需要输出高低电平的其他模式，如：spi uart</li>
<li>复用开漏输出：普通i2c处于该模式</li>
</ol>
<h1 id="GPIO寄存器"><a href="#GPIO寄存器" class="headerlink" title="GPIO寄存器"></a>GPIO寄存器</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>以stm32为例</p>
<ul>
<li>GPIO 端口模式寄存器 (GPIOx_MODER) (x = A…I)</li>
<li>GPIO 端口输出类型寄存器 (GPIOx_OTYPER) (x = A…I)</li>
<li>GPIO 端口输出速度寄存器 (GPIOx_OSPEEDR) (x = A…I/)</li>
<li>GPIO 端口上拉/下拉寄存器 (GPIOx_PUPDR) (x = A…I/)</li>
<li>GPIO 端口输入数据寄存器 (GPIOx_IDR) (x = A…I)</li>
<li>GPIO 端口输出数据寄存器 (GPIOx_ODR) (x = A…I)</li>
<li>GPIO 端口置位/复位寄存器 (GPIOx_BSRR) (x = A…I)</li>
</ul>
<h2 id="GPIO-Shadow"><a href="#GPIO-Shadow" class="headerlink" title="GPIO Shadow"></a>GPIO Shadow</h2><p>由于设置某个模式的过程中配置的不只是一个寄存器，配置过程中就可能出现别的状态的产生，导致错误。而使用shadow寄存器，可以先将所有需要配置的寄存器分别设置进去，但不生效，直至全部设置完毕，再指定GPID即要映射的组上去生效！避免了中间非必要状态的产生。</p>
<h1 id="用户层应用"><a href="#用户层应用" class="headerlink" title="用户层应用"></a>用户层应用</h1><h2 id="配置GPIO"><a href="#配置GPIO" class="headerlink" title="配置GPIO"></a>配置GPIO</h2><p>在内核导出 gpio 节点的前提下， 可以操作/sys/class/gpio 节点， 控制 gpio 输入输出</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">导出节点：  echo <span class="number">20</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">export</span></span></span><br><span class="line"><span class="class">设置方向：  <span class="title">echo</span> [<span class="title">out</span> / <span class="title">in</span>] &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio20</span>/<span class="title">direction</span></span></span><br><span class="line"><span class="class">设置值：    <span class="title">echo</span> [0 / 1] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">value</span></span></span><br><span class="line"><span class="class">设置触发模式：<span class="title">echo</span> [<span class="title">none</span> / <span class="title">rising</span> / <span class="title">falling</span> /  <span class="title">both</span>] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">edge</span></span></span><br><span class="line"><span class="class">翻转属性：  <span class="title">echo</span> [0 / 1] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">active_low</span></span></span><br><span class="line"><span class="class">移除节点：  <span class="title">echo</span> 20 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">unexport</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>注意事项</p>
<ul>
<li>direction<br>如果内核不支持改变 GPIO 的方向，或者在导出时内核代码没有明确允许用户空间可以重新配置 GPIO 方向， 那么这个属性将不存在。</li>
<li>value<br>输出时，控制高低电平；输入时，获取高低电平</li>
<li>edge<br>控制中断触发模式，引脚被配置为中断后可以使用poll() 函数监听引脚<br>非中断引脚、上升沿触发、下降沿触发、边沿触发</li>
<li>active_low<br>用于翻转电平，当外部有效信号与GPIO有效信号不一致（即0可能表示有效，1也有可能表示有效）</li>
</ul>
<h2 id="查看GPIO配置"><a href="#查看GPIO配置" class="headerlink" title="查看GPIO配置"></a>查看GPIO配置</h2><p>不同的厂商对于GPIO配置结果的查看方式有所不同，以下以Ingenic-x2000为例对应相关的手册可以确定相应的IO状态</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">/<span class="meta"># cat /sys/devices/platform/apb/10010000.pinctrl/dump_gpio</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下图, 下面会有每一个GPIO状态</span></span><br><span class="line">REG 	|+++GPA++|+++GPB++|+++GPC++|+++GPD++|</span><br><span class="line"></span><br><span class="line">INL 	|<span class="number">0</span>c3fffff|<span class="number">67f</span>6036f|<span class="number">0110f</span>ef4|<span class="number">0f</span>7fffff|</span><br><span class="line">INT 	|<span class="number">02b</span>00000|<span class="number">30440000</span>|<span class="number">00000081</span>|<span class="number">00000100</span>|</span><br><span class="line">MSK 	|<span class="number">194f</span>cfff|ce0a0040|<span class="number">74f</span>f0076|<span class="number">003f</span>feff|</span><br><span class="line">PAT1 	|<span class="number">0265</span>cfff|f6440000|<span class="number">77</span>efc0fb|<span class="number">003f</span>fbff|</span><br><span class="line">PAT0 	|<span class="number">0f</span>8a3000|<span class="number">1033</span>efc0|<span class="number">88100005</span>|<span class="number">00000400</span>|</span><br><span class="line">EDG 	|<span class="number">3f</span>ffff00|f6037f00|<span class="number">10f</span>ff400|<span class="number">7f</span>ffff00|</span><br><span class="line">PLUP 	|<span class="number">14000000</span>|<span class="number">41800000</span>|<span class="number">00200001</span>|<span class="number">00000100</span>|</span><br><span class="line">PLDWN 	|<span class="number">00000000</span>|<span class="number">800000</span>c0|<span class="number">00100002</span>|<span class="number">00000000</span>|</span><br><span class="line">FLAG 	|<span class="number">00000000</span>|<span class="number">00000000</span>|<span class="number">00000000</span>|<span class="number">00000000</span>|</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="相关功能"><a href="#相关功能" class="headerlink" title="相关功能"></a>相关功能</h1><p>在低功耗场景下，系统休眠以后部分硬件时钟可能关闭。但是GPIO不依赖时钟，故可以配置IO作为中断源对CPU进行唤醒</p>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>GPIO</category>
      </categories>
  </entry>
  <entry>
    <title>MESI协议的优化与内存屏障</title>
    <url>/2023/03/06/computerSystem/cache/MESI%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>无论是计算机硬件还是软件，新的技术的出现的初衷一定是为了解决某项需求，而随之而来的可能会带来新的问题，无所谓解决就是了！</p>
<h1 id="MESI带来的性能问题"><a href="#MESI带来的性能问题" class="headerlink" title="MESI带来的性能问题"></a>MESI带来的性能问题</h1><p>从本质上来讲MESI协议解决的是数据的核间同步问题，但是严格遵守MESI协议一定又会带来新的问题。以下两种情况会再次带来性能问题：</p>
<ol>
<li>更新Shared状态的Cache。当某个缓存行的状态是Shared时，CPU想要修改该缓存行的数据，一定会产生总线事件通知其它CPU将该缓存行副本状态置Invalid，当拥有该缓存行副本的CPU确认并回复它“Invalid acknowledgement”以后，它才能进行数据更新。</li>
<li>更新Invalid状态的Cache。当某个缓存行的状态是Invalid时，CPU想要修改该缓存行的数据，一定会产生总线事件从其它CPU甚至是主存中加载进最新数据，进而基于最新数据进行更新。</li>
</ol>
<h1 id="MESI协议优化"><a href="#MESI协议优化" class="headerlink" title="MESI协议优化"></a>MESI协议优化</h1><p>MESI协议以上两个痛点可以发现是由于事务串行化所带来的负面影响。所以解决这两个问题的关键就是使MESI协议的请求异步化，释放总线提高并行度。因而就有了在硬件上增加写缓存区和失效队列两种方法。</p>
<h2 id="写缓冲-Store-Buffer"><a href="#写缓冲-Store-Buffer" class="headerlink" title="写缓冲 Store Buffer"></a>写缓冲 Store Buffer</h2><p><img src="/images/computerSystem/storage/cache-9.png" alt="image"></p>
<p>基于之前的缓存结构，增加完Store Buffer之后的结果如上图所示。</p>
<p>整个同步过程：CPU想要修改某个缓存数据，首先通过总线广播获得总线所有权，发出信号通知其它CPU需要将该缓存块数据置无效，然后将需要更新的数据放入到Store Buffer。而此时就可以释放总线所有权去做其它的事情不用等待收到ACK（效率提高在此），等其它cpu都收到再由Store Buffer慢慢做核间同步，刷入Cache的值即可</p>
<p>当CPU读数据时，首先会先在Store Buffer中查询记录是否存在，如果存在则会从写缓冲区中直接获取，这一机制即是 Store Fowarding。</p>
<h2 id="失效队列-Invalid-Queue"><a href="#失效队列-Invalid-Queue" class="headerlink" title="失效队列 Invalid Queue"></a>失效队列 Invalid Queue</h2><p><img src="/images/computerSystem/storage/cache-10.png" alt="image"></p>
<p>在Store Buffer基础之上，增加完Invalid Queue之后的结构如上图所示</p>
<p>失效队列的存在可以说是更好的使Store Buffer工作。当CPU收到使某个缓存行失效的请求时，如果迟迟不回复ACK则可能导致Store Buffer里数据越来越多最终溢出，因此Invalid Queue的存在可以说是为了平衡Store Buffer写入速度和收到ACK速度</p>
<p>过程：当CPU Core收到使某个cache失效的消息时，先回复确认收到的消息，然后将失效的数据加入到Invalidate Queue中。而队列的实失效的操作等待空闲时候在进行处理。</p>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><h2 id="MESI优化之后带来的问题"><a href="#MESI优化之后带来的问题" class="headerlink" title="MESI优化之后带来的问题"></a>MESI优化之后带来的问题</h2><p>MESI协议本身属于强一致性协议，但是经过性能的优化变成了弱一致性协议，这就导致在某些中间状态下多核CPU的数据可能并不一致。</p>
<h3 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h3><p>由于Store Buffer的引入将部分事务变成并行，这就将导致数据的更新顺序将不会严格按照代码顺序执行，进而导致其它CPU拿到正确数据的时机延后。例如：CPU需要顺序执行A、B两条写指令，A在CPU0的缓存行状态是S，B在CPU0的缓存行状态是E，最终的cache对于两条指令所对应的两个数据的更新的顺序可能不是我们所期望的</p>
<h3 id="Invalid-Queue"><a href="#Invalid-Queue" class="headerlink" title="Invalid Queue"></a>Invalid Queue</h3><p>CPU1在回复ACK之后实际并没有对数据所在的缓存行置Invalid，而是放入到队列中。假如此刻CPU0更新了缓存行这将导致该数据在两个核的cache上表现不一致</p>
<h3 id="Reorder"><a href="#Reorder" class="headerlink" title="Reorder"></a>Reorder</h3><p>指令重排序从源头上就造成了指令实际执行的顺序与我们代码所期望执行的顺序存在差别。而Reorder设计的本质实际上是为了对我们的代码进行优化，提高cache命令率从而提高执行效率</p>
<ul>
<li>编译器重排序</li>
<li>CPU乱序执行</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>其实对于以上MESI优化带来的问题归根结底是在多核CPU上导致最终结果的偏差。进一步思考是多核CPU同时修改同一个变量时而引发的问题，而在实际过程中这种情况是比较少的。在效率和极少数数据不正确两者的考量下，继续基于此进行优化，但是不是硬件优化而是通过软件由程序员保证数据的一致性。因此在需要核间的同步的情况下，多线程对于数据的修改和对于数据的使用需要引起注意，在适当的地方添加内存屏障</p>
<p>内存屏障（Memory Barriers）其实可以理解为一道墙，前面的读写操作没有完成后面的读写操作不能发生</p>
<h2 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h2><p>本质：读屏障前后指令的读操作不能翻越屏障！强制CPU在屏障前的读操作处理到所有Invalid Queue中的数据，获取到最新的数据。</p>
<h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>本质：写屏障前后指令的写操作不能翻阅屏障！强制CPU在屏障前的写操作清空Store Buffer内容，将数据更新至cache甚至主存</p>
<h2 id="读写屏障"><a href="#读写屏障" class="headerlink" title="读写屏障"></a>读写屏障</h2><p>以上两种屏障只有在区分读写屏障的体系结构里才会有作用，比如 alpha 结构。而在 X86 和 Arm 中是没有作用的，这是因为 X86 采用的 TSO 模型不存在缓存一致性的问题，而 Arm 则是采用了另一种称为单向屏障的分类方式。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/375706879">缓存一致性硬核讲解</a></li>
<li>编程高必学的内存知识（极客时间 海纳）</li>
</ul>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>storage system</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache原理</title>
    <url>/2023/02/15/computerSystem/cache/%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>在大多数程序运行过程中，CPU对于内存的访问会表现出明显的倾向性，具体体现在两个方面：</p>
<ul>
<li>时间局部性：时间维度看，被引用过的内存位置，不远的将来将大概率再次被访问</li>
<li>空间局部性：空间维度看，被引用过的内存位置，不远的将来它附近的内存位置将大概率被访问</li>
</ul>
<h2 id="缓存块"><a href="#缓存块" class="headerlink" title="缓存块"></a>缓存块</h2><blockquote>
<p>linux查看缓存信息命令：getconf -a | grep CACHE</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>根据cache的作用可知cache当中存储的是主存的副本，其必须是要和主存进行数据交换的。基于效率角度考量，根据程序局部性原理，CPU是不会按照一个字节一个字节进行数据的加载至缓存中，而是按块进行加载，而这每一块就叫做cache line，也称缓存块</p>
<ul>
<li>缓存块（cache line），管理缓存结构的最小存储单元，目前常用的是64Bytes（内存系统支持Burst读/写效率更高）</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/images/computerSystem/storage/cache-3.png" alt="image"></p>
<ul>
<li>标识位V：表示该缓存块是否有效</li>
<li>标识位M：表示这个缓存块是否被修改，也就是脏位</li>
<li>Tag：和内存块匹配的标识</li>
<li>Data：缓存数据内容</li>
</ul>
<p>需要注意的是 V、M、Tag这几位是由硬件门电路实现的，并不占缓存空间。而Data才是真正的数据部分</p>
<h2 id="缓存命中-x2F-缺失"><a href="#缓存命中-x2F-缺失" class="headerlink" title="缓存命中/缺失"></a>缓存命中/缺失</h2><ul>
<li>Cache Hit：访存时，如果所需要的数据在cache中则成为缓存命中</li>
<li>Cache Miss：访存时，如果所需要的数据不在cache中则成为缓存缺失</li>
</ul>
<h1 id="缓存映射方式"><a href="#缓存映射方式" class="headerlink" title="缓存映射方式"></a>缓存映射方式</h1><blockquote>
<p>视频链接：<a href="https://www.bilibili.com/video/BV1Qd4y1J7XA">click here</a></p>
</blockquote>
<p>从概念上讲，高速缓存是一个相联存储器（Associative Memory）。硬件电路实现方式及映射策略的不同，缓存的映射方式分为三种：</p>
<ul>
<li>全相连映射：主存块可以映射到任一缓存行（缓存只有一个组，所有的内存块都放在这一个组的不同路上)</li>
<li>直接相连映射：主存块只能映射到固定的缓存行（缓存只有一个路，一个内存块只能放置在特定的组上）</li>
<li>组组相连映射：主存块只能映射到固定的缓存组，组内任一缓存行（缓存同时由多个组和多个路）</li>
</ul>
<p>片外的高速缓存通常是直接映射的，因为组相联需要更宽的接口，可以取得多个标签，并发匹配</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><table>
<thead>
<tr>
<th>组织方式</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>全相联映射</td>
<td>cache利用率高<br>块冲突低<br>淘汰算法复杂</td>
<td>小容量cache</td>
</tr>
<tr>
<td>直接相连映射</td>
<td>cache利用率低<br>块冲突高<br>淘汰算法简单</td>
<td>大容量cache</td>
</tr>
<tr>
<td>组相联映射</td>
<td>cache利用率较高<br>块冲突率较低<br>硬件实现复杂</td>
<td>中等容量cache</td>
</tr>
</tbody></table>
<h2 id="映射算法"><a href="#映射算法" class="headerlink" title="映射算法"></a>映射算法</h2><ul>
<li>全相联：cache行号 = random</li>
<li>直接相联：cache行号 = 内存块号 % cache行数</li>
<li>组相联：主存的数据块映射到Cache特定组的任意行，cache组号=主存块号 % cache组数</li>
</ul>
<h1 id="缓存块替换策略"><a href="#缓存块替换策略" class="headerlink" title="缓存块替换策略"></a>缓存块替换策略</h1><ul>
<li><p>随机法（RAND）</p>
<p>方法简单、易于实现，但命中率比较低。</p>
</li>
<li><p>先进先出算法（FIFO）</p>
<p>先进先出方法易于实现，命中率比随机法好些。</p>
</li>
<li><p>最近最久未使用算法（LRU，Least Recently Used）</p>
<p>可以比较好地遵循程序局部性原理</p>
</li>
</ul>
<h1 id="缓存写策略"><a href="#缓存写策略" class="headerlink" title="缓存写策略"></a>缓存写策略</h1><h2 id="write-back-写回"><a href="#write-back-写回" class="headerlink" title="write back 写回"></a>write back 写回</h2><p>将要写入的数据保留在高速缓存中，并进行标记（Dirty / Modified）。只有缓存块被替换的时候才会将数据写入主存</p>
<p><img src="/images/computerSystem/storage/cache-4.png" alt="image"></p>
<h2 id="write-through-写透-x2F-写穿-x2F-写直达"><a href="#write-through-写透-x2F-写穿-x2F-写直达" class="headerlink" title="write through 写透/写穿/写直达"></a>write through 写透/写穿/写直达</h2><p>CPU总是将数据直接写到主内存中</p>
<blockquote>
<p>note：如果等待写内存完成处理器的性能会急剧下降，通过写缓冲（Write Buffer）硬件可以弥补这一问题。将需要写入的数据存储在一个FIFO队列中（Write Buffer），由内存控制器进行写入操作</p>
</blockquote>
<p><img src="/images/computerSystem/storage/cache-5.png" alt="image"></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><blockquote>
<p>由于效率原因，写更新和写不分配这两种策略在现实中比较少出现</p>
</blockquote>
<ol>
<li><p>CPU 之间的更新策略</p>
<p>当某个 CPU 的缓存中执行写操作，修改其中的某个值时，其他 CPU 的缓存所保有该数据副本的更新策略分为：写更新（Write Update）和写无效（Write Invalidate）。</p>
</li>
<li><p>写缓存时数据是否被加载</p>
<p>当前要写入的数据不在缓存中时，根据是否要先将数据加载到缓存中，写策略分为：写分配（Write Allocate）和写不分配（Not Write Allocate）。</p>
</li>
</ol>
<h1 id="缓存效率"><a href="#缓存效率" class="headerlink" title="缓存效率"></a>缓存效率</h1><h2 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h2><p>两个参数的乘积：</p>
<ol>
<li><strong>高速缓存缺失率</strong>：cache miss / 被执行的指令次数</li>
<li><strong>高速缓存缺失重填的开销</strong>：cpu流水线重新计算从主存取数到缓存中的时间</li>
</ol>
<h2 id="cache-miss的原因？"><a href="#cache-miss的原因？" class="headerlink" title="cache miss的原因？"></a>cache miss的原因？</h2><blockquote>
<p>《see mips run》对于以下缺失类型分别称为：第一次访问；抖动；替换</p>
</blockquote>
<ol>
<li>强制缺失。第一次将数据块读入到缓存所产生的缺失，也被称为冷缺失（cold miss），因为当发生缓存缺失时，缓存是空的（冷的）；</li>
<li>冲突缺失。由于缓存的相连度有限导致的缺失（指在同一组内的缺失）；</li>
<li>容量缺失。由于缓存大小有限导致的缺失（描述范围是整个缓存）</li>
</ol>
<h2 id="如何提高利用率？"><a href="#如何提高利用率？" class="headerlink" title="如何提高利用率？"></a>如何提高利用率？</h2><ul>
<li>软件<ol>
<li>程序更小；</li>
<li>让程序经常执行的部分更小。对于一个程序错误处理/初始化代码等部分代码剥离出来，提高剩余程序的缓存命中率；</li>
<li>安排程序尽量不发生冲突缺失（抖动）</li>
<li>直到必须用到数据时才停止CPU。非阻塞读。取数操作执行完，继续执行不依赖该数据的代码（流水线乱序/分支指令等等）</li>
<li>多线程CPU</li>
</ol>
</li>
<li>硬件<ol>
<li>（1）让高速缓存变的更大（代价）</li>
<li>（1）增加缓存相连度（4路以上效果就不明显了，更高路相连缓存设计目的在于其它原因（降低功耗，不使用时关掉整路））</li>
<li>（1）增加额外层次的高速缓存（L2 L3 cache）</li>
<li>（2）增加带宽，cpu与主存物理位置更近（代价）</li>
<li>（2）增加内存burst带宽（现在很少使用）</li>
<li>（2）尽早地重启CPU</li>
<li>（2）<a href="https://oscpu.github.io/NutShell-doc/%E5%8A%9F%E8%83%BD%E9%83%A8%E4%BB%B6/cache.html">关键字优先</a></li>
</ol>
</li>
</ul>
<h1 id="管理缓存"><a href="#管理缓存" class="headerlink" title="管理缓存"></a>管理缓存</h1><blockquote>
<p>对于MIPS CPU，synci指令做了以下所有工作（用户特权级）</p>
</blockquote>
<p>上电之后CPU的高速缓存阵列内容通常是随机的。引导软件负责初始化高速缓存，系统启动并正常运行后，只有三种情况CPU必须进行干预：</p>
<ol>
<li><strong>DMA设备从内存取数据之前</strong>。如果是Write Back式写策略，需要将在高速缓存中未写入到主存的数据写入得到正确数据</li>
<li><strong>DMA设备写数据到内存之前</strong>。需要将高速缓存中对应的缓存行的标志位置Invalid（无效的）</li>
<li><strong>写指令</strong>。当cpu自身写一部分指令到内存用于稍后执行时，首先需要保证指令写入到内存中，其次保证 I-Cache 中对应的指令无效</li>
</ol>
<blockquote>
<p>视频推荐：</p>
<p><a href="https://www.bilibili.com/video/BV1QA411t7Uv">Cache地址映射与变换方法</a></p>
<p><a href="https://www.bilibili.com/video/BV1h3411h7kV">一张图解决主存和cache的映射问题</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>storage system</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存一致性协议</title>
    <url>/2023/03/06/computerSystem/cache/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="导语-cache、主存与CPU的通信"><a href="#导语-cache、主存与CPU的通信" class="headerlink" title="导语 - cache、主存与CPU的通信"></a>导语 - cache、主存与CPU的通信</h1><p><img src="/images/computerSystem/storage/cache-6.png" alt="image"></p>
<p>如图所示，私有Cache是每个处理器核心所特有的比如L1、L2，共享 Cache是所有处理器核心的共享缓存比如L3，而整体Cache与主存的数据交互是要通过总线进行的。当两个核加载了主存的同一块缓存副本，其中一个核进行了数据的更改，是否要写入主存？是否要通知给其它CPU核心进行修改？因此对于多核CPU来讲，缓存在提高效率的同时也带来了缓存一致性的问题，而这个问题是需要进行解决的</p>
<h1 id="核心需求"><a href="#核心需求" class="headerlink" title="核心需求"></a>核心需求</h1><p>缓存一致性核心核心需要解决的问题就是：<strong>将本CPU更新的数据有效的传播到其它CPU本地缓存中</strong></p>
<p>进一步可以总结成需要遵从两个特性</p>
<ol>
<li>写传播：CPU Core的对内存的写操作，其它CPU Core可见</li>
<li>事务串行化：其它CPU Core看到的内存的写操作的顺序是一致的</li>
</ol>
<p>写传播可以保证修改的数据能够传播给其它CPU，而事物串行化则保证数据在其它CPU内的正确性。比如CPU有3个Core，Core1将x修改为3，Core2将数据修改为5，两个事务需要同步到Core3同时Core1 Core2互相同步，如果不保证串行，最终的数据很大概率是错误的</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h2><p><a href="https://www.inf.ed.ac.uk/teaching/courses/pa/Notes/lecture05-snooping.pdf">嗅探一致性协议</a></p>
<p> 总线除了能在一个主模块和一个从模块之间传输数据，还支持一个主模块对多个从模块写入数据，这种操作就是广播。</p>
<p>写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心，最常⻅实现的方式是总线嗅探(<strong>Bus Snooping</strong>)。当某个CPU Core的缓存行有更新时，需要将所有的读写操作广播到所有 CPU Core，而虽然总线上其它CPU Core的私有缓存不一定有对应的缓存行，但也要时刻监视或侦听总线，以验证它是否具有所请求数据块的副本，如果存在使对应的缓存副本失效或更新。使用广播的方式看似一视同仁，实际这样做大大增加了总线的负担。</p>
<h2 id="Directory-based-机制"><a href="#Directory-based-机制" class="headerlink" title="Directory-based 机制"></a>Directory-based 机制</h2><p><a href="https://courses.cs.washington.edu/courses/cse471/00au/Lectures/luke_directories.pdf">基于目录的缓存一致性协议</a></p>
<p>针对总线嗅探的缺点，<strong>Directory-based 机制</strong>采点对点的传播，基于目录机制总线事件只会传给自己感兴趣的CPU。这是因为所有缓存行的信息，都被记录在 directory 中。比如会记录每个缓存行当前都在那些核的缓存中，直接将缓存行修改的消息发送到那些核。这么做的也有个缺点是每次总线的传输都到 directory 做一次检查，产生耗时。</p>
<h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p>总线的独占性要求同一时刻最多只有一个主模块占用总线，天然地会将所有核心对内存的读写操作串行化。如果多个核心同时发起总线事务，此时总线仲裁单元会对竞争做出仲裁，未获胜的事务只能等待获胜的事务处理完成后才能执行。对于写缓存来讲，多核并发的写事件会通过<strong>总线仲裁机制</strong>转换成串行化的写事件序列</p>
<h2 id="缓存写策略"><a href="#缓存写策略" class="headerlink" title="缓存写策略"></a>缓存写策略</h2><ul>
<li>写分配 Write Allocate：要写入的数据不在缓存中，需要将该数据对应的内存块读入缓存；</li>
<li>写不分配 Write Not Allocate：要写入的数据不在缓存中，无需将该数据对应的内存块读入缓存，而是直接写入主存；</li>
<li>写穿 Write Through：写入缓存到的数据立马传播到主存；</li>
<li>写回 Write Back：写入缓存的数据不会立马传播到主存，而是该缓存块被替换时才更新；</li>
<li>写更新 Write Update：每次缓存写入新值，发起一次总线请求，通知其它CPU如果拥有该缓存块的副本就更新为新的值（需要传新的值）</li>
<li>写无效 Write Invalid：每次缓存写入新值，发起一次总线请求，通知其它CPU如果拥有该缓存块副本置为无效状态，如果未来需要在来要新的值（不需要传新的值）</li>
</ul>
<h1 id="缓存一致性协议种类"><a href="#缓存一致性协议种类" class="headerlink" title="缓存一致性协议种类"></a>缓存一致性协议种类</h1><blockquote>
<p> 该表格翻译自 <a href="https://people.eecs.berkeley.edu/~pattrsn/252F96/Lecture18.pdf">Snooping vs. Directory Based Coherency</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>名字</th>
<th>协议类型</th>
<th>内存写策略</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>Write Once</td>
<td>写无效</td>
<td>第一次写之后写回</td>
<td>First snoopy protocol</td>
</tr>
<tr>
<td>Synapse N+1</td>
<td>写无效</td>
<td>写回</td>
<td>1st cache-coherent MPs</td>
</tr>
<tr>
<td>Berkeley</td>
<td>写无效</td>
<td>写回</td>
<td>伯克利 SPUR</td>
</tr>
<tr>
<td>Illinois</td>
<td>写无效</td>
<td>写回</td>
<td>SGI Power and Challenge</td>
</tr>
<tr>
<td>“Firefly”</td>
<td>写广播（写更新)</td>
<td>写回私有，写穿共享</td>
<td>SPARCCenter 2000</td>
</tr>
<tr>
<td>MESI</td>
<td>写无效</td>
<td>写回</td>
<td>奔腾，PowerPC</td>
</tr>
</tbody></table>
<h1 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过缓存一致性协议的种类核应用场景来看，MESI应用在Intel奔腾处理器和PowerPC上，可以说有着很广泛的应用了。</p>
<p>MESI是四个单词的首字母缩写（Modified，Exclusive，Shared， Invalid），这四个单词代表了四种状态。因此可以缓存行可以用2bit来唯一表征这四种状态的某一种状态。</p>
<ul>
<li>M：Modified，被修改的（也可以称为Dirty 脏的）。当前CPU对应的该缓存行数据被修改，拥有最新数据（private, != Memory）</li>
<li>E：Exclusive，独享的。该缓存行只存在于当前CPU中，并且数据有效（干净）(private, =Memory))</li>
<li>S：Shared，共享的。该缓存行也存在于其它CPU中，并且数据有效（干净）(shared, =Memory)</li>
<li>I：Invalid，无效的。当前CPU内的该缓存行数据失效(NULL)</li>
</ul>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><blockquote>
<p>本部分基于进行重新梳理</p>
</blockquote>
<h3 id="来自处理器的请求"><a href="#来自处理器的请求" class="headerlink" title="来自处理器的请求"></a>来自处理器的请求</h3><ul>
<li>PrRd：处理器请求读一个缓存块</li>
<li>PrWt ：处理器请求写一个缓存块</li>
</ul>
<p><img src="/images/computerSystem/storage/cache-7.png" alt="image"></p>
<ul>
<li><p>M：唯一且数据！=memory（最新数据）。读写依然是最新数据（！= memory）</p>
</li>
<li><p>E：唯一且数据=memory。读不影响状态，写则与主存数据不一致置M</p>
</li>
<li><p>S：共享且数据=memory。读不影响状态，写则将拥有最新数据置M，同时产生总线事务通知其它处理器要写该缓存</p>
</li>
<li><p>I：无效的，一定Cache Miss。读首先将数据加载进缓存，产生BusRd的总线事务，内存控制器响应请求，同时如果发现其它处理器也拥有该缓存块副本则置S，如果没有置E；写则产生BusRdx的总线事务，由于拥有最新数据状态置M</p>
</li>
</ul>
<h3 id="来自总线（其它处理器）的请求"><a href="#来自总线（其它处理器）的请求" class="headerlink" title="来自总线（其它处理器）的请求"></a>来自总线（其它处理器）的请求</h3><ul>
<li><p>BusRd：总线侦听到其它处理器请求读一个缓存块</p>
</li>
<li><p>BusRdX：总线侦听到其它处理器请求写一个自己没有缓存副本的缓存块</p>
</li>
<li><p>BusUpgr：总线侦听到其它处理器请求写本地缓存（该处理器拥有的缓存块）</p>
</li>
<li><p>Flush：总线侦听到其它处理器请求写回一个缓存块到主存（cache to memory）</p>
</li>
<li><p>FlushOpt：总线侦听到其它处理器请求将一个缓存块通过总线的方式发送另外一个处理器（cache to cache）</p>
<p><img src="/images/computerSystem/storage/cache-8.png" alt="image"></p>
</li>
<li><p>M：唯一且数据！=memory（最新数据）。 BusRd说明其它处理器要读，则需要写传播将数据写到主存，因为其它处理器读所以数据=memory且共享置状态S；当BusRdx或BusUpgr说明其它处理器要写，这两种情况无论发起请求的处理器有没有缓存一定不是最新的所以一定产生Flush的总线事务，并且其它处理器写完就不是最新的了置I</p>
</li>
<li><p>E：唯一且数据=memory。BusRd说明其它处理器要读，我的数据已经是最新的了所以产生FlushOpt总线事务，将该缓存块传走并置状态S；其它处理器写最终结果一定是我的私有缓存无效置I，但是如果发起总线事务的处理器没有该缓存我需要产生FlushOpt的总线事务将数据传输，否则不产生总线事务</p>
</li>
<li><p>S：共享且数据=memory。BusRd说明其它处理器要读，我的数据是最新的了所以产生FlushOpt总线事务，将该缓存块传走保持S状态；其它处理器写最终结果一定是我的私有缓存无效置I，但是如果发起总线事务的处理器没有该缓存我需要产生FlushOpt的总线事务将数据传输，否则不产生总线事务</p>
</li>
<li><p>I：无效的。各种读写情况都不会影响，继续保持状态</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《编程高手必学的内存知识》极客时间海纳</li>
<li><a href="https://juejin.cn/post/6844903965696458765">cache一致性里的MESI协议</a></li>
<li><a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm">MESI动画</a></li>
</ul>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>storage system</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache简介</title>
    <url>/2023/02/15/computerSystem/cache/%E7%BC%93%E5%AD%98%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>随着技术的不断进步，芯片制程和工艺有了极大的发展，相应的CPU的计算能力越来越强。作为程序员，我们希望有无线资源的快速存储器可以使用，但是快速存储器的成本非常高昂，因此访存变成了计算机系统的性能瓶颈。为了平衡cpu运行速度与访存速度之间的差异缓存被设计出来！</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>缓冲存储器，简称缓存(cache)，用于存储可能频繁访问的数据。</p>
<p>缓存结合了寄存器速度快和内存造价低的优点，因此通过缓存的设计使整个存储系统的性能接近寄存器，并且每字节的成本都接近内存，甚至是磁盘。</p>
<p>高速缓存的工作就是将内存中最近读写过的数据在高速缓存中保留一个<strong>备份</strong>，使这些数据能够快速地返回给CPU</p>
<h1 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h1><blockquote>
<p>本节内容大多取自极客时间，《编程高手必学的内存知识》海纳</p>
</blockquote>
<p>缓存的组成单元是SRAM，而目前SRAM通常采用了6管式的存储电路</p>
<p>简单来讲，SRAM 存储单元的特点是使用 6 个晶体管来实现。其中两个 P 型 MOS 管和两个 N 型 MOS 管组成两个反相器用于存储信息。还有两个用于控制存储单元是否选通。6 管 SRAM 的结构比触发器简单，速度也比较快</p>
<h2 id="连接图"><a href="#连接图" class="headerlink" title="连接图"></a>连接图</h2><p>如下图所示，M1 和 M3 两个 MOS 管，是 N 沟道场效应管，在高电压时导通；而 M2 和 M4 这两个 MOS，则是 P 沟道场效应管，在低电压时导通。本质上，M1 和 M2 一起组成了一个非门，M3 和 M4 一起组成了另一个非门，这两个非门的输出互为对方的输入，这样，两个非门就组成了一种可以存储比特值的电路。</p>
<p><img src="/images/computerSystem/storage/cache-0.png" alt="image"></p>
<h2 id="等效图"><a href="#等效图" class="headerlink" title="等效图"></a>等效图</h2><p><img src="/images/computerSystem/storage/cache-1.png" alt="image"></p>
<h2 id="读写原理"><a href="#读写原理" class="headerlink" title="读写原理"></a>读写原理</h2><p>当要读入SRAM数据时，字线 (Word Line, WL) 加高电平，使得每个基本单元的两个控制开关M5、M6导通，存储单元与位线 (Bit Line, BL) 连通。位线用于读取或写入基本单元的保存状态。</p>
<p>我们假定储存的内容为 1，即在 Q 处的电平为高。读取周期开始时，两条位线预先设成高电平，随后字线 WL 变成高电平，使得两个访问控制晶体管 M5 与 M6 导通。Q 的高电平使得晶体管 M1 导通，而 Q 反与 BL 反的预充值不同，使得 BL 反经由 M1 与 M5 放电而变成逻辑 0。在位线 BL 一侧，Q 反的低电平使得 M4 导通，再加上 M6 通路，位线就连接到 VDD 的高电压。</p>
<p>如果储存的内容为 0，相反的电路状态将会使 BL 反为 1，而 BL 为 0。这时，只需要 BL 与 BL 反有一个很小的电位差，读取的放大电路就会辨识出哪条位线是 1，哪条是 0。也就是说，当敏感度越高时，读取的速度就越快。</p>
<p>在写入周期开始时，把要写入的状态加载到位线。如果要写入 0，则设置 BL 反为 1 且 BL 为 0。随后字线 WL 加载为高电平，位线的状态被加载进 SRAM 的基本单元。</p>
<h1 id="缓存基础"><a href="#缓存基础" class="headerlink" title="缓存基础"></a>缓存基础</h1><h2 id="集成方式"><a href="#集成方式" class="headerlink" title="集成方式"></a>集成方式</h2><ul>
<li>分布式缓存：一个处理器对应一个缓存；</li>
<li>集中式缓存：多个处理器（核）共享一个内存；</li>
<li>混合式缓存：在 L3 采用集中式缓存，在 L1 和 L2 采用分布式缓存。</li>
</ul>
<p><img src="/images/computerSystem/storage/cache-2.png" alt="image"></p>
<h2 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h2><blockquote>
<p>冯诺依曼架构：指令和数据混合存储在同一存储器</p>
<p>哈弗架构：指令和数据独立存储，分别放在程序存储器和数据存储器</p>
</blockquote>
<p>在cache设计之初，cpu与内存之间只有一个cache。随着芯片工艺的提高，现代CPU通常采用二级/三级多级缓存结构。</p>
<ul>
<li>一级缓存（L1 Cache）：在Core内部，分为指令缓存（I-cache）和数据缓存（D-cache）（冯诺依曼架构）。容量通常在32~256KB，速度3 cycles</li>
<li>二级缓存（L2 Cache）：具体芯片Core内外不同。容量256KB~3MB不等，速度11cycles（哈弗架构）</li>
<li>三级缓存（L3 Cache）：在Core外部，所有CPU核心共享。容量更大，速度25cycles（哈弗架构）</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote>
<p><strong>统一缓存：</strong> 指令和数据统一存放在一个缓存中</p>
<p><strong>分离缓存：</strong> 指令和数据分别存放在不同缓存中</p>
</blockquote>
<h3 id="L1-采用分离缓存的原因？"><a href="#L1-采用分离缓存的原因？" class="headerlink" title="L1 采用分离缓存的原因？"></a>L1 采用分离缓存的原因？</h3><ol>
<li>流水线角度。可避免取指和执行时期的访存冲突。 在 CPU 内核中，取指和访存是由两个不同的硬件单元完成的。如果使用统一缓存，当 CPU 使用超前控制或流水线控制（并行执行）的控制方式时，会存在取指作和访存同时争用同一个缓存的情况，降低 CPU 运行效率</li>
<li>cache行为角度。I-cache大多是顺序取指，指令只有读没有写；D-cache是取数据变化较大，数据可读可写，最重要的是冯诺依曼的结构是指令和数据分离，I和D在一起只有相互干扰</li>
<li>物理设计角度。一块cache，同时需要数据和指令的访问，端口上是很难实现的</li>
</ol>
<h3 id="L1分离缓存、L2统一缓存？"><a href="#L1分离缓存、L2统一缓存？" class="headerlink" title="L1分离缓存、L2统一缓存？"></a>L1分离缓存、L2统一缓存？</h3><ol>
<li>成本角度。L1 cache miss 性能损失与增加L2分离缓存的成本的平衡</li>
<li>物理设计角度。分离式设计会占用逻辑电路的面积与设计难度，对于L1这种size比较小的采用分离式设计可以承受，但是对于更大的Cache全采用分离设计，无疑设计难度和面积都会加大</li>
<li>效率角度。分离缓存不适用所有情况，对于指令和数据存放大小的需求不同，无法做到动态调节cache的大小，可能会有浪费</li>
</ol>
<h3 id="cache放在片内的优势？"><a href="#cache放在片内的优势？" class="headerlink" title="cache放在片内的优势？"></a>cache放在片内的优势？</h3><ol>
<li>片内缓存物理距离更短，片内缓存与取指令单元和取数据单元的物理距离更短，速度更快；</li>
<li>片内缓存不占用系统总线， 片内缓存使用独立的 CPU 片内总线，可以减轻系统总线的负担。</li>
</ol>
<h3 id="不需要cache的场景？"><a href="#不需要cache的场景？" class="headerlink" title="不需要cache的场景？"></a>不需要cache的场景？</h3><p>51单片机、cortex-M0（–M4）系列ARM处理器都没有cache</p>
<ol>
<li>低功耗、低成本处理器并且工作频率不高（几十兆到几百兆）的处理器不需要，可能甚至不需要SRAM</li>
<li>cache无法保证实时性，缓存缺失时向RAM加载数据的时间是不等的</li>
</ol>
]]></content>
      <categories>
        <category>Computure System</category>
        <category>Storage</category>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>storage system</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
</search>

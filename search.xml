<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello New World</title>
    <url>/2022/08/22/Essay/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>Be all you can be!</p>
</blockquote>
<p>Hello World 是程序员进入编程世界后看到的第一道风景，我也十分乐意这作为第一篇博文的标题，对我来讲可能是：你好新世界！</p>
<p>笔者是一名嵌入式软件工程师，未来更多的内容将会是关于Linux、Android等相关内容，编程语言方面将会是以C / C++为主。做这个博客有三个目的：</p>
<ol>
<li>记录自己在工作中遇到的问题及相关解决办法。帮助自己积累调试经验同时帮助其他可能遇到同样问题的朋友，避免踩很多坑；</li>
<li>总结自己近期学到的新的知识和内容。这部分不一定是最全面的但对于处于相同阶段的我们一定是最实用的，后面再不断的完善更新；</li>
<li>最后可能就是简单的记录并安利一些实用的工具或者比较好的文章，能够以通俗的语言帮助我们理解某一个点或者看清楚某一个面。</li>
</ol>
<p>目前我只搭建了主页基础模块，后面随着文章的不断输出也会添砖加瓦的。我也希望后续能写一些读书笔记或者生活经验来做记录做分享！博客更新频率暂定1~2周至少一篇内容也一定是和工作生活相关的。如果有错误还请指正!</p>
<p align="right">2022-8-22/23.38</p>

<p align="right">Lee</p>

]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
  <entry>
    <title>搭建Ubuntu虚拟机</title>
    <url>/2022/10/22/Essay/ubuntu-create/</url>
    <content><![CDATA[<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><p>linus自传《只是为了好玩》中这样定义：</p>
<ul>
<li><p>类Unix操作系统</p>
</li>
<li><p>开放源代码方式协作开发</p>
</li>
<li><p>采用GPL通用许可证维权</p>
</li>
<li><p>主要用于超级电脑、企业级服务器、嵌入式设备等</p>
</li>
</ul>
<h1 id="Ubuntu-简介"><a href="#Ubuntu-简介" class="headerlink" title="Ubuntu 简介"></a>Ubuntu 简介</h1><ul>
<li>桌面应用为主的Linux操作系统</li>
<li>操作简单、方便使用</li>
<li>系统安全性高，默认user权限登录</li>
<li>Ubuntu中文网站：<a href="http://www.wubantu.co/">http://www.wubantu.co</a></li>
<li>Ubuntu中文社区：<a href="http://www.ubuntu.org.cn/">http://www.ubuntu.org.cn</a></li>
<li>Ubuntu技术：<a href="http://wiki.ubuntu.org.cn/">http://wiki.ubuntu.org.cn</a></li>
</ul>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul>
<li>物理主机</li>
<li>iso镜像</li>
<li>vmware / VirtualBox</li>
</ul>
<p>网盘中我准备了ubuntu20.04.4-iso、ubuntu16.04.7-iso、Vmware-16.2.3安装包及密钥和一份linux命令大全！</p>
<p>密钥对于不同版本可能有差异可以都进行尝试，其只是对于个人学习使用，建议购买正版！</p>
<p>同时附上相关官网链接：</p>
<ul>
<li>ubuntu各版本镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/</a></li>
<li>vmware官网：<a href="https://www.vmware.com/cn/products/workstation-pro.html">https://www.vmware.com/cn/products/workstation-pro.html</a></li>
<li>VirtualBox：<a href="https://www.virtualbox.org/">https://www.virtualbox.org</a></li>
<li>资源网盘链接：<a href="https://pan.baidu.com/s/18vxScuvFp2Vf4g28nRSC5w">https://pan.baidu.com/s/18vxScuvFp2Vf4g28nRSC5w</a><br>提取码：f8uo</li>
</ul>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>参考视频：<a href="https://www.bilibili.com/video/BV1hd4y127HY">https://www.bilibili.com/video/BV1hd4y127HY</a></p>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
  <entry>
    <title>理解c/c++ Volatile关键字</title>
    <url>/2022/11/15/LanguageFeatures/Volatile/</url>
    <content><![CDATA[<p>网络上对于volatile的解读众说纷纭，而且其中较多的是java内存模型。</p>
<p>本篇文章将基于自己的学习和实验，针对C/C++语言嵌入式开发场景进行volatile关键字的分析</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>volatile 关键字是 C /C++ 编程语言的一部分，作为一种类型修饰符。我将其作用总结为<em><strong>告诉编译器禁止优化其所修饰对象的读写访存操作及指令顺序，保证变量的可见性</strong></em></p>
<blockquote>
<p>可见性：当一个线程修改了共享变量后，其他线程能够立即得知这个修改。</p>
<p>有序性：程序执行的顺序按照代码的先后顺序执行。</p>
<p>原子性：一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行。</p>
</blockquote>
<p>在《程序员的自我修养》这本书中讲到，volatile基本可以做到两个事情：</p>
<ol>
<li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回</li>
<li>阻止编译器调整操作volatile变量的指令顺序</li>
</ol>
<p>对于第一个作用volatile是可以很好的做到，而对于第二个作用编译器层面可以保证指令有序但是我们无法阻止cpu动态调整顺序。真正保证有序性是需要通过内存屏障完成的，而volatile并没有内存屏障的功能，gcc 提供了一个内联函数 <em><strong>asm volatile (“” : : : “memory”</strong>)</em> 编译器屏障，具体平台相关内存屏障需要到具体的结构平台去参考</p>
<h1 id="理解volatile"><a href="#理解volatile" class="headerlink" title="理解volatile"></a>理解volatile</h1><blockquote>
<p>Collins对于Volatile释义：A situation that is volatile is <strong>likely</strong> to change <strong>suddenly</strong> and <strong>unexpectedly</strong>.</p>
</blockquote>
<p><strong>volatile</strong> 本身释义为 <strong>易失的、易变的</strong></p>
<p>对于用volatile所修饰的对象，在其自身的含义基础上，有三个副词可以很好的对其性质进行诠释：</p>
<ul>
<li><p>likely   可能地，指对象的状态可能变化、也可能不变保持状态，强调结果；</p>
</li>
<li><p>suddenly:   突然地，指对象状态的瞬时变化，强调过程；</p>
</li>
<li><p>unexpectedly:  不可预期地，指对象变化的时间结果都不可预期；</p>
</li>
</ul>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>根据含义性质，在嵌入式开发中以下三种场景是一定要考虑使用volatile关键字的（大多数情况一定使用！！！）</p>
<ol>
<li>多线程任务读写同一全局变量，</li>
<li>中断服务程序修改的全局变量</li>
<li>内存映射外设寄存器</li>
</ol>
<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h2 id="中断场景"><a href="#中断场景" class="headerlink" title="中断场景"></a>中断场景</h2><p>下面一段代码，我们所期待的结果是主程序运行，直到crtl+c按键按下程序退出，代码编译执行之后并不是我们所预期的样子。如果sig_done变量不通过volatile修饰程序将永远不会退出，而volatile关键字很好的解决了这一个问题</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> sig_done = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//static volatile bool sig_done = false;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(sig == SIGINT)</span><br><span class="line">    ┆   sig_done = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main start, press ctrl+c go on\n"</span>);</span><br><span class="line">    signal(SIGINT, handler);</span><br><span class="line">    <span class="keyword">while</span>(!sig_done) {</span><br><span class="line">    }   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main exit\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译命令</span></span><br><span class="line">gcc main.c <span class="number">-02</span></span><br><span class="line">objdump -d a.out &gt; a.s</span><br></pre></td></tr></tbody></table></figure>

<p>通过反汇编比较两个程序的异同（左侧volatile，右侧无volatile）</p>
<p><img src="/images/LanguageFeatures/meld.png" alt="image"></p>
<p>没有voaltile的while实现方式为：</p>
<ol>
<li>比较rip寄存器+0x2f65地址处的值（sig_done）与 0 是否相等</li>
<li>不相等跳转到main+0x30即上一条指令处</li>
<li>跳转</li>
</ol>
<p>有volatile的while实现方式：</p>
<ol>
<li><p>nopl (%rax) 编译器开启优化后使指令按字对齐,减少取指令的时钟周期。</p>
</li>
<li><p>将 rip寄存器+0x2f65地址处的值放到eax寄存器中</p>
<blockquote>
<p>movzbl指令负责拷贝一个字节，并用0填充其目的操作数中的其余各位，这种扩展方式叫“零扩展”。</p>
<p>movsbl指令负责拷贝一个字节，并用源操作数的最高位填充其目的操作数中的其余各位，这种扩展方式叫“符号扩展”。</p>
</blockquote>
</li>
<li><p>test   %al,%al 对eax寄存器低位逻辑与</p>
<blockquote>
<p>Test命令：将两个操作数进行逻辑与运算，并根据运算结果设置相关的标志位（ze: zero flag）。但是，Test命令的两个操作数不会被改变。运算结果在设置过相关标记位后会被丢弃。</p>
</blockquote>
</li>
<li><p>je   如果ZF（零标志位）=1，零标志位为1（真值）说明结果为0，则转到label所指的指令语句；否则跳过这条语句，执行下条语句</p>
</li>
</ol>
<h2 id="多线程场景"><a href="#多线程场景" class="headerlink" title="多线程场景"></a>多线程场景</h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> mstop = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//static volatile bool mstop = true;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">first_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s start\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">while</span>(mstop) {</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s exit\n"</span>, __func__);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">second_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s start\n"</span>, __func__);</span><br><span class="line">    mstop = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s exit\n"</span>, __func__);</span><br><span class="line">}                                                                                                                                                                     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::thread fthread{first_thread};</span><br><span class="line">    std::thread sthread{second_thread};</span><br><span class="line">    fthread.<span class="built_in">join</span>();</span><br><span class="line">	sthread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="外设寄存器"><a href="#外设寄存器" class="headerlink" title="外设寄存器"></a>外设寄存器</h2><p>对于外设通常设置有状态寄存器，我们可以通过循环读取状态寄存器的值来查看对应外设的状态。对于如下示例，如果没有使用volatile关键字，编译器可能生成的代码是读取一个固定地址的值而不会每次都从主存中读取新的值（或者读取n次状态，生成的代码只读取了一次，然后使用n次相同的值）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//设置寄存器</span></span><br><span class="line">*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *) STATUS_BASE_ADDR = <span class="number">1</span> &lt;&lt; <span class="number">24</span>; </span><br><span class="line"><span class="comment">//读寄存器</span></span><br><span class="line"><span class="keyword">while</span>(!(*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *) STATUS_BASE_ADDR)) {</span><br><span class="line">    <span class="comment">// do action</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h1><p>该部分不是volatile的使用，而是对内屏屏障的理解</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mp3decoder.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mp3decoder</span> :</span> public decoderImp </span><br><span class="line">{</span><br><span class="line">    public:</span><br><span class="line">    	<span class="type">static</span> mp3decoder* <span class="title function_">getInstance</span><span class="params">()</span>;</span><br><span class="line">    private:</span><br><span class="line">    	mp3decoder();</span><br><span class="line">    	~mp3decoder();</span><br><span class="line">    	<span class="type">static</span> mp3decoder* mdecoder;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//mp3decoder.cpp</span></span><br><span class="line"><span class="comment">//线程不安全，适用于单线程</span></span><br><span class="line">mp3decoder* mp3decoder::mdecoder = <span class="literal">NULL</span>;</span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全，但锁的代价太高</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全，锁的代价太高</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">        mdecoder = new mp3decoder();</span><br><span class="line">    <span class="keyword">return</span> mdecoder;</span><br><span class="line">    unlock();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Double-Checked Locking Pattern (DCLP 双检查锁)，指令重排序reorder不安全</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">        lock();</span><br><span class="line">    	<span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>)</span><br><span class="line">       		mdecoder = new mp3decoder();</span><br><span class="line">         unlock();</span><br><span class="line">    	<span class="keyword">return</span> mdecoder;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存屏障</span></span><br><span class="line">mp3decoder* <span class="title function_">mp3decoder::getInstance</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">    	<span class="keyword">if</span>(mdecoder == <span class="literal">NULL</span>) {</span><br><span class="line">            mp3decoder *tmp = new mp3decoder();</span><br><span class="line">            MemoryBarrier();</span><br><span class="line">            mdecoder = tmp;</span><br><span class="line">        }</span><br><span class="line">    	<span class="keyword">return</span> mdecoder;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// mdecoder = new mp3decoder()在cpu层面动作：</span></span><br><span class="line"><span class="comment">// 1. 分配内存</span></span><br><span class="line"><span class="comment">// 2. 调用构造函数</span></span><br><span class="line"><span class="comment">// 3. 将内存地址赋值给mdecoder指针</span></span><br><span class="line"><span class="comment">// 由于2、3对于编译器来讲是有可能进行优化的，即先将指针赋值再调用构造函数，导致线程不安全！！</span></span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>参考文章：</p>
<ul>
<li><a href="https://barrgroup.com/embedded-systems/how-to/c-volatile-keyword">How to Use C’s volatile Keyword</a></li>
<li><a href="https://barrgroup.com/tech-talks/volatile-c">Pro Tips for Using C’s volatile Keyword</a></li>
<li><a href="https://liam.page/2018/01/18/volatile-in-C-and-Cpp/">谈谈 c / c++ 中的volatile</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>LanguageFeatures</category>
      </categories>
      <tags>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>libc部分库函数说明</title>
    <url>/2023/05/17/LanguageFeatures/libc-function/</url>
    <content><![CDATA[<h1 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h1><blockquote>
<p>参考文章：<a href="https://blog.csdn.net/liuintermilan/article/details/6280816">strtok和strtok_r的使用要点和实现原理</a> </p>
</blockquote>
<p><em><strong>字符分隔函数最好使用 strsep 而最好不要使用strtok,</strong></em></p>
<p><em><strong>第一个参数源字符串一定为字符串数组变量，不能是字符串常量。因为字符串常量禁止修改！！</strong></em></p>
<ul>
<li><p>头文件：#include &lt;string.h&gt;</p>
<p>声明：char *strtok(char *str, const char *delim);</p>
</li>
<li><p>参数及返回值</p>
<p>源字符串数组指针，分隔符字符串指针；</p>
<p>放回值为指向被分割的子串的指针</p>
</li>
<li><p>函数功能：</p>
<p>对字符串s，以delim为分隔符将s切分为一个个子串</p>
</li>
<li><p>实例</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span>* nbaName = <span class="string">"jordan,james,kobe,curry"</span>;</span><br><span class="line">    <span class="type">char</span> cbaName[] = <span class="string">"yaoMing,yijianLian,wangzhiZhi,zhouQi"</span>;</span><br><span class="line">    <span class="type">char</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>] = {<span class="number">0</span>};</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1 </span></span><br><span class="line"><span class="comment">//    for(ptr=strtok(nbaName,","); ptr; ptr=strtok(NULL,","))  // error </span></span><br><span class="line">    <span class="keyword">for</span>(ptr=strtok(cbaName,<span class="string">","</span>); ptr; ptr=strtok(<span class="literal">NULL</span>,<span class="string">","</span>))    <span class="comment">// right</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ptr);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">memcpy</span>(name, nbaName, <span class="built_in">strlen</span>(nbaName));</span><br><span class="line">    <span class="keyword">for</span>(ptr=strtok(name,<span class="string">","</span>); ptr; ptr=strtok(<span class="literal">NULL</span>,<span class="string">","</span>))</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ptr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="access"><a href="#access" class="headerlink" title="access"></a>access</h1><ol>
<li><p>linux头文件 :  &lt;unistd.h&gt;</p>
<p>声明 : int access ( const char * pathname , int mode)</p>
</li>
<li><p>作用 :  该函数同来判断指定文件或者目录是否有mode对应的属性. 有效返回0, 否则返回-1</p>
</li>
<li><p>参数介绍:</p>
<p>pathname 时文件的路径名字 + 文件名</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>value</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>F_OK</td>
<td>0</td>
<td>判断文件是否存在</td>
</tr>
<tr>
<td>X_OK</td>
<td>1</td>
<td>判断文件是否有可执行权限</td>
</tr>
<tr>
<td>W_OK</td>
<td>2</td>
<td>判断文件是否有写权限</td>
</tr>
<tr>
<td>R_OK</td>
<td>3</td>
<td>判断文件是否有读权限</td>
</tr>
</tbody></table>
<blockquote>
<p>后面三种可以通过“ | ”的方式一起使用,例如 :  W_OK | X_OK</p>
</blockquote>
</li>
<li><p>windows头文件 : &lt;io.h&gt;</p>
<p>声明 : int _access(const char* _Filename, int _AccessMode);</p>
<p>使用与linux同, 存在(00)、仅读(04)、仅写(02)、既可读又可写(06)权限</p>
<p>如果mode传入的值不是0或2或4或6，调用此函数则会crash</p>
</li>
</ol>
<h1 id="c-str"><a href="#c-str" class="headerlink" title="c_str( )"></a>c_str( )</h1><ol>
<li><p>c++ 头文件 : <iostream></iostream></p>
<p>声明 : const char* c_str() const</p>
</li>
<li><p>返回值: </p>
<p>c_str()函数返回一个指向C字符串的指针常量，即是const char*的，不能直接赋值给char*<br>这将与c语言兼容，c_str()把string 对象转换成c中的字符串样式</p>
</li>
<li><p>使用方式</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">20</span>]; </span><br><span class="line"><span class="built_in">string</span> s=<span class="string">"1234"</span>; </span><br><span class="line"><span class="built_in">strcpy</span>(c,s.c_str()); </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="strtoul"><a href="#strtoul" class="headerlink" title="strtoul( )"></a>strtoul( )</h1><ol>
<li>c头文件&lt;stdlib.h&gt;</li>
</ol>
<p>   声明：unsigned long int strtoul(const char *nptr, char **endptr, int base);<br>              unsigned long long int strtoull(const char *nptr, char **endptr,int base);</p>
<ol start="2">
<li><p>参数及返回值</p>
<ul>
<li>参数nptr：字符串的起始地址</li>
<li>参数endptr： 返回字符串有效数字的结尾地址。如 123456fe789 则返回数字f的地址。</li>
<li>参数base：转化基数。参数 base 范围从2 至36，或0。参数 base 代表 nptr 采用的进制方式，如 base 值为10 则采用 10 进制，若 base 值为16 则采用16 进制数等。</li>
</ul>
</li>
<li><p>功能描述</p>
<p>   convert a string to an unsigned long integer(把输入的字符串转换成数字).<br>      strtoul() 会扫描参数nptr 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时(‘\0’)结束转换，并将结果返回。</p>
</li>
<li><p>注意</p>
<ul>
<li>当 base 的值为 0 时，默认采用 10 进制转换，但如果遇到 ‘0x’ / ‘0X’ 前置字符则会使用 16 进制转换，遇到 ‘0’ 前置字符则会使用 8 进制转换。</li>
<li>若 endptr 不为NULL，则会将遇到的不符合条件而终止的字符指针由 endptr 传回；若 endptr 为 NULL，则表示该参数无效，或不使用该参数。本文最后的范例没有展示 endptr 参数的使用，你可以参考 strtol() 函数的范例来更加直观地了解 endptr 参数。</li>
</ul>
</li>
<li><p>实例</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> </span><br><span class="line">{   </span><br><span class="line">	<span class="type">char</span> buffer [<span class="number">256</span>];   </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ul; </span><br><span class="line">    <span class="type">char</span> * endptr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">	   <span class="built_in">printf</span> (<span class="string">"Enter an unsigned number: "</span>);  </span><br><span class="line">	   fgets (buffer, <span class="number">256</span>, <span class="built_in">stdin</span>);   </span><br><span class="line">	   ul = strtoul (buffer, &amp;endptr, <span class="number">10</span>);   </span><br><span class="line">       <span class="built_in">printf</span> (<span class="string">"Value entered: %lu ,the address of the first invalid character is %d ,invalid character=%s\n"</span>, ul,endptr,endptr);   </span><br><span class="line">	   system(<span class="string">"pause"</span>); </span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf( )"></a>snprintf( )</h1><ol>
<li><p>c头文件 ： &lt;stdio.h&gt;</p>
<p>声明：int snprintf(char *str, size_t size, const char *format, …);</p>
</li>
<li><p>参数及返回值</p>
<p>str为要写入的字符串；n为要写入的字符的最大数目，超过n会被截断；format为格式化字符串，与printf()函数相同；argument为变量。</p>
<p>成功则返回参数str 字符串长度，失败则返回-1，错误原因存于errno 中。</p>
</li>
<li><p>函数功能</p>
<p>写入字符串</p>
</li>
<li><p>实例</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> str[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">snprintf</span>(str, <span class="number">3</span>, <span class="string">"%s"</span>, <span class="string">"abcdefg"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="fork-x2F-exec"><a href="#fork-x2F-exec" class="headerlink" title="fork/exec"></a>fork/exec</h1><ul>
<li><p>fork</p>
<p>调用fork可以创建一个新的进程称为子进程, 调用fork函数的进程称为父进程, 子进程的所有内容都和父进程相同, 除了pcb(进程控制模块)。如果这两个进程都没有对内存做写操作的话, 那么两个进程共享调用fork函数的进程的内存页, 这样表面上看fork创建进程比exec创建进程快. 但只要两个进程其中一个对内存做了修改, 那么在修改之前, 就会把内存页复制一份给子进程用（写时复制）</p>
</li>
<li><p>exec</p>
<p>调用exec创建进程, 实际上不是创建进程, 更准确的说是加载可执行文件, 调用exec后会把exec中指定的可执行文件加载到调用exec的进程的空间内, 并把调用exec的进程的内存更新为exec中指定的可执行文件的内容.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>LanguageFeatures</category>
      </categories>
  </entry>
  <entry>
    <title>fork与mmap的底层原理</title>
    <url>/2023/09/10/LanguageFeatures/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>上一篇主要对页中断的机制进行简单的了解并对源码进行相关的阅读，而过程中依赖于页中断的场景是比较多的。本篇主要针对fork、execve、mmap三个系统调用的原理进行分析。对于它们所完成的功能背后都是由页中断在背后进行默默支撑的。</p>
<h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>功能</p>
<p>以当前进程作为父进程，将所有资源进行拷贝创建一个子进程。</p>
</li>
<li><p>返回值</p>
<ul>
<li>&lt;0，fork函数调用失败</li>
<li>=0，父进程返回值</li>
<li>&gt;0，子进程返回值，实际上是子进程的PID</li>
</ul>
<p>当fork系统调用成功时，它会返回两个值：0（父进程），新的子进程的PID（&gt;0</p>
</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol>
<li><p>复制一份进程控制块（Process Control Block，PCB)。</p>
<p>这个过程我理解类似于复制粘贴，此时父子进程拥有相同的虚拟资源（各自一份）和硬件资源（同一个）。PCB结构体内所存储的所有内容对两个进程全部公开且共享。</p>
</li>
<li><p>复制页表并将PTE添加写保护</p>
<p>把页表中所有正常状态的数据段、堆和栈空间的虚拟内存页，设置为不可写，然后把已经映射的物理页面的引用计数加 1。</p>
</li>
<li><p>两个进程加入操作系统调度队列（fork作用结束）</p>
</li>
<li><p>如果父子进程都没有写操作，则正常调度直至两个进程结束，由于复制PCB两个进程的IP寄存器指向fork调用所以有两个返回值</p>
</li>
<li><p>父子进程如果有一个发生写操作，由于页表项设置成不可写，所以一定发生写保护中断</p>
<ul>
<li><p>do_page_fault</p>
</li>
<li><p>handle_pte_fault</p>
<p>判断中断发生类型。PTE页表项PRESENT置位说明已经映射了物理页面，同时flag参数是写请求但是判断PTE并没有写权限，说明是一次写保护中断</p>
</li>
<li><p>do_wp_page</p>
<p>判断发生中断的虚拟地址所对应的物理地址的引用计数，如果大于 1，就说明现在存在多个进程共享这一块物理页面，那么它就需要为发生中断的进程再分配一个物理页面，把老的页面内容拷贝进这个新的物理页，最后把发生中断的虚拟地址映射到新的物理页。这就完成了一次写时复制 (Copy On Write， COW）</p>
</li>
</ul>
</li>
</ol>
<h1 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h1><h2 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>参数</p>
<ul>
<li><p>addr：用户进程中要映射的用户空间的起始地址，通常为NULL（由内核来指定）</p>
</li>
<li><p>length：要映射的内存区域的大小</p>
</li>
<li><p>prot：期望的内存保护标志</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">PROT_EXEC 		<span class="comment">// 页内容可以被执行</span></span><br><span class="line">PROT_READ		<span class="comment">// 页内容可以被读取</span></span><br><span class="line">PROT_WRITE		<span class="comment">// 页可以被写入</span></span><br><span class="line">PROT_NONE 		<span class="comment">// 页不可访问</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>flags：指定映射对象的类型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">MAP_FIXED（***）</span><br><span class="line"><span class="comment">//使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。该参数是用于固定mmap第一个参数addr的</span></span><br><span class="line">MAP_SHARED（***）</span><br><span class="line"><span class="comment">//与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。相当于创建了一个共享映射区，一个进程对该文件的修改，其他进程也可以观察到，这就实现了数据的通讯</span></span><br><span class="line">MAP_PRIVATE（***）</span><br><span class="line"><span class="comment">//建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。</span></span><br><span class="line">MAP_DENYWRITE </span><br><span class="line"><span class="comment">//这个标志被忽略</span></span><br><span class="line">MAP_EXECUTABLE </span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">MAP_NORESERVE</span><br><span class="line"><span class="comment">//不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。</span></span><br><span class="line">MAP_LOCKED</span><br><span class="line"><span class="comment">//锁定映射区的页面，从而防止页面被交换出内存。</span></span><br><span class="line">MAP_GROWSDOWN </span><br><span class="line"><span class="comment">//用于堆栈，告诉内核VM系统，映射区可以向下扩展。</span></span><br><span class="line">MAP_ANONYMOUS（***）</span><br><span class="line"><span class="comment">//匿名映射，映射区不与任何文件关联(需要注意此时，fd参数需要置空)</span></span><br><span class="line">MAP_ANON</span><br><span class="line"><span class="comment">//MAP_ANONYMOUS的别称，不再被使用。</span></span><br><span class="line">MAP_FILE</span><br><span class="line"><span class="comment">//兼容标志，被忽略。</span></span><br><span class="line">MAP_32BIT</span><br><span class="line"><span class="comment">//将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台 上得到支持。</span></span><br><span class="line">MAP_POPULATE</span><br><span class="line"><span class="comment">//为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。</span></span><br><span class="line">MAP_NONBLOCK </span><br><span class="line"><span class="comment">//仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>fd：文件描述符（由open函数返回）</p>
</li>
<li><p>offset：设置在内核空间中已经分配好的的内存区域中的偏移，例如文件的偏移量，大小为PAGE_SIZE的整数倍</p>
</li>
</ul>
</li>
<li><p>返回值</p>
<p>mmap()返回被映射区的指针，该指针就是需要映射的内核空间在用户空间的虚拟地址</p>
</li>
</ul>
<h2 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h2><h3 id="私有匿名映射"><a href="#私有匿名映射" class="headerlink" title="私有匿名映射"></a>私有匿名映射</h3><ul>
<li>应用场景：分配堆空间（本质上来说，这部分申请的空间是从文件映射区映射得到的，但是功能上与堆空间类似，暂且可以称之为堆）</li>
<li>参数<ul>
<li>flag：MAP_PRIVATE、MAP_ANONYMOUS</li>
<li>fd：-1</li>
</ul>
</li>
<li>原理<ol>
<li>在文件映射区分配用户所需要的内存大小</li>
<li>创建VMA结构，不进行实际物理内存的分配，返回</li>
<li>写内存时，调用do_anonymous_page 进行物理内存的分配</li>
<li>建立虚拟内存到物理内存的映射关系</li>
</ol>
</li>
</ul>
<h3 id="私有文件映射"><a href="#私有文件映射" class="headerlink" title="私有文件映射"></a>私有文件映射</h3><ul>
<li><p>应用场景：加载动态链接库</p>
</li>
<li><p>参数</p>
<ul>
<li>flag：MAP_PRIVATE</li>
<li>fd：非空，该参数填充使用open系统调用打开的文件描述符</li>
</ul>
</li>
<li><p>原理：</p>
<ol>
<li>在文件映射区分配用户所需要的内存大小</li>
<li>创建VMA结构，不进行实际物理内存的分配，返回</li>
<li>第一次访问，一定是缺页中断由于是文件映射，则调用do_fault函数进一步判断</li>
<li>如果是读操作，调用do_read_fault</li>
<li>如果是写操作，并且是私有映射调用do_cow_fault</li>
<li>私有文件映射的代码段（只读页）是在多进程间共享的，而数据段（可写页）是私有的在每一个进程中独立，而这个副本仍然是写时复制</li>
</ol>
</li>
<li><p>其它</p>
<p>在linux文件系统上，磁盘上的每一个文件都有一个inode结构与之对应，且这个inode结构在整个系统上是唯一的，也就是说多个进程看到的inode结构是一样的。</p>
<p>该inode包含有关文件或目录的元数据信息，如文件类型、文件大小、权限、所有者、时间戳和数据块指针。</p>
<p>在 inode 结构中，有一个哈希表，以文件的页号为 key，以物理内存页为 value。当进程 A 打开了文件 f，然后读取了它的第 4 页，这时，内核就会把 4 和这个物理页，放入这个哈希表中。当进程 B 再打开文件 f，要读取它的第 4 页时，因为 f 的第 4 页的内容已经被加载到物理页中了，所以就不用再加载一次了。只需要将 B 的虚拟地址与这个物理页建立映射就可以了</p>
</li>
</ul>
<h3 id="共享文件映射"><a href="#共享文件映射" class="headerlink" title="共享文件映射"></a>共享文件映射</h3><ul>
<li><p>应用场景：多进程通信</p>
</li>
<li><p>参数</p>
<ul>
<li>flag：MAP_SHARED</li>
<li>fd：非空，该参数填充使用open系统调用打开的文件描述</li>
</ul>
</li>
<li><p>原理</p>
<p>共享文件映射的原理与私有文件的映射原理几乎一致，但是共享文件的需求就是要求每一个进程对文件的修改对其他文件都可见，所以对于可写页面也不会创建副本而是共享。</p>
<p>而当发生缺页中断的时候，最终调用的函数为do_share_fault（文件映射、共享映射）</p>
</li>
</ul>
<h3 id="共享匿名映射"><a href="#共享匿名映射" class="headerlink" title="共享匿名映射"></a>共享匿名映射</h3><ul>
<li><p>应用场景：父子间的进程通讯</p>
</li>
<li><p>参数</p>
<ul>
<li>flag：MAP_ANONYMOUS、MAP_SHARED</li>
<li>fd：-1</li>
</ul>
</li>
<li><p>代码示例</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 父进程创建一块内存区域，子进程也可以看到这块区域</span></span><br><span class="line">addr = mmap(<span class="literal">NULL</span>, length, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANOUNYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">child_pid = fork();</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>原理</p>
<p>当fork子进程的时候，会将vma结构一起复制一份。父子进程都可以看到这块区域，对于这块内存是共享的可读写，所以后面的操作与共享文件映射是一致的。而当发生写操作的时候，写保护中断发生作用，调用do_wp_fault，这个流程就可以参考fork的操作。</p>
</li>
</ul>
<h2 id="功能总结"><a href="#功能总结" class="headerlink" title="功能总结"></a>功能总结</h2><p><img src="/images/LanguageFeatures/mmapfunc.png" alt="image"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>&lt;&lt;编程高手必学的内存知识 – 10&gt;&gt;   海纳</p>
]]></content>
      <categories>
        <category>LanguageFeatures</category>
      </categories>
  </entry>
  <entry>
    <title>《Google工作法》</title>
    <url>/2023/02/06/ReadingNotes/Google%E5%B7%A5%E4%BD%9C%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/images/ReadingNotes/GoogleWork.jpg" alt="img"></p>
<p>《google工作法》作者是彼得·费利克斯·格日瓦奇，针对google的一些工作方法论和个人经验的进行著书。我认为对于这类书籍的正确使用是通读全篇，二次阅读针对部分内容自己进行场景的带入，此类工具书籍可以经常来进行翻看对自己日常生活工作方式的判断</p>
<p>针对每个细分章节，总结并进行自己的思考</p>
<h1 id="Faster（※）"><a href="#Faster（※）" class="headerlink" title="Faster（※）"></a>Faster（※）</h1><h2 id="一次结束，当场做完"><a href="#一次结束，当场做完" class="headerlink" title="一次结束，当场做完"></a>一次结束，当场做完</h2><p>作者认为决定工作效率的关键在于对 现在 的使用方法。对于一件事情如果能够当场做完就不要推迟到以后，对于一项决定如果当场确定就不要推迟到未来。如果当时没有进行就解决或决定就需要做出相应的计划：要想解决这个问题，需要收集哪些必要的资源。具体策略如下：</p>
<p><img src="/images/ReadingNotes/google-0.jpg" alt="img"></p>
<p>对自己来讲，我曾经负责某个项目，客户在问我一个技术相关的问题的时候，我当时的做法可能就没有很恰当。现在来看我认为正确的流程应该是：将我自己已知的内容对客户进行反馈；将自己不知道的内容如实告诉客户并询问他目前是否有空我去找一下相关负责人来解答他这个问题（<strong>如果现在有必要的话，现在就联系；如果现在应该决定的话，现在就决定</strong>），如果中途遇到其它问题不知道谁是负责人或者负责人不在，也必须做到相关解决方案做到有切实进展（活用身边的人/回来之后第一时间反馈等等），在第一时间内将问题进行解决，不拖延！！！</p>
<h2 id="设置deadline"><a href="#设置deadline" class="headerlink" title="设置deadline"></a>设置deadline</h2><p>能当场解决的问题一定要一次解决，而不能解决的问题一定要设置deadline，要有一种 如果现在不做那要什么时候做 的观念。对于纷杂的工作需要明确优先级、精细程度等因素。将自己的期限提前是提高效率的有效方法。</p>
<p>对于自己来讲，如果领导要求一项工作周五之前完成。那自己的deadline要设置在周三周四做好一个demo给领导查看。在工作进行之前需要明确事情的紧急程度、完成验收的标准、是否有其它注意事项等等</p>
<h2 id="集中精力于此时此刻"><a href="#集中精力于此时此刻" class="headerlink" title="集中精力于此时此刻"></a>集中精力于此时此刻</h2><p>正念（Mindfulness）的意思就是将意识集中于此时此刻，这一词同样被谷歌所采用。大脑就像是一个CPU应尽可能的减少大脑资源的浪费，对于任何一件事情尽可能要提前做准备。比如：前一天晚上就准备好第二天需要穿的衣服；会议前梳理会议的目的成员组织等等；任何一件事情可能发生的后果及相应的解决办法</p>
<p>分析眼前任务的正确方式：搞清楚”为什么需要解决这个问题“，”在什么时间之前必须得出答案“，设定好”目的与目标“之后全力以赴。比如会议之前的准备列表：</p>
<ul>
<li>为什么将大家召集到一起</li>
<li>要做出什么决定</li>
<li>要取得什么成果</li>
<li>通过会议后要得到什么收获</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li><p>增加现在的密度</p>
<p>针对自己来讲可以体现在：通勤路上进行书籍的阅读英语的学习等等，并行一些任务</p>
</li>
<li><p>减少邮件的使用，直接见面最有效率</p>
</li>
<li><p>合理使用工具</p>
<p>时间/时间管理工具（对于notion的使用没有持续）；整理的文档传至云端，随时查看修改</p>
</li>
<li><p>学习英语</p>
<p>目前很多第一手资料都是英文的，为了提高效率必须学会英文。否则内容的准确性排除在外，也是时间和成本的二次浪费</p>
</li>
</ol>
<h1 id="Sense-VS-sensibility"><a href="#Sense-VS-sensibility" class="headerlink" title="Sense VS sensibility"></a>Sense VS sensibility</h1><h2 id="创意思维的产生"><a href="#创意思维的产生" class="headerlink" title="创意思维的产生"></a>创意思维的产生</h2><p>与逻辑和分析相比“ 灵感（创意思维） ”更重要</p>
<p>通过人为地制造混乱，可以使潜意识活性化，从而更容易创造出新的创意。具体方案：准备几个透明文件袋，将各种图片、杂志、报纸剪下来的内容或写在纸上的关键词放在里面，通过任意物品的组合产生新的创意。为了引发这种“突然出现的创意瞬间”，最好的办法就是多准备一些能够激发灵感的资料</p>
<h2 id="直觉-x2F-逻辑场景"><a href="#直觉-x2F-逻辑场景" class="headerlink" title="直觉/逻辑场景"></a>直觉/逻辑场景</h2><p>经验的直觉和逻辑思考本身之间并没有孰优孰劣，两者各自适用于不同的情况，具有不同的作用。对于更重视感性的领域来说，直觉比逻辑更能够发挥作用。</p>
<h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><ol>
<li><p>与逻辑和分析相比”灵感“更重要</p>
</li>
<li><p>一味的模仿不可能实现差异化。</p>
<p>只对竞争对手的商品进行分析无法实现差异化。要想做出与众不同的商品，必须做到其它公司没有做到的事情。</p>
</li>
<li><p>企划会议不需要总结式报告。只确定一个会议议题，然后大家当场讨论</p>
</li>
<li><p>积极听取其它部门或者其它领域的人的意见</p>
</li>
</ol>
<h1 id="Efficiently"><a href="#Efficiently" class="headerlink" title="Efficiently"></a>Efficiently</h1><h2 id="将目标定为原来的10倍"><a href="#将目标定为原来的10倍" class="headerlink" title="将目标定为原来的10倍"></a>将目标定为原来的10倍</h2><p>工作生活中我们对于自己的要求往往是完成任务即可，但是最终的效果往往不尽如人意，可能只完成了七八成。因此在我们设置目标的时候不妨将目标设置的更大一点，既定目标的10倍。这个目标会倒逼自己打破束缚自己的条条框框和固有观念 ，另一方面，要想改变工作方法，必须敢于承担风险、打破规则。最终即使完成七八成也是一个很好的结果了</p>
<h2 id="Think-like-an-owner"><a href="#Think-like-an-owner" class="headerlink" title="Think like an owner"></a>Think like an owner</h2><p>像公司所有者一样思考。针对自己的工作岗位，以我的年收入应该取得多少的成果，想要取得这些成果需要做哪些工作，而每项工作应该有怎样的结果。这个过程中势必要优化自己的工作，着眼于重点工作内容减少工作中的无用功，吸取他人的经验寻求他人的帮助。同样也可以假设自己即将失业，如果没有工作没有了怎么办？想到这里自己的紧迫感油然而生</p>
<h2 id="活用20-原则"><a href="#活用20-原则" class="headerlink" title="活用20%原则"></a>活用20%原则</h2><p>在思考工作的有限顺序的时候，应该优先将时间放在 <strong>能学到很多东西而且影响力比较大</strong>的工作上。而其它类型的工作可以进行分配等等。可以进一步对二八定律进行了解学习</p>
<h2 id="必要的工作素养（※）"><a href="#必要的工作素养（※）" class="headerlink" title="必要的工作素养（※）"></a>必要的工作素养（※）</h2><ol>
<li><p>拥有预见性</p>
<ul>
<li>预见机会与威胁</li>
<li>寻找周期、趋势以及规律</li>
<li>短期、中期与长期思考。考虑<strong>“5/5/5规则”</strong>，即5周以后、5个月以后、5年以后会发生什么事情进行思考</li>
</ul>
</li>
<li><p>换位思考</p>
</li>
<li><p>敢于提出自己的见解</p>
</li>
<li><p>敢说真话（个人认为这一点还是具体情况具体分析）</p>
</li>
<li><p>主动承担责任</p>
</li>
<li><p>积极参与交流</p>
</li>
<li><p>打破常规</p>
</li>
<li><p>不害怕失败</p>
</li>
<li><p>勤于思考、保持质疑</p>
<p>遇到不明白的事情多问一个为什么</p>
</li>
<li><p>改变视角</p>
<p>整体视角；局部视角；反面视角；未来视角；顾客视角；竞争对手视角；特殊视角</p>
</li>
</ol>
<h1 id="Interpersonal-relationship"><a href="#Interpersonal-relationship" class="headerlink" title="Interpersonal relationship"></a>Interpersonal relationship</h1><h2 id="具象化思考"><a href="#具象化思考" class="headerlink" title="具象化思考"></a>具象化思考</h2><p>实物思考我将其总结为具象化思考。工作生活中别人有某项需求时，可以通过某种类比或实物来与对方确认表达是否一致。具体方案：可以是在一张草图上画出来向别人确认“您说的是这种类型吗？”；或者在讨论问题之前将讨论的内容总结到A4纸上，将比较抽象的事情具象化可以实操。这样是可以大幅度的减少交流的成本降低后期的无用功</p>
<h2 id="提升心理安全"><a href="#提升心理安全" class="headerlink" title="提升心理安全"></a>提升心理安全</h2><ul>
<li>心理安全：面对 我可以信赖你吗 或者 我能尊重你吗 这样的问题的时候能够给出肯定的答案</li>
</ul>
<p>得到他人的信赖和尊重也会使自己产生安全感。一旦构筑起信赖关系，交流双方就会像朋友一样，更容易的互相提出意见或建议，工作现场的气氛也会更加活跃。</p>
<h2 id="倾听（※）"><a href="#倾听（※）" class="headerlink" title="倾听（※）"></a>倾听（※）</h2><p>交流Tips：建立信赖关系最重要的一点就是倾听，最好的办法就是让自己对对方产生兴趣并将这种情绪传递给对方。另外，好不容易让对方说出自己的意见，绝对不能将对方的意见完全否定，不能让对方觉得“我说了也没用”的想法！！！</p>
<p>艾米·埃德蒙顿教授指出：不要将问题单纯地看成“需要解决的问题”，而是要将其看作“需要学习的问题”来进行讨论，这样不清楚的部分就会自然而然的浮现，也更容易让团队成员积极思考</p>
<h2 id="建立良好人际关系"><a href="#建立良好人际关系" class="headerlink" title="建立良好人际关系"></a>建立良好人际关系</h2><p>良好的人际关系是快速解决问题的基石</p>
<p>社会各行各业哪怕只要有一点点交集都足可以让对方和自己产生联系。而见到关键的人的时候正确的方式应该是：提前了解设想对方的课题，然后开门见山的根据课题内容进行提问，交流过程中表现出热情、平等的态度就可以心情舒畅的进行交流。在交流过程中还要需要注意 <strong>不要take而要give</strong>，要让别人看到自己的价值</p>
<p><strong>人际关系的优先顺序</strong>：新认识的人 &gt; 熟识的人；新认识并且不断改变自己的人 &gt; 新认识但变化不多的人</p>
<h1 id="Skill"><a href="#Skill" class="headerlink" title="Skill"></a>Skill</h1><h2 id="学习的正确方法"><a href="#学习的正确方法" class="headerlink" title="学习的正确方法"></a>学习的正确方法</h2><p>检索 + 询问专业人士·询问他人·询问同事</p>
<ul>
<li>检索：询问互联网这个老师</li>
<li>询问他人：<ol>
<li>找最擅长这项工作的人询问</li>
<li>询问之前要有自己的思考。带着假设带着思考去提问。具体可以有四要素：具体来说；要在什么地方；改变什么；怎么做才能让工作更顺利</li>
</ol>
</li>
</ul>
<h2 id="前馈与反馈"><a href="#前馈与反馈" class="headerlink" title="前馈与反馈"></a>前馈与反馈</h2><ul>
<li>前馈：找别人询问“我想解决这个问题，应该怎么办才好呢？”</li>
<li>反馈：事后的反思与经验总结</li>
</ul>
<p>要想获取有用的信息，提问的</p>
<p><img src="/images/ReadingNotes/google-1.jpg" alt="img"></p>
<h2 id="多参加交流会"><a href="#多参加交流会" class="headerlink" title="多参加交流会"></a>多参加交流会</h2><p>为了保证自己的生存，最好多参加交流，不论是非正式聚会、公司外部会议等等，给自己多创造几个立足点。</p>
<p>同行业、同年龄的人呆在一起，谈论的事情都是相似的话题，无法从中获取到跟多有用的信息。在交流过程中，也要时刻思考“我应该给对方提供什么样的信息”，输出自己的价值</p>
<h1 id="Relax-Work"><a href="#Relax-Work" class="headerlink" title="Relax Work"></a>Relax Work</h1><h2 id="一分钟冥想"><a href="#一分钟冥想" class="headerlink" title="一分钟冥想"></a>一分钟冥想</h2><p>关闭电脑，将所有注意力都集中在自己的呼吸上，安静的坐在座位上</p>
<h2 id="并行任务与串行任务分类"><a href="#并行任务与串行任务分类" class="headerlink" title="并行任务与串行任务分类"></a>并行任务与串行任务分类</h2><p>比如通勤过程中进行书籍的阅读、听音频等等</p>
<p>而一旦专注于某项工作就尽可能排除外部的干扰，可以尝试将手机静音、放远一点等等操作</p>
<h2 id="睡午觉、吃零食、放松是自己的责任"><a href="#睡午觉、吃零食、放松是自己的责任" class="headerlink" title="睡午觉、吃零食、放松是自己的责任"></a>睡午觉、吃零食、放松是自己的责任</h2><h1 id="Final-Innovation"><a href="#Final-Innovation" class="headerlink" title="Final Innovation"></a>Final Innovation</h1><ol>
<li>思考如何使用AI替代自己的工作</li>
<li>站在革新一侧不袖手旁观，改变自己坚持但不好的习惯，合理使用现代化工具</li>
<li>就算对技术细节不了解，也要跟上趋势</li>
<li>工作不能和昨天一样</li>
</ol>
<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><ol>
<li><p>不要认为“公司就是自己的办公室”，而要时刻记住“自己在哪哪里就是办公室”</p>
</li>
<li><p>会议的目的不是将所有人召集到一起，而是取得结果，所以只需要召集对取得结果有帮助的成员即可</p>
</li>
<li><p>邮件是“等待文化”，即时通信是“实时文化”</p>
</li>
<li><p>工程项目的冲刺阶段一般都会采用“规定期限，集中精神”的工作方法</p>
</li>
<li><p>明确工作的优先顺序和品质要求是专业人士的基本素养</p>
</li>
<li><p>工作的目的并不是“从早9点到晚6点坐在同一个地方“，而是取得令人满意的成果（舒适的工作环境至关重要）</p>
</li>
<li><p>没有结论的分析毫无意义</p>
</li>
<li><p>创意思维需要的是灵感以及丰富经验的直觉</p>
</li>
<li><p>只有敢于走出舒适区才能取得更大的成果</p>
</li>
<li><p>公司之所以给你高额薪水，是因为你能做到别人无法做到的困难工作</p>
</li>
<li><p>交流最大的目的是构筑信赖关系 </p>
</li>
<li><p>当人感觉到自己受到了尊重或者别人很重视我的时候，就会将自己的内心从防备中解放出来</p>
</li>
<li><p>在好奇心驱使下不断的追求自己感兴趣的东西，这将成为你职场中的通行证</p>
</li>
<li><p>应该学习的不是知识而是经验</p>
</li>
<li><p>人的成长就像斐波那契数列，昨天的自己加上前天的自己才是今天的自己</p>
</li>
<li><p>多次实践不但有助于提高自信，更能加快掌握速度</p>
</li>
<li><p>拥有的“选项”越多，在竞争中生存的可能性就越大</p>
</li>
<li><p>究竟是选择站在革新的一侧还是选择袖手旁观，不同的选择带来的结果可谓是天壤之别 </p>
</li>
<li><p>找到在巨变洪流中发挥自己能力并且赚取利润的方法</p>
</li>
</ol>
]]></content>
      <categories>
        <category>ReadingNotes</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《人类群星闪耀时》</title>
    <url>/2023/03/18/ReadingNotes/%E4%BA%BA%E7%B1%BB%E7%BE%A4%E6%98%9F%E9%97%AA%E8%80%80%E6%97%B6/</url>
    <content><![CDATA[<p><img src="/images/ReadingNotes/RenLeiQunXing.jpg" alt="img"></p>
<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>和这本书的渊源应该还是在通勤路上使用得到APP听到的对该书的解读。贾行家老师的解读风格一直是我所喜欢的，通过他的语言我大致了解到这本书讲述的是14个历史的决定性瞬间，当然一定是针对世界的，而其实作者默认将西方世界等同于世界。我自己其实对于西方历史的了解程度一直停留在初中历史书的层面。当听到这十四个历史的决定性瞬间包含了滑铁卢战役、马赛曲、拜占庭帝国等等相关内容，我一下子便提起了兴趣，这些耳熟能详的故事后面究竟有什么故事，带着好奇开始了这本书的阅读。</p>
<p>小注：由于这本书的中文译本高达几十种，我在买书的时候也没有看好，买的书只包含十个瞬间。其它缺失的应该包含：列夫托尔斯泰、菲尔德（建立第一条跨洋电缆）、威尔逊（美国第二十八任总统）、巴塞罗。有机会的话这几个也要补回来。</p>
<h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>这本书的作者是斯蒂芬·茨威格，被誉为”历史上最好的传记作家“。茨威格1881年出生在奥地利犹太的富商家庭，这个时间和身份注定他的命运不平凡。二战时期，茨威格因为反战纳粹被驱逐，随后流亡英国、美国、巴西，他的代表作包括&lt;&lt;象棋的故事&gt;&gt;、《昨日的世界》、《三大师传》等等</p>
<h1 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h1><p>能够读完整本书就已经说明足够吸引人了。整体上这本书的跨度很大，包括时间跨度、人物类型跨度等等，最远的讲到公元前1实际的古罗马政治危机（穆罕默德二世），近的可以到一战后的巴黎和会（威尔逊）；而在类型上有历史上伟大的政治家拿破仑、伟大的音乐家亨德尔、甚至包括我们可能完全不熟悉的马赛曲的作者鲁热……</p>
<p>在语言风格上，用贾行家的老师话可以说是，茨威格高贵的气质、优雅的文风和理想主义的笔调尽显无疑。除此之外，这本书给我的另一个感受就是细节刻画非常到位，但是呢这些细节更像是作者本人设身处地的理解人物在某个时刻某个场景下的心理活动。这对于历史纪实可能并不友好但是我觉得对于我们读者理解人物的形象可以说非常到位了！</p>
<p>例子：</p>
<ol>
<li>人民也许永远不会知道，那扇因为疏忽敞开的凯尔卡门在那次命运攸关的时刻，为人类带来了多么大的灾难</li>
<li>也许格鲁希自己根本没有想到的是在他思考的这一秒钟，却决定了拿破仑和他自己的命运，甚至世界命运的一秒钟</li>
<li>刽子手铡刀一闪，这个人类第一双同时见过两大海洋的眼睛，永远熄灭了神采（巴尔沃亚）</li>
</ol>
<h1 id="记忆点及感受"><a href="#记忆点及感受" class="headerlink" title="记忆点及感受"></a>记忆点及感受</h1><p>我在阅读西方历史的时候的我首先关注的变量就是时间节点，在什么时刻发生了这个事件，而接下来我要了解的就是在这个时间节点上我们自己的这片土地处于哪个朝代发生着什么样的故事。古代的中国各方面还是处于先进水平，但是到了明清时期很明显的感受到西方各种科技、灿烂文化涌现，而我们自己的国家始终在一个内忧外患的阶段，科技文化的积累也在这个时期落后于世界</p>
<p>我自己并对于文学没有可以说没啥天赋对于尼采啊、巴尔沃亚等人故事也没有提起很大的兴趣，相反对于拿破仑、鲁热等人还是蛮感兴趣的。对于不明白滑铁卢战役全过程的人来讲（之前的我）大多数都会归咎于拿破仑，但是究竟如何失败哪里失败却说不出所以然。读完这一部分我反倒觉得没有任何人该承担这一责任，但按照书籍的理论，由于格鲁希将军的不会变通导致了滑铁卢战役的最终胜利。历史是由胜利者来书写的，失败者却连狡辩的机会都没有。我们现在知道结果是这个样子，假设当时战争的细节是另外一种样子而格鲁希将军选择驰援滑铁卢我们可能又会认为是他的主动性太强导致了最终的失败。所以终究还是战争的残酷性和不确定性导致了最终的结果。尽人事听天命，大概说的就是这个含义吧，把握我们所能把握的，剩下的就看天意。</p>
<h1 id="书摘"><a href="#书摘" class="headerlink" title="书摘"></a>书摘</h1><p>穆罕默德二世—-拜占庭的沦陷</p>
<ul>
<li>历史上所有以理智换来的和平都是转瞬即逝的</li>
<li>出奇制胜往往是所有伟大军事行动中取得胜利的关键</li>
<li>人世间空前团结的场面总是在最危急的关头才会出现</li>
<li>人类的历史和一个人的一生是一样的，一失足成千古恨</li>
</ul>
<p>巴尔沃亚—-在不朽的事业里寻求保护</p>
<ul>
<li>能够在生命的中途，也就是年轻力壮的时候找到自己肩负的使命，这真的是人生最美好的事情</li>
</ul>
<p>鲁热—-一个流星般的天才</p>
<ul>
<li>在这个世界上，从来就不会有哪一部蕴含强大能量的作品被埋没或者长久的被封存，也不会有哪一件优秀的艺术品随着时间的流逝而被遗忘，虽然有暂时被禁锢或者埋没的可能，但终究还是生命力的，他会冲破所有阻碍，脱颖而出</li>
</ul>
<p>拿破仑—-决定命运的一分钟</p>
<ul>
<li>命运只愿意成就那些勇敢者。当重任降临到平庸之辈身上时，他们不是感到庆幸，而是害怕。他们把这个成为命运主人的机会，哆哆嗦嗦地失掉了</li>
<li>命运——这掌管世间世界的另一个神，他强有力的双臂只愿高高举起勇敢者，将他们送上英雄的殿堂</li>
</ul>
<p>尼采—-向宇宙高峰走去</p>
<ul>
<li>无法将我置之死地的，更令我坚强</li>
</ul>
<p>斯科特—-争夺南极之战</p>
<ul>
<li>相较于作品中的悲剧，生活本身创造出的悲剧要多一千倍</li>
<li>悲壮的失败依然光荣，这样的失败能够激起人们继续挑战险境的勇气，因为只有雄心壮志才能将满怀的激情点燃，去完成那历经千难万险才能完成的事</li>
</ul>
]]></content>
      <categories>
        <category>ReadingNotes</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《嵌入式C语言自我修养》笔记</title>
    <url>/2023/03/13/ReadingNotes/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<p><img src="/images/ReadingNotes/QianRuShiC.jpg" alt="img"></p>
<h1 id="GNU-C编译器扩展语法精讲（六）"><a href="#GNU-C编译器扩展语法精讲（六）" class="headerlink" title="GNU C编译器扩展语法精讲（六）"></a>GNU C编译器扩展语法精讲（六）</h1><p>github Demo：<a href="https://github.com/yangLieee/codebackup/blob/master/book_%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/gnuc.c">click here</a></p>
<h2 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 数组初始化</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">100</span>] = { [<span class="number">10</span>] = <span class="number">1</span>, [<span class="number">20</span>] = <span class="number">3</span> };</span><br><span class="line"></span><br><span class="line"># ... 前后都需要空格，并且该特性也可以用在<span class="keyword">switch</span>-<span class="keyword">case</span>语句中</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">100</span>] = { [<span class="number">10</span> ... <span class="number">20</span>] = <span class="number">1</span>, [<span class="number">40</span> ... <span class="number">50</span>] = <span class="number">2</span> };</span><br><span class="line"><span class="keyword">switch</span>(i) {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> ... <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 结构体成员初始化  (通过结构域名)</span><br><span class="line">例如linux内核：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">const</span> <span class="title">file_opt</span> <span class="title">codec_opt</span> =</span> {</span><br><span class="line">    .open = codec_open,</span><br><span class="line">    .read = codec_read,</span><br><span class="line">    .write = codec_write,</span><br><span class="line">} </span><br><span class="line">好处：灵活，代码易于维护</span><br></pre></td></tr></tbody></table></figure>

<h2 id="语句表达式"><a href="#语句表达式" class="headerlink" title="语句表达式"></a>语句表达式</h2><ul>
<li>目的：构造复杂宏</li>
<li>结构：（ {  表达式1; 表达式2;  表达式3  } ） 语句表达式用（）小括号括起来，代码块用 { } 大括号括起来，语句表达式的值等于最后一个表达式的值</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol>
<li><p>求和</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">sum = ( {</span><br><span class="line">     <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++&gt;) </span><br><span class="line">        s = s +i;</span><br><span class="line">     s;</span><br><span class="line">} )</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>定义一个宏，求两个数的最大值？</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> my_max(x,y)   ({    \</span></span><br><span class="line"><span class="meta">    typeof(x) _x = (x);     \</span></span><br><span class="line"><span class="meta">    typeof(y) _y = (y);     \</span></span><br><span class="line"><span class="meta">    (void) (&amp;_x == &amp;_y);    \</span></span><br><span class="line"><span class="meta">    _x &gt; _y ? _x : _y;      \</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"><span class="comment">// 第六行的作用：不同类型的指针比较会给出警告，加void消除没有用到比较结果带来的警告</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="container-of宏"><a href="#container-of宏" class="headerlink" title="container_of宏"></a>container_of宏</h2><ul>
<li><p>作用：根据结构体某一成员地址，获取这个结构体的首地址</p>
</li>
<li><p>场景：传给某个函数的参数是某个结构体的成员变量，在这个函数中还可能用到这个结构体其它变量</p>
</li>
<li><p>基础：常量指针的值即为常量本身的值。0强转为结构体指针，结构体的首地址为0，每个成员变量都是首地址的相对偏移</p>
</li>
<li><p>实现</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offset( TYPE , MEMBER ) ((size_t) &amp; (((TYPE*)0)-&gt;MEMBER))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) ({                    \                    </span></span><br><span class="line">            <span class="type">const</span> <span class="title function_">typeof</span><span class="params">(((type*)<span class="number">0</span>)-&gt;member)</span>* _ptr = (ptr);   \</span><br><span class="line">            (type*) ((<span class="type">char</span>*)_ptr - offset(type, member));     \                              </span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="零长数组"><a href="#零长数组" class="headerlink" title="零长数组"></a>零长数组</h2><ul>
<li>定义：长度为0的数组</li>
<li>优点：不占用内存存储空间</li>
<li>其它：C99支持变长数组，即长度编译时期是不能确定，在运行时才可以确定</li>
<li>应用：变长结构体</li>
<li>数组与指针区别：数组名用来表征一块连续的内存地址空间，仅仅是符号不分配空间；指针是一个变量，编译器需要单独给它分配一个内存空间，用来存放他指向的变量的地址。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> {</span></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> ptr[<span class="number">0</span>];  <span class="comment">// 不占大小</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span>* <span class="title">buf</span>;</span></span><br><span class="line">buf = (<span class="keyword">struct</span> buffer*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> buffer) + <span class="number">100</span>);</span><br><span class="line">buf-&gt;len = <span class="number">100</span>;</span><br></pre></td></tr></tbody></table></figure>



<h2 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>__attribute__</p>
<ul>
<li>作用：指导编译器在编译程序的时候进行特定方面优化或代码检查</li>
<li>格式：<strong>attribute</strong>(( ))，后面需要写两对小括号，多个属性之间逗号隔开</li>
<li>支持的属性声明：section、aligned、packed、format、weak、alias、noinline、always_inilne</li>
</ul>
<h3 id="section"><a href="#section" class="headerlink" title="section"></a>section</h3><ul>
<li><p>作用：将一个函数或变量放到指定的段，即放到指定的section</p>
</li>
<li><p>使用：<strong>attribute</strong>(( section(“.data”) ))</p>
</li>
<li><p>可选项：</p>
<ul>
<li><p>.text：函数定义、程序语句</p>
</li>
<li><p>.data：初始化的全局变量、初始化的静态局部变量</p>
</li>
<li><p>.bss：未初始化的全局变量、未初始化的静态局部变量</p>
</li>
</ul>
</li>
</ul>
<h3 id="aligned"><a href="#aligned" class="headerlink" title="aligned"></a>aligned</h3><ul>
<li>作用：地址对齐，在给变量分配存储空间的时候，需要按照制定的地址对齐方式给变量分配地址</li>
<li>注意：地址对齐的字节数必须是2的幂次方</li>
<li>使用：<strong>attribute</strong>(( (aligned(4) ))</li>
<li>对齐的好处：简化CPU与RAM之间的接口和硬件设计。cpu访存硬件设计可能只支持4字节或4字节整数倍对齐的地址访问，对齐后cpu可以一次读完</li>
<li>注意：这个属性声明只是建议编译器按照这种方式对齐，当超过编译器允许的最大值只能按照最大对齐字节数进行地址分配</li>
</ul>
<h3 id="packed"><a href="#packed" class="headerlink" title="packed"></a>packed</h3><ul>
<li>作用：减少地址对齐</li>
<li>使用： <strong>attribute</strong>(( packed ))</li>
<li>通常aligned与packed一起使用，这样既避免了结构体各个成员变量地址对齐产生的内存空洞又指定了整个结构体对齐方式：<strong>attribute</strong>(( packed, aligned(8) ))</li>
</ul>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><ul>
<li>作用：指定变参函数的参数格式检查</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LOG</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span>* fmt, ...)</span> __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>,<span class="number">2</span>,<span class="number">3</span>)))</span>)</span><br><span class="line"><span class="comment">// LOG函数的参数，个数字符串的位置在所有参数列表的索引是2,即前两个参数；要编辑器帮忙检查的参数在所有参数列表里的索引是3</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><ul>
<li>作用：可以将一个强符号转换为弱符号</li>
<li>使用：void _<em>attribute</em>(( weak )) func(void);</li>
<li>好处：当一个函数被声明为一个弱符号之后，链接阶段找不到函数定义不会报错会将这个弱符号设置为0或者特殊值。当程序运行时，调用这个这个函数跳转到零地址或特殊地址才会产生一个内存错误</li>
</ul>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><ul>
<li>作用：给函数定义一个别名</li>
<li>使用：void f() <strong>attribute</strong>((alias(“_f “)));</li>
<li>通常在linux内核中weak和alias一起使用，随着版本升级可以封装旧名字起一个新名字</li>
</ul>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul>
<li><p>特征：用inline修饰的函数被称为内联函数，通常用static 或 extern 修饰</p>
</li>
<li><p>内联函数特征：</p>
</li>
<li><ul>
<li>函数体积小</li>
<li>函数体内无指针赋值、递归、循环等语句</li>
<li>调用频繁</li>
</ul>
</li>
<li><p>与宏相比，内联函数的优点：</p>
</li>
<li><ul>
<li>参数类型检查，本质仍然是函数</li>
<li>便于调试。可以单步、断点调试</li>
<li>有返回值（宏也可以，语句表达式结构）</li>
<li>接口封装</li>
</ul>
</li>
<li><p>使用：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 显式告诉编译器不要展开</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __attribute((noinline)) <span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 显式告诉编译器要内联展开</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __attribute((always_inline)) <span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 否则编译器的行为不固定，考虑诸多因素决定是否展开</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><ul>
<li>含义：编译器内部实现的函数</li>
<li>特征：通常以 __builtin 开头</li>
<li>说明：没有文档，变动频繁，不建议应用程序工程师使用</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//  __builtin_return_address（LEVEL）    返回当前函数或者调用者的返回地址</span></span><br><span class="line"><span class="comment">// LEVEL 0: 获取当前函数返回地址</span></span><br><span class="line"><span class="comment">// LEVEL 1: 获取上一级函数返回地址</span></span><br><span class="line"><span class="comment">// LEVEL 2: 获取上两级函数返回地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// __builtin_frame_address(LEVEL)        查看函数的栈帧地址</span></span><br><span class="line"><span class="comment">// LEVEL 0: 获取当前函数栈帧地址</span></span><br><span class="line"><span class="comment">// LEVEL 1: 获取上一级函数栈帧地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __builtin_constant_p(n)               判断参数n在编译时是否是常量，是常量返回1,否则0</span></span><br><span class="line"><span class="comment">// 内核中判断宏的参数是否是常数，则有更优化的实现方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __builtin_expect(exp,c)        </span></span><br><span class="line"><span class="comment">// 告诉编译器参数exp的值为c的可能性很大，用于分支预测，参数c与返回值无关，返回值一定是exp</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> likely(x) __builtin_expect(!!(x),1)) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> unlikely(x) __builtin_expect(!!(x),0)</span></span><br><span class="line"><span class="comment">// 告诉编译器某一个分支发生的概率很高，自己做优化</span></span><br><span class="line"><span class="comment">// 两次取非是为了将参数x转换为bool类型，与1/0比较</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h2><ul>
<li>用 … 表示变参列表，变参列表由不确定的参数组成，用  <strong>VA_ARGS</strong>  标识符表示变参函数列表</li>
<li>C99规定，可以使用 args…  表示变参列表，用 args 代表变参列表即可</li>
<li>宏连接符  ##  的作用是连接两个字符串</li>
<li>在定义宏的时候通常使用 do { } while(0);的结构，这样是为了防止宏在选择、条等分支语句中展开后，产生宏歧义</li>
</ul>
<p>两种方法实现自定义等级宏打印：<a href="https://github.com/yangLieee/codebackup/blob/master/book_%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/mlog.h">click here</a></p>
<h2 id="Uboot镜像自复制"><a href="#Uboot镜像自复制" class="headerlink" title="Uboot镜像自复制"></a>Uboot镜像自复制</h2><ul>
<li>作用：加载linux内核镜像到内存，给内核传递启动参数，然后引导linux操作系统启动</li>
<li>过程：通过定义两个零长度数组，分别表示要复制自身镜像的起始地址和结束地址，并放在特定的section上，而这两个section分别放在代码段前和数据段后。数组名本身就代表一个地址，通过arm ldr伪指令直接获取要复制的镜像首地址保存在某个寄存器中，从flash复制自身镜像到内存中，然后重定位，最终跳转到内存中执行。（自举）</li>
</ul>
<h1 id="C语言面向对象编程思想（八）"><a href="#C语言面向对象编程思想（八）" class="headerlink" title="C语言面向对象编程思想（八）"></a>C语言面向对象编程思想（八）</h1><h2 id="代码复用与分层"><a href="#代码复用与分层" class="headerlink" title="代码复用与分层"></a>代码复用与分层</h2><p>复用：</p>
<ul>
<li>函数级复用</li>
<li>库级复用</li>
<li>框架级复用</li>
<li>操作系统级复用</li>
</ul>
<p>分层：</p>
<ul>
<li>应用层</li>
<li>Framework层</li>
<li>库</li>
<li>Linux内核</li>
</ul>
<h2 id="面向对象主要特征"><a href="#面向对象主要特征" class="headerlink" title="面向对象主要特征"></a>面向对象主要特征</h2><p>继承、多态、纯虚函数特征（抽象类）</p>
<h1 id="模块化（九）"><a href="#模块化（九）" class="headerlink" title="模块化（九）"></a>模块化（九）</h1><p>模块化的思想内核是分而治之，重点在于抽象的对象之间的关联，而不是内容</p>
<p>面向对象的编程思想主要是为了代码复用，重点在于内容的实现</p>
]]></content>
      <categories>
        <category>ReadingNotes</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《曾国藩传》</title>
    <url>/2022/12/11/ReadingNotes/%E6%9B%BE%E5%9B%BD%E8%97%A9%E4%BC%A0/</url>
    <content><![CDATA[<p><img src="/images/ReadingNotes/zengGuoFan.jpg" alt="img"></p>
<p>近几年，曾国藩倍受成功学的推崇，关于他的书也是铺天盖地。偶然间看到老俞（俞敏洪）在推荐这本书，带着浓厚的兴趣开始对这本书的探索。《曾国藩传》是中国知名历史学家张宏杰先生的作品，除了这本《曾国藩传》他还著有《曾国藩的正面与侧面》《饥饿的盛世》《大明王朝的七张面孔》等等。整本书通读下来，作者按照时间顺序，以曾国藩日记及各种历史参考文献为史实基础进行了深度解读，将曾国藩国之重臣的形象立体的展现在了我们的眼前。</p>
<p>本篇也无所谓是读书笔记、读后感亦或者是书评了，便想到哪里写到哪里吧。</p>
<h1 id="故事自述"><a href="#故事自述" class="headerlink" title="故事自述"></a>故事自述</h1><p>曾国藩历任晚清四朝，生于嘉庆、文于道光、武于咸丰、卒于同治，我这里的文、武分别指其京官时代和领导湘军阶段。</p>
<p>老曾家本是一个殷实的小地主家庭，奈何祖坟一直没冒青烟，祖辈上没有一个读书人。在爷爷曾玉屏的影响下，小小的曾子城（该时期曾国藩未改名）开启了他的读书生涯。屡战屡败、屡败屡战，落榜六次之后，院试中秀才、乡试中举人、会试中进士，也就是在此正式更名为曾国藩，寄以“国之藩篱“之意，此时他才二十八岁。在此之后在京十年中，曾国藩立下学做圣人的宏愿并坚韧不拔地沿着这条仕途之道前进，步步升迁到二品官位。十年七迁，连跃十级。直至1852年充任江西乡试正考官才结束了他的京官生涯。</p>
<p>在曾国藩春风得意之际，却突然收到母亲去世的噩耗，致使他不得不改变自己的行程回家守孝。此时太平天国运动轰轰烈烈席卷半个中国，而清军主力八旗和绿营早已腐败不堪，咸丰皇帝不得不颁布兴办团练的诏书。曾国藩起初内心是拒绝的，但是心系国家的他最终还是决定应诏，以团为表，以军为里组建起了湘军，殊不知这支军队成了日后抵抗太平军的主力。没有任何军事经验、初来乍到再加上曾国藩此时直率的性格特征，组建一支像样且有战斗力的军队的难度可想而知，克服重重困难湘军算是建立起来了。抱着首战必胜的心理曾国藩决定出兵靖港，未曾可知迎来一场大败，这也让他的信心跌落谷底一度跳江自杀，幸被救下。随后大大小小战斗经历无数，湘潭大捷、九江大败…… 1857年父亲去世，他向皇帝请求回家奔丧三个月，未曾想再想复出却被皇帝解除了兵权。</p>
<p>塞翁失马焉知非福？也正是接下来两年的蛰伏让曾国藩完成了脱胎换骨的变化，他开始变得通人情世故，适应晚清官场的环境，但面对自己时仍然选择做圣人。趁着太平军内讧石达开的出走，好兄弟胡林翼给曾国藩争取来了再度出山的机会，之后两人联手攻克了安庆，期间何桂清弃城逃跑也成就了曾国藩得到了梦寐以求的两江总督的职位。水到渠成地1864年正月，攻破天京，结束叛乱。</p>
<p>此时曾国藩任两江总督，后面应该就是被大众所熟知的部分——主办洋务。首先他和自己的接班人李鸿章联手剿灭了北方黄淮一带的捻军起义，随后便是兴办洋务，建立安庆军械所、江南制造总局，翻译大量外文书籍等等。1868年升任直隶总督处理完天津教案事件因备受指责再次担任两江总督，四年后中国传统文化最后一个偶像曾国藩去世。</p>
<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><h2 id="越努力越幸运"><a href="#越努力越幸运" class="headerlink" title="越努力越幸运"></a>越努力越幸运</h2><p>曾国藩不能说是天资卓越的人，从他读书、治军经历不难看出这一点。关于这一点还有一个广为流传的小故事，一日黄昏，他在书桌前背诵《岳阳楼记》，一个小偷偷偷潜入他家爬到房梁上，等待这一家人都入睡后偷东西。奈何小偷睡了好几觉，曾国藩还没有背下来，小偷气急败坏跳下房梁说：就你这个笨样读什么书？随后他完完整整背了一遍，甩门而去，留下的曾国藩目瞪口呆一人凌乱。真实性无从考证，但是由此可见他是真挺笨的，而他未来的成就更多来自于努力。他的人生哲学便是”尚拙“，崇尚笨拙。曾国藩曾说：“天下之至拙，能胜天下之之巧”。一味的追求高效率而不择手段、投机取巧终不能成大才。天赋不够，努力来凑，而越努力才会越幸运。</p>
<h2 id="历史总是有迹可循"><a href="#历史总是有迹可循" class="headerlink" title="历史总是有迹可循"></a>历史总是有迹可循</h2><p>在本书中曾有过这样两个片段。</p>
<p>其一，在曾国藩守制期间大彻大悟完成蜕变，他突然意识到所谓”天下之至柔，驰骋天下之志坚“、”大柔非柔，至刚无刚“真正的含义。行事过于方刚者，表面似乎是强者，实际上确是弱者。而他之前看不起的麻木、圆滑、机诈有时候才是解决问题的最好方法。</p>
<p>其二，在攻打安庆期间，胡林翼创造出”围城打援“的战术，给在湖北作战的湘军统帅多隆阿的信中说道，战争的目的不在于一城一池的得失，而在于消灭对方的有生力量。</p>
<p>读到第一个片段，脑海中不由得浮现出老子”以柔克刚“的思想，而曾国藩大彻大悟后的思想何尝不是对先贤思想的进一步阐述和升华。而读到第二个片段时，脑海里浮现的是解放战争期间，毛主席在延安面对胡宗南二十五万大军主动撤离，决定”拿一个延安换取一个全中国“。当时便提出：存地失人，人地皆失；存人失地，人地皆存。这与胡林翼讲述的战争目的可谓是如出一辙。</p>
<h2 id="尽人事，听天命"><a href="#尽人事，听天命" class="headerlink" title="尽人事，听天命"></a>尽人事，听天命</h2><p>在曾国藩赋闲在家为父亲治丧三个月期满之时，他向皇帝申请继续守制三年，太平天国未灭皇帝当然不会批准这个请求。于是曾国藩说出了实情：哭诉了一番自己的委屈和困难，并对皇帝说如果你不给我督抚大权，我就只能在籍终制。这明显是赤裸裸的要挟，出乎曾国藩的预料，咸丰皇帝居然答应了他的守制请求，彻彻底底没收了军权。而在与太平天国的决战当中，何桂清弃城逃跑，曾国藩没有索要皇帝便把何桂清两江总督职位给到了他。</p>
<p>一旦在做一件事情时有了极强的功利心，实现的过程可能将不择手段，目标也可能会背道而驰，最终一定不会达到最完美的状态。而最好的方式则是做到”尽人事听天命“，尽心尽力的去做事情，而能否成功，则需要顺其自然。</p>
<h2 id="脚踏实地，常于反思"><a href="#脚踏实地，常于反思" class="headerlink" title="脚踏实地，常于反思"></a>脚踏实地，常于反思</h2><p>在八旗兵和绿营兵战斗力如此低下的情况下，一介书生曾国藩为什么创建出战斗力满满的湘军呢？答案就是反思的力量，他追根溯源找到八旗绿营真正症结所在并在湘军中及时调整完成功业。而建立起来的湘军在战斗时奉行的时曾国藩”结硬寨，打呆仗“的战术，具体来讲就是”以静制动，反客为主“，把自己的营寨盘结实等待敌人前来进攻，等待他们露出马脚湘军再反攻，这便是整个逻辑。</p>
<p>细细看下来曾国藩的战术一定不是最先进的但一定是最稳妥的。不论走多远的路，但一定要确保走过的每一步路都有自己的脚印。</p>
<h2 id="保持忧患意识"><a href="#保持忧患意识" class="headerlink" title="保持忧患意识"></a>保持忧患意识</h2><p>在太平天国运动被平定之后，湘军无疑成了整个清王朝最强大的战斗力。曾国藩熟读史书，《易传》中讲：日中则昃，月盈则亏。越是辉煌的时候越应该保持清醒的头脑，懂得趋福避祸。他怎么能不明白朝廷的心思呢，为了不让朝廷猜忌决定自剪羽毛裁撤湘军。与此同时，他默默的将部分主力交给李鸿章的淮军当中。这一手”裁湘留淮“的操作可谓真的是粗中有细，这也保证了它后面官场生涯的延续。</p>
<h2 id="读书永远可以保持竞争力"><a href="#读书永远可以保持竞争力" class="headerlink" title="读书永远可以保持竞争力"></a>读书永远可以保持竞争力</h2><p>选士人，领山农。湘军大部分人都是山农即农民出身。但是湘军重视政治教育，罗泽南部则索性白天打仗，晚上把部下召集到一起，教他们读书，学习理学。流氓不可怕，就怕流氓有文化，这句话可能不是很恰当，但是有了知识的农民部队战斗力、战斗素养提升了可不是一个等级。</p>
<h2 id="桃李满天下"><a href="#桃李满天下" class="headerlink" title="桃李满天下"></a>桃李满天下</h2><p>这一项不能算作是感悟，称得上是曾国藩的成就。晚清大多数重臣都多多少少都受到过曾国藩的提点，李鸿章、左宗棠、沈葆桢、彭玉麟、胡林翼等等，尤其是李鸿章可谓是一手提拔起来的。英国一位历史学家说：曾国藩是中国最有势力的人，但他死去的时候，所有的总督（类似于现在的省委书记）都曾做过他的部下，并且都是由他提名的。如果他希冀，他可能已经成为皇帝。真实性无从考证，但由此也可看出他的影响力之大</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>曾国藩这一生是失败的。为天地立心、为生民立命、为往圣继绝学、为万世开太平。曾国藩用他的一生来践行张载的横渠四句，但可惜生不逢时终究是没有完成全部的理想，无奈成为追日的夸父、填海的精卫。在这里引用一下杨耀在”得到“APP解读李鸿章一书中提到的：时势能够造英雄，而英雄也可以改变时势。而显然传统保守的思想让曾国藩注定只能成为时势造的英雄，而不能成为改变时势的英雄。这不是他一个人的失败，而是整个腐朽政权的失败！</p>
<p>曾国藩这一生又是成功的。立功、立德、立言三不朽的境界他全部做到了。立功而言，他从一介书生起家，创建军队，挽狂澜于既倒，扶大厦之将倾，使中国传统文化免遭毁灭之灾，让清朝又可以在历史上浓墨重彩的多写几笔；立德而言，他以圣贤为标准要求自己，道德修养近乎纯粹；立言而言，我一个普通人能在这里写这篇文章感受曾国藩的风采，其影响力便不言而喻，洋洋洒洒数百万字全集让人受益匪浅。</p>
<p>一万个人有一万个哈姆雷特，同样也会有一万个曾国藩，每个人切入角度不同读出的人物自然不同，但带给我们每个人的力量却是永恒且相同的！</p>
]]></content>
      <categories>
        <category>ReadingNotes</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《格局》</title>
    <url>/2023/01/04/ReadingNotes/%E6%A0%BC%E5%B1%80/</url>
    <content><![CDATA[<p><img src="/images/ReadingNotes/GeJu.jpg" alt="img"></p>
<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>《格局》一书是吴军博士2019年出版的。吴军博士头衔可谓众多，“文津图书奖”得主、硅谷投资人、约翰·霍普金斯大学工学院董事、原腾讯副总裁，出版过《数学之美》《浪潮之巅》《文明之光》《硅谷之谜》等等不同品类的书籍。</p>
<p>我自己对于”格局“一词的理解是一个人对于世界认知的边界以及对事物认知的范围。整书通读下来给我的感觉更像是吴军博士对于自己生活经验及基于某些历史事件的规律总结，甚至有些章节的内容前后都没有很关联，对于本书大部分内容无感的本质原因我认为是自己的经历没有那么丰富无法做到感同身受亦或者是自己对于这本书没有完全读懂。那便写下自己感兴趣的部分的心得吧</p>
<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><h2 id="技术是手段-不是目的"><a href="#技术是手段-不是目的" class="headerlink" title="技术是手段 不是目的"></a>技术是手段 不是目的</h2><p>互联网飞速发展，新的技术理论得到迅速且广泛的传播。对于一名技术从业者来讲，要想在职场行业内始终保持竞争力，需要不断的去学习新的内容来保证自己不会被时代所淘汰。但实际上，技术从来都是手段而不是目的，如果搞不清楚这一点，就会为了技术而研发技术。2022年AI、IOT可能是时代的潮流，但10年后一切都未曾可知而可以肯定的是计算机的底层原理及知识仍然不会落伍。可见洞察一件事情的本质并去学习探索才是真正的硬道理。</p>
<h2 id="未来的特征"><a href="#未来的特征" class="headerlink" title="未来的特征"></a>未来的特征</h2><ul>
<li>不对称性。新技术的产生，最早掌握新技术的少数人可以利用新技术颠覆过去在相关领域中占据统治地位的组织或机构；</li>
<li>复杂性。当下的知识体系非常复杂，通常都是跨学科的而不是单一维度的；</li>
<li>不确定性。没有人能够预测未来</li>
</ul>
<ol>
<li>不过度依赖过去的权威</li>
<li>拉力由于推力（主动获取而不是被动接收）</li>
<li>指南针优于地图（改变一直存在，掌握本质，求渔不求鱼）</li>
<li>拥抱风险</li>
<li>叛逆精神（打破规则）</li>
<li>通才胜于专才（前提一定是已经在某一方面已经是专才）</li>
<li>韧性优于力量</li>
<li>强调整体性</li>
</ol>
<h2 id="以正和，以奇胜"><a href="#以正和，以奇胜" class="headerlink" title="以正和，以奇胜"></a>以正和，以奇胜</h2><p>面对不断变化的未来，把握好常态是关键，而正是常态，奇是非常态。《孙子兵法 兵势篇》中写到：凡战者，以正和，以奇胜。这句话的意思是：作战，要先把正面的兵排好，排的不偏斜合乎法则，此为正；如果这时候还有多余的兵力你就赢了，在现代汉语字典中也可以理解为：出奇制胜。”以正和，以奇胜”更应该是一个人做事的准则，在做好正的基础上出奇制胜，不要相信所谓的弯道超车，这一定是不稳定的。</p>
<h2 id="被信息放大的悲观"><a href="#被信息放大的悲观" class="headerlink" title="被信息放大的悲观"></a>被信息放大的悲观</h2><p>我们明显能够感觉到现在的年轻人普遍会更焦虑，他们仿佛对这个世界充满悲观情绪。xxx飞机失事、xxx公司大规模裁员、xxx地区洪水或火山爆发，这些新闻在现在真的是屡见不鲜，也正是这些新闻的广泛传播给我们造成了很大的焦虑情绪。但实际上飞机其实是比汽车更安全、在大范围内就业形式是向好的、火山喷发地正是处于板块交界地带。可以发现真正广泛传播的言论实际上大多是悲观的，从信息论的角度来讲，越是与众不同的说法信息量越大。相反宣传乐观主义的观点论文不仅没有人看甚至是无法发表的。因为没有人会关心一篇”今年经济持续向好“的文章，大家都知道也自然就不会过多关注。面对各种各样的新闻，适当保持忧患意识是必要的，但请不应过度的悲观！</p>
<h2 id="人立于天地之间必有出路"><a href="#人立于天地之间必有出路" class="headerlink" title="人立于天地之间必有出路"></a>人立于天地之间必有出路</h2><p>面对生活、工作、家庭的压力，我们总是使自己处于一个很忙碌的状态之中，面对未来可能发生的问题我们也常说：车到山前必有路、船到桥头自然直。确实，对于未来的不确定性，我们始终要坚信人立与天地之前必有出路。</p>
<h1 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h1><p>自己花了精力做的事情要尽可能的对自己未来有帮助。</p>
<p>过分追求物质可能会成为生活的负担。</p>
]]></content>
      <categories>
        <category>ReadingNotes</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CODEC移植开发总结</title>
    <url>/2023/07/30/WorkExperience/CODEC%E7%A7%BB%E6%A4%8D%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="CODEC移植开发流程"><a href="#CODEC移植开发流程" class="headerlink" title="CODEC移植开发流程"></a>CODEC移植开发流程</h1><ol>
<li><p>准备原理图、外设（codec、pa）手册。查看硬件音频通路，mic位置、喇叭位置、功放位置等等</p>
</li>
<li><p>准备相关代码，移植到平台中。支持驱动中没有的函数保证编译通过</p>
</li>
<li><p>I2C通信成功，可以读出codec、pa的设备ID</p>
<ul>
<li>配置设备驱动设备树。配置对应设备节点的compatible字段，保证设备可以正常调用probe函数</li>
<li>配置I2C设备树。根据原理图判断在哪一组的I2C，并根据原理图查看设备地址（固定地址+选通地址）保证通讯成功可以读出ChipID</li>
<li>（如果I2C失败，通常有以下几个原因：上拉电阻、上拉电阻电压、设备地址不正确）</li>
</ul>
</li>
<li><p>注册声卡</p>
<ul>
<li>定义声卡的硬件描述。定义声卡硬件的描述信息，包括声卡的名称、DAI（Digital Audio Interface）和 CODEC 的连接配置等。这通常是在设备树中完成的，使用特定的设备树节点来描述声卡的硬件连接。</li>
<li>创建声卡驱动代码：编写相应的 ALSA 声卡驱动代码，该驱动代码将负责与设备树中的声卡节点进行匹配，并在匹配成功时注册声卡。在驱动代码中，你需要实现 snd_soc_card 结构体，并填充相应的字段，包括声卡的名称、DAI 链路、CODEC 控制等。</li>
<li>注册声卡：在驱动代码中，通过调用 snd_soc_register_card() 函数来注册声卡。该函数将会在 ALSA 框架中注册声卡，并建立与硬件之间的连接关系。</li>
<li>声卡初始化：在声卡注册成功后，你可以在声卡的 probe 函数中进行必要的初始化操作，如设置 DAI 和 CODEC 的配置参数、请求 IRQ、创建 ALSA 控制接口等。</li>
</ul>
</li>
<li><p>根据ASoc框架，配置platform和codec（这个步骤和上一步高度耦合，上面介绍比较泛泛，具体配置流程如下）</p>
<ul>
<li>通常数据路径：（playback）RAM -&gt; DMA -&gt; (xxx) -&gt; cpu dai -&gt; codec dai -&gt; pa</li>
<li>板级端platform。根据不同的平台的使用要求，配置route table和dapm。该通路需要保证数据从RAM到cpu dai</li>
<li>设备端codec。根据手册和相关文档，查看相关流程是否正确</li>
<li>设备端pa。根据手册和相关文档，进行配置</li>
</ul>
</li>
<li><p>放音测试正常即可</p>
</li>
<li><p>优化codec寄存器配置</p>
</li>
</ol>
<h1 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h1><ol>
<li><p>codec与cpu不能进行i2c通信？</p>
<ul>
<li>检查设备地址</li>
<li>检查设备供电是否有问题</li>
<li>示波器查看I2C时序</li>
<li>最终定位在codec供电是3.3v，而codec的i2c上拉是1.8v。将i2c上拉电压更改正常通信</li>
</ul>
</li>
<li><p>request_firmware 函数不能正常加载固件？</p>
<ul>
<li>路径不正确。拼写错误</li>
<li>权限不正确<ul>
<li>检查SElinux安全模块，是否是权限问题导致禁止读</li>
<li>检查文件系统的权限，是否可以读</li>
<li>内核配置问题。内核找到函数的实现部分，定位出现错误的位置，最终定位到是某一个宏未选中导致使用的函数未实现</li>
</ul>
</li>
<li>代码有误。在固件加载过程中不同编译器不同平台对于无符号/有符号的处理可能不同。</li>
</ul>
</li>
<li><p>codec、板级通路检查正常，录音报错？</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">/ <span class="meta"># arecord -D hw:0,5 -c 2 -r 16000 -d 10 -t wav baic0_16000-2.wav</span></span><br><span class="line">	Recording WAVE <span class="string">'baic0_16000-2.wav'</span> : Unsigned <span class="number">8</span> bit, Rate <span class="number">16000</span> Hz, Stereo</span><br><span class="line">	arecord: set_params:<span class="number">1312</span>: Broken configuration <span class="keyword">for</span> this PCM: no configurations available</span><br><span class="line">/ #</span><br></pre></td></tr></tbody></table></figure>

<p>CONFIG_SND_ASOC_INGENIC_DMA_PREALLOC_PAGES内核中这个宏配置较小，改成128正常（ingenic平台）</p>
<p>最终宏的值配置在了 struct snd_pcm_hardware 结构体 <code>.buffer_bytes_max</code>成员变量上，该成员变量表示 PCM 设备的最大缓冲区大小（以字节为单位），说明该成员变量的值不能太小，否则会出现以上错误。</p>
<p>另一种解决办法：在命令行加入 -B 参数，表示buffer的大小</p>
</li>
<li><p>录放音通路？</p>
<p>对于录音，通常会有dmic和amic，dmic采样之后已经是数字输出，数字数据输出到CODEC内部对于adc的配置与模拟数据是不一致的，需要调整。</p>
<ul>
<li><p>录音：mic  –&gt;  codec(adc)  –&gt;  codec dai  –&gt;  I2S –&gt; cpu dai –&gt; DMA –&gt;  RAM</p>
</li>
<li><p>放音：RAM  –&gt; DMA  –&gt; cpu dai  –&gt;  I2S  –&gt; codec dai  –&gt;  codec(dac)  –&gt;  pa</p>
</li>
</ul>
</li>
<li><p>录音通路正常，但是使用arecord录音没有数据？</p>
<p>使用示波器对硬件管脚进行检查，定位是在哪一个环节数据没有进一步传输。在此过程中对于时钟也要进行测量。</p>
<p>在上述问题出现的情况下，测量MCLK正常，LRCLK、WS是没有的。通过软件检查发现：对于x2000-soc aic控制器支持独立时钟和共享时钟两种模式，在硬件上codec通常只有一组I2S，五根pin（MCLK、LRCLK、WS、R_DATA、T_DATA），但是对于SOC每一组的I2S时钟都是独立的，需要硬件和软件进行匹配。最后的问题在于将接受数据的clk输出到另外一个管脚（悬空）上，通过修改设备树配置正确输出时钟即可。</p>
</li>
<li><p>耳机录放音无声？</p>
<p>通过示波器检查输出波形，如果存在波形检查硬件是否存在将其拉地的地方</p>
<p>对于录音无声可以检查MICBIAS电压是否存在，通常，麦克风需要一个稳定的直流电压来极化麦克风的电容式元件或其他传感器，以便能够正确地工作和产生音频信号。Micbias电压通常是3.3V、5V或其他适合麦克风工作的电压。具体的Micbias电压值取决于麦克风的类型和规格。</p>
<p><code>对于ES8326这款codec，不能使用VMID来当做耳机的micbias</code></p>
</li>
<li><p>不论是否插入HP设备，都会一直来中断？</p>
<p>首先需要检查中断IO是否配置正确，其次验证对应IO的电平是否发生翻转。最终解决是在设备树中hp_detect_gpio需要配置成HIZ，不能配置成NOBIAS（关闭偏振电压）。</p>
</li>
<li><p>耳机录音的时候发现很强的滋啦滋啦声音？</p>
<p>如果有飞线查看是否存在虚焊</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/weixin_41028621/article/details/105834205">Linux Asoc</a></li>
<li><a href="https://www.cnblogs.com/bobfly1984/p/13966890.html">触发DAPM机制的时机 </a></li>
<li><a href="https://blog.csdn.net/weixin_41028621/category_9941913.html">音频子系统</a></li>
<li><a href="https://elixir.bootlin.com/linux/v6.5-rc3/source/sound/soc/soc-core.c">Linux源代码bootlin</a></li>
</ul>
]]></content>
      <categories>
        <category>WorkExperience</category>
      </categories>
  </entry>
  <entry>
    <title>ENC28J60及Lwip协议栈移植适配</title>
    <url>/2024/02/21/WorkExperience/ENC28J60%E5%8F%8ALwip%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%A7%BB%E6%A4%8D%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="/images/WorkExperience/hardware.png" alt="image"></p>
<p><img src="/images/WorkExperience/framework.png" alt="image"></p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>对于硬件连接不需要进行过多的赘述，只需要将管脚正确连接即可。电源方面：3V3、GND和RESET管脚，对于ENC28J60有软件复位功能，但是两个RESET的功能不一致，所以将硬件RESET管脚连接起来保证功能的稳定性；数据传输SPI方面：CLK、MISO、MOSI和CS；其它：INT，这个中断的作用是当ENC28J60有数据要发送给MCU时或者存在一些状态错误的时候，这个中断会产生。当然，如果MCU软件部分采用轮询模式，循环查询ENC28J60 某个寄存器是否有数据，则不需要连接这个管脚。但是建议使用中断模式，提高主控效率。</p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul>
<li>驱动层。实现硬件抽象和必要的数据发送接收函数。</li>
<li>协议栈。根据驱动函数实现协议栈的初始化、数据发送、数据接收接口。</li>
<li>应用层。使用协议栈的API编写Demo，包括添加网卡、网络配置、DHCP或静态IP配置、数据通讯等等。</li>
</ul>
<h1 id="SPI驱动"><a href="#SPI驱动" class="headerlink" title="SPI驱动"></a>SPI驱动</h1><p>SPI驱动是依赖具体的MCU型号的，所以只需要根据提供的驱动代码进行编程即可。主要实现的函数为：SPI初始化、SPI发送数据、SPI接收数据。</p>
<ul>
<li>初始化函数需要实现SPI的配置信息。ENC28J60的SPI配置信息固定：时钟相位（0，0）、MSB first（大端）、CS低有效、最大传输速率10Mb/s</li>
<li>发送接收函数直接调用驱动接口进一步是实现即可。传输方式（DMA/CPU）、接收中断（下降沿有效）</li>
</ul>
<h1 id="ENC28J60网卡驱动"><a href="#ENC28J60网卡驱动" class="headerlink" title="ENC28J60网卡驱动"></a>ENC28J60网卡驱动</h1><p>网卡驱动厂商一般都会提供网卡驱动代码，而网卡驱动代码的流程都是有迹可循的，对照手册查看时序和寄存器操作流程即可。而需要用户实现就是基于特定的MCU平台调用spi相关函数实现 enc_readopc、enc_writeopc、enc_readbuf、enc_writebuf四个函数。</p>
<p>整体上，ENC28J60包括MAC和PHY，要想访问到特定的寄存器需要 bank + 地址两部分组成，对于其8K的RAM访问需要用户编程写寄存器来划分发送和接收缓冲区的边界，并读写数据。</p>
<h1 id="Lwip协议栈"><a href="#Lwip协议栈" class="headerlink" title="Lwip协议栈"></a>Lwip协议栈</h1><p>关于Lwip协议栈的移植在网上有比较多的示例。最终用户只需要自己实现ethernet.c文件里面的5个函数即可：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">low_level_init</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line"><span class="type">static</span> <span class="type">err_t</span> <span class="title function_">low_level_output</span><span class="params">(<span class="keyword">struct</span> netif *netif, <span class="keyword">struct</span> pbuf *p)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pbuf * <span class="title function_">low_level_input</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ethernetif_input</span><span class="params">(<span class="type">void</span> *pParams)</span></span><br><span class="line"><span class="type">err_t</span> <span class="title function_">ethernetif_init</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="low-level-init"><a href="#low-level-init" class="headerlink" title="low_level_init"></a>low_level_init</h2><p>网卡的初始化函数。它主要用来完成网卡复位及参数初始化，主要包含以下几个步骤</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">low_level_init</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 设置标志位</span></span><br><span class="line">	netif-&gt;flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;</span><br><span class="line">  <span class="comment">// 将 ethernetif_input 作为单独的线程跑起来（数据接收）</span></span><br><span class="line">	thread_create(<span class="string">"receive data"</span>, <span class="number">1024</span>*<span class="number">4</span>,(<span class="type">thread_func_t</span>)ethernetif_input, netif);</span><br><span class="line">  <span class="comment">// 网卡初始化</span></span><br><span class="line">	ENC28J60_Init(netif-&gt;hwaddr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="low-level-output"><a href="#low-level-output" class="headerlink" title="low_level_output"></a>low_level_output</h2><p>网卡数据包的发送函数。将内核数据包pbuf发送出去，伪代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> send_buffer[<span class="number">1500</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">err_t</span> <span class="title function_">low_level_output</span><span class="params">(<span class="keyword">struct</span> netif *netif, <span class="keyword">struct</span> pbuf *p)</span></span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">q</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> templen = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历所有的pbuf，将数据重新排列保证不丢数据</span></span><br><span class="line">  <span class="keyword">for</span>(q = p;q != <span class="literal">NULL</span>;q = q-&gt;next) {</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;send_buffer[templen],q-&gt;payload,q-&gt;len);</span><br><span class="line">    templen +=q-&gt;len;</span><br><span class="line">    <span class="keyword">if</span>(templen&gt;<span class="number">1500</span> || templen &gt; p-&gt;tot_len) {</span><br><span class="line">    ┆   LWIP_DEBUGF(NETIF_DEBUG, (<span class="string">"PacketSend : error; templen = %d tot_len = %d"</span>, templen, p-&gt;tot_len));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">/* 调用网卡发送函数，将数据发送出去 */</span></span><br><span class="line">  <span class="keyword">if</span>(templen == p-&gt;tot_len) {</span><br><span class="line">    ENCPacketSend(send_buffer, templen);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="low-level-input"><a href="#low-level-input" class="headerlink" title="low_level_input"></a>low_level_input</h2><p>网卡数据包接收函数。需要将网卡传过来的数据封装成pbuf的形式传给协议栈</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> recv_buffer[<span class="number">2000</span>];</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pbuf* <span class="title function_">low_level_input</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span>* <span class="title">p</span>, <span class="title">q</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recvlen, i;</span><br><span class="line">		<span class="comment">// 调用网卡接收函数</span></span><br><span class="line">    recvlen = ENCPacketRcv(recv_buffer,<span class="number">2000</span>);</span><br><span class="line">		<span class="comment">// 申请pbuf所需要的内存空间</span></span><br><span class="line">    p = pbuf_alloc(PBUF_RAW,recvlen,PBUF_RAM);</span><br><span class="line">    q = p;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>) {</span><br><span class="line">    ┆   <span class="comment">// 封装pbuf结构体</span></span><br><span class="line">    ┆   <span class="built_in">memcpy</span>(q-&gt;payload,&amp;recv_buffer[i],q-&gt;len);</span><br><span class="line">    ┆   i += q-&gt;len;</span><br><span class="line">    ┆   <span class="comment">// 下一个pload</span></span><br><span class="line">    ┆   q = q-&gt;next;</span><br><span class="line">    ┆   <span class="keyword">if</span>(i&gt;recvlen) <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="ethernetif-input"><a href="#ethernetif-input" class="headerlink" title="ethernetif_input"></a>ethernetif_input</h2><p>调用网卡数据包接收函数 low_level_input 从网卡处读取一个数据包。</p>
<p>对于数据接受来讲，如果使用中断：ETH_IRQHandler() → ethernetif_input() → netif-&gt;input(p, netif) → tcpip_input() → tcpip_inpkt() → tcpip_thread()。当以太网有数据需要Master来接收，首先给主机端产生一个中断，主机端需要做的是将以太网接受数据的过程放在ethernetif_input函数中实现，后面都是通用流程一步步调用，最终将数据返回给应用层。<br>这里还需要注意的是，这里接受数据的过程将可能是耗时的操作，不能放在中断服务程序里面进行，要么使用delay work要么使用thread进行实现。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ethernetif_input</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pbuf</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">netif</span>* <span class="title">netif</span> =</span> (<span class="keyword">struct</span> netif*)param;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">				<span class="comment">// 等待网卡中断或者循环读取网卡寄存器，判断是否有可读数据。满足条件继续执行</span></span><br><span class="line">TRY_GET_NEXT_FRAGMENT:</span><br><span class="line">				<span class="comment">// 调用 low_level_input 函数接收数据</span></span><br><span class="line">    ┆   p = low_level_input(netif);</span><br><span class="line">    ┆   <span class="comment">// 将数据发送到协议栈</span></span><br><span class="line">    ┆   <span class="keyword">if</span> (netif-&gt;input(p, netif) != ERR_OK) {</span><br><span class="line">    ┆   ┆   pbuf_free(p);</span><br><span class="line">    ┆   ┆   p = <span class="literal">NULL</span>;</span><br><span class="line">    ┆   }</span><br><span class="line">    ┆   <span class="keyword">else</span></span><br><span class="line">    ┆   ┆   <span class="keyword">goto</span> TRY_GET_NEXT_FRAGMENT;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="ethernetif-init"><a href="#ethernetif-init" class="headerlink" title="ethernetif_init"></a>ethernetif_init</h2><p>网卡初始化函数。需要完成netif字段的初始化，该函数在上层 netif_add 的时候会调用到</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">err_t</span> <span class="title function_">ethernetif_init</span><span class="params">(<span class="keyword">struct</span> netif *netif)</span></span><br><span class="line">{</span><br><span class="line">  netif-&gt;name[<span class="number">0</span>] = IFNAME0;</span><br><span class="line">  netif-&gt;name[<span class="number">1</span>] = IFNAME1;</span><br><span class="line">  netif-&gt;output = etharp_output;</span><br><span class="line">  <span class="comment">// 设置回调函数</span></span><br><span class="line">  netif-&gt;linkoutput = low_level_output;</span><br><span class="line">  <span class="comment">// 调用初始化</span></span><br><span class="line">  low_level_init(netif);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>展示DHCP配网的基本流程</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dhcp_config</span><span class="params">(<span class="type">uint8_t</span>* hwaddr)</span></span><br><span class="line">{</span><br><span class="line">		<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">netif</span> <span class="title">netif</span>;</span></span><br><span class="line">		<span class="type">ip_addr_t</span> ipaddr, gw, netmask;</span><br><span class="line">		<span class="comment">// Start lwip </span></span><br><span class="line">		tcpip_init(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">// Set data zero</span></span><br><span class="line">    ip_addr_set_zero_ip4(&amp;gw);</span><br><span class="line">    ip_addr_set_zero_ip4(&amp;ipaddr);</span><br><span class="line">    ip_addr_set_zero_ip4(&amp;netmask);</span><br><span class="line">		<span class="comment">// Add netif</span></span><br><span class="line">    netif_add(&amp;netif, &amp;ipaddr, &amp;netmask, &amp;gw, <span class="literal">NULL</span>, &amp;ethernetif_init, &amp;tcpip_input);</span><br><span class="line">    <span class="comment">/*  Registers the default network interface */</span></span><br><span class="line">    netif_set_default(&amp;netif);</span><br><span class="line">    <span class="keyword">if</span> (netif_is_link_up(&amp;netif)) {</span><br><span class="line">    ┆   <span class="comment">/* When the netif is fully configured this function must be called */</span></span><br><span class="line">    ┆   netif_set_up(&amp;netif);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">    ┆   <span class="comment">/* When the netif link is down this function must be called */</span></span><br><span class="line">    ┆   netif_set_down(&amp;netif);</span><br><span class="line">    }</span><br><span class="line">		<span class="comment">// Start dhcp service</span></span><br><span class="line">		dhcp_start(&amp;netif);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ol>
<li><p>分析发现MCU可以从ENC28J60接收到数据包，但是格式不正确？</p>
<p> 分析：多次测试查看数据包内容是否一致。如果不一致可能是中断导致，中断响应不及时等原因；如果一致则可能是发送数据包不正确、数据发送或者接收流程有问题。</p>
<p> 定位：对于ENC28J60有一个8K RAM，按照数据手册将数据从接收缓冲区全部读出验证发现数据是正确的，但是解析不正确，最终定位到ENC_readOpc接口有一个无效字节的问题，对于read buffer所有数据都是有效的，调用这个接口就把有效数据丢掉了进而导致的问题的出现。</p>
</li>
<li><p>数据不正确的调试方法？</p>
<ul>
<li>信号质量。包括电压大小、信号稳定性等等</li>
<li>确认数据不正确是错的一致还是错的不一致，进而确认问题是随机产生还是可能配置导致的bug</li>
<li>对比正确的数据格式，分析可能存在的配置错误</li>
</ul>
</li>
<li><p>ping命令显示主机不可达并且一段时间自行恢复？</p>
<p> 首先可以通过 arp -n 命令查看arp缓存，这种要么是网络存在问题要么就是防火墙或者arp的问题。将设备上Lwip协议栈中 DHCP_DOES_ARP_CHECK 这个宏的配置改成1即可</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://wiki.ocrobot.com/lib/exe/fetch.php?media=ocrobot:alpha:enc28j60:enc28j60_cn.pdf">ENC28J60中文手册</a></li>
<li><a href="http://news.eeworld.com.cn/mcu/article_2017020533638.html">ENC28J60学习笔记——AVRNET项目</a></li>
<li><a href="https://blog.csdn.net/qq_40831436/article/details/126778233">《lwip学习1》-数据流篇</a></li>
</ol>
]]></content>
      <categories>
        <category>WorkExperience</category>
      </categories>
  </entry>
  <entry>
    <title>内存溢出与内存泄漏</title>
    <url>/2023/12/17/WorkExperience/memleak/</url>
    <content><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul>
<li><p>内存溢出</p>
<p>内存溢出是指程序在运行过程中尝试使用超过其分配内存的范围的内存空间。这可能导致程序崩溃或产生不可预测的行为。内存溢出通常发生在程序尝试写入超过分配内存范围的数据时，这可能是由于数组越界、指针错误等原因引起的。比如：数组越界访问；指针错误，尝试访问未分配或已释放的内存。</p>
</li>
<li><p>内存泄漏</p>
<p>内存泄漏是指程序在运行过程中未能正确释放已经不再需要的内存，导致系统中的可用内存逐渐减少，最终可能耗尽系统的可用内存资源。内存泄漏通常发生在程序中的某个部分未能释放动态分配的内存，导致这部分内存无法再被程序访问，但仍然占据系统的内存空间。比如：未使用释放内存的函数（如<code>free</code>或<code>delete</code>）；循环引用；未关闭的文件句柄等资源。</p>
</li>
</ul>
<h1 id="内存溢出解决方案"><a href="#内存溢出解决方案" class="headerlink" title="内存溢出解决方案"></a>内存溢出解决方案</h1><ul>
<li>数组越界检查并合理使用指针。</li>
<li>内存越界检查工具： 使用内存越界检查工具或编译器选项，以检测潜在的内存溢出问题。</li>
<li>使用安全的库函数： 使用strcpy替换strncpy，使用sprtintf替换snprintf。</li>
<li>防御性编程：在代码中使用防御性编程的技术，例如在删除指针后将其置为nullptr，以避免悬空指针引用。</li>
</ul>
<h1 id="内存泄漏解决方案"><a href="#内存泄漏解决方案" class="headerlink" title="内存泄漏解决方案"></a>内存泄漏解决方案</h1><p>这部分主要针对堆空间malloc之后没有free造成的内存泄漏提供的解决方案。其核心思想都是使用自定义的malloc函数来替换掉库函数，使我们能够检测到哪块内存是没有被释放的。</p>
<p><a href="https://github.com/yangLieee/codebackup.git">github代码地址</a></p>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>宏定义方式适用于单个文件检测，使用静态连接的方式进行检测。通过自定义malloc、free函数，使用创建文件的机制来确认哪里出现的内存泄漏</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define STORE_PATH <span class="string">"memleakStore"</span></span></span><br><span class="line">void* my_malloc(size_t size, const char* filename, const char* func, int line)</span><br><span class="line">{</span><br><span class="line">    char buffer[128] = {0};</span><br><span class="line">    const char* storepath = STORE_PATH;</span><br><span class="line">    if(access(storepath, F_OK) != 0) {</span><br><span class="line">        mkdir(storepath,0755);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void* ptr = malloc(size);</span><br><span class="line">    if(ptr != NULL) {</span><br><span class="line">        snprintf(buffer, sizeof(buffer), "%s/%p.mem", storepath, ptr);</span><br><span class="line">        FILE* fp = fopen(buffer, "w");</span><br><span class="line">        memset(buffer, 0, sizeof(buffer));</span><br><span class="line">        snprintf(buffer, sizeof(buffer), "[+] (%s %s %d) (%p + %ld)\n", filename, func, line, ptr, size);</span><br><span class="line">        fwrite(buffer, sizeof(char), sizeof(buffer), fp);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    }</span><br><span class="line">    return ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void my_free(void* ptr, const char* filename, const char* func, int line)</span><br><span class="line">{</span><br><span class="line">    char buffer[128] = {0};</span><br><span class="line">    const char* storepath = STORE_PATH;</span><br><span class="line">    if(access(storepath, F_OK) != 0) {</span><br><span class="line">        printf("%s not exist. Please Check \n", storepath);</span><br><span class="line">        return;                                                                                                                              </span><br><span class="line">    }   </span><br><span class="line"></span><br><span class="line">    snprintf(buffer, sizeof(buffer), "%s/%p.mem", storepath, ptr);</span><br><span class="line">    if(unlink(buffer) != 0) {</span><br><span class="line">        printf("Double Free Error\n");</span><br><span class="line">        FILE* fp = fopen(buffer, "w");</span><br><span class="line">        memset(buffer, 0, sizeof(buffer));</span><br><span class="line">        snprintf(buffer, sizeof(buffer), "[-] (%s %s %d) (%p)\n", filename, func, line, ptr);</span><br><span class="line">        fwrite(buffer, sizeof(char), sizeof(buffer), fp);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        return ;</span><br><span class="line">    }</span><br><span class="line">    free(ptr);</span><br><span class="line">}</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define malloc(size)    my_malloc(size, __FILE__,__func__,__LINE__)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define free(ptr)       my_free(ptr, __FILE__,__func__,__LINE__)</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p>Hook是使用LD_PRELOAD机制，使用dlsym采用动态连接的方式，重定义malloc、free来定位</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define _GNU_SOURCE</span>        </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">include &lt;stdio.h&gt;</span>    </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">include &lt;stdlib.h&gt;</span>    </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">include &lt;dlfcn.h&gt;</span></span><br><span class="line"></span><br><span class="line">typedef void  (*glibc_free)(void* ptr);</span><br><span class="line">typedef void* (*glibc_malloc)(size_t size);</span><br><span class="line"></span><br><span class="line">static glibc_malloc gmalloc = NULL;</span><br><span class="line">static glibc_free   gfree   = NULL;</span><br><span class="line"></span><br><span class="line">static void hook_init(void)</span><br><span class="line">{</span><br><span class="line">    if(gmalloc == NULL) {</span><br><span class="line">        gmalloc = dlsym(RTLD_NEXT, "malloc");</span><br><span class="line">        if (!gmalloc) {</span><br><span class="line">            fprintf(stderr, "unable to get malloc symbol!\n");</span><br><span class="line">            exit(1);</span><br><span class="line">        }</span><br><span class="line">    }   </span><br><span class="line"></span><br><span class="line">    if(gfree == NULL) {                                                                                                                      </span><br><span class="line">        gfree = dlsym(RTLD_NEXT, "free");</span><br><span class="line">        if (!free) {</span><br><span class="line">            fprintf(stderr, "unable to get free symbol!\n");</span><br><span class="line">            exit(1);</span><br><span class="line">        }</span><br><span class="line">    }   </span><br><span class="line">    fprintf(stderr, "malloc and free successfully wrapped\n");</span><br><span class="line">}</span><br><span class="line">void* malloc(size_t size)</span><br><span class="line">{</span><br><span class="line">    void* caller = __builtin_return_address(1);                                                                                              </span><br><span class="line">    if(gmalloc == NULL) {</span><br><span class="line">        hook_init();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void* ptr = gmalloc(size);</span><br><span class="line">    fprintf(stderr, "[+] caller %p malloc from %p size %ld\n", caller, ptr, size);</span><br><span class="line">    // 如果打印，一定要用fprintf(stderr)，否则会产生无限循环，因为fprintf(stdout)也会使用malloc！</span><br><span class="line"></span><br><span class="line">    return ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void free(void* ptr)</span><br><span class="line">{</span><br><span class="line">    void* caller = __builtin_return_address(1);</span><br><span class="line">    if(gfree == NULL) {</span><br><span class="line">        hook_init();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    gfree(ptr);</span><br><span class="line">    fprintf(stderr, "[-] caller %p free from %p\n", caller, ptr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="bpftrace"><a href="#bpftrace" class="headerlink" title="bpftrace"></a>bpftrace</h2><p>bfptrace官方建议linux内核版本为4.9或以上。具体使用方式需要进一步查看相关资料</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载点</span></span><br><span class="line">uprobe:/lib/x86_64-linux-gnu/libc.so.6:malloc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断条件是否发生（进程是否==memleak）</span></span><br><span class="line">/comm == "memleak"/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">action动作</span></span><br><span class="line">{</span><br><span class="line">    printf("malloc\n");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">uprobe:/lib/x86_64-linux-gnu/libc.so.6:free</span><br><span class="line">/comm == "memleak"/</span><br><span class="line">{</span><br><span class="line">    printf("free\n");</span><br><span class="line">}                                                                                                       </span><br></pre></td></tr></tbody></table></figure>



<h1 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h1><p><code>LD_PRELOAD</code> 是一个在 Linux 系统中用于预加载共享库的环境变量。通过设置 <code>LD_PRELOAD</code>，可以在运行时加载指定的共享库，覆盖程序默认加载的库，从而影响程序的行为。这在某些情况下可以用于修改或增强程序的行为，进行调试，或者实现一些特殊的需求。</p>
<p>在dlsym的使用过程中_GNU_SOURCE 是一定要添加的，因为RTLD_NEXT 宏依赖于这个宏。RTLD_NEXT 就是告诉 ld-linux.so 不要在当前文件中找 free 这个符号，而是要按照动态库的搜索顺序找到下一个动态库，并在它里面寻找 free 函数，实际上，这里找到的就是 glibc 里的 free 函数了。</p>
<p>note:</p>
<p>需要注意的是，在实现malloc函数的时候，里面的打印函数不要使用printf，因为printf里面也调用了malloc，这就导致无限递归最终stackoverflow。所以打印方式使用fprintf(sterr,xxx)即可</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1HG411m7Bd/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=325c04c6d1981d42775f7af13e48765d">5种内存泄漏检测的方式</a></li>
<li><a href="https://blog.csdn.net/legend050709/article/details/128320047">bpftrace的使用方法</a></li>
</ul>
]]></content>
      <categories>
        <category>WorkExperience</category>
      </categories>
  </entry>
  <entry>
    <title>电池电量检测</title>
    <url>/2023/03/06/WorkExperience/%E7%94%B5%E6%B1%A0%E7%94%B5%E9%87%8F%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>近期在做关于电池电量检测的工作，而硬件电路并没有使用库仑计（在部分嵌入式场景下成本太高），而是使用分压电路ADC采样。基于此对相关学习到的内容做总结和分享</p>
<h1 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h1><ul>
<li>锂电池的放电非线性；</li>
<li>充放电瞬间，电压值是突变的</li>
<li>锂电池随着使用电量减少，需要实现自动校准</li>
<li>……</li>
</ul>
<h1 id="充电IC基础原理"><a href="#充电IC基础原理" class="headerlink" title="充电IC基础原理"></a>充电IC基础原理</h1><h2 id="IC充电阶段"><a href="#IC充电阶段" class="headerlink" title="IC充电阶段"></a>IC充电阶段</h2><ul>
<li><p>涓流充电（Trickle Charge）</p>
<p>涓流充电阶段通常只在电池电压低于一个极低水平时采用。</p>
<p>在这种状态下，电池组的内部保护 IC 可能由于深度放电或发生过流事件已经断开了电池。充电器 IC 提供一个小电流（通常为 50mA）为电池组的电容充电，以触发保护 IC ，合上其 FET重新连接电池。虽然涓流充电通常只持续几秒钟，但充电器 IC 仍然需要集成一个定时器。如果电池组在一定时间内未重新连接，则定时器停止充电，因为这表明电池已损坏。</p>
</li>
<li><p>预充电（PreCharge）</p>
<p>一旦电池组重新连接或处于放电状态，就进入预充电阶段。</p>
<p>预充电期间，充电IC开始以一个较低的电流水平为耗尽的电池安全充电，该电流通常为 C / 10（C 为容量，以 mAh 为单位）。预充电使电池电压缓慢上升。其目的是在低电流水平下对电池进行安全的充电，以防止损坏电池，直到其电压达到一个较高的水平。</p>
</li>
<li><p>恒流充电（Constant Current Charge）</p>
<p>恒流（CC）充电也被称作快速充电阶段，恒流充电在预充电之后开始。</p>
<p>在恒流充电阶段，电池可以安全地处理 0.5C 至3C 之间的较高充电电流。恒流充电会持续到电池电压达到“满电”或浮动电压水平，然后进入恒压充电阶段。</p>
</li>
<li><p>恒压充电（Constant voltage Charge）</p>
<p>充电器 IC 会在恒流充电期间监测电池电压。一旦电池达到恒压充电阈值，充电器IC就会从恒流转换至恒压调节阶段。当充电器 IC 监测到外部电池组电压超过了电池组中的实际电池电压，就开始执行恒压充电。这是由于存在内部电池电阻、PCB 电阻和来自保护 FET 和单电池的等效串联电阻 (ESR)。充电器 IC 不应允许电池电压超过其最大浮动电压，以保证安全的运行。</p>
</li>
<li><p>截止阶段</p>
<p>对于浮充型充电芯片，当达到浮充阈值，输出恒定电压</p>
<p>对于关断型充电芯片，当充电充满，芯片处于关断待机状态，无充电电流</p>
</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li>对于IC各个充电阶段需要参考IC的手册最终确定有哪些阶段，有些将涓流充电和预充电合成一个阶段处理，所以需要具体分析。</li>
<li>有些充电IC提供了可编程配置阈值的功能，即通过连接不同的阻值来对其进行设置，如果没有需要参考手册确定每个阶段的阈值分别是多少。配置的阈值能够提供一层额外的安全保护，保护电池免受过压、过热条件以及过载的影响，从而避免电池的永久损坏或容量降级。</li>
</ol>
<h1 id="流程整理"><a href="#流程整理" class="headerlink" title="流程整理"></a>流程整理</h1><ol>
<li><p>配置 ADC</p>
<p>中断模式、设置重复采样时间、设置采样次数</p>
<ul>
<li>Vadc = adcNumer(ADC采样数据) x Vref（ADC基准电压）/  （2^ADC量化位数）</li>
<li>Vbat = k（电阻分压系数比） ×  Vadc</li>
</ul>
</li>
<li><p>配置 Timer</p>
<p>配置ADC采样的时间即多久进行一次电池电量检测</p>
</li>
<li><p>启动电池电量检测主线程</p>
</li>
<li><p>等待USB插拔事件中断或者Timer时间触发电池检测</p>
<ul>
<li>打开ADC采样通道</li>
<li>获取ADC数据</li>
<li>关闭ADC采样通道</li>
<li>计算最终输出的电池电量</li>
</ul>
</li>
</ol>
<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/************************************   ADC    *******************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">adc_interrupt_cb</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// calculate adc voltage</span></span><br><span class="line">    <span class="comment">// 校准：采集多次去掉一个最小值、去掉一个最大值，取平均值</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">adc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// config adc interrupt mode and callback</span></span><br><span class="line">    <span class="comment">// config adc sampling times</span></span><br><span class="line">    <span class="comment">// enable adc channels</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/************************************   USB    *******************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_interrupt_callback</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// get usb charging / discharging state</span></span><br><span class="line">    <span class="comment">// put battery detect time to default</span></span><br><span class="line">    <span class="comment">// enable adc sampling(enter adc_interrupt_cb)</span></span><br><span class="line">}   </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// request drv_bus gpio</span></span><br><span class="line">    <span class="comment">// config  drv_bus interrupt and trigger mode</span></span><br><span class="line">    <span class="comment">// config  interrupt callback</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/***********************************    TIMER     ***************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_interrupt_cb</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// enable adc sampling(enter adc_interrupt_cb)</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// config timer</span></span><br><span class="line">    <span class="comment">// config default battery detect time to timer</span></span><br><span class="line">    <span class="comment">// config timer interrupt callback</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/***********************************   BATTERY    ***************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_battery_voltage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// enable channels</span></span><br><span class="line">    <span class="comment">// get battery voltage</span></span><br><span class="line">    <span class="comment">// disable channels</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adjust_battery_voltage</span><span class="params">(<span class="type">int</span> vbat)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// record pre_percent pre_voltage</span></span><br><span class="line">    <span class="comment">// record voltage and timestamp, calculate new battery detect time</span></span><br><span class="line">    <span class="comment">// other optimize ways</span></span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">calculate_battery_percent</span><span class="params">(<span class="type">int</span> vbat)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 需要厂家提供电池充放电电池容量百分比对应的电压</span></span><br><span class="line">    <span class="comment">// 查表===&gt;计算出百分比</span></span><br><span class="line">    <span class="comment">// 策略：</span></span><br><span class="line">    <span class="comment">//   最终的百分比相较于上一次是否有跳变，+-1；</span></span><br><span class="line">    <span class="comment">//   充电百分比减少，放电百分比增加。不被允许，需要对这两种情况处理掉</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//电池电量检测函数可以进一步优化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">battery_detect_thread</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    adc_init();</span><br><span class="line">    usb_init();</span><br><span class="line">    timer_init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// calculate battery percent</span></span><br><span class="line">        <span class="type">int</span> vbat = get_battery_voltage();</span><br><span class="line">        vbat = adjust_battery_voltage(vbat);</span><br><span class="line">        <span class="type">int</span> percent = calculate_battery_percent(vbat);</span><br><span class="line">    }</span><br><span class="line">    adc_deinit();</span><br><span class="line">    usb_deinit();</span><br><span class="line">    timer_deinit();</span><br><span class="line">}   </span><br></pre></td></tr></tbody></table></figure>

<h1 id="误差来源"><a href="#误差来源" class="headerlink" title="误差来源"></a>误差来源</h1><ol>
<li>ADC量化误差</li>
<li>分压电阻值不准确，导致分压比不确定带来的误差</li>
<li>OCV表格内记录的是阶段性的电压与容量比，每一格实际上不是线性变化的，但在实际处理过程中按照线性来处理</li>
</ol>
<h1 id="校准误差及优化策略"><a href="#校准误差及优化策略" class="headerlink" title="校准误差及优化策略"></a>校准误差及优化策略</h1><ol>
<li><p>ADC采样</p>
<p>平均值滤波。取十次adc数据，去掉最大值、最小值取平均值</p>
</li>
<li><p>插入usb / 拔出usb瞬间触发电池检测</p>
</li>
<li><p>记录最近十次采样的结果及sysTime，计算掉电或上电1%容量所消耗的时间，从而可以计算出下一次检测的时间间隔</p>
</li>
<li><p>在最终电池电量的显示上，需要逐步递增逼近采集的值不能突变</p>
</li>
<li><p>校准：根据一个确定状态下，确定的电压值和我们采集到的电压值，计算出偏差，校准</p>
</li>
</ol>
<h1 id="缩写表"><a href="#缩写表" class="headerlink" title="缩写表"></a>缩写表</h1><ul>
<li><p>OCV：Open Circuitt Voltage  开路电压</p>
</li>
<li><p>CV：Cyclic Voltammetry 循环伏安法（改变电位以得到氧化还原电流方向之方法）</p>
</li>
<li><p>UVLO：Under Voltage Lock Out 欠压锁定（输入电压低于某一值时，电源芯片不工作，处于保护状态）</p>
</li>
<li><p>OVP：Over Voltage Protection  过压保护</p>
</li>
<li><p>UVP：Under voltage Protection  欠压保护</p>
</li>
<li><p>ASOC：Absolute State-Of-Charge  绝对电荷状态 （绝对荷电状态则是一个当电池制造完成时，根据所设计的固定容量值所计算出来的的参考值）</p>
</li>
<li><p>RSOC： Relative State-Of-Charge 相对电荷状态（相对荷电状态的范围是 0% - 100%）</p>
</li>
</ul>
<p>一个全新完全充电电池的绝对荷电状态是100%；而老化的电池即便完全充电，在不同充放电情况中也无法到100%。</p>
<h1 id="IC原理图及其它参考资料"><a href="#IC原理图及其它参考资料" class="headerlink" title="IC原理图及其它参考资料"></a>IC原理图及其它参考资料</h1><ol>
<li><a href="https://www.dioo.com/uploads/product/20210521/77eaa63f9de5e6b03018958741f47a52.pdf">DIO58056</a></li>
<li><a href="https://www.docin.com/p-2290652672.html">SY8602</a></li>
<li><a href="https://www.ti.com.cn/cn/lit/an/zhcaaf7/zhcaaf7.pdf">TI电量计设计指导</a></li>
<li><a href="https://blog.csdn.net/Linux_LR/article/details/119787382">ADC电量检测与校准</a></li>
</ol>
]]></content>
      <categories>
        <category>WorkExperience</category>
      </categories>
  </entry>
  <entry>
    <title>Problem &amp; Tools</title>
    <url>/2023/04/27/WorkExperience/problem_tools/</url>
    <content><![CDATA[<h1 id="ubuntu软件"><a href="#ubuntu软件" class="headerlink" title="ubuntu软件"></a>ubuntu软件</h1><h2 id="音频-audacity"><a href="#音频-audacity" class="headerlink" title="音频 audacity"></a>音频 audacity</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install audacity</span><br></pre></td></tr></tbody></table></figure>

<h2 id="USB摄像头-chesse"><a href="#USB摄像头-chesse" class="headerlink" title="USB摄像头 chesse"></a>USB摄像头 chesse</h2><ol>
<li><p>设置→添加→usb控制器→兼容usb3.0</p>
</li>
<li><p>虚拟机→可移动设备→web camera→连接（断开主机）</p>
</li>
<li><p>查看是否配置成功，打开终端，输入</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lsusb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /dev/video0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出 /dev/video0,配置成</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>打开ubuntu自带的chesse软件（茄子），运行摄像头</p>
</li>
</ol>
<h2 id="USB摄像头-luvcview"><a href="#USB摄像头-luvcview" class="headerlink" title="USB摄像头 luvcview"></a>USB摄像头 luvcview</h2><ol>
<li><p>源码下载 ，链接：<a href="https://launchpad.net/ubuntu/+source/luvcview/1:0.2.6-6">https://launchpad.net/ubuntu/+source/luvcview/1:0.2.6-6</a></p>
</li>
<li><p>安装依赖</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install debhelper</span><br><span class="line">sudo apt-get install libsdl1.2-dev</span><br><span class="line">sudo apt-get install libv4l-dev</span><br><span class="line">sudo apt-get install pkg-config</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>将源码移动到安装文件夹下</p>
</li>
<li><p>执行 make 编译</p>
<p>执行 make install 安装可执行文件</p>
</li>
<li><p>使用方法</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">luvcview -d /dev/video0 -f yuv -s 640x480</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>问题</p>
<ul>
<li><p>报错 ”luvcview.c:32:10: fatal error: SDL/SDL.h: 没有那个文件或目录“</p>
<p>没有安装依赖</p>
</li>
<li><p>报错 ”luvcview.c:36:10: fatal error: linux/videodev.h: 没有那个文件或目录“</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo ln -s /usr/include/linux/videodev2.h /usr/include/linux/videodev.h</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ol>
<h2 id="图片格式7yuv"><a href="#图片格式7yuv" class="headerlink" title="图片格式7yuv"></a>图片格式7yuv</h2><p>好像只维护到16.0.4，可以搜索下查看</p>
<h2 id="串口工具minicom"><a href="#串口工具minicom" class="headerlink" title="串口工具minicom"></a>串口工具minicom</h2><h2 id="嵌入式开发工具"><a href="#嵌入式开发工具" class="headerlink" title="嵌入式开发工具"></a>嵌入式开发工具</h2><ul>
<li>UI：vim、emacs</li>
<li>多窗口管理工具：tmux</li>
<li>文本对比工具：meld、vimdiff</li>
<li>文档记录工具：typora</li>
<li>性能调优工具：perf</li>
</ul>
<h1 id="ssh-x2F-scp免密"><a href="#ssh-x2F-scp免密" class="headerlink" title="ssh / scp免密"></a>ssh / scp免密</h1><ol>
<li><p>本地ssh到服务器</p>
<ul>
<li>ssh-keygen产生公钥与私钥对（命令：ssh-keygen，过程中一直回车）</li>
<li>复制公钥至服务器（命令：ssh-copy-id -i ~/.ssh/id_rsa.pub username@服务器ip）</li>
<li>再次ssh即可实现免密登录</li>
</ul>
</li>
<li><p>服务器端scp免密</p>
<ul>
<li>产生密钥对（ssh-keygen -t rsa）</li>
<li>复制公钥至本地（ssh-copy-id -p 22 -i ~/.ssh/id_rsa.pub username@本地ip）</li>
<li>再次scp即可实现免密传输</li>
</ul>
</li>
<li><p>参数说明</p>
<ul>
<li>ssh-keygen     -t    type</li>
<li>ssh-copy-id    -p    port</li>
<li>ssh-copy-id	 -i    identity_file</li>
</ul>
</li>
</ol>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">export		    # 显示当前系统定义的所有的环境变量</span><br><span class="line">echo $PATH		# 输出当前PATH环境变量的值</span><br><span class="line"></span><br><span class="line">:               # 冒号分割不同的路径</span><br></pre></td></tr></tbody></table></figure>





<h1 id="pc无法识别usb"><a href="#pc无法识别usb" class="headerlink" title="pc无法识别usb"></a>pc无法识别usb</h1><ul>
<li><p>现象</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">error: insufficient permissions for device</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>解决方案</p>
</li>
</ul>
<ol>
<li><p>使用lsusb命令，查看usbID</p>
</li>
<li><p>插入usb之后，再次使用usbID，查找多出来的设备ID</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Bus 002 Device 002: ID 045e:00db Microsoft Corp. Natural Ergonomic Keyboard 4000 V1.0</span><br><span class="line"></span><br><span class="line">Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub </span><br><span class="line"></span><br><span class="line">Bus 001 Device 025: ID 18d1:4e12 </span><br><span class="line"></span><br><span class="line">Bus 001 Device 007: ID 1a40:0101 TERMINUS TECHNOLOGY INC. </span><br><span class="line"></span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ID后面分号前面对应xxx1，分号后面对应xxx2</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在/etc/udev/rules.d中创建“51-android.rules”（名字不固定）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">添加内容：</span><br><span class="line"></span><br><span class="line">UBSYSTEM=="usb", ATTRS{idVendor}=="xxx1", ATTRS{idProduct}=="xxx2",MODE="0666"</span><br><span class="line">SUBSYSTEMS=="usb", ATTRS{idVendor}=="18d1", ATTRS{idProduct}=="4e12", MODE="0666", OWNER="your_name"</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>为51-android.rules加上权限（sudo chmod a+x 51-android.rules）</p>
</li>
<li><p>重启UDEV（adb sudo restart udev; adb kill-server）</p>
</li>
<li><p>拔掉USB，并重新插上（adb devices）<br>adb devices</p>
</li>
</ol>
<h1 id="修改根目录权限"><a href="#修改根目录权限" class="headerlink" title="修改根目录权限"></a>修改根目录权限</h1><ul>
<li><p>场景</p>
<p>错误修改usr/bin下的所有文件权限为777，sudo无法使用</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/usr/bin/sudo must be owned by uid 0 and have the setuid bit se</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>解决方案</p>
</li>
</ul>
<ol>
<li><p>命令行 reboot 重启</p>
</li>
<li><p>按ESC进入，选择Advanced options for Ubuntu。选择recovery mode，选择root命令行模式</p>
<p>mount -o remount rw /<br>mount –all</p>
<p>因为recovery模式默认是以只读模式挂载，所以我们要重新挂载切换到读写模式</p>
</li>
<li><p>给sudo权限</p>
</li>
</ol>
<pre><code> chown root:root /usr/bin/sudo

 chmod 4755 /usr/bin/sudo 

 pkexec chmod go-w /usr/bin/sudo/sudoers.so
</code></pre>
<ol start="4">
<li>重启系统，reboot</li>
</ol>
<h1 id="minicom"><a href="#minicom" class="headerlink" title="minicom"></a>minicom</h1><ol>
<li><p>启动minicom之后没有打印</p>
<ul>
<li>“ctrl+a &gt; 按键o” 或者启动时“sudo minicom -s”进入配置界面</li>
<li>选择“Serial port setup”进入</li>
<li>将 “A -    Serial Device” 修改成 “/dev/ttyUSB0”</li>
</ul>
</li>
<li><p>启动之后不能键盘输入</p>
</li>
</ol>
<ul>
<li>“ctrl+a &gt; 按键o” 或者启动时“sudo minicom -s”进入配置界面</li>
<li>选择“Serial port setup”进入</li>
<li>将“F - Hardware Flow Control” 硬件流控关闭，即选择“No”</li>
</ul>
<p>​	</p>
]]></content>
      <categories>
        <category>WorkExperience</category>
      </categories>
  </entry>
  <entry>
    <title>ADC</title>
    <url>/2023/03/18/Hardware/Controller/ADC/</url>
    <content><![CDATA[<h1 id="ADC基础"><a href="#ADC基础" class="headerlink" title="ADC基础"></a>ADC基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>ADC：Analog to Digital Converter，模数转换器</li>
<li>模拟信号：随时间变化连续的信号，一段时间内有无数个取值 </li>
<li>数字信号：随时间变化离散的信号，一段时间内有固定个数的取值</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ol>
<li><strong>采样 Sampling：</strong>按照一定的频率对模拟信号的瞬时时刻进行样本采集；</li>
<li><strong>量化 Quantization：</strong>对采样点的幅度赋予具体的数值；</li>
<li><strong>编码 Encoding：</strong>按照一定的格式记录数据；</li>
</ol>
<p><img src="/images/Hardware/Controller/ADC.png" alt="image"></p>
<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ol>
<li><strong>采样速率 / 时钟频率</strong>：单位时间内能进行采样的次数	</li>
<li><strong>位宽 / 分辨率：</strong>输入信号值的最小变化</li>
<li>其它细化指标<ul>
<li>DLN：微分非线性，相对指标</li>
<li>ILN： 积分非线性，绝对指标</li>
<li>SFDR：无杂散动态范围</li>
</ul>
</li>
</ol>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="SAR"><a href="#SAR" class="headerlink" title="SAR"></a>SAR</h3><ul>
<li>SAR：Successive Approximation Register，逐次逼近型</li>
<li>原理：二分查找</li>
<li>特点：低延迟，低功耗</li>
</ul>
<h3 id="∆-∑"><a href="#∆-∑" class="headerlink" title="∆ -∑"></a><strong>∆ -∑</strong></h3><ul>
<li>∆ -∑ ：Delta-Sigma ADC</li>
<li>原理：就是把待测信号Vin与参考电压之间的差值进行不断的累积并通过反馈令这个差值趋于零（尺子量纸）</li>
<li>特点：精度高，延迟相较于SAR高</li>
</ul>
<h2 id="信号误差来源"><a href="#信号误差来源" class="headerlink" title="信号误差来源"></a>信号误差来源</h2><ul>
<li>电磁辐射 EMI</li>
<li>电路板设计缺陷</li>
<li>电源电压的变化</li>
<li>环境的变化</li>
<li>量化误差（内部）</li>
</ul>
<h1 id="SAR-A-x2F-D-Controller"><a href="#SAR-A-x2F-D-Controller" class="headerlink" title="SAR A/D Controller"></a>SAR A/D Controller</h1><p>该部分涉密不做具体说明</p>
<h2 id="逻辑框图"><a href="#逻辑框图" class="headerlink" title="逻辑框图"></a>逻辑框图</h2><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><ul>
<li><p>轮询Polling</p>
</li>
<li><p>中断Interrupt</p>
<p>使用中断方式采样完成后会自动进入中断服务函数。节约CPU资源</p>
</li>
<li><p>定时器触发</p>
</li>
<li><p>DMA</p>
</li>
</ul>
<h1 id="结果计算"><a href="#结果计算" class="headerlink" title="结果计算"></a>结果计算</h1><p>Vout = ADATA / ( 2 ^ Resolution) × Vref_ADC</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>ADC Clock Divide 寄存器分频系数计算公式x1600与x2000不一致</p>
</li>
<li><p>ADVDATn(0-3)寄存器读出结果后 AUXEN(0-3) 寄存器自动清零（但是如果将采样模式设置为重复采样模式则不会自动清零）</p>
</li>
<li><p>ADC 最终计算得到的结果可能是中间结果，需要对照原理图看是否有分压，进一步计算最终结果</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.ti.com/seclit/eb/slyw038c/slyw038c.pdf">模拟工程师口袋参考指南</a></li>
<li><a href="https://training.ti.com/ti-precision-labs-adcs">TI高精度实验室培训视频</a></li>
</ul>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Controller</category>
      </categories>
  </entry>
  <entry>
    <title>I2C</title>
    <url>/2023/07/01/Hardware/Protocol/I2C/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>I2C：Inter-Integrated Circuit，内部集成电路。作为一种广泛使用的串行通信协议，通过双线接口使多个电子设备能够彼此通信。它由飞利浦半导体（现在的恩智浦半导体）在上世纪80年代初开发，并且后来成为了业界事实上的标准。</p>
<p>BUS：总线。早期的计算机体积庞大，连线复杂，所有数据都通过实际的电缆传输，这变得非常混乱。把这些大捆的杂乱的电缆线，有序的布置在一个公共线排上，这些规则排列在一起的公共线束就是术语“总线”的早期来源，用BUS表示。在计算体系结构中， 总线（Bus）是计算机内部组件之间或计算机之间传送信息的公共通信干线，它是由导线组成的传输路径。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li><p><strong>工作模式</strong>：半双工，某一时刻要么发要么收</p>
</li>
<li><p><strong>总线接口</strong>：双线，串行数据线（SDA）、串行时钟线（SCL）</p>
</li>
<li><p><strong>寻址</strong>：总线上的每个设备都有唯一的地址，允许主设备与特定从设备通信。地址空间支持最多128个设备，但由于一些保留地址，可用范围会减少。</p>
</li>
<li><p><strong>设备功能</strong>：功能允许的情况下，每一个设备都可以做主设备或从设备（可收可发）</p>
</li>
<li><p><strong>同步通信</strong>：总线上的通信是同步的，意味着时钟信号由主设备产生，数据按位在数据线上与时钟同步传输</p>
</li>
<li><p><strong>位级确认</strong>：在发送每个字节的数据后，接收设备通过拉低数据线（SDA）来确认成功接收。如果没有收到确认，则表示发生错误。</p>
</li>
<li><p><strong>多主支持</strong>：支持多主通信，允许多个主设备同时存在于同一总线上。通过主设备仲裁机制，确定哪个主设备在任何时刻控制总线。</p>
</li>
<li><p><strong>传输速率</strong>：标准模式下可达 100kbit/s，快速模式下可达 400kbit/s， 高速模式下可达 3.4Mbit/s</p>
</li>
<li><p><strong>最大设备量</strong>：连接到相同总线的 IIC 数量只受到总线的最大电容 400pF 限制（128个唯一设备地址）</p>
</li>
<li><p><strong>其它</strong>：片上的滤波器可以滤去总线数据线上的毛刺波 保证数据完整</p>
</li>
</ul>
<h1 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h1><p><img src="/images/Hardware/Protocol/I2C/I2C-1.png" alt="image"></p>
<p>I2C协议采用主——从架构，其中一个设备（主设备）启动和控制通信，而一个或多个设备（从设备）响应主设备的命令。I2C使用的两根通信线是串行数据线（SDA）和串行时钟线（SCL）。总线空闲时，两条线路都是高电平。连接到总线的器件输出级必须是漏极开路或集电极开路才能执行线与的功能</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h2><p><img src="/images/Hardware/Protocol/I2C/I2C-2.png" alt="image"></p>
<p>SDA上的数据必须在SCL的高电平周期保持稳定，SDA高或低电平状态只有在 SCL 时钟信号是低电平时才能改变</p>
<h2 id="起始结束条件"><a href="#起始结束条件" class="headerlink" title="起始结束条件"></a>起始结束条件</h2><p><img src="/images/Hardware/Protocol/I2C/I2C-3.png" alt="image"></p>
<p>在5.1中对于数据有效性做了规范，时钟线高电平数据线不能动。因此对于起始和结束条件一定是在SCL高电平，具体是这样规定的：SCL高电平，SDA由高到低电平的切换表示开始传输；SCL高电平，SDA有低到高的电平切换表示传输结束。</p>
<p>起始结束条件一般是由主机产生，总线在起始条件后被认为处于忙（BUSY）的状态，在停止条件的某段时间后总线被认为再次处于空闲（IDLE）状态</p>
<h2 id="传输单元"><a href="#传输单元" class="headerlink" title="传输单元"></a>传输单元</h2><p> I2C总线上的主设备与从设备之间以字节(8位)为单位进行双向的数据传输，并且每个字节后面必须跟一个响应位。</p>
<h2 id="总线操作"><a href="#总线操作" class="headerlink" title="总线操作"></a>总线操作</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="/images/Hardware/Protocol/I2C/I2C-4.png" alt="image"></p>
<ul>
<li>起始条件</li>
<li>master将7位从设备地址 + 1位读写标志位 写到总线</li>
<li>从设备通过发送确认位 (ACK) 作为反馈来响应总线上存在具有正确地址的从设备并等待进一步通信的主设备</li>
<li>通信</li>
<li>结束条件</li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><p>master write to slave</p>
</li>
<li><p>master read from slave</p>
</li>
<li><p>读写方向交叉，重复传输（主设备往从设备中写数据，然后重启起始条件，紧接着从从设备中读取数据；或者是主设备从从设备中读数据，然后重启起始条件，紧接着主设备往从设备中写数据）</p>
<table>
<thead>
<tr>
<th>START</th>
<th>ADDR</th>
<th>R/W</th>
<th>ACK</th>
<th>DATA</th>
<th>ACK</th>
<th>START</th>
<th>ADDR</th>
<th>R/W</th>
<th>ACK</th>
<th>DATA</th>
<th>ACK</th>
<th>STOP</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>XX</td>
<td>XX</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>XX</td>
<td>XX</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="写入方式"><a href="#写入方式" class="headerlink" title="写入方式"></a>写入方式</h2><p>在I2C通信中，有两种常见的写入方式：字节写入（Byte Write）和页写入（Page Write）。具体使用哪种写入方式取决于从设备的支持和应用需求。有些从设备可能只支持字节写入，而有些设备可能支持页写入。在开发过程中，需要参考从设备的规格和文档，确定合适的写入方式。</p>
<h3 id="字节写入（Byte-Write）"><a href="#字节写入（Byte-Write）" class="headerlink" title="字节写入（Byte Write）"></a>字节写入（Byte Write）</h3><p>字节写入：字节写入是一种逐个字节写入数据的方式。在字节写入中，每个数据字节都会带有一个ACK（应答）信号，表示接收方正确接收了数据。主机发送一个字节后，等待从设备发送ACK信号，然后再发送下一个字节。这种方式适用于单个字节的数据传输或者在寄存器中写入单个字节的情况。</p>
<h3 id="页写入（Page-Write）"><a href="#页写入（Page-Write）" class="headerlink" title="页写入（Page Write）"></a>页写入（Page Write）</h3><p>页写入：页写入是一种批量写入数据的方式。在页写入中，主机可以连续写入多个字节的数据，而不需要每个字节都等待ACK信号。主机发送一系列字节后，等待从设备发送一个ACK信号，表示接收方正确接收了一组字节。这种方式可以提高写入数据的效率，尤其在写入大量数据时。</p>
<p>需要注意的是，对于页写入，有一个页的大小限制。页的大小是指从设备支持一次连续写入的最大字节数。超过页的大小进行写入操作可能会导致数据丢失或错误。因此，在使用页写入时，需要确保写入的数据量不超过从设备规定的页大小。</p>
<h1 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="开发注意事项"></a>开发注意事项</h1><ul>
<li>电平兼容性：确保I2C总线上的所有设备和主控制器的电平兼容。确认设备和主控制器使用相同的电源电压和电平标准（如3.3V、5V等），以避免电平不匹配导致的通信问题。</li>
<li>电源稳定性：提供稳定的电源供应给I2C设备，确保电源电压和电流满足设备的要求。电源的波动和噪声可能会对I2C通信产生干扰，导致通信错误或故障。</li>
<li>电缆长度和布线：I2C通信的可靠性与电缆长度和布线有关。确保电缆长度不超过I2C标准规定的最大长度，并避免电缆过长或扭曲的情况。同时，布线应避免与电源线、高频干扰源等信号相互干扰。</li>
<li>I2C地址冲突：I2C设备的地址应唯一，不得出现地址冲突。在设计时，仔细选择和分配每个I2C设备的地址，确保各设备地址不重复。</li>
<li>时钟频率选择：根据I2C设备的要求和总线长度，选择合适的时钟频率。过高的时钟频率可能导致信号失真或通信错误，而过低的时钟频率可能导致通信速度较慢。</li>
<li>错误处理和超时机制：在I2C通信中，可能会发生错误，如<strong>设备未响应、总线冲</strong>突等。在开发中，应实现适当的错误处理和超时机制，例如设置适当的超时时间和错误处理策略，以确保程序的鲁棒性和可靠性。</li>
<li>适当的延时：I2C通信需要一些延时以确保数据传输的稳定性。在编程时，根据具体设备的要求和I2C标准，适当添加延时以确保数据的正确传输。</li>
<li>电容限制：I2C总线上的电容负载应在规定范围内。过高的电容负载可能导致信号波形变形和传输错误。在设计中，需要根据I2C标准和设备规格表的要求，控制电容负载并添加必要的电容补偿。</li>
<li>适当的软件实现：编写I2C通信的软件实现时，需要确保正确地操作I2C控制器和设备的寄存器。遵循I2C通信的协议和流程，正确设置起始条件、地址、读写位和数据传输。</li>
</ul>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>从设备的设备地址是自定义的吗？</p>
<p>在大多数情况下，I2C设备的地址是由设备制造商提供的，并由开发人员在软件开发过程中进行配置和使用。一般来说，I2C设备的地址是一个7位的值，有时也可以是10位。7位地址模式下，地址范围是从0x00到0x7F，其中一些地址是保留地址或用于特定目的的预定义地址。</p>
</li>
<li><p>为什么I2C总线不能太长？</p>
<p>过长的总线长度可能会引起信号失真、时序问题以及通信错误。这是由于I2C总线使用的是开漏架构和电容负载的特性所决定的。</p>
<p>I2C总线的长度限制是由总线的电容负载和通信速率决定的。较长的总线长度会引入额外的电容负载，这会导致信号的上升和下降时间变慢，从而影响信号的稳定性和正确传输。此外，总线长度过长也会增加信号的传输延迟，导致时序问题。</p>
<p>根据I2C标准规范，对于标准模式（Standard Mode）的I2C总线，总线长度应在3-5米范围内。对于高速模式（High-Speed Mode）的I2C总线，总线长度则更短，通常不超过1米。</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://d1.amobbs.com/bbs_upload782111/files_24/ourdev_522629.pdf">周立功I2C总线规范</a></li>
<li><a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">I2C-bus specification and user manual</a></li>
<li><a href="https://www.analog.com/en/technical-articles/i2c-primer-what-is-i2c-part-1.html">I2C Primer: What is I2C? (Part 1)</a></li>
</ul>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>硬件传输协议</tag>
      </tags>
  </entry>
  <entry>
    <title>IIS</title>
    <url>/2023/04/05/Hardware/Protocol/IIS/</url>
    <content><![CDATA[<p>ADC将模拟信号转换为数字信号，而数字信号的音频数据则是按照一定标准（硬件传输协议）传入SOC中进行处理；同理DAC将数字信号转换为模拟信号，模拟信号的音频数据也是按照同样的标准将数据传输到喇叭进行声音的播放</p>
<h1 id="数字音频信号传输标准"><a href="#数字音频信号传输标准" class="headerlink" title="数字音频信号传输标准"></a>数字音频信号传输标准</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>数字音频信号传输标准也可以称作音频硬件传输协议，主要包括：</p>
<ul>
<li>I2S：Integrated Interchip Sound，集成电路内部音频</li>
<li>PCM：Pulse Code Modulation，脉冲编码调制</li>
<li>PDM：Pulse Density Modulation，脉冲密度调制</li>
<li>S/PDIF：Sony/Philips Digital Interface，索尼/飞利浦数字接口</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>PCM：单声道，时延小。打电话之间的数据；</p>
<p>I2S：双声道，速度快。主要用于传输音乐；</p>
<p>PDM：尺寸受限的场景。手机cpu到蓝牙的通话实时音频；</p>
<p>S/PDIF：用于板间长距离及需要电缆连接的场合</p>
<h1 id="I2S基础"><a href="#I2S基础" class="headerlink" title="I2S基础"></a>I2S基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>I2S(Inter-IC Sound)总线,  又称集成电路内置音频总线，是飞利浦半导体公司(现为恩智浦半导体公司)针对数字音频设备之间的音频数据传输而制定的一种总线标准。</p>
<p>该总线专门用于音频设备之间的数据传输，广泛应用于各种多媒体系统。</p>
<p>它采用了独立的导线传输时钟与数据信号的设计，通过将数据和时钟信号分离，避免了因时差诱发的失真，为用户节省了购买抵抗音频抖动的专业设备的费用。</p>
<h2 id="信号定义"><a href="#信号定义" class="headerlink" title="信号定义"></a>信号定义</h2><h3 id="WS"><a href="#WS" class="headerlink" title="WS"></a>WS</h3><p>WS：Word Select，左右声道选择信号（也称帧时钟 Left Right Clock）</p>
<p>标准I2S定义：WS=0，表示正在传输左声道的数据；WS=1，表示正在传输右声道的数据。</p>
<h3 id="SCK"><a href="#SCK" class="headerlink" title="SCK"></a>SCK</h3><p>SCK：Serial Clock，串行时钟信号（也称位时钟Bit Clock）</p>
<p>SCK是模块内的同步信号，从模式时由外部提供，主模式时由模块内部自己产生。对应数字音频的每一位数据，SCK都有一个脉冲。</p>
<h3 id="SD"><a href="#SD" class="headerlink" title="SD"></a>SD</h3><p>SD：Serial Data，串行数据信号（分时复用）</p>
<p>SD以二进制补码形式在数据线上传输，并且按照由高位(MSB)到低位(LSB)依次进行传输。之所以这样设计是为了保证重要的数据能够保存下来。因为发送设备和接收设备的字长可能不一样，如果接收设备接受的字长比规定的字长长的话就会产生截断，将超出字长部分忽略，相反如果接收设备接收的字长比规定字长短就会将空位补0。这样确保了最高有效位能够传输。</p>
<ul>
<li>LSB：Least Significant Bit，最低有效位</li>
<li>MSB：Most Significant Bit，最高有效位</li>
</ul>
<blockquote>
<p>发送器可以在时钟脉冲的前沿或后沿发送数据,，这可以在相应的控制寄存器中配置。但是接收器仅在时钟脉冲的前沿锁存串行数据和 WS。</p>
</blockquote>
<h3 id="MCLK"><a href="#MCLK" class="headerlink" title="MCLK"></a>MCLK</h3><p>除此之外，通常还有还有一个SYSCLK（MCLK），用于提供给音频功放工作时钟，通常是2/4/8倍的BCLK</p>
<h2 id="系统框图"><a href="#系统框图" class="headerlink" title="系统框图"></a>系统框图</h2><ul>
<li>只有一个主设备，并且SCK和WS信号一定是主设备产生</li>
<li>在复杂系统中，通常有多个发送器和接收器，此时通常有外部控制器进行控制</li>
</ul>
<p><img src="/images/Hardware/Protocol/i2s/I2S-1.png" alt="image"></p>
<h1 id="典型I2S时序图"><a href="#典型I2S时序图" class="headerlink" title="典型I2S时序图"></a>典型I2S时序图</h1><blockquote>
<p>说明：本部分的作图是以位宽为16bit为例进行说明</p>
<p>可以参考文章尾TI CODEC文中对于时序的描述</p>
</blockquote>
<p>随着技术的发展，I2S也出现了一些变种，但是换汤不换药协议核心是不变的。</p>
<p>根据SD相较于LRCLK的位置的不同分为三种模式：I2S格式（PHILIPS模式）、左对齐格式（较少使用）、右对齐格式（日本格式/SONY格式）</p>
<h2 id="共通特性"><a href="#共通特性" class="headerlink" title="共通特性"></a>共通特性</h2><ol>
<li><p>WS叫字选择，即每一个高低电平持续时间内传输的是一个字（32bit）的数据；</p>
</li>
<li><p>SCK叫位时钟，用于同步数据传输，波形为方波（对应WS一个周期最大有64个方波）</p>
</li>
<li><p>WS的频率等于采样频率。假设采样频率44.1khz，即1秒内有44100采样点（44100个周期）</p>
</li>
<li><p>SCK的频率 = 声道数 * 采样频率 * 采样位数。</p>
</li>
</ol>
<h2 id="I2S格式"><a href="#I2S格式" class="headerlink" title="I2S格式"></a>I2S格式</h2><ul>
<li><p>左声道的MSB在字时钟下降沿后的第二个位时钟上升沿有效。 同样，右声道的MSB在字时钟上升沿后的第二个位时钟上升沿有效</p>
</li>
<li><p>SCK延迟一个时钟位开始传输数据（为接收器提供了时间来存储已经接收的字，并清除下一个字的输入寄存器）</p>
</li>
</ul>
<p><img src="/images/Hardware/Protocol/i2s/I2S-2.png" alt="image"></p>
<h2 id="左对齐"><a href="#左对齐" class="headerlink" title="左对齐"></a>左对齐</h2><ul>
<li>左对齐模式下，右声道的 MSB 在字时钟下降沿之后的位时钟上升沿有效。 同样，左声道的MSB在字时钟上升沿之后的位时钟上升沿有效</li>
</ul>
<p><img src="/images/Hardware/Protocol/i2s/I2S-3.png" alt="image"></p>
<h2 id="右对齐"><a href="#右对齐" class="headerlink" title="右对齐"></a>右对齐</h2><ul>
<li><p>右对齐模式，左声道的 LSB 在字时钟下降沿之前的位时钟上升沿有效。 同样，右声道的 LSB 在字时钟上升沿之前的位时钟上升沿有效。</p>
</li>
<li><p>接收设备必须事先知道待传数据的字长</p>
</li>
</ul>
<p><img src="/images/Hardware/Protocol/i2s/I2S-4.png" alt="image"></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li><p>发送端和接收端的数据格式要一致，同为左对齐、右对齐或I2S格式</p>
</li>
<li><p>标准左对齐和标准右对齐模式的LRCK/WS高低电平对应的左右声道与标准I2S模式的规定相反。I2S：0：L，1：R；左对齐/右对齐：0：R，1：L；</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://users.ece.utexas.edu/~bevans/courses/realtime/lectures/10_Data_Conversion/AP_Understanding_PDM_Digital_Audio.pdf">Understanding PDM Digital Audio</a> </li>
<li><a href="https://www.sparkfun.com/datasheets/BreakoutBoards/I2SBUS.pdf">I2S Bus Specification</a></li>
<li><a href="https://www.elprocus.com/i2s-protocol/">I2S Protocol : Working, Differences &amp; Its Applications</a></li>
<li><a href="https://www.crifan.com/common_audio_interface_tdm_pdm_i2s_pcm/">音频接口：TDM，PDM，I2S，PCM 简介</a></li>
<li><a href="https://www.ti.com.cn/cn/lit/ds/symlink/tlv320aic31.pdf">TI CODEC手册</a></li>
</ul>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>硬件传输协议</tag>
      </tags>
  </entry>
  <entry>
    <title>SDIO</title>
    <url>/2024/05/01/Hardware/Protocol/SDIO/</url>
    <content><![CDATA[<blockquote>
<p>本次文档基于 <a href="https://www.sdcard.org/downloads/pls/pdf/?p=PartE1_SDIO_Simplified_Specification_Ver3.00.jpg&amp;f=PartE1_SDIO_Simplified_Specification_Ver3.00.pdf&amp;e=EN_SSE1">SDIO Simplified Specification Version 3.00</a> 进行学习记录</p>
</blockquote>
<h1 id="SDIO卡描述"><a href="#SDIO卡描述" class="headerlink" title="SDIO卡描述"></a>SDIO卡描述</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>SDIO卡。可插拔设备，SPI模式在SDIO卡中是强制的，但并非所有功能在SPI模式下可用</li>
<li>嵌入式SDIO。不可插拔设备，焊接在电路板上。SPI模式在嵌入式SDIO设备中是可选的。并非所有的功能都可以在SPI模式下可用。</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li>全速SDIO卡。支持SPI、1bitSD和4位bitSD传输模式，数据传输速率超过100Mb/秒（10MB/秒）</li>
<li>低速SDIO卡。支持SPI和1bitSD传输模式，4bit的支持可选，支持0-400 KHz的全时钟范围</li>
</ul>
<p>如果一个卡是一个“组合卡”（内存加上SDIO），那么对卡的内存和SDIO部分都是全速和4位操作是必须的。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><ul>
<li><p>SPI</p>
</li>
<li><p>1-bit。data[0]、CLK、CMD</p>
</li>
<li><p>4-bit。data[3:0]、CLK、CMD</p>
</li>
</ul>
<h1 id="CIA"><a href="#CIA" class="headerlink" title="CIA"></a>CIA</h1><p><img src="/images/Hardware/Protocol/sdio/sdio_internal.png" alt="image"></p>
<p>CIA（Common I/O Area）通用IO区域，是所有SDIO卡都要支持的一个固定的公共端口区域。它包含三部分：CCCR (Card Common Control Registers)， FBR (Function Basic Registers) 和 CIS (Card Information Structure) ，这三部分的功能决定的CIA的功能，主机端通过读写Func0对CIA区域寄存器进行相关操作。</p>
<h2 id="CCCR"><a href="#CCCR" class="headerlink" title="CCCR"></a>CCCR</h2><p>CCCR （Card Common Control Registers）卡通用控制寄存器（Page-43）。主机端通过CMD52命令Func0对CCCR寄存器组进行读写，完成对SDIO卡的信息检查和状态操作，CCCR 地址为 0x000000-0x0000FF 。以下是相关寄存器列表，具体说明可参考手册</p>
<p><img src="/images/Hardware/Protocol/sdio/sdio_cccr.png" alt="image"></p>
<ul>
<li>00H。分别定义了CCCR/FBR格式版本 和 该卡所遵循的SDIO spec版本</li>
<li>01H。定义了SD格式版本号（物理层规范）</li>
<li>02H - 03H。定义了所要使能的Func号和是否使能成功的标志位</li>
<li>06H。如果需要软件复位SDIO需要写RES比特</li>
<li>08H。定义了一些SDIO卡的功能范围，是否支持中断， 是否支持热插拔等<ul>
<li>SDC：是否支持CMD52</li>
<li>SMB：是否支持CMD53</li>
<li>LSC：定义卡的速率类型（低速卡 / 高速卡）</li>
<li>4BLS：如果是低速卡（LSC=1前提），是否支持4Bit传输</li>
</ul>
</li>
<li>09H - 0BH。通用CIS的指针，可以通过这个指针找到公共CIS区域</li>
</ul>
<h2 id="FBR"><a href="#FBR" class="headerlink" title="FBR"></a>FBR</h2><p>FBR (Function Basic Registers) 功能基本寄存器（Page-53）。 每个支持的I/O功能都有一个256字节的区域，用于允许主机快速确定每个功能的能力和要求，为每个功能启用电源选择，并启用软件加载。该区域的地址为从0x00n00h到0x00nFFh（其中 n 为功能端口号 1-7）。</p>
<p><img src="/images/Hardware/Protocol/sdio/sdio_fbr.png" alt="image"></p>
<ul>
<li>n00H  - n01H。每个功能支持的接口类型</li>
<li>n09H - n0BH。各端口功能的 CIS 指针，指向各功能端口的 CIS</li>
<li>n10H - n11H。设置每个Func I/O操作块的大小</li>
</ul>
<p>(其中 n是功能端口号1-7)</p>
<h2 id="CIS"><a href="#CIS" class="headerlink" title="CIS"></a>CIS</h2><p>CIS (Card Information Structure) ，卡信息结构（Page-72）。CIS 存储关于SDIO卡的信息和配置，地址为 0x001000-0x017FFF。需要注意的是CIS分成公共CIS和各自Func的CIS，公共的CIS地址存储在CCCR的09H - 0BH地址区域，每个func的CIS地址存储在FBR的n09H - n11H地址区域</p>
<p>CIS 中的信息是以 TUPLE 为单位的， TUPLE 的格式如下：tuple code + next tuple address + context</p>
<p><img src="/images/Hardware/Protocol/sdio/sdio_cis.png" alt="image"></p>
<ul>
<li>00H。指示这个Tuple的功能</li>
<li>01H。下一个Tuple的地址</li>
<li>02H - (2+n)。Tuple的实际内容，软件结合tuple code和这个内容解析配置</li>
</ul>
<h3 id="Tuple-Code"><a href="#Tuple-Code" class="headerlink" title="Tuple Code"></a>Tuple Code</h3><p><img src="/images/Hardware/Protocol/sdio/sdio_cis_code.png" alt="image"></p>
<ul>
<li>CISTPL_MANFID：制造商标识字符串元组</li>
<li>CISTPL_FUNCE：函数扩展元组。这个为CIS提供了FUNC类型的扩展识别码，可以进一步通过新的协议内容判断是针对哪一个func的信息，其中下一个识别码如果是0x00代表通用func的信息，0x01代表特定的func的信息（具体参照Page-75）</li>
</ul>
<p>需要注意的在驱动代码中，当解析特定Func的CIS区域时，主要是将每个func的max block size（0EH - 0FH）和enable func timeout（1EH - 1FH）取出来，具体参考Page-76</p>
<h1 id="CSA"><a href="#CSA" class="headerlink" title="CSA"></a>CSA</h1><p>为了支持SDIO卡的“即插即用”的概念，卡中包含的每个功能可能需要包含一块内存，用于存储驱动程序和/或应用程序。此外，由于相同的SDIO卡可以在多个不同的主机平台上使用，因此每个功能可能需要几个不同版本的代码。一种选择是将这些程序存储在组合卡的标准SD内存部分。另外，在可选的代码存储区（CSA）中还包含了一种加载代码的标准访问手段。CSA是一个单独的16MB内存区域，可以使用CSA地址指针和包含在FBR寄存器中的CSA窗口寄存器进行访问。请注意，每个函数可能都有自己的CSA来支持它。CSA数据可以是只读的或R/W的。CSA的实际存储方法不是本规范的一部分，而留给实现者</p>
<p>为了让主机访问一个函数的CSA，它首先要确定该函数是否支持一个CSA。主机读取地址为00n00h的FBR寄存器，其中n是函数号（1到7）。如果位6=1，则该函数支持CSA，并且主机通过写入位7=1来启用访问。下一步是让主机加载24位地址以开始读取或写。这是通过将24位（A23-0）写入寄存器00n0Ch到00n0Eh来实现的，其中n是函数数（1到7）。一旦写入了起始地址，就可以通过访问CSA数据窗口寄存器00n0Fh来读取或写入数据。如果需要读取或写入多个字节，则可以使用OP代码0（固定地址）执行扩展I/O命令（字节或块）。地址指针应随着对窗口寄存器的每次访问而自动增加，因此访问将是对CSA内的顺序地址。操作完成后，NEXT操作的地址应保存在24位地址寄存器中，以便主机读取。</p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>对于这些所有CMD有些位是固定的，具体到每一个不再具体阐述</p>
<ul>
<li><p>S（start bit）：开始位。始终为0</p>
</li>
<li><p>D（direction）：方向。1表示从主机转移到卡。0指示从卡到主机的传输。</p>
</li>
<li><p>Command Index：命令索引。是哪一个CMD正好对应6bit二进制数</p>
</li>
<li><p>CRC7：7位CRC校验数据</p>
</li>
<li><p>E（end bit）：结束位。总是1</p>
</li>
</ul>
<h2 id="CMD5（IO-SEND-OP-COND）"><a href="#CMD5（IO-SEND-OP-COND）" class="headerlink" title="CMD5（IO_SEND_OP_COND）"></a>CMD5（IO_SEND_OP_COND）</h2><p>CMD5对SDIO卡的功能类似于ACMD41对SD存储卡的操作。它用于查询I/O板卡所需的电压范围。对CMD5的正常反应是SD或SPI格式的R4。</p>
<p><img src="/images/Hardware/Protocol/sdio/sdio_cmd5.png" alt="image"></p>
<ul>
<li>Stuff Bits：内容位。未使用，应设置为0。</li>
<li>S18R：切换到1.8V请求（Switch 1v8 Request）</li>
<li>I/O OCR：操作条件寄存器。为VDD提供受支持的最小值和最大值。（参考Page-23 Table3-1）</li>
</ul>
<h2 id="R4（IO-SEND-OP-COND-Response）"><a href="#R4（IO-SEND-OP-COND-Response）" class="headerlink" title="R4（IO_SEND_OP_COND Response）"></a>R4（IO_SEND_OP_COND Response）</h2><p><img src="/images/Hardware/Protocol/sdio/sdio_r4.png" alt="image"></p>
<ul>
<li>C：如果卡初始化后准备操作，则设置为1</li>
<li>I/O function个数：表示此卡支持的I/O功能总数。该范围为0-7。其中功能0处所有I/O卡上的公共区域不包括在此计数中。输入/输出功能应从功能1开始按顺序实现。</li>
<li>内存是否存在：如果包含SD内存，则设置为1。如果仅为I/O，则设置为0。</li>
<li>S18A：切换到1.8V已接受（仅支持SD模式）</li>
<li>I/O OCR：操作条件寄存器。为VDD提供受支持的最小值和最大值。</li>
</ul>
<h2 id="CMD52（IO-RW-DIRECT）"><a href="#CMD52（IO-RW-DIRECT）" class="headerlink" title="CMD52（IO_RW_DIRECT）"></a>CMD52（IO_RW_DIRECT）</h2><p>IO_RW_DIRECT是访问任何I/O函数中总共128K的寄存器空间中的单个寄存器的最简单的方法，包括公共I/O区域（CIA）。此命令仅使用1个命令/响应对来读取或写出1个字节。常用的是初始化I/O功能的寄存器或监视状态值。此命令是读取或写入单个I/O寄存器的最快方法，因为它只需要单个命令/响应对（Page-35）</p>
<p><img src="/images/Hardware/Protocol/sdio/sdio_cmd52.png" alt="image"></p>
<ul>
<li>R/W标志：此位确定I/O操作的方向。如果该位为0，则该命令将从SDIO卡的函数号和寄存器地址指定的地址读取数据到主机，数据字节在响应R5中返回；如果此位设置为1，则该命令应将写入数据字段中的字节写入由函数编号和寄存器地址寻址的I/O位置。如果RAW标志为0，则应读取被写入的寄存器中的数据，并在响应中返回该值。</li>
<li>RAW标志：写后的标志。如果该位设置为1，而R/W标志设置为1，则该命令应在写入后读取寄存器的值。这对于允许写入控制寄存器并在同一地址读取状态非常有用。如果清除此位，则R5响应中返回的值应与命令中的写入数据相同。如果设置该位，R5响应的数据字段</li>
<li>功能编号：您希望读取或写出的I/O卡内的功能编号。函数0会选择公共I/O区域（CIA）。</li>
<li>寄存器地址：这是要读取或写的选定函数内的数据字节的地址。有17位可用的地址，因此寄存器位于该函数的前128K（131072）地址内。</li>
<li>写入数据/内容位：对于直接写入命令（R/W=1），这是写入所选地址的字节。对于直接读取（R/W=0），不使用此字段，且应设置为0。</li>
</ul>
<h2 id="R5（IO-RW-DIRECT-Response）"><a href="#R5（IO-RW-DIRECT-Response）" class="headerlink" title="R5（IO_RW_DIRECT Response）"></a>R5（IO_RW_DIRECT Response）</h2><p><img src="/images/Hardware/Protocol/sdio/sdio_r5.png" alt="image"></p>
<ul>
<li>stuff bits：未使用，应设置为0</li>
<li>响应标志：8位标志数据表示SDIO卡的状态</li>
<li>读取或写入数据：对于具有RAW标志集（RAW=1）的I/O写入（R/W=1），该字段应包含在命令中包含的数据写入后从寻址寄存器读取的值。注意，在这种情况下，读取数据可能与写入寄存器的数据不相同，这取决于硬件的设计。对于使用RAW位=0的I/O写，SDIO函数不得进行逐读操作，该字段中的数据应与写命令中的数据字节相同。对于I/O读取（R/W=0），此处将返回从I/O位置读取的实际值。</li>
</ul>
<h2 id="CMD53（IO-RW-EXTENDED）"><a href="#CMD53（IO-RW-EXTENDED）" class="headerlink" title="CMD53（IO_RW_EXTENDED）"></a>CMD53（IO_RW_EXTENDED）</h2><p>此命令允许使用一个命令读取或写入大量I/O寄存器。由于这是一个数据传输命令，因此它提供了最高可能的传输速率（Page-38）</p>
<p><img src="/images/Hardware/Protocol/sdio/sdio_cmd53.png" alt="image"></p>
<ul>
<li><p>收发标志：此位确定I/O操作的方向。如果此位为0，则该命令将从SDIO卡的函数号和注册地址指定的地址读取数据到主机。读取的数据应在DAT行上返回。如果此位设置为1，则该命令应将DAT[x]行中的字节写入由函数号和寄存器地址寻址的I/O位置。</p>
</li>
<li><p>功能编号：您希望读取或写出的I/O卡内的功能编号。注意，函数00h选择公共I/O区域（CIA）。</p>
</li>
<li><p>块模式（可选）：此位如果设置为1，则表示读取或写操作应按块执行，而不是按普通字节执行。如果设置了此位，则字节/块计数值应包含要读/写的块数。函数1-7的块大小是通过将块大小写入FBR中的I/O块大小寄存器来设置的（请参见表6-3和表6-4)。函数0的块大小是通过写入CCCR中的FN0块大小寄存器来设置的。</p>
</li>
<li><p>操作码：定义读/写操作。0代表固定地址读写，1代表自增地址读写</p>
</li>
<li><p>寄存器地址：要读取或写的I/O注册器的起始地址。范围为[1 FFFF h：0]</p>
</li>
<li><p>字节/块计数：要读或写的字节/块数</p>
</li>
</ul>
<h1 id="SDIO卡初始化序列"><a href="#SDIO卡初始化序列" class="headerlink" title="SDIO卡初始化序列"></a>SDIO卡初始化序列</h1><h2 id="通过非I-x2F-O感知主机进行的初始化"><a href="#通过非I-x2F-O感知主机进行的初始化" class="headerlink" title="通过非I/O感知主机进行的初始化"></a>通过非I/O感知主机进行的初始化</h2><p>当SDIO卡插入的时候，不能使主机发生故障。CMD5（IO_SEND_OP_COND）代替ACMD41</p>
<p>复位或上电后，卡上的所有I/O功能都被禁用，卡上的I/O部分不得执行除CMD5或CMD0以外的任何操作。如果卡上有SD内存（也称为组合卡），则该内存应对所有强制内存命令进行正常响应。</p>
<h2 id="通过I-x2F-O感知主机进行初始化"><a href="#通过I-x2F-O感知主机进行初始化" class="headerlink" title="通过I/O感知主机进行初始化"></a>通过I/O感知主机进行初始化</h2><ol>
<li><p>初始化IO。I/O部分保持不活动状态直至接收到CMD5。主机发送CMD5，卡以R4响应。通过R4主机知道可用的I/O函数的数量，以及是否有内存</p>
</li>
<li><p>读取CIA（公共信息区）。这是通过发出I/O函数0的地址00h的字节开始的读命令来实现的。CIA包含卡公共控制寄存器（CCCR）和功能基本寄存器（FBR）。还包括指向卡的公共卡信息结构（CIS）和每个单独函数的CIS的指针。CIS包括有关电源、功能、制造商和主机需要确定I/O功能是否适合通电的其他信息。如果主机确定应该激活卡，则CCCR区域的寄存器将启用卡和每个单独的功能。此时，I/O板卡的所有功能都已全部可用。此外，主机还可以逐个功能地控制功耗和启用/禁用中断。如果存在的I/O访问不会干扰对卡的内存访问。</p>
</li>
</ol>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><ul>
<li><p>int sdio_enable_func / sdio_disable_func (struct sdio_func *func)</p>
<p>使能/失能特定的Func。通过CMD52操作CCCR-02H，等CCCR-03H ready返回，否则超时；失能不需要等完成</p>
</li>
<li><p>int sdio_set_block_size(struct sdio_func *func, unsigned blksz)</p>
<p>设置特定Func的block size。通过CMD52操作CCCR - 10H~11H</p>
</li>
<li><p>sdio_readb / sdio_writeb<br>读取/写入特定的Func中的register address的1个byte的内容。CMD52实现</p>
</li>
<li><p>sdio_memcpy_fromio / sdio_memcpy_toio<br>采用增量的方式从特定的Func，register address读取/写入内容CMD53实现</p>
</li>
</ul>
<p>其它还有一些读写IO的相关函数，其中如果是对Func0进行操作一般都是通过CMD52实现，通用函数的多字节读写都是通过CMD53实现，在此不进行描述</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/lowkeyway/Embedded/blob/master/Hardware/Hardware%20Interface/SDIO.md">Github - SDIO</a><br><a href="https://www.sdcard.org/downloads/pls/pdf/?p=PartE1_SDIO_Simplified_Specification_Ver3.00.jpg&amp;f=PartE1_SDIO_Simplified_Specification_Ver3.00.pdf&amp;e=EN_SSE1">SDIO Simplified Specification Version 3.00</a></p>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>硬件传输协议</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA</title>
    <url>/2024/02/24/Hardware/Controller/DMA/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>DMA：Direct Memory Access，直接内存访问。</p>
<p>DMA是计算机系统中一种数据传输的技术，允许将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输，而整个过程不需要CPU的直接干预。用户需要做的是根据实际需求，配置DMA控制器，一旦使能控制器数据将自动根据配置进行传输。解放出来的CPU可以去做其它的事情，极大的提高了效率。需要注意的是DMA只是不再占用CPU，但仍需要占用总线</p>
<h1 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h1><h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><ul>
<li><p>Burst Mode</p>
<p>Burst传输，可以翻译为突发传输或者是连续传输。是指在同一行中相邻的存储单元连续进行数据传输的方式，只要指定起始地址和突发长度（Burst lengths，可以理解为跨度），控制器就会依次自动对后面相同数量的存储单元进行读/写操作，而不需要控制器连续提供列地址。DMA仅在完成整个数据传输后将总线移交给CPU。同时，如果 CPU 需要总线，它必须保持IDLE并等待数据传输。</p>
</li>
<li><p>Cycle Stealing Mode</p>
<p>单字节传输。DMA 在传输每个字节后将总线的控制权交给 CPU。它不断发出总线控制请求，传输一个字节并返回总线。这样一来，如果 CPU 需要总线来执行更高优先级的任务，则不必等待很长时间。</p>
</li>
<li><p>Transparent Mode</p>
<p>DMA 仅在 CPU 执行不需要使用总线的指令时传输数据。该模式传输数据块所需的时间最多，但就整体系统性能而言，它也是最有效的模式。 DMA 传输在时间上是自由的，而缺点是硬件需要确定 CPU 何时不使用系统总线比较复杂。</p>
</li>
</ul>
<h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>DMA传输的本质就是实现数据从一个内存区域到另一个内存区域的拷贝，主要包含四种情况：外设到内存；内存到外设；内存到内存；外设到外设。</p>
<h2 id="传输结构"><a href="#传输结构" class="headerlink" title="传输结构"></a>传输结构</h2><h3 id="寄存器模式"><a href="#寄存器模式" class="headerlink" title="寄存器模式"></a>寄存器模式</h3><p>处理器直接对DMA控制寄存器进⾏编程来启动传输。在寄存器模式下⼜分为两种⼦模式组成：⾃动缓存模式和停⽌模式。</p>
<p>在⾃动缓存模式中，当⼀个传输块传输完毕，控制寄存器就⾃动重新载⼊其最初的设定值，同⼀个DMA进程重新启动。这构成了⼀个“循环缓冲器”，因为当⼀个值被写⼊到缓冲器的最后⼀个位置上时，下⼀个值将被写⼊到缓冲器的第⼀个位置上。⾃动缓冲 DMA 使⽤场景：对性能敏感的、存在持续数据流的应⽤。DMA控制器可以在独⽴于处理器其他活动的情况下读⼊数据流，然后在每次传输结束时，发出中断。</p>
<p>停⽌模式 DMA 与⾃动缓冲型类似，区别在于各寄存器在DMA结束后不会重新载⼊，因此整个DMA传输只发⽣⼀次。使⽤场景：⾮定期地将数据块从⼀个位置转移到另⼀个位置、某些事务的⼀次性传输。</p>
<h3 id="描述符模式"><a href="#描述符模式" class="headerlink" title="描述符模式"></a>描述符模式</h3><p>基于描述符的 DMA 要求DMA 通道需要⼀组称为 DMA 描述符的参数，该参数存储在存储器中。每个描述符包含特定 DMA 传送序列所需要的所有信息，⽐如 数据块的起始地址、传送的数据量、其他各种控制信息、指向下⼀个描述符的指针。</p>
<p>该模式可以更好的减少中断的产生，因为可以配置一个descriptor链，按照链上的顺序进行传输（4+1+2+x+x）</p>
<h2 id="传输流程"><a href="#传输流程" class="headerlink" title="传输流程"></a>传输流程</h2><p><img src="/images/Hardware/Controller/dma-0.jpg" alt="image"></p>
<p>cpu通过配置DMA各个寄存器，使其具有相应的功能 ； DMA通过总线从device中取出数据，在通过特有的DMA通道传输给DDR</p>
<h1 id="DMA系统框图（STM32）"><a href="#DMA系统框图（STM32）" class="headerlink" title="DMA系统框图（STM32）"></a>DMA系统框图（STM32）</h1><p><img src="/images/Hardware/Controller/dma-1.png" alt="image"></p>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><ol>
<li><p>配置数据传输的源和目标地址</p>
</li>
<li><p>配置传输数量</p>
</li>
<li><p>配置数据位宽（8bit / 16bit / 32bit）</p>
</li>
<li><p>配置功能：数据传输方向、循环模式以及源和目标地址是否自增</p>
</li>
<li><p>配置中断（全部完成 / 完成一半 或其它所支持的方式）</p>
</li>
<li><p>使能DMA</p>
</li>
</ol>
<h2 id="请求及响应流程"><a href="#请求及响应流程" class="headerlink" title="请求及响应流程"></a>请求及响应流程</h2><ol>
<li>（外设-&gt;DMA控制器）请求DRQ（DMA Request）。当设备需要通过DMA通道传输数据，首先外设需要向DMA控制器发送DMA请求。</li>
<li>（DMA控制器-&gt;CPU）保持请求 HRQ（Hold Request）。DMA 控制器向 CPU 发送保持请求 并等待 CPU 断言 HLDA 信号。</li>
<li>（CPU-&gt;DMA控制器）保持确认 HLDA（Hold Acknowledgment）。CPU所有数据总线、地址总线和控制总线三态化并释放总线控制权，回复HLDA 信号允许DMA控制器接管总线</li>
<li>（DMA控制器-&gt;外设）回复DACK（DMA Acknowledgment）。DMA控制器向发出DRQ信号的外设的回应，表示收到请求和正在进行处理。</li>
</ol>
<h1 id="注意事项（重要）"><a href="#注意事项（重要）" class="headerlink" title="注意事项（重要）"></a>注意事项（重要）</h1><ol>
<li><strong>DMA需要使用物理地址</strong>。因为编程使用的是虚拟地址，所以配置DMA时必须将虚拟地址转化成物理地址</li>
<li><strong>DMA启动前刷Cache</strong>。因为程序使用虚拟地址，而且一般使用Cached地址，所以虚拟地址中的内容与其物理地址上的内容不一定一致，所以在启动DMA传输前一定要将该地址的Cache刷新，即写入主存。</li>
<li><strong>地址对齐且尽量一次申请一大块内存保证连续</strong>。由于系统产时间使用之后可能产生内存碎片，申请到的空间可能不连续导致错误，如果不连续就需要把这段内存分成几段让DMA完成传输</li>
<li><strong>性能瓶颈</strong>。对于DMA控制器来讲，通常有多个通道可以配置，不同的通道可以并发传输。虽然多通道可以同时工作但是总线只有一条，因此在特定时刻实际只有一个通道能在总线上传输数据。不同的MCU对于DMA通道传输的调度策略有所不同，可能是先到先调度、也可能是基于channel的优先级进行调度</li>
<li>某些设备内部可能有自己的<strong>专用DMA</strong>，硬件上与通用DMA是一致的，但是在速度、可靠性上有所提高。通用DMA：burst可能更小一些；专用DMA：burst可以传输的更大一些 。DMA尽量按照最大数据量进行传输（某些设备除外，串口可能就是按照1byte传输），但是对于5byte可以按照 4 +1  的方式传输</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.davuniversity.org/images/files/study-material/DMA%20Controller.pdf">DMA</a></li>
<li><a href="https://www.eet-china.com/mp/a167316.html">DMA原理，步骤超细详解，一文看懂DMA</a></li>
<li><a href="https://blog.csdn.net/imred/article/details/50357819">DMA中的四种控制信号：DRQ、DACK、HRQ、HLDA</a></li>
<li><a href="https://xuanxuanblingbling.github.io/assets/attachment/stm32/STM32%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8CV10.pdf">STM32中文手册</a></li>
</ol>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Controller</category>
      </categories>
  </entry>
  <entry>
    <title>MIPI &amp;&amp; D-PHY</title>
    <url>/2023/05/30/Hardware/Protocol/mipi_dphy/</url>
    <content><![CDATA[<h1 id="MIPI基础"><a href="#MIPI基础" class="headerlink" title="MIPI基础"></a>MIPI基础</h1><p><img src="/images/Hardware/Protocol/mipi/mipi-1.png" alt="image"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>含义：MIPI（Mobile Industry Processor Interface）移动行业处理器接口</li>
<li>MIPI联盟：一家开放的会员制组织，2003年7月，由TI、ST、ARM、Nokia四家公司共同成立。</li>
<li>MIPI协议：MIPI协议本质是多个协议族，随着MIPI的规范的不断的更新改进，目前较为成熟的接口包括摄像头接口CSI、显示接口DSI，而对于其中每一种又分别在物理层和协议层做出了相应的规范。该协议最初制定目的是把手机内部各种接口（显示屏、摄像头、射频等）标准化，减少手机设计的复杂度和增加设计的灵活性。</li>
</ul>
<h2 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h2><ul>
<li><p>DCS：Display Command Set，显示命令集合。用于显示模块命令模式下的标准化命令集</p>
</li>
<li><p>DBI：Display Bus Interface，显示总线接口。与具有显示控制器和帧缓冲器的显示模块的并行接口</p>
</li>
<li><p>DPI：Display Pixel Interface，显示像素接口。与显示模块的并行接口，不带显示控制器或帧缓冲器</p>
</li>
<li><p>DSI：Display Serial Interface，显示串行接口。主机处理器与显示模块之间的高速串行接口</p>
</li>
<li><p>CSI：Camera Serial Interface，相机串行接口。主机处理器与摄像头模块之间的高速串行接口</p>
</li>
<li><p>PHY：Physical，物理层。物理层规范了传输介质、电气特性、IO电路、和同步机制。通俗地说，就是指定物理层构建的规则，比如指定如何拿到数据、怎样编码、转化成怎样的电信号、通过多少根/组通道送出去等等。</p>
<ul>
<li>C-PHY：100Mbits/s，C是罗马数字（拉丁文数字）中100 </li>
<li>D-PHY： 500Mbits/s，D是罗马数字（拉丁文数字）中500 </li>
<li>M-PHY：1000Mbits/s，M是罗马数字（拉丁文数字）中1000</li>
</ul>
</li>
<li><p>APPI：Abstracted PHY-Protocol Interface，抽象物理协议接口</p>
</li>
<li><p>PPI：PHY-Protocol Interface， 物理协议接口</p>
</li>
<li><p>SoT：Start of Transmission，传输开始</p>
</li>
<li><p>EoT：End of Transmission，传输结束</p>
</li>
</ul>
<h2 id="MIPI层次"><a href="#MIPI层次" class="headerlink" title="MIPI层次"></a>MIPI层次</h2><blockquote>
<p>本部分文字说明均来自官方文档说明</p>
</blockquote>
<p><img src="/images/Hardware/Protocol/mipi/mipi-2.png" alt="image"></p>
<h3 id="DSI"><a href="#DSI" class="headerlink" title="DSI"></a>DSI</h3><ul>
<li><p>PHY layer</p>
<p>PHY 层指定传输介质（电导体）、输入/输出电路和从串行比特流中捕获“1”和“0”的时钟机制。 规范的这一部分记录了传输介质的特性、信号的电气参数以及时钟和数据通道之间的时序关系。</p>
<p>传输开始 (SoT) 和传输结束 (EoT) 的信令机制以及可以在传输和接收 PHY 之间传送的其他“带外”信息被指定。 位级和字节级同步机制作为 PHY 的一部分包含在内。</p>
</li>
<li><p>Lane Management Layer</p>
<p>DSI 通过通道扩展以提高性能。 根据应用的带宽要求，数据信号的数量可以是 1、2、3 或 4。 接口的发送端将输出数据流分配到一个或多个通道（“分配器”功能）。 在接收端，接口从通道收集字节并将它们合并到一个重新组合的数据流中，恢复原始流序列（“合并”功能）。</p>
</li>
<li><p>Protocol Layer</p>
<p>在最低级别，DSI 协议规定了通过接口的位和字节的顺序和值。 它指定如何将字节组织成称为数据包的定义组。 该协议定义了每个数据包所需的标头，以及如何生成和解释标头信息。 接口的发送端将报头和错误检查信息附加到正在发送的数据上。 在接收方，标头被剥离并由接收方中的相应逻辑解释。 错误检查信息可用于测试传入数据的完整性。 DSI 协议还记录了如何标记数据包以使用单个 DSI 将多个命令或数据流交织到不同的目的地。</p>
</li>
<li><p>App Layer</p>
<p>该层描述了数据流中包含的数据的更高级别的编码和解释。 根据显示子系统架构，它可能包含具有规定格式的像素，或由显示模块内的显示控制器解释的命令。 DSI 规范描述了像素值、命令和命令参数到数据包组件中字节的映射。 （DCS specification文档）</p>
</li>
</ul>
<h3 id="CSI-2"><a href="#CSI-2" class="headerlink" title="CSI-2"></a>CSI-2</h3><ul>
<li><p>PHY layer：同DSI</p>
</li>
<li><p>Protocol Layer：指定如何标记和交错多个数据流，以便可以正确地重建每个数据流。</p>
<ul>
<li>像素/字节打包/解包层（Pixel/Byte Packing/Unpacking Layer）</li>
</ul>
<p>  CSI-2 支持具有从每像素 6 到 24 位的不同像素格式的图像应用程序。 在发送器中，该层在将数据发送到低级协议层之前将来自应用层的像素打包成字节。 在接收器中，该层在将数据发送到应用层之前将来自低级协议层的字节解压缩为像素。 该层以不变的方式传输每像素八位数据。</p>
<ul>
<li>低级协议层（Low Level Protocol）</li>
</ul>
<p>  低级协议 (LLP) 包括为 SoT（传输开始）和 EoT（传输结束）事件之间传输的串行数据建立 bit508 级和字节级同步以及将数据传递到下一层的方法。 LLP 的最小数据粒度是一个字节。 LLP 还包括字节内位值解释的分配，即“Endian”分配。</p>
<ul>
<li>通道管理层（Lane Management ）：同DSI</li>
</ul>
</li>
<li><p>APP layer：该层描述了更高级别的数据编码和解释包含在数据流中。 CSI-2 规范描述了像素值到字节。</p>
</li>
</ul>
<h2 id="差分-x2F-单端信号"><a href="#差分-x2F-单端信号" class="headerlink" title="差分/单端信号"></a>差分/单端信号</h2><ul>
<li>单端信号：单端信号是相对于差分信号而言的，单端输入指信号有一个参考端和一个信号端构成，参考端一般为地端</li>
<li>差分信号：两根线上都传输信号，这两个信号的振幅相等，相位相反（大小等、方向反），也称差模信号</li>
<li>共模信号：两个信号振幅相等，相位相同（干扰信号）</li>
</ul>
<p><img src="/images/Hardware/Protocol/mipi/mipi-3.png" alt="image"></p>
<p>如上图所示，左侧为差分信号，右侧为单端信号。对于差分信号V+电流流向地、V-电流由地流出。对于同一个地来讲，如果存在共模误差，两根线都有做差值就抵消掉了，对于电磁干扰由于相位相反磁场抵消。因此差分信号特点：易分辨小信号，抗干扰能力强；但同时由于使用了两根线成本较高</p>
<h1 id="PHY"><a href="#PHY" class="headerlink" title="PHY"></a>PHY</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>PHY层规范了传输介质、电气特性、IO电路、和同步机制。通俗地说，就是指定物理层构建的规则，比如指定如何拿到数据、怎样编码、转化成怎样的电信号、通过多少根/组通道送出去等等。通过标准化不同制造商的产品之间的接口来降低移动设备的设计成本，从而缩短产品上市时间。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><img src="/images/Hardware/Protocol/mipi/mipi-4.png" alt="image"></p>
<h1 id="D-PHY"><a href="#D-PHY" class="headerlink" title="D-PHY"></a>D-PHY</h1><p>D-PHY 描述了一种源同步、高速、低功耗、低成本的 PHY，特别适用于移动应用。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Lane"><a href="#Lane" class="headerlink" title="Lane"></a>Lane</h3><p>Lane本意是航道、车道，在这里我们可以将其引申为两个模块间传输数据的通道。</p>
<p>对于一组信号来讲，主从端（收发端）各有一个Lane模块，并且模块间使用一组差分信号进行连接，也就是2条line即V+ 、V-。而Lane模块和中间的连线作为整个物理层核心，共同构成了完整的数据数据传输通道。</p>
<p>D-PHY协议规定了必须拥有一条时钟通道（Clock Lane：Clock+、Clock-）和一条或者多条数据通道（Data Lane：D+、D-）</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li><p>主从模式（master提供时钟）</p>
</li>
<li><p>时钟通道 Clock Lane：单向由master至slave</p>
</li>
<li><p>数据通道 Data Lane：数据可单向、可双向（半双工），其中token控制了传输方向，并且当在反向传输数据的时候（Slave To Master），带宽只有正向传输（Master To Slave）的四分之一</p>
</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/images/Hardware/Protocol/mipi/mipi-5.png" alt="image"></p>
<p>上图是通用通道模块架构，为了通用性和层次抽象，将LP、HS都做了双向的展示。而在实际设计或者开发中，根据实际需求只设计或配置单项传输都是ok的</p>
<h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><ul>
<li><p>高速模式（High Speed，HS）</p>
<p>High-Speed 也叫 Burst Mode，用于高速的数据传输，其实就是图像数据传输；在这种模式下，吞吐率可以达到 2500 Mbps，也就是 2.5Gbps/per Lane；</p>
</li>
<li><p>低速模式（Low Power，LP）</p>
<p>Low-Power 模式用于一些控制信息，比如，传一些指令之类的；在这种模式下的最大速率是 10Mbps；</p>
<p>data lane差分线电平的高低表明了当前处于何种状态，发送方通过驱动差分线一系列的状态变化，进入不同的工作模式</p>
</li>
</ul>
<p>无论是HS模式还是LP模式，都采用LSB fisrt、MSB last的传输方式。两种模式的结合保证了MIPI总线在需要传输大量数据（如图像）时可以高速传输，而在不需要大数据量传输时又能够减少功耗。</p>
<p><img src="/images/Hardware/Protocol/mipi/mipi-6.png" alt="image"></p>
<table>
<thead>
<tr>
<th></th>
<th>HS模式</th>
<th>LP模式</th>
</tr>
</thead>
<tbody><tr>
<td>传输模式</td>
<td>低压差分信号传输</td>
<td>单端信号传输</td>
</tr>
<tr>
<td>信号电平</td>
<td>100mV ~ 300mV</td>
<td>0 ~ 1.2V</td>
</tr>
<tr>
<td>传输速度</td>
<td>80Mbps ~ 1Gbps（v1.0）<br>80Mbps ~ 1.5Gbps（v1.1）<br>2.5Gbps（v1.2）<br>10Gbps ~ 14Gbps（v3.0）</td>
<td>&lt;10Mbps</td>
</tr>
<tr>
<td>功耗</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<h2 id="Lane状态描述"><a href="#Lane状态描述" class="headerlink" title="Lane状态描述"></a>Lane状态描述</h2><p>在 High-Speed 模式下，Lane 上传输的是差分信号；</p>
<p>在 Low-Power 模式下，Lane 上的 2 根线是独立的信号，不再是差分的含义了；</p>
<p><img src="/images/Hardware/Protocol/mipi/mipi-7.png" alt="image"></p>
<h2 id="数据Lane操作模式"><a href="#数据Lane操作模式" class="headerlink" title="数据Lane操作模式"></a>数据Lane操作模式</h2><p>在正常操作期间，数据通道将处于控制或高速模式。</p>
<h3 id="高速模式（High-Speed-Mode）"><a href="#高速模式（High-Speed-Mode）" class="headerlink" title="高速模式（High-Speed Mode）"></a>高速模式（High-Speed Mode）</h3><p>高速数据传输以突发（burst）方式发生。传输从停止状态开始，并以停止状态结束。在突发之间的中间时间内，数据通道应保持停止状态，除非通道上出现 turnaround 或 escape 请求。在HS 数据突发期间，时钟通道应处于高速模式，为从端提供 DDR 时钟</p>
<p><img src="/images/Hardware/Protocol/mipi/mipi-8.png" alt="image"></p>
<p>传输开始（SOT）至 传输结束 （EOT）序列：</p>
<ul>
<li>驱动 停止 状态（LP-11）</li>
<li>驱动 HS-Rqst 状态持续TLPS时间 (LP-01)</li>
<li>驱动 Bridge 状态持续HS-PREPARE时间（LP-00）</li>
<li>同时启用高速驱动器和禁用低功耗驱动器</li>
<li>驱动 HS-0 持续THS-ZERO时间</li>
<li>采样开始！！！</li>
<li>……</li>
<li>完成有效载荷数据的传输</li>
<li>在最后一个有效载荷数据位之后立即切换差分状态并保持该状态一段时间 THS-TRAIL</li>
<li>禁用 HS-TX，启用 LP-TX，并驱动停止状态 (LP-11) 一段时间 THS-EXI</li>
</ul>
<h3 id="控制模式（Control-Mode）"><a href="#控制模式（Control-Mode）" class="headerlink" title="控制模式（Control Mode）"></a>控制模式（Control Mode）</h3><p>low power下的一种模式，可以通过变化不同的state进入其它模式。这个目前没有看到更多相关资料。</p>
<h4 id="双向数据传输-Data-Lane-Turnaround"><a href="#双向数据传输-Data-Lane-Turnaround" class="headerlink" title="双向数据传输 Data Lane Turnaround"></a>双向数据传输 Data Lane Turnaround</h4><p><img src="/images/Hardware/Protocol/mipi/mipi-9.png" alt="image"></p>
<p>D-PHY双向通道支持TurnAround操作，即反转操作双向传输。虽然数据反向传输但是master/slave角色不变，master向slave去读数据。这个过程是在控制模式下执行的！！！</p>
<p>流程：</p>
<ul>
<li>驱动停止状态 LP11</li>
<li>驱动 LP-Rqst 状态 (LP-10) 持续 TLPX 时间</li>
<li>驱动桥态 (LP-00) 时间 TLPX 时间</li>
<li>驱动 LP-10 状态 TLPX 时间</li>
<li>驱动桥态 (LP-00) 时间 TTA-GO时间</li>
<li>停止驱动线路并使用其 LP-RX 观察线路状态以查看确认Wait ACK（接收 LP-00）</li>
<li>接收 LP-10</li>
<li>接收 LP-11</li>
</ul>
<h3 id="逃逸模式（Escape-mode）"><a href="#逃逸模式（Escape-mode）" class="headerlink" title="逃逸模式（Escape mode）"></a>逃逸模式（Escape mode）</h3><p>low power下的特殊模式，在这种模式下可以使用一些特别的功能。在这种模式下，可以进入一些额外的功能：LPDT（低功耗数据传输模式）, ULPS(超低功耗模式)、Trigger。一旦进入Escape mode模式，发送端必须发送1个8-bit的命令来响应请求的动作（对于Escape Mode流程来讲，最终需要发送一个Entry Command，而Table 8就是3个命令）</p>
<ul>
<li>进入Escape Mode流程：LP-11、LP-10、LP-00、LP-01、LP-00、[Entry Command]</li>
<li>退出Escape Mode流程：LP-00、LP-10、LP-11</li>
</ul>
<p><img src="/images/Hardware/Protocol/mipi/mipi-10.png" alt="image"></p>
<h4 id="LPDT"><a href="#LPDT" class="headerlink" title="LPDT"></a>LPDT</h4><p><img src="/images/Hardware/Protocol/mipi/mipi-11.png" alt="image"></p>
<p>这个模式下呢，数据可以在低速情况下进行传输，Lane 可以暂停发送</p>
<h4 id="RESET"><a href="#RESET" class="headerlink" title="RESET"></a>RESET</h4><p><img src="/images/Hardware/Protocol/mipi/mipi-12.png" alt="image"></p>
<h2 id="Calibration校准"><a href="#Calibration校准" class="headerlink" title="Calibration校准"></a>Calibration校准</h2><p>当以高于 1.5 Gbps 的速度运行或更改为超过 1.5 Gbps 的任何速率时，应在正常操作中的高速数据传输之前发送初始去偏移序列。对于周期性去偏移校准，发送器应在发送 deskew序列之前完成当前突发</p>
<p>当以 1.5 Gbps 或以下速率运行时，初始去偏移序列的传输是可选的。周期性去偏移是可选的，与数据速率无关。当改变状态时，例如从 ULPS 到 HS，任何去偏移序列的传输都是可选的，前提是 HS 操作以先前已传输初始去偏移序列的速率恢复。</p>
<h2 id="时钟Lane操作模式"><a href="#时钟Lane操作模式" class="headerlink" title="时钟Lane操作模式"></a>时钟Lane操作模式</h2><p><img src="/images/Hardware/Protocol/mipi/mipi-13.png" alt="image"></p>
<h3 id="High-Speed"><a href="#High-Speed" class="headerlink" title="High Speed"></a>High Speed</h3><p>启动高速时钟传输的过程：</p>
<ul>
<li>驱动停止状态 (LP-11)</li>
<li>驱动 HS-Req 状态 (LP-01) 时间 TLPX</li>
<li>驱动桥状态 (LP-00) 时间 TCLK-PREPARE</li>
<li>启用高速驱动器并同时禁用低功耗驱动器。驱动 HS-0 一段时间 TCLK-ZERO</li>
<li>在任何数据通道启动之前，在 TCLK-PRE 时间段内驱动高速时钟信号，Data Lane开始工作</li>
</ul>
<p>将时钟通道切换到低功耗模式的过程：</p>
<ul>
<li>驱动高速时钟信号（切换 HS-0/HS-1）</li>
<li>最后一个数据通道进入低功耗模式</li>
<li>继续驱动高速时钟信号一段时间 TCLK-POST 并以 HS-0 状态结束</li>
<li>驱动 HS-0 一段时间 TCLK-TRA</li>
<li>禁用 HS-TX，启用 LP-TX，并驱动停止状态 (LP-11) 一段时间 THS-EXI</li>
</ul>
<h3 id="Low-Power（ULPS）"><a href="#Low-Power（ULPS）" class="headerlink" title="Low Power（ULPS）"></a>Low Power（ULPS）</h3><p>传输过程：</p>
<ul>
<li>LP-11，TX-Stop </li>
<li>LP-10，TX-ULPS-Rqst</li>
<li>LP-00，TX-ULPS</li>
<li>LP-10，TX-ULPS-Exit</li>
</ul>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p><img src="/images/Hardware/Protocol/mipi/mipi-14.png" alt="image"></p>
<h2 id="检测（P50）"><a href="#检测（P50）" class="headerlink" title="检测（P50）"></a>检测（P50）</h2><p>存在三种不同的机制来检测链路故障。总线争用和 错误检测功能包含在 D-PHY 中。这些功能应该检测许多典型故障。然而，有些故障无法在 D-PHY 内检测到，需要协议级解决方案。</p>
<h3 id="争用检测"><a href="#争用检测" class="headerlink" title="争用检测"></a>争用检测</h3><h3 id="序列错误检测"><a href="#序列错误检测" class="headerlink" title="序列错误检测"></a>序列错误检测</h3><p>• SoT Error<br>• SoT Sync Error<br>• EoT Sync Error<br>• Escape Entry Command Error<br>• LP Transmission Sync Error<br>• False Control Error</p>
<h3 id="协议看门狗定时器（资料性）"><a href="#协议看门狗定时器（资料性）" class="headerlink" title="协议看门狗定时器（资料性）"></a>协议看门狗定时器（资料性）</h3><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li>mipi csi 如何理解虚拟通道?</li>
</ol>
<p>   在MIPI CSI（Camera Serial Interface）中，虚拟通道（Virtual Channel）是一种用于在单个物理通道上传输多个数据流的机制。</p>
<p>   MIPI CSI标准允许将单个物理通道划分为多个虚拟通道，每个虚拟通道可以独立传输不同的数据流或数据类型。通过虚拟通道的使用，可以实现并行传输多个数据流，提高带宽利用率和系统的灵活性。</p>
<p>   在MIPI CSI中，虚拟通道的数量和配置是根据具体的应用需求进行定义和配置的。每个虚拟通道可以传输不同的图像数据流，例如主摄像头数据、辅助摄像头数据、深度图像数据等。此外，还可以使用虚拟通道传输其他与图像相关的数据，如元数据、时间戳、图像标签等。</p>
<p>   通过虚拟通道的使用，可以灵活地组织和传输多种类型的数据，从而满足不同应用场景下的需求。例如，在多摄像头系统中，可以使用不同的虚拟通道将各个摄像头的数据进行分离和传输。</p>
<p>   需要注意的是，虚拟通道的使用需要在发送方和接收方之间进行协商和配置，以确保数据能够正确地路由到相应的虚拟通道。因此，在实际应用中，需要遵循MIPI CSI标准并进行正确的配置和处理，以实现数据的正确传输和解析。</p>
<p>   总而言之，MIPI CSI中的虚拟通道是一种在单个物理通道上传输多个数据流的机制，通过划分和配置虚拟通道，可以实现并行传输不同类型的数据，提高带宽利用率和系统的灵活性。</p>
<ol start="2">
<li><p>mipi  ULPS和LPDT的区别?</p>
<p>在MIPI（Mobile Industry Processor Interface）标准中，ULPS（Ultra Low Power Save）和LPDT（Low Power Data Transmission）是两种不同的低功耗模式，用于在移动设备中实现节能和延长电池寿命。</p>
<ol>
<li>ULPS（Ultra Low Power Save）：ULPS是一种更为极端的低功耗模式，旨在将设备的功耗降至最低限度。在ULPS模式下，设备的电源消耗极低，主要通过减少电压和关闭非必要的模块来实现。这可能包括关闭不使用的传感器、降低主频、进入深度睡眠状态等措施。ULPS模式通常用于极端低功耗要求的场景，例如待机模式或长时间不使用时的电源管理。</li>
<li>LPDT（Low Power Data Transmission）：LPDT是一种在数据传输过程中实现低功耗的模式。在LPDT模式下，数据传输过程中采用一些技术手段来降低功耗，如降低传输速率、减少电压、采用更节能的传输协议等。LPDT模式在需要进行数据传输的同时，尽量减少功耗的消耗。这种模式适用于需要在传输数据的同时保持较低功耗的场景，例如实时数据传输、图像传输等。</li>
</ol>
<p>需要注意的是，ULPS和LPDT都是根据MIPI标准中的要求和规范来定义的，具体实现和支持程度可能因设备和厂商而有所不同。在实际应用中，设备制造商根据具体需求和硬件能力，选择和实现适当的低功耗模式以平衡性能和功耗之间的关系，以提供更长的电池寿命和更好的用户体验。</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://caxapa.ru/thumbs/799244/mipi_D_PHY_specification_v1_2.pdf">Specification for D-PHY</a></li>
<li><a href="https://www.bilibili.com/video/BV1Tv411j7Q6/">MIPI设计基础</a></li>
<li><a href="https://www.bilibili.com/video/BV1e4411q7CC/">差分信号与单端信号的差别</a></li>
<li><a href="https://blog.csdn.net/zhoutaopower/article/details/123662047">MIPI 系列之 D-PHY</a></li>
<li><a href="https://picture.iczhiku.com/resource/eetop/WHISUkJqgiqojbxm.pdf">MIPI DSI</a></li>
<li><a href="https://caxapa.ru/thumbs/799244/MIPI_Alliance_Specification_for_Camera_S.pdf">MIPI CSI-2</a></li>
</ul>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>硬件传输协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Uart</title>
    <url>/2023/08/10/Hardware/Protocol/uart/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>UART：Universal Asynchronous Receiver/Transmitter，通用异步收发传输器。一种常用的串行通信协议，用于在电子设备之间进行数据传输。它是一种异步通信方式，意味着数据没有固定的时钟信号来同步发送和接收端的数据。相比同步通信协议（如SPI和I2C），UART不需要在数据传输中传递时钟信号，从而更加简单且适用于各种设备和环境。</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li><p>点对点：uart协议只能作用于两个单点设备之间，通常没有明确意义上的主从关系</p>
</li>
<li><p>异步通信：异步通信体现在没有时钟的控制，而是按照别的方式进行数据的确认（需要协商固定波特率Baud Rate）</p>
</li>
<li><p>全双工通信：使用两个UART通道，一个用于发送（TX）一个用于接收（RX）。</p>
</li>
<li><p>速率灵活性：UART通信的波特率可以根据具体需求进行灵活配置，允许在不同的传输速率下进行数据传输。</p>
</li>
<li><p>数据格式灵活性：可以按需配置数据位数、停止位数、校验位等等</p>
</li>
</ul>
<h2 id="逻辑框图"><a href="#逻辑框图" class="headerlink" title="逻辑框图"></a>逻辑框图</h2><p><img src="/images/Hardware/Protocol/uart/uart-1.png" alt="image"></p>
<h1 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h1><h2 id="uart收发控制器之间"><a href="#uart收发控制器之间" class="headerlink" title="uart收发控制器之间"></a>uart收发控制器之间</h2><p>在UART中，传输的方式是数据包的形式。数据包由起始位、数据帧、奇偶校验位和停止位组成</p>
<p><img src="/images/Hardware/Protocol/uart/uart-2.png" alt="image"></p>
<ul>
<li><p>起始位</p>
<p>UART 数据传输线在不传输数据时通常保持在高电平。为了开始数据传输，发送 UART 将传输线从高电平拉至低电平，持续1个时钟周期。当接收UART检测到高电平到低电平的转变时，它开始以波特率的频率读取数据帧中的位。</p>
</li>
<li><p>数据帧</p>
<p>数据帧包含正在传输的实际数据。如果使用奇偶校验位，它的长度可以是5-8 位。如果不使用奇偶校验位，则数据帧可以是9 位。在大多数情况下，数据首先以最低有效位发送。</p>
</li>
<li><p>奇偶校验位</p>
<p>奇偶校验描述了数字的偶数或奇数。奇偶校验位是UART_RX 判断数据在传输过程中是否发生变化的一种方式。位可能因电磁辐射、不匹配的波特率或长距离数据传输而改变。<br>如果奇偶校验位为 0（偶校验），则数据帧中的 1 或逻辑高位总计应为偶数。如果奇偶校验位为 1（奇校验），则数据帧中的 1 位或逻辑高电平总计应为奇数。当奇偶校验位与数据匹配时，UART 就知道传输没有错误。但如果奇偶校验位为 0，并且总数为奇数，或者奇偶校验位为 1，并且总数为偶数，则 UART 知道数据帧中的位已更改。</p>
</li>
<li><p>结束位</p>
<p>为了发出数据包结束的信号，发送 UART 将数据传输线从低电压驱动到高电压，持续时间为1-2位。</p>
</li>
</ul>
<h2 id="控制器与总线"><a href="#控制器与总线" class="headerlink" title="控制器与总线"></a>控制器与总线</h2><p>需要注意的是，数据在控制器之前数据是串行传输的。但是当数据从内容到数据总线，数据总线到uart发送器之间数据是并行传输的，相应的数据接收器到数据总线数据的发送也是并行的。</p>
<h1 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h1><p>对于异步通信需要解决的一个问题就是：当发送方连续发送了多个逻辑1，接收方如何确认其具体个数。同步通信很好解决即通过时钟同步，对于串口通信使用波特率即可解决该问题。</p>
<p>波特率（Baud Rate）是衡量串行通信传输速率的单位，表示每秒钟传输的比特数。它用于定义数据传输速度，即在单位时间内发送的二进制位数。波特率是串行通信中一个重要的参数，需要发送方和接收方事先约定相同的波特率，以确保数据的正确传输。</p>
<p>波特率通常以每秒传输的位数来表示，例如：9600、115200、38400等。每个波特率都代表每秒传输的比特数，例如：波特率115200表示每秒传输115200个位；则对应传输1bit的时间也可以计算出来，这样接收方统计接收某个电平的时长即可计算出具体有几个数据。波特率和数据传输速度之间的关系是线性的。例如，波特率为9600时，每秒传输的位数为9600 bps（bits per second），而一个典型的8位数据帧包含了一个起始位、8位数据位、一个可选的校验位和一个或多个停止位，因此总的数据传输速率将高于9600 bps，但9600 bps是通信速率的基准。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p>
<ul>
<li>仅需要两根线即可进行全双工数据传输（电源线除外）</li>
<li>不需要时钟或任何其他定时信号</li>
<li>奇偶校验位确保将基本错误检查集成到数据包帧中</li>
</ul>
<p>缺点</p>
<ul>
<li>帧中数据的大小是有限的</li>
<li>与并行通信相比，数据传输速度较低</li>
<li>发送器和接收器必须同意传输规则并选择合适的波特率</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.analog.com/en/analog-dialogue/articles/uart-a-hardware-communication-protocol.html">A Hardware Communication Protocol Understanding UART</a></li>
</ul>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>硬件传输协议</tag>
      </tags>
  </entry>
  <entry>
    <title>GPIO</title>
    <url>/2022/09/22/Hardware/Controller/GPIO/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>GPIO：General Purpose Input Output，通用输入输出，简称为“IO口”，芯片与外围设备交互的硬件接口</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>以下图片来自STM32的GPIO硬件电路图</p>
<p><img src="/images/Hardware/Controller/GPIO-1.png" alt="image"></p>
<p>施密特触发器：在正向递增和负向递减两个方向有不同的阈值，有一定的抗干扰能力，外部的小扰动不会导致cpu误判，直至剧烈变化或者真的有电平的变化。</p>
<h1 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h1><h2 id="输入（4）"><a href="#输入（4）" class="headerlink" title="输入（4）"></a>输入（4）</h2><ol>
<li>浮空输入：多用于外部按键输入，io状态不确定完全由外部输入决定</li>
<li>上拉输入：IO口输入设定为高电平输入（1），检测低电平或下降沿</li>
<li>下拉输入：IO口输入设定为低电平输入（0）</li>
<li>模拟输入：ADC模拟输入，测量外部电压幅值不通过TTL</li>
</ol>
<h2 id="输出（4）"><a href="#输出（4）" class="headerlink" title="输出（4）"></a>输出（4）</h2><ol>
<li>推挽输出：输出高低电平</li>
<li>开漏输出：只有一个NMOS导通，只能输出低电平+高阻态，不能输出高电平；当NMOS导通输出低电平，截至输出高阻态。用作线与，电平不匹配的场合，外部上拉</li>
<li>复用推挽输出：需要输出高低电平的其他模式，如：spi uart</li>
<li>复用开漏输出：普通i2c处于该模式</li>
</ol>
<h1 id="GPIO寄存器"><a href="#GPIO寄存器" class="headerlink" title="GPIO寄存器"></a>GPIO寄存器</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>以stm32为例</p>
<ul>
<li>GPIO 端口模式寄存器 (GPIOx_MODER) (x = A…I)</li>
<li>GPIO 端口输出类型寄存器 (GPIOx_OTYPER) (x = A…I)</li>
<li>GPIO 端口输出速度寄存器 (GPIOx_OSPEEDR) (x = A…I/)</li>
<li>GPIO 端口上拉/下拉寄存器 (GPIOx_PUPDR) (x = A…I/)</li>
<li>GPIO 端口输入数据寄存器 (GPIOx_IDR) (x = A…I)</li>
<li>GPIO 端口输出数据寄存器 (GPIOx_ODR) (x = A…I)</li>
<li>GPIO 端口置位/复位寄存器 (GPIOx_BSRR) (x = A…I)</li>
</ul>
<h2 id="GPIO-Shadow"><a href="#GPIO-Shadow" class="headerlink" title="GPIO Shadow"></a>GPIO Shadow</h2><p>由于设置某个模式的过程中配置的不只是一个寄存器，配置过程中就可能出现别的状态的产生，导致错误。而使用shadow寄存器，可以先将所有需要配置的寄存器分别设置进去，但不生效，直至全部设置完毕，再指定GPID即要映射的组上去生效！避免了中间非必要状态的产生。</p>
<h1 id="用户层应用"><a href="#用户层应用" class="headerlink" title="用户层应用"></a>用户层应用</h1><h2 id="配置GPIO"><a href="#配置GPIO" class="headerlink" title="配置GPIO"></a>配置GPIO</h2><p>在内核导出 gpio 节点的前提下， 可以操作/sys/class/gpio 节点， 控制 gpio 输入输出</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">导出节点：  echo <span class="number">20</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">export</span></span></span><br><span class="line"><span class="class">设置方向：  <span class="title">echo</span> [<span class="title">out</span> / <span class="title">in</span>] &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio20</span>/<span class="title">direction</span></span></span><br><span class="line"><span class="class">设置值：    <span class="title">echo</span> [0 / 1] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">value</span></span></span><br><span class="line"><span class="class">设置触发模式：<span class="title">echo</span> [<span class="title">none</span> / <span class="title">rising</span> / <span class="title">falling</span> /  <span class="title">both</span>] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">edge</span></span></span><br><span class="line"><span class="class">翻转属性：  <span class="title">echo</span> [0 / 1] &gt;</span> sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">gpio19</span>/<span class="title">active_low</span></span></span><br><span class="line"><span class="class">移除节点：  <span class="title">echo</span> 20 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">gpio</span>/<span class="title">unexport</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>注意事项</p>
<ul>
<li>direction<br>如果内核不支持改变 GPIO 的方向，或者在导出时内核代码没有明确允许用户空间可以重新配置 GPIO 方向， 那么这个属性将不存在。</li>
<li>value<br>输出时，控制高低电平；输入时，获取高低电平</li>
<li>edge<br>控制中断触发模式，引脚被配置为中断后可以使用poll() 函数监听引脚<br>非中断引脚、上升沿触发、下降沿触发、边沿触发</li>
<li>active_low<br>用于翻转电平，当外部有效信号与GPIO有效信号不一致（即0可能表示有效，1也有可能表示有效）</li>
</ul>
<h2 id="查看GPIO配置"><a href="#查看GPIO配置" class="headerlink" title="查看GPIO配置"></a>查看GPIO配置</h2><p>不同的厂商对于GPIO配置结果的查看方式有所不同，以下以Ingenic-x2000为例对应相关的手册可以确定相应的IO状态</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">/<span class="meta"># cat /sys/devices/platform/apb/10010000.pinctrl/dump_gpio</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果如下图, 下面会有每一个GPIO状态</span></span><br><span class="line">REG 	|+++GPA++|+++GPB++|+++GPC++|+++GPD++|</span><br><span class="line"></span><br><span class="line">INL 	|<span class="number">0</span>c3fffff|<span class="number">67f</span>6036f|<span class="number">0110f</span>ef4|<span class="number">0f</span>7fffff|</span><br><span class="line">INT 	|<span class="number">02b</span>00000|<span class="number">30440000</span>|<span class="number">00000081</span>|<span class="number">00000100</span>|</span><br><span class="line">MSK 	|<span class="number">194f</span>cfff|ce0a0040|<span class="number">74f</span>f0076|<span class="number">003f</span>feff|</span><br><span class="line">PAT1 	|<span class="number">0265</span>cfff|f6440000|<span class="number">77</span>efc0fb|<span class="number">003f</span>fbff|</span><br><span class="line">PAT0 	|<span class="number">0f</span>8a3000|<span class="number">1033</span>efc0|<span class="number">88100005</span>|<span class="number">00000400</span>|</span><br><span class="line">EDG 	|<span class="number">3f</span>ffff00|f6037f00|<span class="number">10f</span>ff400|<span class="number">7f</span>ffff00|</span><br><span class="line">PLUP 	|<span class="number">14000000</span>|<span class="number">41800000</span>|<span class="number">00200001</span>|<span class="number">00000100</span>|</span><br><span class="line">PLDWN 	|<span class="number">00000000</span>|<span class="number">800000</span>c0|<span class="number">00100002</span>|<span class="number">00000000</span>|</span><br><span class="line">FLAG 	|<span class="number">00000000</span>|<span class="number">00000000</span>|<span class="number">00000000</span>|<span class="number">00000000</span>|</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="相关功能"><a href="#相关功能" class="headerlink" title="相关功能"></a>相关功能</h1><p>在低功耗场景下，系统休眠以后部分硬件时钟可能关闭。但是GPIO不依赖时钟，故可以配置IO作为中断源对CPU进行唤醒</p>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Controller</category>
      </categories>
  </entry>
  <entry>
    <title>SPI</title>
    <url>/2023/07/15/Hardware/Protocol/spi/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>SPI：Serial Peripheral Interface 串行外设接口，用于在微控制器和外部设备之间进行数据传输。SPI 接口广泛应用于嵌入式系统中，特别是与外围设备进行通信，如传感器、存储器、显示屏和通信模块等。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>传输信号：MSIO、MOSI、SCKL、CS</p>
</li>
<li><p>主从结构。SPI 通信由一个主设备（Master）和一个或多个从设备（Slave）组成。主设备控制通信的时序和数据传输，而从设备按照主设备的命令响应数据传输。</p>
</li>
<li><p>同步协议。SPI 使用一个时钟信号（SCLK）来同步数据的传输。主设备产生时钟信号，控制数据传输的速率和时序，而从设备根据时钟信号采样和发送数据。</p>
</li>
<li><p>全双工传输（双向传输）。数据可以同时在主设备和从设备之间双向传输。主设备通过 MOSI（Master Out Slave In）线路发送数据，而从设备通过 MISO（Master In Slave Out）线路接收数据。</p>
</li>
<li><p>多设备支持：SPI 接口可以连接多个从设备，每个从设备使用一个片选信号（SS）来选择与其通信的从设备。主设备通过选择特定的片选信号来与特定的从设备进行通信。</p>
</li>
<li><p>传输速率。SPI 接口的传输速率可以通过调整时钟频率来控制，支持高速传输。传输速率可以根据实际应用需求进行配置，但受硬件和设备的限制。</p>
</li>
</ul>
<h2 id="信号定义"><a href="#信号定义" class="headerlink" title="信号定义"></a>信号定义</h2><ul>
<li>SCK：Serial Clock，串行时钟</li>
<li>MOSI：Master Output Slave Input，主发从收</li>
<li>MISO：Master Input Slave Output，主收从发</li>
<li>CS/SS：Slave Select / Chip Select，片选信号</li>
</ul>
<h2 id="系统框图"><a href="#系统框图" class="headerlink" title="系统框图"></a>系统框图</h2><p><img src="/images/Hardware/Protocol/spi/spi-0.png" alt="image"></p>
<p>对于SPI来讲，通常是一主（MCU）多从（外设），而多个从机是通过CS片选信号线来选择具体和哪一个设备进行通信，从机也将规定片选信号线是高电平有效还是低电平有效</p>
<h1 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h1><p>不同于I2C，SPI在通信过程中不需要发送起始信号、结束信号，同时也不需要等待应答信号，它的数据线只发送数据，一个byte接着一个byte的数据进行发送。显而易见，它的速度相较于I2C一定是更快的，但是却不能保证数据的可靠性（不能确认从机是否真正收到数据）。另外，在空闲状态的保持和数据发送时的时钟状态上，spi与i2c也是存在差异的。</p>
<h2 id="相位极性"><a href="#相位极性" class="headerlink" title="相位极性"></a>相位极性</h2><ul>
<li><p>时钟极性（Clock Polarity）：定义了在时钟信号在空闲状态下的状态</p>
<ul>
<li>0：在时钟信号的空闲状态时，数据线上保持低电平（0），而在时钟信号激活时传输数据。</li>
<li>1：在时钟信号的空闲状态时，数据线上保持高电平（1），而在时钟信号激活时传输数据。</li>
</ul>
</li>
<li><p>时钟相位（Clock Phase）：定义了数据信号采样对应的时钟信号的状态（上升沿/下降沿采样）</p>
<ul>
<li>0：时钟上升沿采样</li>
<li>1：时钟下降沿采样</li>
</ul>
</li>
</ul>
<p>根据相位极性的每种状态，因此对于spi有四种工作模式，具体选择哪一种模式取决于从机支持哪一种。（I2C相位极性是固定的）</p>
<h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><ul>
<li>兼容性：不同的设备可能对SPI的极性和相位有不同的要求，选择适当的组合可以确保设备之间的兼容性。</li>
<li>时序控制：极性和相位的选择影响了数据传输的时序和同步方式。通过调整极性和相位，可以满足具体应用的时序要求，确保数据的正确传输。</li>
<li>信号完整性：正确的极性和相位组合可以减少噪声和时钟抖动对数据传输的影响，提高信号的可靠性和稳定性。</li>
</ul>
<h1 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h1><h2 id="CPOL-x3D-0-CPHA-x3D-0"><a href="#CPOL-x3D-0-CPHA-x3D-0" class="headerlink" title="CPOL = 0,CPHA = 0"></a>CPOL = 0,CPHA = 0</h2><p>空闲状态低电平，上升沿采样下降沿从机读数据</p>
<p><img src="/images/Hardware/Protocol/spi/spi-1.png" alt="image"></p>
<h2 id="CPOL-x3D-0-CPHA-x3D-1"><a href="#CPOL-x3D-0-CPHA-x3D-1" class="headerlink" title="CPOL = 0,CPHA = 1"></a>CPOL = 0,CPHA = 1</h2><p>空闲状态低电平，下降沿采样上升沿从机读数据</p>
<p><img src="/images/Hardware/Protocol/spi/spi-2.png" alt="image"></p>
<h2 id="CPOL-x3D-1-CPHA-x3D-0"><a href="#CPOL-x3D-1-CPHA-x3D-0" class="headerlink" title="CPOL = 1,CPHA = 0"></a>CPOL = 1,CPHA = 0</h2><p>空闲状态高电平，上升沿采样下降沿从机读数据</p>
<p><img src="/images/Hardware/Protocol/spi/spi-3.png" alt="image"></p>
<h2 id="CPOL-x3D-1-CPHA-x3D-1"><a href="#CPOL-x3D-1-CPHA-x3D-1" class="headerlink" title="CPOL = 1,CPHA = 1"></a>CPOL = 1,CPHA = 1</h2><p>空闲状态高电平，下降沿采样上升沿从机读数据</p>
<p><img src="/images/Hardware/Protocol/spi/spi-4.png" alt="image"></p>
<h1 id="SPI-controller"><a href="#SPI-controller" class="headerlink" title="SPI controller"></a>SPI controller</h1><blockquote>
<p>这个是 <a href="https://www.ti.com/lit/ug/sprugp2a/sprugp2a.pdf?ts=1689464223160&amp;ref_url=https%253A%252F%252Fwww.google.es%252F">TI SPI User Guide</a>中的控制器的框图</p>
</blockquote>
<p><img src="/images/Hardware/Protocol/spi/spi-5.png" alt="image"></p>
<h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><p>通过读图可以发现，对于控制内部通路存在buffer和移位寄存器。</p>
<ol>
<li>发送数据时，主设备将要发送的数据逐位加载到移位寄存器中，然后通过移位寄存器按照时钟信号的节奏逐位发送。在这个过程中，FIFO缓冲区可以用于存储多个待发送的数据字节，以便在移位寄存器中逐位移动数据之前，提供数据的供应。</li>
<li>接收数据时，数据线上的位被移位寄存器接收和存储。如果存在FIFO缓冲区，接收到的数据字节可以先存储在FIFO中，以便在主设备准备好读取时进行传输</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li><p><code>时钟</code></p>
<p>SPI控制器产生时钟信号，用于同步数据传输。它通常提供可配置的时钟频率选项，以适应不同的通信速率需求</p>
</li>
<li><p><code>数据缓冲区</code></p>
<p>SPI控制器提供数据缓冲区，用于存储要发送或接收的数据。它可以是一个单独的寄存器或一个FIFO（First-In-First-Out）缓冲区。</p>
</li>
<li><p><code>通信模式选择</code></p>
<p>根据从机的需求配置极性和相位以适应其传输模式</p>
</li>
<li><p><code>中断DMA</code></p>
<p>为了提高传输效率，控制器通常有中断DMA相关的配置等等</p>
</li>
</ul>
<h1 id="TI-SSP"><a href="#TI-SSP" class="headerlink" title="TI SSP"></a>TI SSP</h1><h2 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h2><p>数据传输通过断言帧指示线开始（ss_0_n）一个串行时钟周期。要传输的数据被驱动到txd一个串行时钟周期后行；类似地，来自从机的数据被驱动到接收线。数据在串行时钟的上升沿传播（sclk_输出/slk_输入）并在下降沿捕获。</p>
<p>注：从机选择信号（ss_0_n) 仅当用作从机 SPI 时才有效。对于主 SPI，一旦输出使能信号无效，数据传输就开始。</p>
<p><img src="/images/Hardware/Protocol/spi/spi-6.png" alt="image"></p>
<h2 id="连续传输"><a href="#连续传输" class="headerlink" title="连续传输"></a>连续传输</h2><p>连续数据帧的传输方式与单个数据帧相同。在与当前传输的 LSB 相同的周期内，帧指示符在一个时钟周期内被置位，指示接下来是另一个数据帧。</p>
<p><img src="/images/Hardware/Protocol/spi/spi-7.png" alt="image"></p>
<h1 id="National‘s-Microwire"><a href="#National‘s-Microwire" class="headerlink" title="National‘s Microwire"></a><a href="https://developer.arm.com/documentation/ddi0194/h/functional-overview/primecell-ssp-operation/national-semiconductor-microwire-frame-format">National‘s Microwire</a></h1><p>Microwire 格式与 SPI 格式非常相似，不同之处在于传输是半双工而不是全双工，</p>
<h2 id="单次传输"><a href="#单次传输" class="headerlink" title="单次传输"></a>单次传输</h2><p>使用主从消息传递技术。每个串行传输都以一个 8 位控制字开始，该控制字从 PrimeCell SSP 传输到片外从设备。在此传输期间，PrimeCell SSP 不接收传入数据。消息发送后，片外从机对其进行解码，并在发送 8 位控制消息的最后一位后等待一个串行时钟后，以所需的数据进行响应。返回数据的长度为 4 至 16 位，使得总帧长度在 13-25 位范围内。</p>
<p>在此配置中，在空闲期间：SSPCLKOUT被强制为低电平；SSPFSSOUT被强制为高电平；发送数据线SSPTXD被任意强制为低电平；nSSPOE焊盘使能信号被强制为高电平，使发送焊盘处于高阻抗。</p>
<p>通过将控制字节写入发送 FIFO 来触发发送。SSPFSSOUT的下降沿导致发送 FIFO 底部条目中包含的值被传输到发送逻辑的串行移位寄存器，并且 8 位控制帧的 MSB 被移出到 SSPTXD引脚。SSPFSSOUT在帧传输期间保持低电平。SSPRXD引脚在此传输期间保持三态。</p>
<p>片外串行从设备在每个SSPCLKOUT的上升沿将每个控制位锁存到其串行移位器中。最后一位被从设备锁存后，控制字节在一个时钟等待状态期间被解码，并且从设备通过将数据传输回 PrimeCell SSP 来做出响应。每个位在SSPCLKOUT的下降沿被驱动到SSPRXD线上。PrimeCell SSP 依次锁存SSPCLKOUT上升沿上的每一位。在帧结束时，对于单次传输，SSPFSSOUT信号在最后一位被锁存在接收串行移位器中后一个时钟周期被拉高，这导致数据被传输到接收 FIFO。</p>
<p><img src="/images/Hardware/Protocol/spi/spi-8.png" alt="image"></p>
<h2 id="连续传输-1"><a href="#连续传输-1" class="headerlink" title="连续传输"></a>连续传输</h2><p>片外从设备可以在 LSB 被接收移位器锁存后在SSPCLKOUT的下降沿或当SSPFSSOUT引脚变高时使接收线处于三态。</p>
<p>对于连续传输，数据传输的开始和结束方式与单次传输相同。然而，SSPFSSOUT线持续有效，保持低电平，并且数据传输连续发生。下一帧的控制字节紧跟在当前帧接收数据的 LSB 之后。在帧的 LSB 被锁存到 PrimeCell SSP 中之后，每个接收到的值都会在下降沿SSPCLKOUT上从接收移位器传输。</p>
<p><img src="/images/Hardware/Protocol/spi/spi-9.png" alt="image"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.analog.com/media/en/analog-dialogue/volume-52/number-3/introduction-to-spi-interface.pdf">Introduction to SPI Interface</a></li>
<li><a href="https://www.ti.com/lit/ug/sprugp2a/sprugp2a.pdf">KeyStone Architecture Serial Peripheral Interface</a></li>
<li><a href="https://www.bilibili.com/video/BV1NK411X7mV/">SPI通信原理及应用</a></li>
<li><a href="https://ww1.microchip.com/downloads/en/DeviceDoc/31015a.pdf">Synchronous Serial Port (SSP)</a></li>
</ul>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>硬件传输协议</tag>
      </tags>
  </entry>
  <entry>
    <title>RTC</title>
    <url>/2023/05/18/Hardware/Controller/RTC/</url>
    <content><![CDATA[<h1 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h1><p>对于一个设备来讲，通常会有两个时钟一个被称为硬件时钟另一个被称为系统时钟。</p>
<ul>
<li><p>硬件时钟</p>
<p>指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟，也称为 RTC或 BIOS 时钟。这是电池供电的时钟，即使在系统关闭时也能保持时间。</p>
</li>
<li><p>系统时钟</p>
<p>由操作系统维护，所有Linux相关指令与函数都是读取系统时钟的设定，包括systick也是属于系统时钟。当系统启动的一瞬间，硬件时钟被读取并用于设置系统时钟。从这个时刻起，系统时钟用于跟踪时间，软件时钟在硬件上是由计数器配合工作的。</p>
<p>而系统时钟频率指cpu产生中断供软件系统执行调度的时间间隔。一般一次中断我们叫一个tick。比如我们将系统时钟频率设置为100（sysClkRate函数可设置），即意味着1秒钟会产生100次中断供系统软件调度。</p>
</li>
</ul>
<h1 id="RTC简介"><a href="#RTC简介" class="headerlink" title="RTC简介"></a>RTC简介</h1><p>RTC ：Real Time Clock，实时时钟</p>
<p>实时时钟是系统使用的一种时钟功能，即使在主设备（例如 MCU）断电时也可以通过电池或者超级电容器为RTC提供电能测量时间。当微控制器处于深度睡眠或低功耗模式时，RTC 的内部时钟和电路将继续运行以保持准确的计时和警报功能。在这种模式下，电流消耗将低至 0.2uA——0.5uA</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>无论是对于内置RTC的MCU或者外置RTC芯片来说，通常都会具有以下几种功能：</p>
<ol>
<li>定时器</li>
<li>通过软件配置，提供日历功能</li>
<li>wakeup唤醒功能 / Alarm 闹钟功能</li>
</ol>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>RTC实质是一个掉电后还继续运行的定时器。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/images/Hardware/Controller/rtc.png" alt="image"></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h3><p>以STM32来讲，通常由三个时钟源可供选择</p>
<ul>
<li>外部低速时钟LSE，频率32.768KHz</li>
<li>内部低速时钟LSI</li>
<li>外部高速时钟HSE，一般是需要通过PLL分频得到RTC所需时钟</li>
</ul>
<p>对于LSI、HSE来讲在主电源断电的情况下，两个时钟源都会受到影响，所以通常使用LSE外部晶振。而晶振的时钟频率为32768Hz，这是因为2^15=32768，一个十六位寄存器即可表征，同时分频出1hz时钟</p>
<h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><ul>
<li>闹钟中断，当设置的闹钟等于计数值的时候则产生一个闹钟中断。同时它也可以作为唤醒休眠的设备功能</li>
<li>秒中断，每1s产生一个中断</li>
<li>溢出中断，计数器溢出变成0</li>
</ul>
<h3 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h3><p>对于RTC有两种供电方式，主电源存在则使用主电源。当主电源断开，如果电池有电则电池继续供电保证RTC的正常工作。对于有些设备使用纽扣电池做备用电源，所以这一定是低功耗的</p>
<h1 id="linux下RTC相关命令"><a href="#linux下RTC相关命令" class="headerlink" title="linux下RTC相关命令"></a>linux下RTC相关命令</h1><p>当Linux启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。用date命令对系统时间进行设置后，并不会去修改硬件时钟，所以系统重启后，系统时间还算会去读取硬件时间，这就是为何date设置失效到原因。因此，需要在设置系统时间后，需要将系统时间同步到硬件时钟。</p>
<h2 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h2><blockquote>
<p>使用文档：<a href="https://www.freedesktop.org/software/systemd/man/timedatectl.html">click here</a></p>
</blockquote>
<p>timedatectl可用于查询和更改系统时钟及其设置，以及启用或禁用时间同步服务</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用方式：timedatectl  [选项...]  {命令}</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl									<span class="comment"># 查看时钟设置</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl list-timezones 					<span class="comment"># 显示可用时区列表</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">timedatectl set-timezone Europe/London		<span class="comment"># 设置时区</span></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>使用 date 命令设置系统时间不会自动同步 RTC，只针对系统时间</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> 									<span class="comment">#查看系统时间</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span> <span class="string">"2022-01-20 17:50:30"</span>		    <span class="comment">#设置系统时间</span></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="hwclock"><a href="#hwclock" class="headerlink" title="hwclock"></a>hwclock</h2><blockquote>
<p>使用文档：<a href="https://busybox.net/downloads/BusyBox.html#hwclock">click here</a></p>
</blockquote>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hwclock --show								<span class="comment"># 查看硬件时间</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hwclock --<span class="built_in">set</span> --<span class="built_in">date</span> <span class="string">'2021-01-13 14:37:23'</span>	<span class="comment"># 设置硬件时间</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hwclock -w									<span class="comment"># 将系统时间同步到硬件时间</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hwclock -s									<span class="comment"># 将硬件时间同步到系统时间</span></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h2><p>在睡眠模式下，RTC 可用于稍后唤醒系统。并非所有 RTC 都支持这种唤醒模式，请检查 wakealarm 文件的可用性。</p>
<p>要启用从现在起 20 秒后唤醒，可以使用以下语句：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> +20 &gt; /sys/class/rtc/rtc2/wakealarm</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：软件设计读取时间？</p>
<p>A：上电之后，同时读取系统时间和硬件时间，并计算差值。在之后的任意时刻想要读取时间即可读取软件时间+差值即可得到实际时间，这样减少了频繁读取RTC的次数</p>
</li>
<li><p>Q：soc系统中，rtc作为一个重要内置的电路单元，对于低功耗设计有重要的意义。rtc电路是单独设计电源域。内部RTC难点？</p>
<p>A：CPU面积小，但需要有读写隔离区；面积小，静电不容易消除；占用芯片较大面积</p>
</li>
<li><p>RTC不受RESET控制，可监测Reset</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.st.com/resource/en/reference_manual/DM00031020-.pdf">STM32 Reference manual</a></li>
<li><a href="https://www.st.com/resource/zh/application_note/an3060-applications-guide-for-serial-realtime-clocks-rtcs-stmicroelectronics.pdf">ST串行实时时钟（RTC）应用指南</a></li>
</ul>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Controller</category>
      </categories>
  </entry>
  <entry>
    <title>DDR基础与原理</title>
    <url>/2023/04/05/Hardware/Storage/DDR/</url>
    <content><![CDATA[<p><a href="https://yanglieee.com/2023/02/07/computerSystem/%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/">前面的文章</a>对SRAM的Cache做了详细分析，而这部分将对另一种随机存取器动态随机存储器DRAM做进一步说明。本文大部分是基于BranchEducation的视频内容和其它文章进行行文的，文章截图全部来自视频，部分是自己所画，视频连接放在最后的参考资料部分。</p>
<h1 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h1><p>DRAM：Dynamic Random Access Memory，动态随机存储器。</p>
<p>在DRAM的分类中，SDRAM（Synchronous DRAM）同步动态随机存储器在各个行业则占较大的比例。而我们经常听到的DDR（Double Data Rate SDRAM）即双倍速率SDRAM则又是SDRAM中的主要代表，本篇将着重对DDR原理进行分析</p>
<p>DRAM是程序运行的和临时数据存储的媒介，无论是计算机还是手机的参数主存大小即指的是DRAM的大小。在工作中我们其实很少区分DDR和DRAM，严格来说DDR只能是DRAM中的一种，whatever，工作中不影响正常理解和使用就好。</p>
<h1 id="DDR-SDRAM"><a href="#DDR-SDRAM" class="headerlink" title="DDR SDRAM"></a>DDR SDRAM</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Wiki：<a href="https://en.wikipedia.org/wiki/DDR_SDRAM">英文</a>；<a href="https://zh.m.wikipedia.org/wiki/DDR_SDRAM">中文</a></p>
</blockquote>
<ul>
<li><p>DDR SDRAM：Double Data Rate Synchronous Dynamic Random Access Memory，双倍数据率同步动态随机存取存储器。之所以“同步”是指内存的工作需要同步时钟，命令的发送和数据的传输都要以此为基准；“动态”则是因为我们需要为其提供电压定时刷新来保证数据的完整性，掉电则数据丢失；“双倍”则是由于其在时钟的上升沿和下降沿都可以进行数据的传输</p>
</li>
<li><p>LPDDR SDRAM：Low-Power Double Data Rate SDRAM，是一种功耗较低的同步动态随机存取存储器，主要用于移动计算机和手机等设备。较旧的变体也称为移动 DDR，缩写为 mDDR。现代 LPDDR SDRAM 与DDR SDRAM截然不同，具有多种差异，甚至LPDDR 技术标准是独立于 DDR 标准开发的。（本篇不对此做详细说明）</p>
</li>
</ul>
<h2 id="各版本参数对比"><a href="#各版本参数对比" class="headerlink" title="各版本参数对比"></a>各版本参数对比</h2><table>
<thead>
<tr>
<th align="center">DDR SDRAM Standard</th>
<th align="center">Bus clock (MHz)</th>
<th align="center">Internal rate (MHz)</th>
<th align="center">Prefetch (min burst)</th>
<th align="center">Transfer Rate (MT/s)</th>
<th align="center">Voltage</th>
<th align="center"><a href="https://zh.m.wikipedia.org/wiki/DIMM">DIMM</a> pins</th>
<th align="center"><a href="https://zh.m.wikipedia.org/wiki/SO-DIMM">SO-DIMM</a> pins</th>
<th align="center"><a href="https://zh.m.wikipedia.org/w/index.php?title=MicroDIMM&amp;action=edit&amp;redlink=1">MicroDIMM</a> pins</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>DDR</strong></td>
<td align="center">100–200</td>
<td align="center">100–200</td>
<td align="center">2n</td>
<td align="center">200–400</td>
<td align="center">2.5/2.6</td>
<td align="center">184</td>
<td align="center">200</td>
<td align="center">172</td>
</tr>
<tr>
<td align="center"><a href="https://zh.m.wikipedia.org/wiki/DDR2_SDRAM">DDR2</a></td>
<td align="center">200–533</td>
<td align="center">100–266</td>
<td align="center">4n</td>
<td align="center">400–1066</td>
<td align="center">1.8</td>
<td align="center">240</td>
<td align="center">200</td>
<td align="center">214</td>
</tr>
<tr>
<td align="center"><a href="https://zh.m.wikipedia.org/wiki/DDR3_SDRAM">DDR3</a></td>
<td align="center">400–1066</td>
<td align="center">100–266</td>
<td align="center">8n</td>
<td align="center">800–2400</td>
<td align="center">1.5</td>
<td align="center">240</td>
<td align="center">204</td>
<td align="center">214</td>
</tr>
<tr>
<td align="center"><a href="https://zh.m.wikipedia.org/wiki/DDR4_SDRAM">DDR4</a></td>
<td align="center">800–1200</td>
<td align="center">200–300</td>
<td align="center">16n</td>
<td align="center">1600–5067</td>
<td align="center">1.2</td>
<td align="center">288</td>
<td align="center">260</td>
<td align="center">214</td>
</tr>
</tbody></table>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>channel：通道，属于控制器端的概念。可以简单理解为一个通道对应一个DDR控制器，每个通道拥有一组地址线、控制线和数据线</p>
</li>
<li><p>SIMM：Single In-line Memory Module，单列内存模组。内存模组电路板与主板插槽的接口只有一列引脚</p>
</li>
<li><p>DIMM：Double In-line Memory Module，双列内存模组，主板上的一个内存插槽，内存模组电路板与主板插槽的接口有两列引脚。一个Channel可以包括多个DIMM。</p>
</li>
<li><p>Rank：CPU在一个时钟周期取数据的大小取决于数据总线的位宽（这个位宽被称为物理 Bank（Physical Bank)，通常内存颗粒都没有P-Bank大小的位宽，这时就需要多个内存颗粒组合起来满足CPU的一次访存。假设P-Bank=64bit即64位数据总线，而内存颗粒Chip的位宽是8bit，则8个chip组成了一个Rank。</p>
</li>
<li><p>Chip：1个chip大多是4bit/8bit/16bit等，多个chip组成一个rank，配合完成一次访问的位宽要求。这就是颗粒。内存颗粒共享地址和命令总线，各自有自己的数据总线</p>
</li>
<li><p>Bank：也称Logic Bank逻辑Bank，与物理bank的概念相对应。由于成本、技术以及SDRAM工作原理的限制，做一个全容量的Bank不太现实（寻址冲突），所以在寻址时需要先选中Bank，在根据行列选中数据。DDR2、DDR3已经有8个Bank </p>
</li>
<li><p>row/column：行列，存储的最小单元，每一个行列交叉点存储了1bit的数据。</p>
</li>
</ul>
<p>笼统上讲从大到小为：<strong>channel ＞ DIMM ＞ rank ＞ chip ＞ bank ＞ row/column</strong>，如下图：</p>
<p><img src="/images/Hardware/Storage/ddr-1.png" alt="image"></p>
<h2 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h2><p>SDRAM总存储容量 = 行数 x 列数 x L-Bank数量  = 存储单元个数 x 存储单元容量（4bit/8bit/16bit）</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><blockquote>
<p>Tips：判断MOS管是N沟道还是P沟道，里N外P，即箭头指向G是NMOS，反之是PMOS</p>
</blockquote>
<p>利用了电容能够保持电荷及其充放电的特性。目前市场最常用的存储1bit数据的SDRAM的结构是由一个MOS管、一个电容和两根导线组成的。电容一段连接晶体管一端另一端接地、字线连接MOS管的栅极，位线连接到晶体管通道的另一端，如下图所示：</p>
<p><img src="/images/Hardware/Storage/ddr-2.png" alt="image"></p>
<ul>
<li><p>写</p>
<p>当字线（WL）电压为逻辑1时开关打开，存储单元选通，如果此时位线（BL）为高电压，则向电容中充电，则就是向存储单元中写1；相反如果WL=1，BL=0电容放电，这就是向存储单元中写0</p>
</li>
<li><p>读</p>
<p>当字线（WL）电压为逻辑1时开关打开，此时在位线上连接电量计就可以测量电容中存储的的值。如果电容放电，那么就表示这个单元里原来存的值是 1，如果电容不放电，则表示原来的值是 0。可见当DRAM进行数据读取的时候会使存储单元中的1变成0，是有破坏性的，而实际中我们需要读出继续保持数据或电荷，后面有对此的解决办法（感应放大器）</p>
</li>
</ul>
<p>当字线关闭的时候就不进行任何读写操作了，晶体管也紧跟着被关闭，电容器与位线隔离从而保存了之前写入的数据或电荷。但是由于晶体管十分小，存储在电容器中的电荷会在通道上慢慢泄露，因此又需要另外的技术来对此进行修复（Recharge）</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>下图是对一个bank的一部分作图进行说明。行译码器、列选择复用器之所以这样设计是因为：当数据进行读写的时候，只需要打开某一个固定行（其它行关闭）即可，这样子该行所在的电容将连接到位线上，而在进行列选择的时候，由于是进行多比特的选择（4bit/8bit）所以要这里的列多路复用器相当于列中的第几组（组数*位宽）</p>
<p><img src="/images/Hardware/Storage/ddr-3.png" alt="image"></p>
<h2 id="读-x2F-写"><a href="#读-x2F-写" class="headerlink" title="读/写"></a>读/写</h2><h3 id="通用流程"><a href="#通用流程" class="headerlink" title="通用流程"></a>通用流程</h3><blockquote>
<p>预充电电压根据DDR每一代是有所不同的，但一定是充电电压的一半</p>
</blockquote>
<ol>
<li>选择bank；</li>
<li>关闭所有行；关闭所有字线，隔离所有电容</li>
<li>预充电；将所有位线的电压升值供电电压一半（DDR5：0.55V；DDR4：0.6V；DDR3：0.75V）</li>
<li>行选择；字线上电打开MOS管形成的开关，电容连接到对应的位线</li>
<li>列选择；位线通过多路复用选择器连接到数据线上</li>
</ol>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>读（保证数据不丢失）</p>
<p>行选择时，当字线选中后，该行所在的电容被连接到对应的位线。如果电容存储的数据是1（电容压差是供电电压1.1 / 1.2 / 1.4），由于位线预充电后电压至供电电压的一半，所以电荷将从电容流向位线，进而位线电压增加，这时位线下面所连接的感应放大器能感受到这种轻微的变化或扰动，并放大这一变化，将位线电压再增加到供电电压（1.1 / 1.2 / 1.4）；相反，如果存储的是0，电荷将从位线流向电容，位线电压降低，感应放大器放大这一变化，将位线电压降低至0V。这样就保证了既能够通过位线读取数据又保证电容数据不丢失</p>
</li>
<li><p>写</p>
<p>写流程与读类似，但当要写入的数据–&gt;数据总线–&gt;写驱动器器–&gt;多路选择复用器–&gt;感应放大器—&gt;位线 这样流程下来的时候，由于写驱动器的存在，它比感应放大器强大的多，这将会导致写驱动器出来的数据直接覆盖掉位线上原有的数据</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>假设32位地址总线，32个bank，65536（2^16^）行，8192（2^13^）列，8bitddr颗粒</p>
<ul>
<li>0-4，5位地址将选择某个bank</li>
<li>行关闭 + 预充电</li>
<li>5-21，16位选择某个行</li>
<li>22-31，10bit选择某个组（每一组8列，这个由L-bank位宽决定）</li>
</ul>
<h2 id="刷新Refresh"><a href="#刷新Refresh" class="headerlink" title="刷新Refresh"></a>刷新Refresh</h2><p>refresh每一行的刷新时间是50ns。而整个bank刷新的时间间隔是64ms/次（小于电荷泄露1-&gt;0的最短时间）</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>由于SDRAM最小存储单元电路形式是电容，电容是有自放电的特性。长时间存储电容电荷会漏电，故需要刷新和预充电进行补充。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>自动刷新（Auto Refresh，简称AR/REF，需要CK，CKE高）</li>
<li>自刷新（Self Refresh，简称SR/SRE-SRF，SDRAM内部产生，不依赖CK，CKE低，用于休眠模式或低功耗）</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>关闭所有行</li>
<li>预充电</li>
<li>打开行，感应放大并填充电荷</li>
<li>从第一行到最后一行重复第3步骤</li>
</ol>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><ul>
<li>CAS：Column Address Select，列地址选择</li>
<li>RAS：Row Address Select，行地址选择</li>
<li>CAS Latency：(CL）CAS延迟。指的是从行打开到到接收到存储在列中的数据的时间</li>
<li>tRCD：RAS to CAS Delay RAS-CAS延迟，激活时间。指的是在字线全部关闭，位线被预充电的情况下，打开一行所需要的时间</li>
<li>tRP：RAS Precharge Time ，行预充电时间。指的是再打开一行之前对位线进行预充电的时间</li>
<li>tRAS：激活一行和接下来预充电之间的时间</li>
</ul>
<p><img src="/images/Hardware/Storage/ddr-4.png" alt="image"></p>
<h1 id="优化-x2F-访存加速"><a href="#优化-x2F-访存加速" class="headerlink" title="优化/访存加速"></a>优化/访存加速</h1><h2 id="行命中"><a href="#行命中" class="headerlink" title="行命中"></a>行命中</h2><p>在DRAM的读写过程中，其中比较耗时的步骤应该就是行打开。</p>
<p>可以考虑这样一个场景：CPU第一次访存是在249行，第二次所需要的数据大概率也可能在249行，因此在第一次和第二次访存中间我们就可以不关闭行了，而是等到新的行访存再进行整个读写步骤。进而将一个bank内的情况推广到整个内存颗粒，每一个bank上都存在一行未关闭（即上次访存数据所在的行），而当下次访存所在的行如果打开则成为Row Hit行命中，如果没有称为Row Miss（参考【5参数】章节的图片）</p>
<h2 id="Burst-Buffer"><a href="#Burst-Buffer" class="headerlink" title="Burst Buffer"></a>Burst Buffer</h2><p>Burst：突发，是指在同一行中相邻的存储单元连续进行数据传输的方式，连续传输所涉及到存储单元（列）的数量就是突发长度（Burst Lengths，简称 BL）。 </p>
<p>如果所示就是两个128bit的burst buffer，上端连接列选择即数据段，下面连接读写驱动器。人们只要指定起始列地址与突发长度，内存就会依次地自动对后面 相应数量的存储单元进行读/写操作而不再需要控制器连续地提供列地址。这样，除了第一笔数据的传输需要若干个周期（主要是之前的延迟，一般的是 tRCD+CL）外，其后每个数据只需一个周期的即可获得。</p>
<p>至于 BL 的数值，也是不能随便设或在数据进行传输前临时决定。一定要参考相应的数据手册进行设置，比较常见的设定是 4 和 8。</p>
<p><img src="/images/Hardware/Storage/ddr-5.png" alt="image"></p>
<h2 id="感应放大器"><a href="#感应放大器" class="headerlink" title="感应放大器"></a>感应放大器</h2><ul>
<li><p>优化方式</p>
<p>让每一个感应放大器上由两个位线连接到其上，让交替排列的存储单元分别连接在左侧和右侧的位线。交叉耦合反相器的存在使得一半的位线处于1，另一半处于0，这被称为差分对</p>
</li>
<li><p>好处：</p>
<ol>
<li>预充电时，由于差分对两侧一边是0，一边是1，所以断开两个反相器然后通过三极管将两个位线连接，电压将降低到中值</li>
<li>抗噪音</li>
<li>减少位线寄生电容</li>
</ol>
</li>
</ul>
<p><img src="/images/Hardware/Storage/ddr-6.png" alt="image"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote>
<p>1、2链接为同一视频，区别在于1是Youtube英文版，2是B站中文译版</p>
</blockquote>
<ol>
<li><a href="https://www.youtube.com/watch?v=7J7X7aZvMXQ&amp;t=831s">How does Computer Memory Work?</a></li>
<li><a href="https://www.bilibili.com/video/BV1vP411c7pt/?s">计算机如何工作？</a></li>
<li><a href="https://www.bilibili.com/video/BV1ZZ4y1M79G/">SDRAM与DDR2存储器原理详解【FPGA应用场景】</a></li>
<li><a href="http://www.bdtic.com/datasheet/Micron/64Mb_x4_x8_x16SDRAM.pdf">美光SDRAM MT48LC2M32B2TG-7 数据手册</a></li>
</ol>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>DDR</tag>
      </tags>
  </entry>
  <entry>
    <title>Flash</title>
    <url>/2023/05/08/Hardware/Storage/Flash/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Flash Memory闪存，一种非易失性存储器，断电数据也不会丢失。早期的闪存进行一次抹除，就会清除掉整颗芯片上的数据，但目前已可以精确到对指定的区域进行删除。闪存允许在操作中被多次擦或写的存储器，这种科技主要用于一般性数据存储，以及在计算机与其他数字产品间交换传输数据。SmartMedia（SM卡）、Compact Flash（CF卡)）、MultiMediaCard（MMC卡）、Secure Digital（SD卡）都属于闪存</p>
<p>闪存Flash也被认为是一种EEPROM（电可擦除可编程只读存储器），而区别在于传统的EEPROM以字节为单位进行擦写，而Flash则实现了以块为单位进行擦写。</p>
<h2 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h2><blockquote>
<p>NOR NAND命名：取用了电路逻辑运算中的或非（Not OR）和与非（Not AND）</p>
</blockquote>
<p>Flash在大类上区分可以认为有两种规格：NOR Flash和NAND Flash</p>
<p>1984年，东芝公司的发明人舛冈富士雄首先提出了闪存的概念。而在四年后1988年，做存储起家的Intel推出了世界第一款Nor Flash芯片，它结合EPROM(可擦除可编程只读存储器)和EEPROM(电可擦除可编程只读存储器)两项技术，并拥有一个SRAM接口，从此也彻底打破了EPPRON和EPROM一统天下的局面。</p>
<p>1989年，东芝公司发表了NAND Flash 结构，强调降低每比特的成本，有更高的性能，并且像磁盘一样可以通过接口轻松升级。因此NAND Flash并被认为是NOR闪存的理想替代者。鉴于其出色的性价比，它常常被应用于诸如CompactFlash、SmartMedia、 SD、 MMC等存储卡上。</p>
<p>1997年西门子和 Sandisk 推出MMC（Multi Media Card，多媒体卡） ，而在1999年基于MMC发展而来的SD（Secure Digital Memory Card）卡首次由松下、东芝和 Sandisk 公开发布，二者最初的外观尺寸也很类似，SD 卡比 MMC 卡厚 0.7mm。但是随着移动互联网时代的到来，对的存储芯片提出了更高的要求：高容量、高稳定性和高读写速度的同时要求拥有更小存储空间，因此eMMC（Embedded Multi Media Card）应运而生。简单来理解 <em><strong>eMMC = NAND Flash + 闪存控制芯片 + 标准接口封装</strong></em></p>
<h2 id="NAND-Flash分类"><a href="#NAND-Flash分类" class="headerlink" title="NAND Flash分类"></a>NAND Flash分类</h2><ul>
<li>不带控制器<ul>
<li>RAW NAND，可焊接在PCB上</li>
</ul>
</li>
<li>带控制器<ul>
<li>模组（可插拔）<ul>
<li>TF / SD</li>
<li>SSD</li>
</ul>
</li>
<li>芯片（可焊接）<ul>
<li>SD NAND</li>
<li>eMMC</li>
<li>SPI NAND</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="/images/Hardware/Storage/flash.png" alt="image"></p>
<p>​																		（图片来自 <a href="https://www.bilibili.com/video/BV1hV411H76e/">郭天祥老师B站课程</a>）</p>
<p>NOR Flash 与 NAND Flash都是用三端器件作为存储单元，分别为源极、漏极和栅极，与场效应管的工作原理 相同，主要是利用电场的效应来控制源极与漏极之间的通断，栅极的 电流消耗极小，不同 的是场效应管为单栅极结构，而 FLASH 为双栅极结构，在栅极与硅衬底之间增加了一个浮置栅极。</p>
<p>写入：S接0V（地），D接6V，当PN结超过一定电压出现雪崩击穿，电子从S流向D。Gc端有12V脉冲，与此同时Gc与衬底之间也有场强，电子也会穿过氧化层到浮栅区。（氧化隧道区的存在保证了数据不容易流失）</p>
<p>擦除：S 接12V，Gc 接0v，此时源极栅极两端形成场强，电子从浮栅区经过隧道区流向衬底</p>
<p>通过上述描述可以发现数据存储的关键在于浮栅层，当其中充满电子代表写入状态，代表二进制0；相反，没有电子代表擦除状态，代表二进制1（S—-&gt;D没有电流0，说明有电子；S—–&gt;D有电流1，说明没有电子）</p>
<h1 id="NOR-x2F-NAND特点"><a href="#NOR-x2F-NAND特点" class="headerlink" title="NOR/NAND特点"></a>NOR/NAND特点</h1><table>
<thead>
<tr>
<th></th>
<th>NOR</th>
<th>NAND</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>接口</td>
<td>数据线地址线分开</td>
<td>数据线地址线共用</td>
<td>最大区别</td>
</tr>
<tr>
<td>介质类型</td>
<td>随机存储</td>
<td>连续存储</td>
<td></td>
</tr>
<tr>
<td>读写单元</td>
<td>基于字节</td>
<td>基于页</td>
<td></td>
</tr>
<tr>
<td>擦除单位</td>
<td>扇区</td>
<td>块</td>
<td></td>
</tr>
<tr>
<td>读速度</td>
<td>稍快</td>
<td>稍慢</td>
<td></td>
</tr>
<tr>
<td>写速度</td>
<td>慢</td>
<td>快</td>
<td></td>
</tr>
<tr>
<td>单个cell成本</td>
<td>高</td>
<td>低</td>
<td></td>
</tr>
<tr>
<td>坏块</td>
<td>较少</td>
<td>较多</td>
<td></td>
</tr>
<tr>
<td>寿命</td>
<td>长</td>
<td>短</td>
<td></td>
</tr>
<tr>
<td>是否支持XIP片内执行</td>
<td>支持</td>
<td>不支持</td>
<td></td>
</tr>
</tbody></table>
<h2 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h2><ul>
<li>先擦后写，即写数据前必须将芯片对应内容清空。只不过NOR Flash芯片只用擦写一个字，而NAND需要擦写整个块</li>
<li>闪存存放数据必须使用算法实现</li>
<li>擦除次数有限</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="接口（读性能）"><a href="#接口（读性能）" class="headerlink" title="接口（读性能）"></a>接口（读性能）</h3><p>NOR Flash带有SRAM接口，有足够的地址引脚来寻址，可以直接和CPU相连，CPU可以直接通过地址总线对NOR Flash进行访问，可以很容易地存取其内部的每一个字节。因此使用NOR Flash不需要建立文件系统，因为可以直接用地址访问到数据</p>
<p>NAND Flash器件使用复杂的I/O口来串行地存取数据，只能通过I/O接口发送命令和地址，对NAND Flash内部数据进行访问，当然各个产品或厂商的方法可能各不相同。</p>
<p>由于具有这样的接口就导致NOR Flash的读性能是要稍高于NAND Flash的</p>
<h3 id="擦除速度（写性能）"><a href="#擦除速度（写性能）" class="headerlink" title="擦除速度（写性能）"></a>擦除速度（写性能）</h3><p>任何flash器件的写入操作只能在空或已擦除的单元内进行，所以大多数情况下，在进行写入操作之前必须先执行擦除。</p>
<p>NAND器件执行擦除操作是十分简单的，而NOR则要求在进行擦除前先要将目标块内所有的位都写为0。由于擦除NOR器件时是以64～128KB的块进行的，执行一个写入/擦除操作的时间为5s，与此相反，擦除NAND器件是以8～32KB的块进行的，执行相同的操作最多只需要4ms。NAND闪存的写周期比NOR闪存短90%，它的保存与删除处理的速度也相对较快。</p>
<h3 id="容量及成本"><a href="#容量及成本" class="headerlink" title="容量及成本"></a>容量及成本</h3><p>NOR flash占据了容量为1～16MB闪存市场的大部分，而NAND flash只是用在8～128MB的产品当中</p>
<p>NOR Flash的成本相对高，容量相对小；NAND flash的单元尺寸几乎是NOR器件的一半，由于生产过程更为简单，NAND结构可以在给定的模具尺寸内提供更高的容量，也就相应地降低了价格。</p>
<h3 id="寿命（耐用性）"><a href="#寿命（耐用性）" class="headerlink" title="寿命（耐用性）"></a>寿命（耐用性）</h3><p>在NAND闪存中每个块的最大擦写次数是一百万次，而NOR的擦写次数是十万次。NAND存储器除了具有10比1的块擦除周期优势，典型的NAND块尺寸要比NOR器件小8倍，每个NAND存储器块在给定的时间内的删除次数要少一些。</p>
<p>由于NAND Flash通常是整块擦写，块内的页面中如果有一位失效整个块就会失效，而且由于擦写过程复杂，失败的概率相对较高，所以从整体上来说NOR的寿命较长。</p>
<h3 id="数据正确性"><a href="#数据正确性" class="headerlink" title="数据正确性"></a>数据正确性</h3><p>所有flash器件都受<em><strong>位交换现象</strong></em>的困扰。在某些情况下，一个比特位会发生反转或被报告反转了。这个问题对于用NAND存储多媒体信息时倒不是致命的。当然，如果用本地存储设备来存储操作系统、配置文件或其他敏感信息时，将可能导致停机。如果只是报告有问题，多读几次就可能解决了。当然，如果这个位真的改变了，就必须采用错误探测/错误更正(EDC/ECC)算法。</p>
<p>这些问题常发生在NAND Flash中，除此之外它还需要始终进行坏块扫描，一旦发现标记为不可用</p>
<h3 id="软件支持"><a href="#软件支持" class="headerlink" title="软件支持"></a>软件支持</h3><p>NAND和NOR器件在进行写入和擦除操作时通常都需要MTD（Memory Technology Drivers）驱动，只是NOR使用的较少一些。许多厂商都提供用于NOR器件的更高级软件，这其中包括M-System的TrueFFS驱动。</p>
<p>其作用还包括NAND闪存的管理，包括纠错、坏块处理和损耗平衡。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>一般使用原则是：在大容量的多媒体应用中选用NAND型，而在数据/程序存贮应用中选用NOR。NOR flash占据了容量为1～16MB闪存市场的大部分（嵌入式领域），而NAND flash只是用在8～128MB的产品当中（视频监控、网络监控、网络终端等等大容量场景）</p>
<h1 id="eMMC特点"><a href="#eMMC特点" class="headerlink" title="eMMC特点"></a>eMMC特点</h1><p>eMMC 采用统一的MMC标准接口， 把高密度NAND Flash以及MMC Controller封装在一颗BGA芯片中（在原有内置存储器的基础上，又额外加了一个控制芯片，最后再以统一的方式封装，并预留一个标准接口，以便客户拿来直接使用）。针对Flash的特性，产品内部已经包含了Flash管理技术，包括错误探测和纠正，flash平均擦写，坏块管理，掉电保护等技术。用户无需担心产品内部flash晶圆制程和工艺的变化。同时eMMC单颗芯片为主板内部节省更多的空间。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>容量大</li>
<li>速度快</li>
<li>兼容性好</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>成本高。eMMC主流起跳容量16GB，客户即使只用128MB，也需要付出16GB的成本。</li>
<li>尺寸大。11.5*13的尺寸对于很多穿戴式或者物联网设备来说还是太大了。</li>
<li>Pin脚多，不方便焊接。eMMC是BGA153封装，153个pin脚，pin间距0.5mm。焊接是个问题，特别是PCB板比较小的时候。另外使eMMC必须要用4层板。</li>
<li>通用性。对于新推出的大核CPU来说，基本都支持eMMC。但物联网由于使用场景限制，很多还是采用MCU平台。而这些平台基本都不支持eMMC接口。</li>
<li>擦写寿命。主流eMMC内部采用都是TLC NAND, 擦写寿命只有500次左右。在需要频繁擦写的应用场景会比较吃力。</li>
</ul>
<h2 id="未来发展"><a href="#未来发展" class="headerlink" title="未来发展"></a>未来发展</h2><ul>
<li>大小：物联网嵌入式的更高需求导致eMMC需要做的更小</li>
<li>容量：128GB算是eMMC最大容量了。更高容量产品会切换到UFS。</li>
<li>接口：eMMC 是针对手机或平板电脑等产品的内嵌式存储器标准规格，目前市场上主流手机都采用eMMC 5.0规格的闪存标准。但是未来eMMC接口慢慢会切换到UFS接口。UFS的接口有着更快的读写性能。目前新推出的主流手机和平板产品都已经采用了UFS接口内部材质：市面上还是少量有MLC晶圆的eMMC，主要针对行业市场。</li>
</ul>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：分别擦除NAND、eMMC读数据分别是1，0；eMMC属于NAND，为什么读出的数据不一致呢</p>
<p>A：原因就在于eMMC内部存在控制器</p>
</li>
<li><p>Q：flash数据掉电丢失？</p>
<p>A：flash在掉电时，会存在一段电压区间，工作不稳定，可能导致数据丢失。写保护是nor提供的功能，即可以通过配置一些寄存器，将某些区域保护起来。如果没有解除保护，那对这个区域的写入和擦除，都会被直接忽略掉。</p>
</li>
<li><p>换nor flash之后无法正常启动？</p>
<p>对于串口没有打印的情况：通信两端的波特率不一致</p>
<p>打印出现乱码或者读出的数据不正确：flash的数据没有写入或者没有重启还不能读，导致读出的错误，延长reset的delay时间</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://www.21ic.com/a/916024.html">闪存的发展历史</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_38880380/article/details/78884522">NAND flash和NOR flash的区别详解</a></p>
</li>
<li><p><a href="https://www.sohu.com/a/483186780_121149658">必看“芯”知识：最全NAND flash与NOR flash详情解读</a> </p>
</li>
<li><p><a href="http://www.longsto.com/news/28.html">详解eMMC的前世今生和优劣势</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>Flash</tag>
      </tags>
  </entry>
  <entry>
    <title>MESI协议的优化与内存屏障</title>
    <url>/2023/03/06/Hardware/Storage/MESI%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>无论是计算机硬件还是软件，新的技术的出现的初衷一定是为了解决某项需求，而随之而来的可能会带来新的问题，无所谓解决就是了！</p>
<h1 id="MESI带来的性能问题"><a href="#MESI带来的性能问题" class="headerlink" title="MESI带来的性能问题"></a>MESI带来的性能问题</h1><p>从本质上来讲MESI协议解决的是数据的核间同步问题，但是严格遵守MESI协议一定又会带来新的问题。以下两种情况会再次带来性能问题：</p>
<ol>
<li>更新Shared状态的Cache。当某个缓存行的状态是Shared时，CPU想要修改该缓存行的数据，一定会产生总线事件通知其它CPU将该缓存行副本状态置Invalid，当拥有该缓存行副本的CPU确认并回复它“Invalid acknowledgement”以后，它才能进行数据更新。</li>
<li>更新Invalid状态的Cache。当某个缓存行的状态是Invalid时，CPU想要修改该缓存行的数据，一定会产生总线事件从其它CPU甚至是主存中加载进最新数据，进而基于最新数据进行更新。</li>
</ol>
<h1 id="MESI协议优化"><a href="#MESI协议优化" class="headerlink" title="MESI协议优化"></a>MESI协议优化</h1><p>MESI协议以上两个痛点可以发现是由于事务串行化所带来的负面影响。所以解决这两个问题的关键就是使MESI协议的请求异步化，释放总线提高并行度。因而就有了在硬件上增加写缓存区和失效队列两种方法。</p>
<h2 id="写缓冲-Store-Buffer"><a href="#写缓冲-Store-Buffer" class="headerlink" title="写缓冲 Store Buffer"></a>写缓冲 Store Buffer</h2><p><img src="/images/Hardware/Storage/cache-9.png" alt="image"></p>
<p>基于之前的缓存结构，增加完Store Buffer之后的结果如上图所示。</p>
<p>整个同步过程：CPU想要修改某个缓存数据，首先通过总线广播获得总线所有权，发出信号通知其它CPU需要将该缓存块数据置无效，然后将需要更新的数据放入到Store Buffer。而此时就可以释放总线所有权去做其它的事情不用等待收到ACK（效率提高在此），等其它cpu都收到再由Store Buffer慢慢做核间同步，刷入Cache的值即可</p>
<p>当CPU读数据时，首先会先在Store Buffer中查询记录是否存在，如果存在则会从写缓冲区中直接获取，这一机制即是 Store Fowarding。</p>
<h2 id="失效队列-Invalid-Queue"><a href="#失效队列-Invalid-Queue" class="headerlink" title="失效队列 Invalid Queue"></a>失效队列 Invalid Queue</h2><p><img src="/images/Hardware/Storage/cache-10.png" alt="image"></p>
<p>在Store Buffer基础之上，增加完Invalid Queue之后的结构如上图所示</p>
<p>失效队列的存在可以说是更好的使Store Buffer工作。当CPU收到使某个缓存行失效的请求时，如果迟迟不回复ACK则可能导致Store Buffer里数据越来越多最终溢出，因此Invalid Queue的存在可以说是为了平衡Store Buffer写入速度和收到ACK速度</p>
<p>过程：当CPU Core收到使某个cache失效的消息时，先回复确认收到的消息，然后将失效的数据加入到Invalidate Queue中。而队列的实失效的操作等待空闲时候在进行处理。</p>
<h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><h2 id="MESI优化之后带来的问题"><a href="#MESI优化之后带来的问题" class="headerlink" title="MESI优化之后带来的问题"></a>MESI优化之后带来的问题</h2><p>MESI协议本身属于强一致性协议，但是经过性能的优化变成了弱一致性协议，这就导致在某些中间状态下多核CPU的数据可能并不一致。</p>
<h3 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h3><p>由于Store Buffer的引入将部分事务变成并行，这就将导致数据的更新顺序将不会严格按照代码顺序执行，进而导致其它CPU拿到正确数据的时机延后。例如：CPU需要顺序执行A、B两条写指令，A在CPU0的缓存行状态是S，B在CPU0的缓存行状态是E，最终的cache对于两条指令所对应的两个数据的更新的顺序可能不是我们所期望的</p>
<h3 id="Invalid-Queue"><a href="#Invalid-Queue" class="headerlink" title="Invalid Queue"></a>Invalid Queue</h3><p>CPU1在回复ACK之后实际并没有对数据所在的缓存行置Invalid，而是放入到队列中。假如此刻CPU0更新了缓存行这将导致该数据在两个核的cache上表现不一致</p>
<h3 id="Reorder"><a href="#Reorder" class="headerlink" title="Reorder"></a>Reorder</h3><p>指令重排序从源头上就造成了指令实际执行的顺序与我们代码所期望执行的顺序存在差别。而Reorder设计的本质实际上是为了对我们的代码进行优化，提高cache命令率从而提高执行效率</p>
<ul>
<li>编译器重排序</li>
<li>CPU乱序执行</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>其实对于以上MESI优化带来的问题归根结底是在多核CPU上导致最终结果的偏差。进一步思考是多核CPU同时修改同一个变量时而引发的问题，而在实际过程中这种情况是比较少的。在效率和极少数数据不正确两者的考量下，继续基于此进行优化，但是不是硬件优化而是通过软件由程序员保证数据的一致性。因此在需要核间的同步的情况下，多线程对于数据的修改和对于数据的使用需要引起注意，在适当的地方添加内存屏障</p>
<p>内存屏障（Memory Barriers）其实可以理解为一道墙，前面的读写操作没有完成后面的读写操作不能发生</p>
<h2 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h2><p>本质：读屏障前后指令的读操作不能翻越屏障！强制CPU在屏障前的读操作处理到所有Invalid Queue中的数据，获取到最新的数据。</p>
<h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>本质：写屏障前后指令的写操作不能翻阅屏障！强制CPU在屏障前的写操作清空Store Buffer内容，将数据更新至cache甚至主存</p>
<h2 id="读写屏障"><a href="#读写屏障" class="headerlink" title="读写屏障"></a>读写屏障</h2><p>以上两种屏障只有在区分读写屏障的体系结构里才会有作用，比如 alpha 结构。而在 X86 和 Arm 中是没有作用的，这是因为 X86 采用的 TSO 模型不存在缓存一致性的问题，而 Arm 则是采用了另一种称为单向屏障的分类方式。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/375706879">缓存一致性硬核讲解</a></li>
<li>编程高必学的内存知识（极客时间 海纳）</li>
</ul>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机存储体系</title>
    <url>/2023/02/07/Hardware/Storage/%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>作为计算机五大核心功能（运算、存储、控制、输入、输出）之一的存储，无疑在整个计算机体系结构中有着举足轻重的地位。</p>
<p>存储器属于计算机的记忆装置，用于存放程序和数据。在我看来程序是作为计算机的灵魂而存在的，它指导了计算机的一切行为，而数据则是这一切行为的基石。</p>
<p>本文将基于存储器对计算机的存储系统做简要介绍</p>
<h1 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h1><p><img src="/images/Hardware/Storage/storage-0.png" alt="image"></p>
<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="/images/Hardware/Storage/storage-1.png" alt="image"></p>
<h2 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h2><p>通过存储器分类图不难看出存储器的种类繁多，而如何合理的使用每一种存储器组成庞大的存储体系结构无不体现着工程师们的智慧。</p>
<p>存储系统设计的核心问题在于：<strong>成本（存储1bit）、容量、速度三者平衡</strong>。恰好这三者之间又是相互矛盾的，主要体现在：容量越高，成本越低，而速度越慢；速度越块，成本就越高（其它情况可根据 2.2金字塔章节 理解），因此平衡成了关键。因此存储体系结构设计目的可总结为：将各种不同的器件组合成一个体系，让各种器件扬长避短，从而形成一种快速、大容量、低成本的内存系统</p>
<p>通过优化存储系统的组织来使得针对典型应用平均访存时间最短</p>
<h2 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h2><p><img src="/images/Hardware/Storage/storage-2.png" alt="image"></p>
<p>越靠近金字塔顶，距离处理器越近，访问速度就越快，造价也就越高，同时容量也会更小</p>
<table>
<thead>
<tr>
<th></th>
<th>存储器种类</th>
<th>硬件（存储1bit）</th>
<th>速度</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>触发器</td>
<td>十几个晶体管</td>
<td>300ps</td>
</tr>
<tr>
<td>缓存</td>
<td>sram</td>
<td>6个晶体管</td>
<td>L1-1ns；L2-10ns</td>
</tr>
<tr>
<td>内存</td>
<td>dram</td>
<td>1个mos管+1个电容</td>
<td>100ns</td>
</tr>
<tr>
<td>硬盘</td>
<td>flash/磁性存储…</td>
<td>/</td>
<td>SSD-25us；HDD-5ms</td>
</tr>
</tbody></table>
<p>通过表格可以发现内存的组成有电容的存在，因此不再是单纯的逻辑电路更不能用CMOS工艺制造，而SRAM却可以。这也就是为什么缓存可以集成到芯片内部，而内存是和芯片分开制造的。</p>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Storage</category>
      </categories>
  </entry>
  <entry>
    <title>缓存一致性协议</title>
    <url>/2023/03/06/Hardware/Storage/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="导语-cache、主存与CPU的通信"><a href="#导语-cache、主存与CPU的通信" class="headerlink" title="导语 - cache、主存与CPU的通信"></a>导语 - cache、主存与CPU的通信</h1><p><img src="/images/Hardware/Storage/cache-6.png" alt="image"></p>
<p>如图所示，私有Cache是每个处理器核心所特有的比如L1、L2，共享 Cache是所有处理器核心的共享缓存比如L3，而整体Cache与主存的数据交互是要通过总线进行的。当两个核加载了主存的同一块缓存副本，其中一个核进行了数据的更改，是否要写入主存？是否要通知给其它CPU核心进行修改？因此对于多核CPU来讲，缓存在提高效率的同时也带来了缓存一致性的问题，而这个问题是需要进行解决的</p>
<h1 id="核心需求"><a href="#核心需求" class="headerlink" title="核心需求"></a>核心需求</h1><p>缓存一致性核心核心需要解决的问题就是：<strong>将本CPU更新的数据有效的传播到其它CPU本地缓存中</strong></p>
<p>进一步可以总结成需要遵从两个特性</p>
<ol>
<li>写传播：CPU Core的对内存的写操作，其它CPU Core可见</li>
<li>事务串行化：其它CPU Core看到的内存的写操作的顺序是一致的</li>
</ol>
<p>写传播可以保证修改的数据能够传播给其它CPU，而事物串行化则保证数据在其它CPU内的正确性。比如CPU有3个Core，Core1将x修改为3，Core2将数据修改为5，两个事务需要同步到Core3同时Core1 Core2互相同步，如果不保证串行，最终的数据很大概率是错误的</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h2><p><a href="https://www.inf.ed.ac.uk/teaching/courses/pa/Notes/lecture05-snooping.pdf">嗅探一致性协议</a></p>
<p> 总线除了能在一个主模块和一个从模块之间传输数据，还支持一个主模块对多个从模块写入数据，这种操作就是广播。</p>
<p>写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心，最常⻅实现的方式是总线嗅探(<strong>Bus Snooping</strong>)。当某个CPU Core的缓存行有更新时，需要将所有的读写操作广播到所有 CPU Core，而虽然总线上其它CPU Core的私有缓存不一定有对应的缓存行，但也要时刻监视或侦听总线，以验证它是否具有所请求数据块的副本，如果存在使对应的缓存副本失效或更新。使用广播的方式看似一视同仁，实际这样做大大增加了总线的负担。</p>
<h2 id="Directory-based-机制"><a href="#Directory-based-机制" class="headerlink" title="Directory-based 机制"></a>Directory-based 机制</h2><p><a href="https://courses.cs.washington.edu/courses/cse471/00au/Lectures/luke_directories.pdf">基于目录的缓存一致性协议</a></p>
<p>针对总线嗅探的缺点，<strong>Directory-based 机制</strong>采点对点的传播，基于目录机制总线事件只会传给自己感兴趣的CPU。这是因为所有缓存行的信息，都被记录在 directory 中。比如会记录每个缓存行当前都在那些核的缓存中，直接将缓存行修改的消息发送到那些核。这么做的也有个缺点是每次总线的传输都到 directory 做一次检查，产生耗时。</p>
<h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p>总线的独占性要求同一时刻最多只有一个主模块占用总线，天然地会将所有核心对内存的读写操作串行化。如果多个核心同时发起总线事务，此时总线仲裁单元会对竞争做出仲裁，未获胜的事务只能等待获胜的事务处理完成后才能执行。对于写缓存来讲，多核并发的写事件会通过<strong>总线仲裁机制</strong>转换成串行化的写事件序列</p>
<h2 id="缓存写策略"><a href="#缓存写策略" class="headerlink" title="缓存写策略"></a>缓存写策略</h2><ul>
<li>写分配 Write Allocate：要写入的数据不在缓存中，需要将该数据对应的内存块读入缓存；</li>
<li>写不分配 Write Not Allocate：要写入的数据不在缓存中，无需将该数据对应的内存块读入缓存，而是直接写入主存；</li>
<li>写穿 Write Through：写入缓存到的数据立马传播到主存；</li>
<li>写回 Write Back：写入缓存的数据不会立马传播到主存，而是该缓存块被替换时才更新；</li>
<li>写更新 Write Update：每次缓存写入新值，发起一次总线请求，通知其它CPU如果拥有该缓存块的副本就更新为新的值（需要传新的值）</li>
<li>写无效 Write Invalid：每次缓存写入新值，发起一次总线请求，通知其它CPU如果拥有该缓存块副本置为无效状态，如果未来需要在来要新的值（不需要传新的值）</li>
</ul>
<h1 id="缓存一致性协议种类"><a href="#缓存一致性协议种类" class="headerlink" title="缓存一致性协议种类"></a>缓存一致性协议种类</h1><blockquote>
<p> 该表格翻译自 <a href="https://people.eecs.berkeley.edu/~pattrsn/252F96/Lecture18.pdf">Snooping vs. Directory Based Coherency</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>名字</th>
<th>协议类型</th>
<th>内存写策略</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>Write Once</td>
<td>写无效</td>
<td>第一次写之后写回</td>
<td>First snoopy protocol</td>
</tr>
<tr>
<td>Synapse N+1</td>
<td>写无效</td>
<td>写回</td>
<td>1st cache-coherent MPs</td>
</tr>
<tr>
<td>Berkeley</td>
<td>写无效</td>
<td>写回</td>
<td>伯克利 SPUR</td>
</tr>
<tr>
<td>Illinois</td>
<td>写无效</td>
<td>写回</td>
<td>SGI Power and Challenge</td>
</tr>
<tr>
<td>“Firefly”</td>
<td>写广播（写更新)</td>
<td>写回私有，写穿共享</td>
<td>SPARCCenter 2000</td>
</tr>
<tr>
<td>MESI</td>
<td>写无效</td>
<td>写回</td>
<td>奔腾，PowerPC</td>
</tr>
</tbody></table>
<h1 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过缓存一致性协议的种类核应用场景来看，MESI应用在Intel奔腾处理器和PowerPC上，可以说有着很广泛的应用了。</p>
<p>MESI是四个单词的首字母缩写（Modified，Exclusive，Shared， Invalid），这四个单词代表了四种状态。因此可以缓存行可以用2bit来唯一表征这四种状态的某一种状态。</p>
<ul>
<li>M：Modified，被修改的（也可以称为Dirty 脏的）。当前CPU对应的该缓存行数据被修改，拥有最新数据（private, != Memory）</li>
<li>E：Exclusive，独享的。该缓存行只存在于当前CPU中，并且数据有效（干净）(private, =Memory))</li>
<li>S：Shared，共享的。该缓存行也存在于其它CPU中，并且数据有效（干净）(shared, =Memory)</li>
<li>I：Invalid，无效的。当前CPU内的该缓存行数据失效(NULL)</li>
</ul>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><blockquote>
<p>本部分基于进行重新梳理</p>
</blockquote>
<h3 id="来自处理器的请求"><a href="#来自处理器的请求" class="headerlink" title="来自处理器的请求"></a>来自处理器的请求</h3><ul>
<li>PrRd：处理器请求读一个缓存块</li>
<li>PrWt ：处理器请求写一个缓存块</li>
</ul>
<p><img src="/images/Hardware/Storage/cache-7.png" alt="image"></p>
<ul>
<li><p>M：唯一且数据！=memory（最新数据）。读写依然是最新数据（！= memory）</p>
</li>
<li><p>E：唯一且数据=memory。读不影响状态，写则与主存数据不一致置M</p>
</li>
<li><p>S：共享且数据=memory。读不影响状态，写则将拥有最新数据置M，同时产生总线事务通知其它处理器要写该缓存</p>
</li>
<li><p>I：无效的，一定Cache Miss。读首先将数据加载进缓存，产生BusRd的总线事务，内存控制器响应请求，同时如果发现其它处理器也拥有该缓存块副本则置S，如果没有置E；写则产生BusRdx的总线事务，由于拥有最新数据状态置M</p>
</li>
</ul>
<h3 id="来自总线（其它处理器）的请求"><a href="#来自总线（其它处理器）的请求" class="headerlink" title="来自总线（其它处理器）的请求"></a>来自总线（其它处理器）的请求</h3><ul>
<li><p>BusRd：总线侦听到其它处理器请求读一个缓存块</p>
</li>
<li><p>BusRdX：总线侦听到其它处理器请求写一个自己没有缓存副本的缓存块</p>
</li>
<li><p>BusUpgr：总线侦听到其它处理器请求写本地缓存（该处理器拥有的缓存块）</p>
</li>
<li><p>Flush：总线侦听到其它处理器请求写回一个缓存块到主存（cache to memory）</p>
</li>
<li><p>FlushOpt：总线侦听到其它处理器请求将一个缓存块通过总线的方式发送另外一个处理器（cache to cache）</p>
<p><img src="/images/computerSystem/storage/cache-8.png" alt="image"></p>
</li>
<li><p>M：唯一且数据！=memory（最新数据）。 BusRd说明其它处理器要读，则需要写传播将数据写到主存，因为其它处理器读所以数据=memory且共享置状态S；当BusRdx或BusUpgr说明其它处理器要写，这两种情况无论发起请求的处理器有没有缓存一定不是最新的所以一定产生Flush的总线事务，并且其它处理器写完就不是最新的了置I</p>
</li>
<li><p>E：唯一且数据=memory。BusRd说明其它处理器要读，我的数据已经是最新的了所以产生FlushOpt总线事务，将该缓存块传走并置状态S；其它处理器写最终结果一定是我的私有缓存无效置I，但是如果发起总线事务的处理器没有该缓存我需要产生FlushOpt的总线事务将数据传输，否则不产生总线事务</p>
</li>
<li><p>S：共享且数据=memory。BusRd说明其它处理器要读，我的数据是最新的了所以产生FlushOpt总线事务，将该缓存块传走保持S状态；其它处理器写最终结果一定是我的私有缓存无效置I，但是如果发起总线事务的处理器没有该缓存我需要产生FlushOpt的总线事务将数据传输，否则不产生总线事务</p>
</li>
<li><p>I：无效的。各种读写情况都不会影响，继续保持状态</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《编程高手必学的内存知识》极客时间海纳</li>
<li><a href="https://juejin.cn/post/6844903965696458765">cache一致性里的MESI协议</a></li>
<li><a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm">MESI动画</a></li>
</ul>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache简介</title>
    <url>/2023/02/15/Hardware/Storage/%E7%BC%93%E5%AD%98%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>随着技术的不断进步，芯片制程和工艺有了极大的发展，相应的CPU的计算能力越来越强。作为程序员，我们希望有无线资源的快速存储器可以使用，但是快速存储器的成本非常高昂，因此访存变成了计算机系统的性能瓶颈。为了平衡cpu运行速度与访存速度之间的差异缓存被设计出来！</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>缓冲存储器，简称缓存(cache)，用于存储可能频繁访问的数据。</p>
<p>缓存结合了寄存器速度快和内存造价低的优点，因此通过缓存的设计使整个存储系统的性能接近寄存器，并且每字节的成本都接近内存，甚至是磁盘。</p>
<p>高速缓存的工作就是将内存中最近读写过的数据在高速缓存中保留一个<strong>备份</strong>，使这些数据能够快速地返回给CPU</p>
<h1 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h1><blockquote>
<p>本节内容大多取自极客时间，《编程高手必学的内存知识》海纳</p>
</blockquote>
<p>缓存的组成单元是SRAM，而目前SRAM通常采用了6管式的存储电路</p>
<p>简单来讲，SRAM 存储单元的特点是使用 6 个晶体管来实现。其中两个 P 型 MOS 管和两个 N 型 MOS 管组成两个反相器用于存储信息。还有两个用于控制存储单元是否选通。6 管 SRAM 的结构比触发器简单，速度也比较快</p>
<h2 id="连接图"><a href="#连接图" class="headerlink" title="连接图"></a>连接图</h2><p>如下图所示，M1 和 M3 两个 MOS 管，是 N 沟道场效应管，在高电压时导通；而 M2 和 M4 这两个 MOS，则是 P 沟道场效应管，在低电压时导通。本质上，M1 和 M2 一起组成了一个非门，M3 和 M4 一起组成了另一个非门，这两个非门的输出互为对方的输入，这样，两个非门就组成了一种可以存储比特值的电路。</p>
<p><img src="/images/Hardware/Storage/cache-0.png" alt="image"></p>
<h2 id="等效图"><a href="#等效图" class="headerlink" title="等效图"></a>等效图</h2><p><img src="/images/Hardware/Storage/cache-1.png" alt="image"></p>
<h2 id="读写原理"><a href="#读写原理" class="headerlink" title="读写原理"></a>读写原理</h2><p>当要读入SRAM数据时，字线 (Word Line, WL) 加高电平，使得每个基本单元的两个控制开关M5、M6导通，存储单元与位线 (Bit Line, BL) 连通。位线用于读取或写入基本单元的保存状态。</p>
<p>我们假定储存的内容为 1，即在 Q 处的电平为高。读取周期开始时，两条位线预先设成高电平，随后字线 WL 变成高电平，使得两个访问控制晶体管 M5 与 M6 导通。Q 的高电平使得晶体管 M1 导通，而 Q 反与 BL 反的预充值不同，使得 BL 反经由 M1 与 M5 放电而变成逻辑 0。在位线 BL 一侧，Q 反的低电平使得 M4 导通，再加上 M6 通路，位线就连接到 VDD 的高电压。</p>
<p>如果储存的内容为 0，相反的电路状态将会使 BL 反为 1，而 BL 为 0。这时，只需要 BL 与 BL 反有一个很小的电位差，读取的放大电路就会辨识出哪条位线是 1，哪条是 0。也就是说，当敏感度越高时，读取的速度就越快。</p>
<p>在写入周期开始时，把要写入的状态加载到位线。如果要写入 0，则设置 BL 反为 1 且 BL 为 0。随后字线 WL 加载为高电平，位线的状态被加载进 SRAM 的基本单元。</p>
<h1 id="缓存基础"><a href="#缓存基础" class="headerlink" title="缓存基础"></a>缓存基础</h1><h2 id="集成方式"><a href="#集成方式" class="headerlink" title="集成方式"></a>集成方式</h2><ul>
<li>分布式缓存：一个处理器对应一个缓存；</li>
<li>集中式缓存：多个处理器（核）共享一个内存；</li>
<li>混合式缓存：在 L3 采用集中式缓存，在 L1 和 L2 采用分布式缓存。</li>
</ul>
<p><img src="/images/Hardware/Storage/cache-2.png" alt="image"></p>
<h2 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h2><blockquote>
<p>冯诺依曼架构：指令和数据混合存储在同一存储器</p>
<p>哈弗架构：指令和数据独立存储，分别放在程序存储器和数据存储器</p>
</blockquote>
<p>在cache设计之初，cpu与内存之间只有一个cache。随着芯片工艺的提高，现代CPU通常采用二级/三级多级缓存结构。</p>
<ul>
<li>一级缓存（L1 Cache）：在Core内部，分为指令缓存（I-cache）和数据缓存（D-cache）（冯诺依曼架构）。容量通常在32~256KB，速度3 cycles</li>
<li>二级缓存（L2 Cache）：具体芯片Core内外不同。容量256KB~3MB不等，速度11cycles（哈弗架构）</li>
<li>三级缓存（L3 Cache）：在Core外部，所有CPU核心共享。容量更大，速度25cycles（哈弗架构）</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote>
<p><strong>统一缓存：</strong> 指令和数据统一存放在一个缓存中</p>
<p><strong>分离缓存：</strong> 指令和数据分别存放在不同缓存中</p>
</blockquote>
<h3 id="L1-采用分离缓存的原因？"><a href="#L1-采用分离缓存的原因？" class="headerlink" title="L1 采用分离缓存的原因？"></a>L1 采用分离缓存的原因？</h3><ol>
<li>流水线角度。可避免取指和执行时期的访存冲突。 在 CPU 内核中，取指和访存是由两个不同的硬件单元完成的。如果使用统一缓存，当 CPU 使用超前控制或流水线控制（并行执行）的控制方式时，会存在取指作和访存同时争用同一个缓存的情况，降低 CPU 运行效率</li>
<li>cache行为角度。I-cache大多是顺序取指，指令只有读没有写；D-cache是取数据变化较大，数据可读可写，最重要的是冯诺依曼的结构是指令和数据分离，I和D在一起只有相互干扰</li>
<li>物理设计角度。一块cache，同时需要数据和指令的访问，端口上是很难实现的</li>
</ol>
<h3 id="L1分离缓存、L2统一缓存？"><a href="#L1分离缓存、L2统一缓存？" class="headerlink" title="L1分离缓存、L2统一缓存？"></a>L1分离缓存、L2统一缓存？</h3><ol>
<li>成本角度。L1 cache miss 性能损失与增加L2分离缓存的成本的平衡</li>
<li>物理设计角度。分离式设计会占用逻辑电路的面积与设计难度，对于L1这种size比较小的采用分离式设计可以承受，但是对于更大的Cache全采用分离设计，无疑设计难度和面积都会加大</li>
<li>效率角度。分离缓存不适用所有情况，对于指令和数据存放大小的需求不同，无法做到动态调节cache的大小，可能会有浪费</li>
</ol>
<h3 id="cache放在片内的优势？"><a href="#cache放在片内的优势？" class="headerlink" title="cache放在片内的优势？"></a>cache放在片内的优势？</h3><ol>
<li>片内缓存物理距离更短，片内缓存与取指令单元和取数据单元的物理距离更短，速度更快；</li>
<li>片内缓存不占用系统总线， 片内缓存使用独立的 CPU 片内总线，可以减轻系统总线的负担。</li>
</ol>
<h3 id="不需要cache的场景？"><a href="#不需要cache的场景？" class="headerlink" title="不需要cache的场景？"></a>不需要cache的场景？</h3><p>51单片机、cortex-M0（–M4）系列ARM处理器都没有cache</p>
<ol>
<li>低功耗、低成本处理器并且工作频率不高（几十兆到几百兆）的处理器不需要，可能甚至不需要SRAM</li>
<li>cache无法保证实时性，缓存缺失时向RAM加载数据的时间是不等的</li>
</ol>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>耳机插拔检测</title>
    <url>/2023/08/04/OperatingSystem/Andriod/HPDetect/</url>
    <content><![CDATA[<h1 id="耳机分类"><a href="#耳机分类" class="headerlink" title="耳机分类"></a>耳机分类</h1><p>目前市场上的耳机种类繁多每一种耳机都有其较为匹配的应用场景。按照佩戴方式可以划分为：入耳式、外耳式、头戴式等等；按照数据传输方式可以划分为：有线耳机、无线耳机；按照进入耳机的数据类型分类可以划分为：模拟耳机、数字耳机；本文主要是根据嵌入式产品上应用较多的两种不同的接口耳机进行说明：type-c耳机和3.5mm音频接口耳机（type-c耳机不一定是数字耳机，3.5mm圆孔耳机一定是模拟耳机）</p>
<h2 id="3-5mm音频接口耳机"><a href="#3-5mm音频接口耳机" class="headerlink" title="3.5mm音频接口耳机"></a>3.5mm音频接口耳机</h2><p><img src="/images/OperatingSystem/Andriod/hp_detect.png" alt="image"></p>
<ul>
<li>3-pole（Headphone）</li>
<li>4-pole（Headset）<ul>
<li>OMTP（Open Mobile Terminal Platform），对应插头上的塑料环一般是黑色，国标 / 欧标；</li>
<li>CITA（Cellular Telecommunications and Internet Association），对应插头上的塑料环一般是白色，美标；</li>
</ul>
</li>
</ul>
<h1 id="硬件检测原理"><a href="#硬件检测原理" class="headerlink" title="硬件检测原理"></a>硬件检测原理</h1><p>一般的耳机检测包含普通的耳机（Headphone）检测和带mic的耳机（Headset）检测两种，这两种耳机统称为Headset。</p>
<p>对于耳机装置的插拔检测，一般通过Jack即耳机插座来完成，大致的原理是使用带检测机械结构的耳机插座，将检测脚连到可GPIO中断上，当耳机插入时，耳机插头的金属会碰到检测脚，使得检测脚的电平产生变化，从而引起中断。这样就可以在中断处理函数中读取GPIO的的值，进一步判断出耳机是插入还是拔出。而对于耳机是否带mic的检测，需要通过codec附加的micbias电流的功能</p>
<h1 id="检测机制"><a href="#检测机制" class="headerlink" title="检测机制"></a>检测机制</h1><h2 id="InputEvent"><a href="#InputEvent" class="headerlink" title="InputEvent"></a>InputEvent</h2><p>在 Linux 内核中，Input Event 是用于处理输入设备事件的机制，它允许内核捕获和处理各种输入设备的事件。内核中的 Input Event 机制通过 struct input_event 结构体来表示输入事件的信息。但是在音频部分ASOC已经为我们封装好了相应Jack接口函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span> <span class="comment">// 时间戳，记录事件发生的时间</span></span><br><span class="line">    __u16 type;          <span class="comment">// 事件类型，如 EV_KEY (键盘按键事件)、EV_REL (相对坐标事件)、EV_ABS (绝对坐标事件) 等</span></span><br><span class="line">    __u16 code;          <span class="comment">// 事件码，表示事件的具体类型或键码</span></span><br><span class="line">    __s32 value;         <span class="comment">// 事件的值，表示事件状态，例如按键的按下 (1) 或释放 (0)，坐标事件的位置值等</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="ASoc-Jack函数"><a href="#ASoc-Jack函数" class="headerlink" title="ASoc Jack函数"></a>ASoc Jack函数</h3><ol>
<li><p>创建生成jack对象</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snd_soc_jack_new</span> <span class="params">(<span class="keyword">struct</span> snd_soc_codec *codec, <span class="type">const</span> <span class="type">char</span> *id, <span class="type">int</span> type, <span class="keyword">struct</span> snd_soc_jack *jack)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// id: 名字</span></span><br><span class="line"><span class="comment">// type: 被检测的类型，即可能插入的设备, SND_JACK_HEADPHONE / SND_JACK_HEADSET或者其他</span></span><br></pre></td></tr></tbody></table></figure>

<p>函数调用关系：snd_jack_new  –&gt;  input_allocate_device  申请input device空间，注册成输入设备</p>
</li>
<li><p>将定义好的pins加入dapm widgets进行电源管理。这一步和InputEvent没有一定联系，也可以不调用。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>	<span class="title function_">snd_soc_jack_add_pins</span> <span class="params">(<span class="keyword">struct</span> snd_soc_jack *jack, <span class="type">int</span> count, <span class="keyword">struct</span> snd_soc_jack_pin *pins)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_jack_pin</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pin;		<span class="comment">// 耳机检测引脚的名称或标识符</span></span><br><span class="line">    <span class="type">int</span> mask;				<span class="comment">// 需要报告的插拔事件类型</span></span><br><span class="line">    <span class="type">bool</span> invert;</span><br><span class="line">}; </span><br></pre></td></tr></tbody></table></figure>

<p>这里说之前定义好的pins指的是：使用类似于SND_SOC_DAPM_MIC / SND_SOC_DAPM_HP等等宏声明过的控件名称，否则在add_pins的过程中就会失败。在使用宏声明过后还需要将其定义为snd_soc_jack_pin结构体类型，其中两个重要的两个参数就是pin、mask两个字段需要声明。</p>
<p>本质上还是对控件的管理，当jack有动作其符合mask所标识的时候，就会将对应的控件进行控制。</p>
</li>
<li><p>向用户空间上报事件</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">snd_soc_jack_report</span> <span class="params">(<span class="keyword">struct</span> snd_soc_jack *jack, <span class="type">int</span> status, <span class="type">int</span> mask)</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>判断此时的status和mask事件是否对应 使用snd_soc_jack_add_pins函数注册的dapm pin状态，并进行电源管理</p>
</li>
<li><p>通过调用 –&gt;  snd_jack_report  –&gt; input_report_key/input_report_switch函数来向上层汇报input event</p>
</li>
</ol>
</li>
<li><p>将GPIO引脚状态变化与音频时间关联起来。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snd_soc_jack_add_gpios</span><span class="params">(<span class="keyword">struct</span> snd_soc_jack *jack, <span class="type">int</span> count,  <span class="keyword">struct</span> snd_soc_jack_gpio *gpios)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> snd_soc_jack_gpio {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> gpio;			<span class="comment">//GPIO 引脚的编号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">gpiod_dev</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;		<span class="comment">// 这个jack结构体标识符</span></span><br><span class="line">    <span class="type">int</span> report;				<span class="comment">// 表示插拔事件的报告类型或标志位。</span></span><br><span class="line">    <span class="type">int</span> invert;</span><br><span class="line">    <span class="type">int</span> debounce_time;		<span class="comment">// GPIO 引脚的去抖动时间，用于在检测到状态变化后延迟一段时间再处理事件，以避免抖动现象。</span></span><br><span class="line">    <span class="type">bool</span> wake;				<span class="comment">// 用于表示是否在检测到插拔事件后唤醒系统。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_jack</span> *<span class="title">jack</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">    <span class="comment">/* public: */</span></span><br><span class="line">    <span class="type">int</span> (*jack_status_check)(<span class="type">void</span> *data);	<span class="comment">//检查耳机插拔状态的回调函数。</span></span><br><span class="line">};  </span><br></pre></td></tr></tbody></table></figure>

<p>该函数通过标准GPIO驱动申请GPIO及GPIO对应中断，并提供了统一的中断处理函数来汇报事件。此函数只适用于耳机中断接至GPIO且GPIO驱动为Linux标准驱动的情况下，并且不支持mic检测。</p>
</li>
</ol>
<h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><ol>
<li><p>snd_soc_jack_new 创建jack对象</p>
</li>
<li><p>snd_soc_jack_add_pins将其加入到dapm wigets中（可不调用）</p>
</li>
<li><p>将耳机detect_pin GPIO注册成中断，并在中断处理函数中进一步读取codec相关寄存器判断是headset还是headphone（这一步骤需要注意hp_detect pin需要连接到codec，并且codec是支持该功能的）</p>
</li>
<li><p>根据判断结果调用snd_soc_jack_report发送InputEvent</p>
</li>
</ol>
<h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><p>对于InputEvent的方式本质上还是Jack和IRQ方式的结合，但是如果codec不支持headset / headphone的检测，就只能使用snd_soc_jack_add_gpios这个函数来进行向应用层通知插拔事件。</p>
<p>当然如果用户层不需要感知HP插拔事件的时候，我们可以直接在中断处理函数中操作codec寄存器进行录放音的切换即可，这样只是用户层将拿不到状态信息。</p>
<h2 id="UEvent"><a href="#UEvent" class="headerlink" title="UEvent"></a>UEvent</h2><blockquote>
<p>源码位置：<a href="http://androidxref.com/kernel_3.18/xref/drivers/switch/switch_class.c">andriod-kernel_3.18</a></p>
</blockquote>
<p>UEvent 是 Linux 内核对设备插拔等事件的通知机制，当设备插入或拔出时，内核会生成相应的 UEvent，并发送给用户空间，以便用户空间的应用程序可以对事件作出响应。UEvent是Android系统默认的耳机插拔机制，而UEvent机制比较简单，它基于switch driver。switch driver的目录在Linux kernel的drivers/staging/android/switch目录下，switch_class.c是switch driver的内部实现，它提供了switch driver所需的一些API；switch_gpio.c是一个例子，它实现了一个基于GPIO中断的switch driver。下面着重对switch_class.c进行分析。（只分析kernel层，不关注framework和app Layer）</p>
<h3 id="switch原理"><a href="#switch原理" class="headerlink" title="switch原理"></a>switch原理</h3><p>Switch是Android引进的新的驱动，目的是用于检测一些开关量，比如检测耳机插入、检测 USB 设备插入等。Switch在sysfs文件系统中创建相应entry，用户可以通过sysfs与之交互； 此外还可以通过UEvent机制与之交互， 从而检测switch状态。 </p>
<h3 id="switch函数实现"><a href="#switch函数实现" class="headerlink" title="switch函数实现"></a>switch函数实现</h3><p>Switch class在Android中实现为一个module，可动态加载。switch_class.c文件创建了一个switch_class，实现了内核的switch机制，提供支持函数供其他switch device驱动调用。 </p>
<ol>
<li><p>创建switch_class</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">create_switch_class</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></tbody></table></figure>

<p>驱动注册入口函数 module_init()  中调用 create_switch_class() 函数。而该函数主要功能是调用 class_create() 函数创建了一个名为 <code>switch</code> 的class</p>
</li>
<li><p>注册 / 注销switch设备</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">switch_dev_register</span><span class="params">(<span class="keyword">struct</span> switch_dev *sdev)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_dev_unregister</span><span class="params">(<span class="keyword">struct</span> switch_dev *sdev)</span>;</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>显示设备名字和状态</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">state_show</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">name_show</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR</span><span class="params">(state, S_IRUGO, state_show, <span class="literal">NULL</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DEVICE_ATTR</span><span class="params">(name, S_IRUGO, name_show, <span class="literal">NULL</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define DEVICE_ATTR(_name, _mode, _show, _store)</span></span><br><span class="line"><span class="comment">// sysfs（system file system）接口的一部分，允许将设备的状态信息以文件的形式暴露给用户空间，使用户空间可以通过读写这些文件来与设备进行交互和配置。</span></span><br></pre></td></tr></tbody></table></figure>

<p>这两个sysfs操作函数分别用于输出switch device的name和state。当用户读取sysfs中对应的switch entry（/sys/class/switch/<dev_name>/name和/sys/class/switch/<dev_name>/state）时候，系统会自动调用这两个函数向用户返回switch设备的名称和状态。</dev_name></dev_name></p>
</li>
<li><p>改变并通知用户swtich状态</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_set_state</span><span class="params">(<span class="keyword">struct</span> switch_dev *sdev, <span class="type">int</span> state)</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>调用name_show和state_show输出switch设备名称和状态至sysfs文件系统；</li>
<li>调用 kobject_uevent_env() 函数发送UEvent通知用户switch device的信息(名称和状态)</li>
</ol>
</li>
</ol>
<h3 id="用户层使用"><a href="#用户层使用" class="headerlink" title="用户层使用"></a>用户层使用</h3><p>UEvent机制比较简单，它基于switch driver，switch driver会在Android建立耳机插拔的目录/sys/devices/virtual/switch/h2w，在此目录下有个设备结点名为state，driver通过更新state的值，从而通知Android上层耳机状态的改变。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://blog.csdn.net/Qidi_Huang/article/details/51969396">3.5mm 音频接口类型说明</a></p>
</li>
<li><p><a href="https://blog.csdn.net/fengying765/article/details/38301483/">Android4.×耳机插拔检测</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zhgn2/article/details/7422095">Android 耳机系统综述</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>OperatingSystem</category>
        <category>Andriod</category>
      </categories>
  </entry>
  <entry>
    <title>Cache原理</title>
    <url>/2023/02/15/Hardware/Storage/%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>在大多数程序运行过程中，CPU对于内存的访问会表现出明显的倾向性，具体体现在两个方面：</p>
<ul>
<li>时间局部性：时间维度看，被引用过的内存位置，不远的将来将大概率再次被访问</li>
<li>空间局部性：空间维度看，被引用过的内存位置，不远的将来它附近的内存位置将大概率被访问</li>
</ul>
<h2 id="缓存块"><a href="#缓存块" class="headerlink" title="缓存块"></a>缓存块</h2><blockquote>
<p>linux查看缓存信息命令：getconf -a | grep CACHE</p>
</blockquote>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>根据cache的作用可知cache当中存储的是主存的副本，其必须是要和主存进行数据交换的。基于效率角度考量，根据程序局部性原理，CPU是不会按照一个字节一个字节进行数据的加载至缓存中，而是按块进行加载，而这每一块就叫做cache line，也称缓存块</p>
<ul>
<li>缓存块（cache line），管理缓存结构的最小存储单元，目前常用的是64Bytes（内存系统支持Burst读/写效率更高）</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/images/Hardware/Storage/cache-3.png" alt="image"></p>
<ul>
<li>标识位V：表示该缓存块是否有效</li>
<li>标识位M：表示这个缓存块是否被修改，也就是脏位</li>
<li>Tag：和内存块匹配的标识</li>
<li>Data：缓存数据内容</li>
</ul>
<p>需要注意的是 V、M、Tag这几位是由硬件门电路实现的，并不占缓存空间。而Data才是真正的数据部分</p>
<h2 id="缓存命中-x2F-缺失"><a href="#缓存命中-x2F-缺失" class="headerlink" title="缓存命中/缺失"></a>缓存命中/缺失</h2><ul>
<li>Cache Hit：访存时，如果所需要的数据在cache中则成为缓存命中</li>
<li>Cache Miss：访存时，如果所需要的数据不在cache中则成为缓存缺失</li>
</ul>
<h1 id="缓存映射方式"><a href="#缓存映射方式" class="headerlink" title="缓存映射方式"></a>缓存映射方式</h1><blockquote>
<p>视频链接：<a href="https://www.bilibili.com/video/BV1Qd4y1J7XA">click here</a></p>
</blockquote>
<p>从概念上讲，高速缓存是一个相联存储器（Associative Memory）。硬件电路实现方式及映射策略的不同，缓存的映射方式分为三种：</p>
<ul>
<li>全相连映射：主存块可以映射到任一缓存行（缓存只有一个组，所有的内存块都放在这一个组的不同路上)</li>
<li>直接相连映射：主存块只能映射到固定的缓存行（缓存只有一个路，一个内存块只能放置在特定的组上）</li>
<li>组组相连映射：主存块只能映射到固定的缓存组，组内任一缓存行（缓存同时由多个组和多个路）</li>
</ul>
<p>片外的高速缓存通常是直接映射的，因为组相联需要更宽的接口，可以取得多个标签，并发匹配</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><table>
<thead>
<tr>
<th>组织方式</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>全相联映射</td>
<td>cache利用率高<br>块冲突低<br>淘汰算法复杂</td>
<td>小容量cache</td>
</tr>
<tr>
<td>直接相连映射</td>
<td>cache利用率低<br>块冲突高<br>淘汰算法简单</td>
<td>大容量cache</td>
</tr>
<tr>
<td>组相联映射</td>
<td>cache利用率较高<br>块冲突率较低<br>硬件实现复杂</td>
<td>中等容量cache</td>
</tr>
</tbody></table>
<h2 id="映射算法"><a href="#映射算法" class="headerlink" title="映射算法"></a>映射算法</h2><ul>
<li>全相联：cache行号 = random</li>
<li>直接相联：cache行号 = 内存块号 % cache行数</li>
<li>组相联：主存的数据块映射到Cache特定组的任意行，cache组号=主存块号 % cache组数</li>
</ul>
<h1 id="缓存块替换策略"><a href="#缓存块替换策略" class="headerlink" title="缓存块替换策略"></a>缓存块替换策略</h1><ul>
<li><p>随机法（RAND）</p>
<p>方法简单、易于实现，但命中率比较低。</p>
</li>
<li><p>先进先出算法（FIFO）</p>
<p>先进先出方法易于实现，命中率比随机法好些。</p>
</li>
<li><p>最近最久未使用算法（LRU，Least Recently Used）</p>
<p>可以比较好地遵循程序局部性原理</p>
</li>
</ul>
<h1 id="缓存写策略"><a href="#缓存写策略" class="headerlink" title="缓存写策略"></a>缓存写策略</h1><h2 id="write-back-写回"><a href="#write-back-写回" class="headerlink" title="write back 写回"></a>write back 写回</h2><p>将要写入的数据保留在高速缓存中，并进行标记（Dirty / Modified）。只有缓存块被替换的时候才会将数据写入主存</p>
<p><img src="/images/Hardware/Storage/cache-4.png" alt="image"></p>
<h2 id="write-through-写透-x2F-写穿-x2F-写直达"><a href="#write-through-写透-x2F-写穿-x2F-写直达" class="headerlink" title="write through 写透/写穿/写直达"></a>write through 写透/写穿/写直达</h2><p>CPU总是将数据直接写到主内存中</p>
<blockquote>
<p>note：如果等待写内存完成处理器的性能会急剧下降，通过写缓冲（Write Buffer）硬件可以弥补这一问题。将需要写入的数据存储在一个FIFO队列中（Write Buffer），由内存控制器进行写入操作</p>
</blockquote>
<p><img src="/images/Hardware/Storage/cache-5.png" alt="image"></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><blockquote>
<p>由于效率原因，写更新和写不分配这两种策略在现实中比较少出现</p>
</blockquote>
<ol>
<li><p>CPU 之间的更新策略</p>
<p>当某个 CPU 的缓存中执行写操作，修改其中的某个值时，其他 CPU 的缓存所保有该数据副本的更新策略分为：写更新（Write Update）和写无效（Write Invalidate）。</p>
</li>
<li><p>写缓存时数据是否被加载</p>
<p>当前要写入的数据不在缓存中时，根据是否要先将数据加载到缓存中，写策略分为：写分配（Write Allocate）和写不分配（Not Write Allocate）。</p>
</li>
</ol>
<h1 id="缓存效率"><a href="#缓存效率" class="headerlink" title="缓存效率"></a>缓存效率</h1><h2 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h2><p>两个参数的乘积：</p>
<ol>
<li><strong>高速缓存缺失率</strong>：cache miss / 被执行的指令次数</li>
<li><strong>高速缓存缺失重填的开销</strong>：cpu流水线重新计算从主存取数到缓存中的时间</li>
</ol>
<h2 id="cache-miss的原因？"><a href="#cache-miss的原因？" class="headerlink" title="cache miss的原因？"></a>cache miss的原因？</h2><blockquote>
<p>《see mips run》对于以下缺失类型分别称为：第一次访问；抖动；替换</p>
</blockquote>
<ol>
<li>强制缺失。第一次将数据块读入到缓存所产生的缺失，也被称为冷缺失（cold miss），因为当发生缓存缺失时，缓存是空的（冷的）；</li>
<li>冲突缺失。由于缓存的相连度有限导致的缺失（指在同一组内的缺失）；</li>
<li>容量缺失。由于缓存大小有限导致的缺失（描述范围是整个缓存）</li>
</ol>
<h2 id="如何提高利用率？"><a href="#如何提高利用率？" class="headerlink" title="如何提高利用率？"></a>如何提高利用率？</h2><ul>
<li>软件<ol>
<li>程序更小；</li>
<li>让程序经常执行的部分更小。对于一个程序错误处理/初始化代码等部分代码剥离出来，提高剩余程序的缓存命中率；</li>
<li>安排程序尽量不发生冲突缺失（抖动）</li>
<li>直到必须用到数据时才停止CPU。非阻塞读。取数操作执行完，继续执行不依赖该数据的代码（流水线乱序/分支指令等等）</li>
<li>多线程CPU</li>
</ol>
</li>
<li>硬件<ol>
<li>（1）让高速缓存变的更大（代价）</li>
<li>（1）增加缓存相连度（4路以上效果就不明显了，更高路相连缓存设计目的在于其它原因（降低功耗，不使用时关掉整路））</li>
<li>（1）增加额外层次的高速缓存（L2 L3 cache）</li>
<li>（2）增加带宽，cpu与主存物理位置更近（代价）</li>
<li>（2）增加内存burst带宽（现在很少使用）</li>
<li>（2）尽早地重启CPU</li>
<li>（2）<a href="https://oscpu.github.io/NutShell-doc/%E5%8A%9F%E8%83%BD%E9%83%A8%E4%BB%B6/cache.html">关键字优先</a></li>
</ol>
</li>
</ul>
<h1 id="管理缓存"><a href="#管理缓存" class="headerlink" title="管理缓存"></a>管理缓存</h1><blockquote>
<p>对于MIPS CPU，synci指令做了以下所有工作（用户特权级）</p>
</blockquote>
<p>上电之后CPU的高速缓存阵列内容通常是随机的。引导软件负责初始化高速缓存，系统启动并正常运行后，只有三种情况CPU必须进行干预：</p>
<ol>
<li><strong>DMA设备从内存取数据之前</strong>。如果是Write Back式写策略，需要将在高速缓存中未写入到主存的数据写入得到正确数据</li>
<li><strong>DMA设备写数据到内存之前</strong>。需要将高速缓存中对应的缓存行的标志位置Invalid（无效的）</li>
<li><strong>写指令</strong>。当cpu自身写一部分指令到内存用于稍后执行时，首先需要保证指令写入到内存中，其次保证 I-Cache 中对应的指令无效</li>
</ol>
<blockquote>
<p>视频推荐：</p>
<p><a href="https://www.bilibili.com/video/BV1QA411t7Uv">Cache地址映射与变换方法</a></p>
<p><a href="https://www.bilibili.com/video/BV1h3411h7kV">一张图解决主存和cache的映射问题</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hardware</category>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Andriod Property工作机制</title>
    <url>/2023/04/27/OperatingSystem/Andriod/property/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Property属性系统是 Android 中使用最广泛的进程间信息共享机制了。本质上属性(property)是一对键/值(key/value)组合，键和值都是字符串类型。Androd中非常多的应用程序和库直接或者间接的依赖于属性系统，并由此决定其运行期的行为。它的处理流程同android的其他模块一样，也分为服务端和客户端，property设置必须在服务端，读取直接在客户端。其特点可以总结为</p>
<ul>
<li>启动启动后将init.rc、build.prop、default.prop等属性文件中加载进一块共享内存</li>
<li>属性文件的格式类似于map表，以key/value的形式存在，所有键值是以字线树的形式进行组织起来的</li>
<li>任何进程都会将共享内存映射到自己的内存中，进而可以读出值</li>
<li>修改变量不同进程只可以通过socket方式，向属性服务发出修改属性值的请求，而不能直接修改属性值</li>
<li>系统中只有一个实体可以设置修改属性值，即属性服务</li>
</ul>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>属性在内存中是以字典树的形式进行存储的</p>
<ol>
<li>首先是共享内存起始块prop_area。其中规定了byte_used、version、magic_number等等</li>
<li>紧接着是一个空白节点prop_bt，其作为整棵树的根节点</li>
<li>下面将依次存储相关属性<ul>
<li>属性名将以‘.’符号为分割符被分割开来。比如ro.secure属性名就会被分割成“ro”和“secure”两部分，而且每个部分用一个prop_bt节点表达。</li>
<li>属性名中的这种‘.’关系被表示为父子关系，所以“ro”节点的children域，会指向“secure”节点，一个节点只有一个children域，如果它还有其他孩子，那些孩子将会和第一个子节点（比如secure节点）组成一棵二叉树。</li>
<li>当一个属性名对应的“字典树枝”都已经形成好后，会另外创建一个prop_info节点，专门表示这个属性，该节点就是“字典树叶”</li>
</ul>
</li>
</ol>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h2><p>getprop 属性名</p>
<h2 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h2><p>setprop 属性名 属性值</p>
<h2 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h2><h3 id="获取所有属性"><a href="#获取所有属性" class="headerlink" title="获取所有属性"></a>获取所有属性</h3><ul>
<li>property_list -call-&gt; __system_property_foreach(void (*propfn)(const prop_info *pi, void *cookie)</li>
<li>__system_property_foreach(void (*propfn)(const prop_info *pi, void *cookie) -call-&gt; foreach_property()遍历所有属性</li>
</ul>
<h3 id="获取某个属性"><a href="#获取某个属性" class="headerlink" title="获取某个属性"></a>获取某个属性</h3><p>说明：获取属性的流程不再走socket，而是直接从共享内存中读取</p>
<ul>
<li>int property_get-call-&gt;system_property_get(key, value)</li>
<li>__system_property_find-call-&gt; __system_property_find_compat(name)</li>
</ul>
<h3 id="设置属性-1"><a href="#设置属性-1" class="headerlink" title="设置属性"></a>设置属性</h3><ul>
<li>property_set call-&gt; __system_property_set(key, value)</li>
<li>__system_property_set(key, value) -call-&gt; send_prop_msg(&amp;msg)</li>
</ul>
<p>__system_property_set通过本地SOCKET: “/dev/socket/property_service” 与init进程中properties服务通讯。</p>
<h1 id="Property调用流程"><a href="#Property调用流程" class="headerlink" title="Property调用流程"></a>Property调用流程</h1><ol>
<li><p>初始化一块共享内存</p>
<ul>
<li>void property_init(void)  ==&gt; init_property_area(void)</li>
</ul>
<ul>
<li><p>property_area_inited  初始化内存区域标志位检查</p>
</li>
<li><p>__system_property_area_init()  ==&gt;  map_prop_area_rw()</p>
<p>创建并打开/tmp/__properties__文件；ftruncate(fd, PA_SIZE)文件大小指定为PA_SIZE；映射一段地址到文件并初始化内存；将内存地址__system_property_area__赋值到全局变量</p>
</li>
<li><p>init_workspace(workspace *w, size_t size)   设置waorspace结构体，只读打开PROP_FILENAME</p>
</li>
<li><p>fcntl(pa_workspace.fd, F_SETFD, FD_CLOEXEC)</p>
</li>
<li><p>property_area_inited = 1; 置位</p>
</li>
</ul>
</li>
<li><p>加载所有默认属性</p>
<ul>
<li>load_all_props( )   ==&gt;  load_properties_from_file(const char *fn, const char *filter)</li>
</ul>
<ul>
<li><p>*read_file(fn, &amp;sz)   读fn文件大小存入sz，开辟一块size+2的堆空间，首地址作为返回值return出去</p>
</li>
<li><p>void load_properties(char *data, const char *filter)</p>
<ul>
<li><p>while ((eol = strchr(sol, ‘\n’))) 逐行解析</p>
<ul>
<li><p>#   关键字符比较。处理：注释</p>
</li>
<li><p>import 关键字符比较。处理：导入其他.prop文件</p>
</li>
<li><p>= 关键字符比较。处理：按照key，value</p>
<ul>
<li><p>property_set(key, value)</p>
</li>
<li><p>__system_property_add(const char *name, unsigned int namelen,  const char *value, unsigned int valuelen)</p>
</li>
<li><p>prop_info *find_property(prop_bt *const trie, const char *name, uint8_t namelen, const char *value, uint8_t valuelen, bool alloc_if_needed)</p>
<p>核心函数，将prop按照map存储到对应的内存位置</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>解析加载init.rc中的service</p>
<p>init_parse_config_file(“/etc/init.rc”)</p>
</li>
<li><p>将某个动作添加到队列</p>
<p>queue_builtin_action(property_service_init_action， (char*)”property_service_init”);</p>
</li>
<li><p>在某个阶段出发某个service</p>
<p>action_for_each_trigger(“late-init”, action_add_queue_tail);</p>
</li>
<li><p>for(;;) 循环</p>
</li>
</ol>
<h1 id="如何实现共享"><a href="#如何实现共享" class="headerlink" title="如何实现共享"></a>如何实现共享</h1><p>init_workspaced函数调用的时候，打开的句柄记录在pa_workspace.fd处，以后每当init进程执行socket命令，并调用service_start()时，执行：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">get_property_workspace(&amp;fd, &amp;sz);                                          </span><br><span class="line"><span class="built_in">sprintf</span>(tmp, <span class="string">"%d,%d"</span>, dup(fd), sz);</span><br><span class="line">add_environment(<span class="string">"ANDROID_PROPERTY_WORKSPACE"</span>, tmp);</span><br></pre></td></tr></tbody></table></figure>

<p>其实就是把 pa_workspace.fd 的句柄记入一个名叫“ ANDROID_PROPERTY_WORKSPACE ”的环境变量去。</p>
<p>android采用了gcc的constructor属性，该属性指明一个_libc_preinit函数,当bionic库被加载时将自动调用_libc_preinit,关键call过程如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">__libc_preinit -call-&gt; __libc_init_common(*args)-&gt;__system_properties_init-&gt;map_prop_area</span><br></pre></td></tr></tbody></table></figure>

<p>map_prop_area( )</p>
<ul>
<li>get_fd_from_env()， 通过ANDROID_PROPERTY_WORKSPACE环境变量拿到fd</li>
<li>map_fd_ro(const int fd)，映射该内存区域到本地进程</li>
</ul>
<h1 id="属性特殊处理"><a href="#属性特殊处理" class="headerlink" title="属性特殊处理"></a>属性特殊处理</h1><p>ctl.开头的属性是控制属性，用于控制系统的本地服务</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">ctl.xxx（start/stop/restart）   servicename[:args]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ro.开头的属性不能被修改；</li>
<li>net.开始的属性(除net.change外)设置， 将引发net.change=key的属性设置，被bionic/libc/netbsd/resolv/res_state.c中的代码处理(通过__system_property_find函数)；</li>
<li>persist.开始的属性，如果在init.rc和代码中设置， 将会被写到/data/property目录下；</li>
</ul>
<h1 id="rtos实现方式"><a href="#rtos实现方式" class="headerlink" title="rtos实现方式"></a>rtos实现方式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>自己在freertos的开发中，整体使用C语言，针对property的功能自己实现了一套相关代码。主要包括：get/set property；针对property的前置属性进行判断，ro/rw/presist等等</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol>
<li>前期准备<ul>
<li>选择基础数据结构：map</li>
<li>选择语言：C</li>
<li>构建整体软件框架：rbtree–&gt;map—&gt;system_prop—&gt;server_prop</li>
</ul>
</li>
<li>在PC进行代码构建<ul>
<li>基于<a href="https://github.com/forhappy/rbtree">开源代码rbtree</a>的实现，封装出map接口</li>
<li>基于andriod的实现和提供的map接口封装system_prop</li>
<li>基于system_prop封装导出的API接口</li>
</ul>
</li>
<li>测试代码功能</li>
<li>移植到开发板并调试</li>
<li>添加内存池，进行代码优化</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://www.pianshen.com/article/8653307704/">深入讲解Android Property机制</a></li>
<li><a href="https://blog.csdn.net/weixin_39613712/article/details/117314185">Android Property属性的实现细节</a></li>
</ul>
]]></content>
      <categories>
        <category>OperatingSystem</category>
        <category>Andriod</category>
      </categories>
  </entry>
  <entry>
    <title>init.rc语法及解析</title>
    <url>/2022/11/16/OperatingSystem/Andriod/init.rc/</url>
    <content><![CDATA[<p>在linux设备上输入“pstree”命令我们便会看到一棵进程树，不同状态不同设备树上进程名字进程号可能不完全一致，但进程号pid=1的进程一定是init进程！对于Android系统来讲，其实际是运行于Linux内核之上的一系列“服务进程”，而这些服务进程的“老祖宗”就是init，它是Android中第一个被启动的进程，所有服务都是通过解析init.rc文件得到的（部分可以执行程序通过init.d/文件夹下的脚本启动）</p>
<p>本篇文章将对init.rc文件语法进行解析</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>查看andriod源码：<a href="http://androidxref.com/">http://androidxref.com/</a></p>
</blockquote>
<p>init.rc是系统启动的第一个程序所加载的语法文件。init.rc文件是以“块”(section)为单位服务的，一个“块”(section)可以包含多行，而一行中包含多个tokens(符号)。“块”(section)分成两大类：一类称为”动作(action)”，另一类称为“服务(service)”。而一个init.rc脚本由四个类型的声明组成：</p>
<ol>
<li>动作 ：Actions，以关键字“on”开始</li>
<li>命令 ：Commands，以关键字“start”“restart”“stop”开始</li>
<li>服务 ：Services</li>
<li>选项 ：Options</li>
</ol>
<h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><p>Actions就是响应某个事件的过程。如下所示当满足trigger触发条件时依次执行Commands命令。源码会依次将这些命令添加到“命令执行队列尾部”，系统对这些命令顺序执行。所以服务启动的根本就是on类型的section被执行的过程</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">on &lt;trigger&gt;        //触发条件</span><br><span class="line">    &lt;command1&gt;      //命令1</span><br><span class="line">    &lt;command2&gt;      //命令2</span><br><span class="line">    &lt;command3&gt;      //命令3</span><br></pre></td></tr></tbody></table></figure>

<p>对于trigger（触发器）来讲，常见的有两种形式：</p>
<ol>
<li>单纯的字符串。例如：on boot</li>
<li>键值匹配，格式为“ on property <key> = <value> ”。例如：on property:init.svc.wifi = stopped</value></key></li>
</ol>
<p>此外还有两种形式：</p>
<ol>
<li>device-added/removed-<patch> 当设备节点添加/删除时触发此事件</patch></li>
<li>sevice-exited-<name> 当指定服务<name> 存在时触发</name></name></li>
</ol>
<h2 id="Actions解析后执行顺序"><a href="#Actions解析后执行顺序" class="headerlink" title="Actions解析后执行顺序"></a>Actions解析后执行顺序</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">on early-init           #在初始化早期阶段触发</span><br><span class="line">on init                 #初始化阶段触发。这里会执行完属性服务，接下来就可以设置属性了</span><br><span class="line">on late-init            #在初始化晚期触发。在这里会通过trigger来执行其他的action,以下均是</span><br><span class="line">on early-fs</span><br><span class="line">on fs</span><br><span class="line">on post-fs</span><br><span class="line">on post-fs-data</span><br><span class="line">on firmware_mounts_complete</span><br><span class="line">on early-boot</span><br><span class="line">on boot`</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>start <service></service></td>
<td>启动一个服务，如果它没有处于运行状态的话</td>
</tr>
<tr>
<td>stop <service></service></td>
<td>停止一个服务，如果当前它处于运行状态的话</td>
</tr>
<tr>
<td>restart <service></service></td>
<td></td>
</tr>
<tr>
<td>setprop <name> <value></value></name></td>
<td>设置<name>的属性值为<value></value></name></td>
</tr>
<tr>
<td>trigger <event></event></td>
<td>触发一个事件</td>
</tr>
<tr>
<td>export <name> <value></value></name></td>
<td>设置<name>环境变量的值为<value>，全局有效</value></name></td>
</tr>
<tr>
<td>mount <type> <device> <dir> [<mountoption>]*</mountoption></dir></device></type></td>
<td>尝试在指定路径上挂载一个设备</td>
</tr>
</tbody></table>
<h1 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h1><p>实际上每一个service就是一个可执行程序，它们在特定选项的约束下是被init程序运行或者重启(service可以在配置中指定是否需要退出重启，这样当service出现异常crash时就可以有机会复原)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">        &lt;option&gt;</span><br><span class="line">        &lt;option&gt;</span><br><span class="line">        ...</span><br><span class="line"># &lt;name&gt;       service服务的名字</span><br><span class="line"># &lt;pathname&gt;   service路径，一般对应可执行程序或者脚本</span><br><span class="line"># &lt;argument&gt;   启动pathname下的service所需要的参数</span><br><span class="line"># &lt;option&gt;     service的约束项</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h1><table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>disable</td>
<td>隐式声明，默认不会自动启动该服务，需要显式调用</td>
</tr>
<tr>
<td>oneshot</td>
<td>字面意思一次性，即服务退出时，不要主动重启该服务</td>
</tr>
<tr>
<td>onrestart</td>
<td>当服务重启时，执行某些命令（需要理解）</td>
</tr>
<tr>
<td>class <name></name></td>
<td>指定该服务属于<name>class类，默认class名为default（注：同一个class所有服务必须是同时启动或停止）</name></td>
</tr>
<tr>
<td>socket <name> <type> <perm> [<user> [<group>] ]</group></user></perm></type></name></td>
<td>创建一个名为dev/socket/<name>的 socket，然后将它的fd值传给启动它的进，有效的<type>值包括dgram,stream 和seqpacket。ueser 和group 的默认值为0。</type></name></td>
</tr>
<tr>
<td>critical</td>
<td>表明这是对设备至关重要的服务；如果它在四分钟内退出超过四次，则设备将进入Recovery 模式</td>
</tr>
<tr>
<td>group <groupname> [<groupname>]*</groupname></groupname></td>
<td>在启动服务前将用户组切换至<groupname></groupname></td>
</tr>
<tr>
<td>setenv <name> <value></value></name></td>
<td>设置环境变量<name> 为值<value></value></name></td>
</tr>
</tbody></table>
<h1 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h1><ol>
<li>service和Actions都是有唯一的名字的。如果有重名的情况会作为错误忽略。</li>
<li>无论是动作还是服务，并不是按照文件的编排顺序执行的。</li>
<li>该文件中注释以“#”开始；反斜杠“\”在行尾表示下面一行是同一行</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * copy from http://androidxref.com/6.0.0_r5/xref/bootable/recovery/etc/init.rc</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import /init.recovery.${ro.hardware}.rc</span><br><span class="line"></span><br><span class="line">on early-init</span><br><span class="line">    start ueventd</span><br><span class="line">    start healthd</span><br><span class="line"></span><br><span class="line">on init</span><br><span class="line">    export PATH /sbin:/system/bin</span><br><span class="line">    export ANDROID_ROOT /system</span><br><span class="line">    export ANDROID_DATA /data</span><br><span class="line">    export EXTERNAL_STORAGE /sdcard</span><br><span class="line"></span><br><span class="line">    symlink /system/etc /etc</span><br><span class="line"></span><br><span class="line">    mkdir /sdcard</span><br><span class="line">    mkdir /system</span><br><span class="line">    mkdir /data</span><br><span class="line">    mkdir /cache</span><br><span class="line">    mkdir /sideload</span><br><span class="line">    mount tmpfs tmpfs /tmp</span><br><span class="line"></span><br><span class="line">    chown root shell /tmp</span><br><span class="line">    chmod 0775 /tmp</span><br><span class="line"></span><br><span class="line">    write /proc/sys/kernel/panic_on_oops 1</span><br><span class="line">    write /proc/sys/vm/max_map_count 1000000</span><br><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    mkdir /dev/usb-ffs 0770 shell shell</span><br><span class="line">    mkdir /dev/usb-ffs/adb 0770 shell shell</span><br><span class="line">    mount functionfs adb /dev/usb-ffs/adb uid=2000,gid=2000</span><br><span class="line"></span><br><span class="line">    write /sys/class/android_usb/android0/enable 0</span><br><span class="line">    write /sys/class/android_usb/android0/idVendor 18D1</span><br><span class="line">    write /sys/class/android_usb/android0/idProduct D001</span><br><span class="line">    write /sys/class/android_usb/android0/f_ffs/aliases adb</span><br><span class="line">    write /sys/class/android_usb/android0/functions adb</span><br><span class="line">    write /sys/class/android_usb/android0/iManufacturer ${ro.product.manufacturer}</span><br><span class="line">    write /sys/class/android_usb/android0/iProduct ${ro.product.model}</span><br><span class="line">    write /sys/class/android_usb/android0/iSerial ${ro.serialno}</span><br><span class="line"></span><br><span class="line">on boot</span><br><span class="line">    ifup lo</span><br><span class="line">    hostname localhost</span><br><span class="line">    domainname localdomain</span><br><span class="line"></span><br><span class="line">    class_start default</span><br><span class="line"></span><br><span class="line"># Load properties from /system/ + /factory after fs mount.</span><br><span class="line">on load_all_props_action</span><br><span class="line">    load_all_props</span><br><span class="line"></span><br><span class="line">on firmware_mounts_complete</span><br><span class="line">   rm /dev/.booting</span><br><span class="line"></span><br><span class="line"># Mount filesystems and start core system services.</span><br><span class="line">on late-init</span><br><span class="line">    trigger early-fs</span><br><span class="line">    trigger fs</span><br><span class="line">    trigger post-fs</span><br><span class="line">    trigger post-fs-data</span><br><span class="line"></span><br><span class="line">    # Load properties from /system/ + /factory after fs mount. Place</span><br><span class="line">    # this in another action so that the load will be scheduled after the prior</span><br><span class="line">    # issued fs triggers have completed.</span><br><span class="line">    trigger load_all_props_action</span><br><span class="line"></span><br><span class="line">    # Remove a file to wake up anything waiting for firmware</span><br><span class="line">    trigger firmware_mounts_complete</span><br><span class="line"></span><br><span class="line">    trigger early-boot</span><br><span class="line">    trigger boot</span><br><span class="line"></span><br><span class="line">on property:sys.powerctl=*</span><br><span class="line">   powerctl ${sys.powerctl}</span><br><span class="line"></span><br><span class="line">service ueventd /sbin/ueventd</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:ueventd:s0</span><br><span class="line"></span><br><span class="line">service healthd /sbin/healthd -r</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:healthd:s0</span><br><span class="line"></span><br><span class="line">service recovery /sbin/recovery</span><br><span class="line">    seclabel u:r:recovery:s0</span><br><span class="line"></span><br><span class="line">service adbd /sbin/adbd --root_seclabel=u:r:su:s0 --device_banner=recovery</span><br><span class="line">    disabled</span><br><span class="line">    socket adbd stream 660 system system</span><br><span class="line">    seclabel u:r:adbd:s0</span><br><span class="line"></span><br><span class="line"># Always start adbd on userdebug and eng builds</span><br><span class="line">on property:ro.debuggable=1</span><br><span class="line">    write /sys/class/android_usb/android0/enable 1</span><br><span class="line">    start adbd</span><br><span class="line"></span><br><span class="line"># Restart adbd so it can run as root</span><br><span class="line">on property:service.adb.root=1</span><br><span class="line">    write /sys/class/android_usb/android0/enable 0</span><br><span class="line">    restart adbd</span><br><span class="line">    write /sys/class/android_usb/android0/enable 1</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>OperatingSystem</category>
        <category>Andriod</category>
      </categories>
  </entry>
  <entry>
    <title>IO多路复用</title>
    <url>/2023/07/09/OperatingSystem/Linux/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>文件描述符：File Descriptor，简称FD，当应用程序请求内核打开/新建一个文件时，内核会返回一个文件描述符用于对应这个打开/新建的文件。FD本质上就是一个非负整数的索引值。</p>
<p>每一个进程只能看到自己的文件描述符，每个进程的文件描述符的编号都是从0开始，进程启动，默认都会打开标准输入(fd=0)，标准输出(fd=1)，标准错误这三个文件(fd=2)，之后再打开的文件的描述符从编号3开始</p>
<h2 id="最大个数限制"><a href="#最大个数限制" class="headerlink" title="最大个数限制"></a>最大个数限制</h2><p><img src="/images/OperatingSystem/Linux/iomux-1.png" alt="image"></p>
<p>按照对于文件描述符概念的理解，其最大个数限制应该取决于系统资源的使用情况。但是内核通常会有系统级限制，对单个进程打开最大文件数做限制（通常是1024，可以通过 <code>ulimit -n</code> 命令查看）</p>
<p>在使用完文件描述符之后需要将其释放（close函数）给操作系统，否则文件描述符将一直存在。</p>
<h2 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> fd_set) = <span class="number">1024</span>	<span class="comment">// 按bit操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数，初始化一个set集合，将set 1024个标志位置0</span></span><br><span class="line"><span class="type">void</span> FD_ZERO(fd_set *<span class="built_in">set</span>);</span><br><span class="line"><span class="comment">// 将文件描述符fd对应的标志位在set集合中清空（=0）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 将文件描述符fd对应的标志位在set集合中置位（=1）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">// 判断set集合中fd对应的标志位是否置位（==1？）</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>



<h2 id="网络文件描述符"><a href="#网络文件描述符" class="headerlink" title="网络文件描述符"></a>网络文件描述符</h2><p>在网络编程中，对于服务器端有两类文件描述符：<code>监听文件描述符（Listen FD）</code> <code>通信文件描述符（Communication FD）</code>,而对于每一种文件描述符又对应两个读写缓冲区：Read Buffer、Write Buffer</p>
<table>
<thead>
<tr>
<th></th>
<th>Listen FD</th>
<th>Communication FD</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>监听客户端的连接请求，检测到之后调用 accept 就可以建立新的连接</td>
<td>负责和建立连接的客户端数据通信</td>
</tr>
<tr>
<td>个数</td>
<td>1个</td>
<td>取决于与服务器建立连接的客户端（N个）</td>
</tr>
<tr>
<td>流程</td>
<td>调用accept函数，监听FD的读缓冲区是否有数据。<br>-  有数据说明客户端有请求，接触阻塞，建立连接<br>-  没有数据，阻塞，继续监听</td>
<td>1. 发送数据（write / send）<br>    将数据写入对应的文件描述符对应的写缓冲区，内核检测到写缓冲区有数据，将数据发送到客户端<br>2. 接收数据（read / recv）<br>    始终监听对应的文件描述符的读缓冲区，当检测到有数据，读出！</td>
</tr>
</tbody></table>
<p><img src="/images/OperatingSystem/Linux/iomux-2.png" alt="image"></p>
<h1 id="IO多路复用方法对比"><a href="#IO多路复用方法对比" class="headerlink" title="IO多路复用方法对比"></a>IO多路复用方法对比</h1><table>
<thead>
<tr>
<th></th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td>底层原理</td>
<td>线性表（轮询）</td>
<td>线性表（轮询）</td>
<td>红黑树（事件通知触发）</td>
</tr>
<tr>
<td>效率</td>
<td>较低</td>
<td>较低</td>
<td>最高</td>
</tr>
<tr>
<td>连接上限</td>
<td>1024</td>
<td>取决于系统</td>
<td>取决于系统</td>
</tr>
<tr>
<td>平台限制</td>
<td>跨平台（linux / window / mac…）</td>
<td>linux</td>
<td>linux</td>
</tr>
</tbody></table>
<h1 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The time structures involved are defined in &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">//  struct timeval {</span></span><br><span class="line"><span class="comment">//       long    tv_sec;         /* seconds */</span></span><br><span class="line"><span class="comment">//       long    tv_usec;        /* microseconds */</span></span><br><span class="line"><span class="comment">//  };</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><p>nfds（指示内核需要检测最大文件描述符个数+1）</p>
<p>select默认最大检测个数是1024，这是由于内核进程最大可以维护1024个文件描述符（可以修改）。但是指定第一个参数select函数在遍历文件描述符的时候不用全部遍历，只需要遍历nfds个即可。在windows中，这个参数是无效的，指定-1即可</p>
</li>
<li><p>readfds（读缓冲区的文件描述符的个数）</p>
<p>只检测这个文件描述符的读缓冲区是否可读</p>
</li>
<li><p>writefds（写缓冲区的文件描述符的个数）</p>
<p>只检测这个文件描述符的读缓冲区是否可写</p>
</li>
<li><p>exceptfds（需要异常检测文件描述符的个数）</p>
</li>
<li><p>timeout（超时时长）</p>
<p>该函数本身是阻塞的，当加入timeout参数之后即使没有可读、可写、异常的文件描述符，达到timeout时长函数也将解除阻塞返回。当被设置为NULL，将阻塞直至检测到文件描述符状态改变</p>
</li>
</ul>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>readfds、writefds、execptfds是传入传出参数。传入fd_set类型指针，最终可读、可写、异常的文件描述符同样写回用户传入的指针指向的空间内（一定小于等于传入文件描述符的个数）</p>
<ul>
<li>大于0：表示三个集合中总共被置位的位数之和</li>
<li>等于0：timeout=0 &amp;&amp; 三个集合没有被检测到</li>
<li>小于0：select出错，根据errno判断出错原因</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>初始化read、write、except三个文件描述符集合（FD_ZERO）</li>
<li>将文件描述符设置到select函数中，交付内核检测</li>
<li>内核首先一份需要检测的文件描述符，在检测对应的读写缓冲区</li>
<li>当检测到可读/可写将文件描述符对应的标志位写回fd_set对应的文件描述符集合中</li>
<li>用户处理</li>
</ol>
<h1 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> {</span></span><br><span class="line">     <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">     <span class="type">short</span> events;     <span class="comment">/* requested events */</span> (传入)要监视的事件（输入事件、输出事件、错误事件等）</span><br><span class="line">     <span class="type">short</span> revents;    <span class="comment">/* returned events */</span>  (传出)实际发生的事件（由系统填充）</span><br><span class="line"> };</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul>
<li>struct pollfd fds<ul>
<li>fd：被检测的文件描述符</li>
<li>events：委托给内核检测的事件</li>
<li>revents：实际发生的事件，内核的返回值</li>
</ul>
</li>
<li>nfds：fds数组中的结构体数量。<ul>
<li><code>POLLIN</code>：表示有数据可读（输入事件）。</li>
<li><code>POLLOUT</code>：表示可以写数据（输出事件）。</li>
<li><code>POLLERR</code>：表示发生错误。</li>
<li><code>POLLHUP</code>：表示发生挂起事件。</li>
<li><code>POLLNVAL</code>：表示文件描述符无效。</li>
</ul>
</li>
<li>timeout：：指定超时时间（ms）<ul>
<li>-1：永久阻塞，直到有事件发生。</li>
<li>0：立即返回，无论是否有事件发生。</li>
<li>大于0：表示超时时间，poll函数会等待指定的毫秒数，如果超过该时间还没有事件发生，则返回。</li>
</ul>
</li>
</ul>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><ol>
<li>创建epoll实例（epoll_create）</li>
<li>注册文件描述符和事件（epoll_ctl）</li>
<li>等待事件发生（epoll_wait）</li>
<li>处理事件（自定义）</li>
</ol>
<h2 id="相关函数及结构体"><a href="#相关函数及结构体" class="headerlink" title="相关函数及结构体"></a>相关函数及结构体</h2><ul>
<li><p>epoll_create</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>作用：创建一个epoll实例，也就是一颗红黑树</li>
<li>参数size：Linux 2.6.8之后这个参数被忽略，大于0即可。之前的版本该参数指定了红黑树节点个数</li>
<li>返回值：一个epoll实例</li>
</ul>
</li>
<li><p>epoll_ctl</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>作用：将要监视的文件描述符和关注的事件注册到epoll实例中</li>
<li>参数：<ul>
<li>epfd：epoll实例，即通过epoll_create创建出来的返回值</li>
<li>op：操作类型，可以是<code>EPOLL_CTL_ADD</code>（添加文件描述符）、<code>EPOLL_CTL_MOD</code>（修改文件描述符）或<code>EPOLL_CTL_DEL</code>（删除文件描述符）</li>
<li>fd：要操作的文件描述符</li>
<li>event：指定关注的事件类型（见下文）</li>
</ul>
</li>
</ul>
</li>
<li><p>epoll_wait</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>作用：等待事件的发生，该函数会阻塞程序执行，直到有事件发生或超时。</p>
</li>
<li><p>参数</p>
<ul>
<li>epfd：epoll_create实例的文件描述符</li>
<li>events：：指向struct epoll_event结构体数组的指针，用于存储事件的结果（传出参数）</li>
<li>maxevents：events数组的大小，表示最大可以存储多少个事件。</li>
<li>timeout：等待超时时间（ms）。传入-1表示永久等待，传入0表示立即返回，传入正整数表示等待指定的毫秒数。</li>
</ul>
</li>
</ul>
</li>
<li><p>struct epoll_event</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> {</span></span><br><span class="line">    <span class="type">uint32_t</span> events;  	<span class="comment">// 事件类型</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;  <span class="comment">// 用户自定义数据</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> {</span></span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">   	<span class="type">int</span>          fd;</span><br><span class="line"> 	<span class="type">uint32_t</span>     u32;</span><br><span class="line"> 	<span class="type">uint64_t</span>     u64;</span><br><span class="line">} <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>参数<ul>
<li>events：事件类型，EPOLLIN / EPOLLOUT / EPOLLRDHUP / EPOLLPRI / EPOLLERR</li>
<li>data：用户自定义数据（联合体结构，只能使用一个，通常使用fd）。这个参数必须是用户来指定，最终返回的时候，可以根据传入参数判断文件描述符的index或者其它数据类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://subingwen.cn/linux/socket/">套接字：socket</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1fg411376j">IO多路复用-[多线程网络并发通信 select/poll]</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/alantu2018/p/8612722.html">linux select函数详解</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>OperatingSystem</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>51job爬虫项目</title>
    <url>/2022/12/03/SoftwareDevelopment/Item/51job/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>紧接着豆瓣爬虫的项目，该项目作为其后的练习和扩展，算是一个较为不错的上手练习。本文所涉及的是对于51job数据的爬取、解析和保存。对于数据可视化操作，在后续会持续更新，请关注！<br>在下面代码中有些函数内部调用了其他函数，需要补全各个部分的函数。如果需要源码请私信或者评论。</p>
<blockquote>
<p>具体关于库的操作我选择了一些官方文档和较好理解的解读文章做链接，知识点比较全面请参考下列表。</p>
</blockquote>
<ul>
<li><p><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/">详情页URL获取模块：selenium</a></p>
</li>
<li><p><a href="https://requests.readthedocs.io/zh_CN/latest/">URL处理第三方模块：requests</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/9135d7833d6d">数据提取etree模块：lxml</a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.7/library/sqlite3.html">数据库保存模块：sqlite3</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/python-robot/p/9958352.html">本地文件保存模块：xlwt</a></p>
</li>
</ul>
<h1 id="数据爬取与解析"><a href="#数据爬取与解析" class="headerlink" title="数据爬取与解析"></a>数据爬取与解析</h1><h2 id="详情页链接的获取：selenium"><a href="#详情页链接的获取：selenium" class="headerlink" title="详情页链接的获取：selenium"></a>详情页链接的获取：selenium</h2><p>selenium作为web自动化测试工具，目前在python爬虫中应用也越来越广泛。其主要应用原理是：通过完全模拟浏览器的操作，比如输入框输入、点击超链接元素、下拉滚动条等等来拿到js渲染之后的代码。<br>必要性：之前用的requests是对一个页面发送请求，只能获得当前加载出来的部分页面即最初的源代码，动态加载的数据是获取不到的，比如js渲染后的代码、下拉滚轮得到的数据和一些框内隐藏元素等等。<br>对于selenium的解读，<a href="https://blog.csdn.net/heartbeat196/article/details/113831482">请点击click</a>！</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#获得所有网页详情页链接</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_link</span>():</span><br><span class="line">    linklist = []</span><br><span class="line">    <span class="comment">#创建驱动器对象</span></span><br><span class="line">    wd = webdriver.Chrome(<span class="string">r'C:\Program Files\Google\Chrome\Application\chromedriver.exe'</span>)</span><br><span class="line">    wd.implicitly_wait(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">#访问51job网站</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">        wd.get(<span class="string">f"https://search.51job.com/list/010000,000000,0000,00,9,99,keyword,2,<span class="subst">{i}</span>.html?"</span>)</span><br><span class="line">        <span class="comment">#查找每每一条信息链接进入详情页</span></span><br><span class="line">        joblists = wd.find_elements_by_xpath(<span class="string">'//div[@class="j_joblist"]/div/a'</span>)</span><br><span class="line">        <span class="keyword">for</span> joblist <span class="keyword">in</span> joblists:</span><br><span class="line">            con_link = joblist.get_attribute(<span class="string">"href"</span>)</span><br><span class="line">            linklist.append(con_link)</span><br><span class="line">    wd.quit()</span><br><span class="line">    <span class="keyword">return</span> linklist</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注释：</p>
<ol>
<li>代码中的 webdriver.Chrome，后面是自己所用的驱动器的本地地址。</li>
<li>webdriver对象wd，调用 get方法，后面括号内为自己所要访问的网页链接地址。</li>
</ol>
</blockquote>
<h2 id="数据爬取与解析：xpath"><a href="#数据爬取与解析：xpath" class="headerlink" title="数据爬取与解析：xpath"></a>数据爬取与解析：xpath</h2><p>由于自己习惯于使用xpath方法解析，在此只做xpath解析的方法，如果需要re正则表达式或者BeautifulSoup解析，评论后续会更新。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>():</span><br><span class="line">    job_information = []</span><br><span class="line">    url_lists = get_link()</span><br><span class="line">    <span class="keyword">for</span> i,url <span class="keyword">in</span> <span class="built_in">enumerate</span>(url_lists):</span><br><span class="line">        datalist=[]</span><br><span class="line">        header = {</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0(Windows NT 10.0;Win64;x64)AppleWebKit/537.36(KHTML,likeGecko)Chrome/88.0.4324.150Safari/537.36"</span></span><br><span class="line">        }</span><br><span class="line">        response = requests.get(url, headers=header)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            html = response.content.decode(<span class="string">"gbk"</span>)</span><br><span class="line">            data = etree.HTML(html)</span><br><span class="line">            link = url</span><br><span class="line">            datalist.append(link)		<span class="comment">#存入岗位链接</span></span><br><span class="line">            title = data.xpath(<span class="string">r'//div[@class="cn"]/h1/@title'</span>)[<span class="number">0</span>]</span><br><span class="line">            datalist.append(title)		<span class="comment">#存入岗位名称</span></span><br><span class="line">            salary = data.xpath(<span class="string">r'//div[@class="cn"]/strong/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">            datalist.append(salary)</span><br><span class="line">            information = data.xpath(<span class="string">r'//p[@class="msg ltype"]/@title'</span>)[<span class="number">0</span>]</span><br><span class="line">            information = re.sub(<span class="string">r"\s+"</span>, <span class="string">""</span>, information)  <span class="comment"># 去除空白格</span></span><br><span class="line">            experience = information.split(<span class="string">"|"</span>)[<span class="number">1</span>]</span><br><span class="line">            datalist.append(experience)</span><br><span class="line">            education = information.split(<span class="string">"|"</span>)[<span class="number">2</span>]</span><br><span class="line">            datalist.append(education)</span><br><span class="line">            num = information.split(<span class="string">"|"</span>)[<span class="number">3</span>]</span><br><span class="line">            datalist.append(num)</span><br><span class="line">            place = data.xpath(<span class="string">r'//p[@class="fp"]/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">            datalist.append(place)</span><br><span class="line">            treatment = data.xpath(<span class="string">r'//span[@class="sp4"]/text()'</span>)</span><br><span class="line">            treatment = <span class="string">" "</span>.join(treatment)</span><br><span class="line">            datalist.append(treatment)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"-----第{}条------"</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            job_information.append(datalist)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"-----第{}条出错，原因是{}------"</span>.<span class="built_in">format</span>(i,e))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">#print(job_information)		#测试</span></span><br><span class="line">    <span class="keyword">return</span> job_information</span><br></pre></td></tr></tbody></table></figure>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="Excel本地保存"><a href="#Excel本地保存" class="headerlink" title="Excel本地保存"></a>Excel本地保存</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_data_excel</span>(<span class="params">datalist</span>):</span><br><span class="line">    workbook = xlwt.Workbook(encoding=<span class="string">"gbk"</span>, style_compression=<span class="number">0</span>)</span><br><span class="line">    worksheet = workbook.add_sheet(<span class="string">"python"</span>)</span><br><span class="line">    col = [<span class="string">"链接"</span>, <span class="string">"岗位名称"</span>, <span class="string">"薪资"</span>, <span class="string">"工作经验"</span>, <span class="string">"学历"</span>, <span class="string">"招聘人数"</span>, <span class="string">"工作地点"</span>, <span class="string">"福利"</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">        worksheet.write(<span class="number">0</span>, i, col[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(datalist)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">            worksheet.write(i+<span class="number">1</span>,j,datalist[i][j])</span><br><span class="line">    workbook.save(<span class="string">"北京-python工作.xls"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Excel数据保存结果展示"><a href="#Excel数据保存结果展示" class="headerlink" title="Excel数据保存结果展示"></a>Excel数据保存结果展示</h2><p><img src="/images/SoftwareDevelopment/Item/51job-1.png" alt="在这里插入图片描述"></p>
<h2 id="sqlite数据库保存"><a href="#sqlite数据库保存" class="headerlink" title="sqlite数据库保存"></a>sqlite数据库保存</h2><p>在此部分只写了数据库保存的工作，数据库的初始化创建需函数sql_init需要添加即可使用。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_data_sql</span>(<span class="params">datalist,dbpath</span>):</span><br><span class="line">    sql_init(dbpath)</span><br><span class="line">    conn = sqlite3.connect(dbpath)</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datalist:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            data[index] = <span class="string">'"'</span> + data[index] + <span class="string">'"'</span></span><br><span class="line">        sql = <span class="string">'''</span></span><br><span class="line"><span class="string">        insert into job_information(</span></span><br><span class="line"><span class="string">            link,title,salary,experience,education,num,place,treatment)</span></span><br><span class="line"><span class="string">            values(%s)'''</span>%<span class="string">","</span>.join(data)</span><br><span class="line">        <span class="comment">#print(sql)     #测试sql语句是否正确</span></span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        conn.commit()</span><br><span class="line">    cur.close()</span><br><span class="line">    conn.close()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="sqlite数据库保存结果展示"><a href="#sqlite数据库保存结果展示" class="headerlink" title="sqlite数据库保存结果展示"></a>sqlite数据库保存结果展示</h2><p><img src="/images/SoftwareDevelopment/Item/51job-2.png" alt="在这里插入图片描述"></p>
<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p>null</p>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Item</category>
      </categories>
  </entry>
  <entry>
    <title>中断及异常原理</title>
    <url>/2023/09/17/OperatingSystem/Linux/%E4%B8%AD%E6%96%AD%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在计算机体系结构体中，CPU与外设的工作速度不匹配一直是存在的性能瓶颈点，而如何使CPU与外设正常的协调工作成为了重要问题。当然存在像轮询这样的解决办法，每隔一段时间去询问一次，但是这样无疑会降低处理效率。中断显然是更有效的解决办法。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>中断（Interrupt）是一种机制，允许计算机在执行当前任务的同时响应和处理来自外部设备或其他源的事件。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="按中断来源"><a href="#按中断来源" class="headerlink" title="按中断来源"></a>按中断来源</h3><ul>
<li><p>硬件中断</p>
<p>硬件中断是由计算机硬件生成的，通常是外部设备请求 CPU 处理的事件。例如，键盘、鼠标、定时器、网络适配器等设备可以触发硬件中断。通常通过中断控制器（如 PIC 或 APIC）进行管理和分发，然后由操作系统处理。</p>
</li>
<li><p>软件中断</p>
<p>也称为异常或陷阱，是由计算机程序生成的，通常表示程序执行期间的异常情况。例如，除零错误、越界访问等情况可以触发软件中断。通常由程序执行指令（如 <code>int</code> 指令或系统调用）来触发，并由操作系统或程序本身进行处理。</p>
</li>
</ul>
<h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><ul>
<li><p>同步中断</p>
<p>软件中断通常是同步中断。同步中断是与程序执行相关的、可预测的中断，通常由程序中的异常情况引发。</p>
</li>
<li><p>异步中断</p>
<p>硬件中断通常是异步中断。异步中断是与程序执行无关的、不可预测的中断，通常由外部事件或设备触发。</p>
</li>
</ul>
<h2 id="中断与异常区别"><a href="#中断与异常区别" class="headerlink" title="中断与异常区别"></a>中断与异常区别</h2><table>
<thead>
<tr>
<th></th>
<th>中断</th>
<th>异常</th>
</tr>
</thead>
<tbody><tr>
<td>例子</td>
<td>敲击键盘、插入usb</td>
<td>除0、缺页中断</td>
</tr>
<tr>
<td>来源</td>
<td>通常是硬件</td>
<td>通常是软件由于编程失误导致</td>
</tr>
<tr>
<td>处理</td>
<td>do_IRQ</td>
<td>给进程发送信号</td>
</tr>
<tr>
<td>位置</td>
<td>根据架构有所不同，但每一种固定</td>
<td>可屏蔽中断的中断向量则是可配的</td>
</tr>
</tbody></table>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><ul>
<li>中断触发及检测。满足中断触发条件中断来到，并检测是哪种原因的中断</li>
<li>现场保存。保存寄存器的值（下一条指令的地址）并屏蔽中断，确保中断正常执行和恢复</li>
<li>跳入中断向量表。根据原因进入中断向量表查看对应的中断处理流程</li>
<li>中断处理程序</li>
<li>恢复现场。清楚中断标志位并恢复寄存器的值</li>
</ul>
<h2 id="proc-x2F-interrupts"><a href="#proc-x2F-interrupts" class="headerlink" title="proc/interrupts"></a>proc/interrupts</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">cat /proc/interrupts</span><br></pre></td></tr></tbody></table></figure>

<p>proc是一个虚拟文件系统存在于内核中。通过上述命令就可以查看系统中中断号、个数、名字等等内容。这个是和体系相关的，show_interrupts（）函数实现的。</p>
<h1 id="中断控制方法"><a href="#中断控制方法" class="headerlink" title="中断控制方法"></a>中断控制方法</h1><p><img src="/images/OperatingSystem/Linux/interrupt.png" alt="image"></p>
<h1 id="中断上下半部"><a href="#中断上下半部" class="headerlink" title="中断上下半部"></a>中断上下半部</h1><p>中断的执行会打断系统正常的运行，因此为了提高系统的响应度和效率就需要中断程序的执行尽可能要快速，中断恢复系统正常运行。但是实际中有些中断的工作就会导致阻塞，因此可以将这部分内容等到系统不忙的时候执行。因此将中断处理过程分为两个部分：上半部（Top Half）和下半部（Bottom Half）。</p>
<ul>
<li>上半部：时间敏感、硬件相关、原子执行不希望被其它中断打断</li>
<li>下半部：执行耗时长</li>
</ul>
<h2 id="下半部实现方式"><a href="#下半部实现方式" class="headerlink" title="下半部实现方式"></a>下半部实现方式</h2><ul>
<li>软中断（中断上下文。静态创建，操作多处理器变量需要注意）</li>
<li>tasklet（中断上下文。不能并发执行，如果不能确定是否是多处理器，选择这个）</li>
<li>工作队列（进程上下文。执行时间可以推迟到进程上下文完成，推荐！！）</li>
</ul>
<h2 id="工作队列的使用方式"><a href="#工作队列的使用方式" class="headerlink" title="工作队列的使用方式"></a>工作队列的使用方式</h2><figure class="highlight d"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*定义工作队列和关联函数*/</span></span><br><span class="line"><span class="keyword">struct</span> work_struct my_wq;</span><br><span class="line"><span class="keyword">struct</span> work_struct my_delay_wq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断处理底半部*/</span></span><br><span class="line"><span class="keyword">void</span> xxx_do_work(unsigned <span class="built_in">long</span>)</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"><span class="keyword">void</span> xxx_do_delay_work(unsigned <span class="built_in">long</span>)</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断处理顶半部*/</span></span><br><span class="line">irqreturn_t xxx_interrupt(<span class="keyword">int</span> irq,<span class="keyword">void</span> *dev_id)</span><br><span class="line">{</span><br><span class="line">schedule_work(&amp;my_wq);</span><br><span class="line">schedule_delay_work(&amp;my_delay_wq);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备驱动模块加载函数*/</span></span><br><span class="line"><span class="keyword">int</span> xxx_init(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">request = request_irq(xxx_wq,xxx_interrupt,IRQF_DISABLED,<span class="string">"XXX"</span>,NULL);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 初始化工作队列(可以是一个延时队列，指定时间)</span></span><br><span class="line">INIT_WORK(&amp;my_wq,(<span class="keyword">void</span>(*)(<span class="keyword">void</span> *))xxx_do_work,NULL)</span><br><span class="line">INIT_DELAYED_WORK(&amp;my_delay_wq,(<span class="keyword">void</span>(*)(<span class="keyword">void</span> *))xxx_do_delay_work,NULL)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设备驱动模块卸载函数*/</span></span><br><span class="line"><span class="keyword">void</span> xxx_exit(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//释放中断</span></span><br><span class="line">free_irq(xxx_irq,xxx_interrupt);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="中断描述符"><a href="#中断描述符" class="headerlink" title="中断描述符"></a>中断描述符</h1><p>Linux中断机制的核心数据结构 irq_desc， 它完整地描述了一条中断线 （或可简单理解为 “一个中断源” ）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>  <span class="title">irq_common_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>     <span class="title">irq_data</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> __percpu   *kstat_irqs;</span><br><span class="line">    <span class="type">irq_flow_handler_t</span>  handle_irq;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IRQ_PREFLOW_FASTEOI</span></span><br><span class="line">    <span class="type">irq_preflow_handler_t</span>   preflow_handler;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>    *<span class="title">action</span>;</span>    <span class="comment">/* IRQ action list */</span><span class="comment">//该中断线的中断服务程序</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        status_use_accessors;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        core_internal_state__do_not_mess_with_it;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        depth;      <span class="comment">/* nested irq disables */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        wake_depth; <span class="comment">/* nested wake enables */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        irq_count;  <span class="comment">/* For detecting broken IRQs */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       last_unhandled; <span class="comment">/* Aging timer for unhandled count */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        irqs_unhandled;</span><br><span class="line">    <span class="type">atomic_t</span>        threads_handled;</span><br><span class="line">    <span class="type">int</span>         threads_handled_last;</span><br><span class="line">    <span class="type">raw_spinlock_t</span>      lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>      *<span class="title">percpu_enabled</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span>    *<span class="title">affinity_hint</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">    <span class="type">cpumask_var_t</span>       pending_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       threads_oneshot;</span><br><span class="line">    <span class="type">atomic_t</span>        threads_active;</span><br><span class="line">    <span class="type">wait_queue_head_t</span>       wait_for_threads;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        nr_actions;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        no_suspend_depth;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        cond_suspend_depth;                                                                                                                                               </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        force_resume_depth;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>   *<span class="title">dir</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span>         parent_irq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>       *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>      *name;</span><br><span class="line">} ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="中断初始化流程"><a href="#中断初始化流程" class="headerlink" title="中断初始化流程"></a>中断初始化流程</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/init/main.c (version-4.4.94)</span></span><br><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    local_irq_disable();</span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line"> 	trap_init();</span><br><span class="line">	<span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">    early_irq_init();</span><br><span class="line">    init_IRQ();</span><br><span class="line">	...</span><br><span class="line">    WARN(!irqs_disabled(), <span class="string">"Interrupts were enabled early\n"</span>);</span><br><span class="line">    early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">    local_irq_enable();		<span class="comment">// 开启本地中断</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="trap-init"><a href="#trap-init" class="headerlink" title="trap_init"></a>trap_init</h2><p>中断初始化函数入口 <code>trap_init()</code>，不同体系结构下的实现可能有所不同，但是完成的功能基本一致，完成填写IDT描述符构成中断向量表的功能。</p>
<h3 id="MIPS中断异常类型"><a href="#MIPS中断异常类型" class="headerlink" title="MIPS中断异常类型"></a>MIPS中断异常类型</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">///arch/mips/include/asm/mipsregs.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Cause.ExcCode trap codes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_INT			0	<span class="comment">/* Interrupt pending */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_MOD			1	<span class="comment">/* TLB modified fault */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_TLBL		2	<span class="comment">/* TLB miss on load or ifetch */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_TLBS		3	<span class="comment">/* TLB miss on a store */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_ADEL		4	<span class="comment">/* Address error on a load or ifetch */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_ADES		5	<span class="comment">/* Address error on a store */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_IBE			6	<span class="comment">/* Bus error on an ifetch */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_DBE			7	<span class="comment">/* Bus error on a load or store */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_SYS			8	<span class="comment">/* System call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_BP			9	<span class="comment">/* Breakpoint */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_RI			10	<span class="comment">/* Reserved instruction exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_CPU			11	<span class="comment">/* Coprocessor unusable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_OV			12	<span class="comment">/* Arithmetic overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_TR			13	<span class="comment">/* Trap instruction */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_MSAFPE		14	<span class="comment">/* MSA floating point exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_FPE			15	<span class="comment">/* Floating point exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_TLBRI		19	<span class="comment">/* TLB Read-Inhibit exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_TLBXI		20	<span class="comment">/* TLB Execution-Inhibit exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_MSADIS		21	<span class="comment">/* MSA disabled exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_MDMX		22	<span class="comment">/* MDMX unusable exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_WATCH		23	<span class="comment">/* Watch address reference */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_MCHECK		24	<span class="comment">/* Machine check */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_THREAD		25	<span class="comment">/* Thread exceptions (MT) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_DSPDIS		26	<span class="comment">/* DSP disabled exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_GE			27	<span class="comment">/* Virtualized guest exception (VZ) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXCCODE_CACHEERR	30	<span class="comment">/* Parity/ECC occured on a core */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Implementation specific trap codes used by MIPS cores */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIPS_EXCCODE_TLBPAR	16	<span class="comment">/* TLB parity error exception */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Implementation specific trap codes used by Loongson cores */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOONGSON_EXCCODE_GSEXC	16	<span class="comment">/* Loongson-specific exception */</span></span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="x86中断异常类型"><a href="#x86中断异常类型" class="headerlink" title="x86中断异常类型"></a>x86中断异常类型</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// /arch/x86/include/asm/trapnr.h</span></span><br><span class="line"><span class="comment">/* Interrupts/Exceptions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_DE		 0	<span class="comment">/* Divide-by-zero */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_DB		 1	<span class="comment">/* Debug */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_NMI	 2	<span class="comment">/* Non-maskable Interrupt */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_BP		 3	<span class="comment">/* Breakpoint */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_OF		 4	<span class="comment">/* Overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_BR		 5	<span class="comment">/* Bound Range Exceeded */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_UD		 6	<span class="comment">/* Invalid Opcode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_NM		 7	<span class="comment">/* Device Not Available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_DF		 8	<span class="comment">/* Double Fault */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_OLD_MF	 9	<span class="comment">/* Coprocessor Segment Overrun */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_TS		10	<span class="comment">/* Invalid TSS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_NP		11	<span class="comment">/* Segment Not Present */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_SS		12	<span class="comment">/* Stack Segment Fault */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_GP		13	<span class="comment">/* General Protection Fault */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_PF		14	<span class="comment">/* Page Fault */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_SPURIOUS	15	<span class="comment">/* Spurious Interrupt */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_MF		16	<span class="comment">/* x87 Floating-Point Exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_AC		17	<span class="comment">/* Alignment Check */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_MC		18	<span class="comment">/* Machine Check */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_XF		19	<span class="comment">/* SIMD Floating-Point Exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_VE		20	<span class="comment">/* Virtualization Exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_CP		21	<span class="comment">/* Control Protection Exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_VC		29	<span class="comment">/* VMM Communication Exception */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X86_TRAP_IRET	32	<span class="comment">/* IRET Exception */</span></span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="ARM中断异常类型"><a href="#ARM中断异常类型" class="headerlink" title="ARM中断异常类型"></a>ARM中断异常类型</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ./arch/arm/kernel/entry-armv.S</span></span><br><span class="line">__vectors_start:</span><br><span class="line">    W(b)    vector_rst						<span class="comment">// 复位异常</span></span><br><span class="line">    W(b)    vector_und						<span class="comment">// 未定义指令异常</span></span><br><span class="line">    W(ldr)  pc, __vectors_start + <span class="number">0x1000</span>	<span class="comment">// 软件中断</span></span><br><span class="line">    W(b)    vector_pabt						<span class="comment">// 中止（预取）</span></span><br><span class="line">    W(b)    vector_dabt						<span class="comment">// 中止（数据）</span></span><br><span class="line">    W(b)    vector_addrexcptn				<span class="comment">// 保留</span></span><br><span class="line">    W(b)    vector_irq						<span class="comment">// 一般中断请求</span></span><br><span class="line">    W(b)    vector_fiq     					<span class="comment">// 快速中断请求</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="MIPS实现过程"><a href="#MIPS实现过程" class="headerlink" title="MIPS实现过程"></a>MIPS实现过程</h3><ul>
<li>将异常处理函数放在中断异常的地址入口（except_vec3_generic放到BASE+0x180位置）</li>
<li>填充中断向量表（填充exception_handlers，exception_handlers[0] = 中断入口）</li>
<li>当发生中断的时候，进入中断异常地址入口</li>
<li>做保护现场等动作</li>
<li>跳转进入except_vec3_generic中断异常处理函数</li>
<li>向量表第一项即会调入平台相关的中断中</li>
</ul>
<p>如下代码所示即为mips对于trap_init函数的实现（只保留关键代码）。其主要作用是判断寄存器或者系统相关变量的值来设置中断向量表，而中断向量表是一个全局变量，其在genex.S汇编中进行了引用。而在汇编中，通过指令mfc0把控制寄存器CP0_CAUSE值拷贝到通用寄存器k1。CP0_CAUSE保存了这次中断发生的原因。用andi指令把k1的值加上0x7c，然后用指令ld加载具体一个中断处理程序的入口地址exception_handlers(k1)。exception_handlers就是我们记录的中断处理程序，根据k1的值找到当前系统需要执行哪个中断处理程序。然后使用指令jr跳转到这个中断处理程序。</p>
<p>k0和k1是为MIPS系统所保留，专门保留给系统发生中断时程序使用的寄存器。这里的”k”代表keep。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/arch/mips/kernel/traps.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> exception_handlers[<span class="number">32</span>];</span><br><span class="line"><span class="type">void</span> __init *<span class="title function_">set_except_vector</span><span class="params">(<span class="type">int</span> n, <span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    old_handler = xchg(&amp;exception_handlers[n], handler);</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> __init <span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 把except_vec3_generic函数指针放在地址为 KSEG0 ＋ 0x180 处，这个地址就是中断异常的入口地址。</span></span><br><span class="line">    set_handler(<span class="number">0x180</span>, &amp;except_vec3_generic, <span class="number">0x80</span>);</span><br><span class="line">    ...</span><br><span class="line">    set_except_vector(<span class="number">0</span>, using_rollback_handler() ? rollback_handle_int: handle_int);</span><br><span class="line">    set_except_vector(<span class="number">1</span>, handle_tlbm);</span><br><span class="line">    set_except_vector(<span class="number">2</span>, handle_tlbl);</span><br><span class="line">    set_except_vector(<span class="number">3</span>, handle_tlbs);</span><br><span class="line">    set_except_vector(<span class="number">4</span>, handle_adel);</span><br><span class="line">    set_except_vector(<span class="number">5</span>, handle_ades);                                  </span><br><span class="line">    set_except_vector(<span class="number">6</span>, handle_ibe);</span><br><span class="line">    set_except_vector(<span class="number">7</span>, handle_dbe);</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/arch/mips/kernel/genex.S</span></span><br><span class="line">NESTED(except_vec3_generic, <span class="number">0</span>, sp) </span><br><span class="line">    .<span class="built_in">set</span>    push</span><br><span class="line">    .<span class="built_in">set</span>    noat</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> R5432_CP0_INTERRUPT_WAR</span></span><br><span class="line">    mfc0    k0, CP0_INDEX</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    mfc0    k1, CP0_CAUSE</span><br><span class="line">    andi    k1, k1, <span class="number">0x7c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">    dsll    k1, k1, <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ld   k0, exception_handlers(k1)</span><br><span class="line">    jr  k0  </span><br><span class="line">    .<span class="built_in">set</span>    pop</span><br><span class="line">    <span class="title function_">END</span><span class="params">(except_vec3_generic)</span>      </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// handle_int</span></span><br><span class="line">BUILD_ROLLBACK_PROLOGUE handle_int</span><br><span class="line"><span class="title function_">NESTED</span><span class="params">(handle_int, PT_SIZE, sp)</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">    ┆* Check to see if the interrupted code has just disabled</span></span><br><span class="line"><span class="comment">    ┆* interrupts and ignore this interrupt for now if so.                                                                                                                                </span></span><br><span class="line"><span class="comment">    ┆*</span></span><br><span class="line"><span class="comment">    ┆* local_irq_disable() disables interrupts and then calls</span></span><br><span class="line"><span class="comment">    ┆* trace_hardirqs_off() to track the state. If an interrupt is taken</span></span><br><span class="line"><span class="comment">    ┆* after interrupts are disabled but before the state is updated</span></span><br><span class="line"><span class="comment">    ┆* it will appear to restore_all that it is incorrectly returning with</span></span><br><span class="line"><span class="comment">    ┆* interrupts disabled</span></span><br><span class="line"><span class="comment">    ┆*/</span></span><br><span class="line">    .<span class="built_in">set</span>    push</span><br><span class="line">    .<span class="built_in">set</span>    noat</span><br><span class="line">	...</span><br><span class="line">    # Check <span class="keyword">if</span> already on IRQ <span class="built_in">stack</span></span><br><span class="line">    PTR_LI  t1, ~<span class="params">(_THREAD_SIZE<span class="number">-1</span>)</span></span><br><span class="line">    and t1, t1, sp</span><br><span class="line">    beq t0, t1, 2f</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch to IRQ stack */</span></span><br><span class="line">    li  t1, _IRQ_STACK_START</span><br><span class="line">    PTR_ADD sp, t0, t1</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save task's sp on IRQ stack so that unwinding can follow it */</span></span><br><span class="line">    LONG_S  s1, 0<span class="params">(sp)</span></span><br><span class="line">2:</span><br><span class="line">    jal plat_irq_dispatch</span><br><span class="line">    <span class="comment">/* Restore sp */</span></span><br><span class="line">    move    sp, s1</span><br><span class="line"></span><br><span class="line">    j   ret_from_irq</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_MICROMIPS</span></span><br><span class="line">    nop</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="title function_">END</span><span class="params">(handle_int)</span></span><br></pre></td></tr></tbody></table></figure>

<p>如上代码所示，最终跳转到plat_irq_dispatch函数，很明显这个函数是与平台相关的，具体代码不做分析。主要完成的功能是：根据中断状态寄存器判断中断类型和中断号等等，随后通过一系列跳转最终调到 <code>desc-&gt;handle_irq(desc)</code> 这样一个语句，即注册的中断服务程序中。</p>
<h2 id="early-irq-init"><a href="#early-irq-init" class="headerlink" title="early_irq_init"></a>early_irq_init</h2><p>early_irq_init属于与硬件和平台无关的通用逻辑层，为irq_desc[]中个元素的某些成员填充默认值。</p>
<p>完成后调用体系相关的arch_early_irq_init函数完成进一步的初始化工作，不过ARM / MIPS体系没有实现该函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/irq/irqdesc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> <span class="title">irq_desc</span>[<span class="title">NR_IRQS</span>] __<span class="title">cacheline_aligned_in_smp</span> =</span> {</span><br><span class="line">    [<span class="number">0</span> ... NR_IRQS<span class="number">-1</span>] = { </span><br><span class="line">        .handle_irq = handle_bad_irq,</span><br><span class="line">        .depth      = <span class="number">1</span>,</span><br><span class="line">        .lock       = __RAW_SPIN_LOCK_UNLOCKED(irq_desc-&gt;lock),</span><br><span class="line">    }   </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">early_irq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> count, i, node = first_online_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">    init_irq_default_affinity();</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">"NR_IRQS:%d\n"</span>, NR_IRQS);</span><br><span class="line"></span><br><span class="line">    desc = irq_desc;</span><br><span class="line">    count = ARRAY_SIZE(irq_desc);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">        desc[i].kstat_irqs = alloc_percpu(<span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">        alloc_masks(&amp;desc[i], GFP_KERNEL, node);</span><br><span class="line">        raw_spin_lock_init(&amp;desc[i].lock);</span><br><span class="line">        lockdep_set_class(&amp;desc[i].lock, &amp;irq_desc_lock_class);</span><br><span class="line">        desc_set_defaults(i, &amp;desc[i], node, <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arch_early_irq_init();</span><br><span class="line">}   </span><br></pre></td></tr></tbody></table></figure>

<h2 id="init-IRQ"><a href="#init-IRQ" class="headerlink" title="init_IRQ"></a>init_IRQ</h2><p>初始化不同SOC的中断处理器等操作</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">init_IRQ</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_IRQS; i++)</span><br><span class="line">        irq_set_noprobe(i);</span><br><span class="line"></span><br><span class="line">    arch_init_irq();		<span class="comment">// 调用不同厂家基于MIPS架构实现的中断初始化函数</span></span><br><span class="line"></span><br><span class="line">    for_each_possible_cpu(i) {</span><br><span class="line">        <span class="type">int</span> irq_pages = IRQ_STACK_SIZE / PAGE_SIZE;</span><br><span class="line">        <span class="type">void</span> *s = (<span class="type">void</span> *)__get_free_pages(GFP_KERNEL, irq_pages);</span><br><span class="line"></span><br><span class="line">        irq_stack[i] = s;</span><br><span class="line">        pr_debug(<span class="string">"CPU%d IRQ stack at 0x%p - 0x%p\n"</span>, i,</span><br><span class="line">            irq_stack[i], irq_stack[i] + IRQ_STACK_SIZE);</span><br><span class="line">    }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/336641609">从0开始学ARM-异常及中断处理、异常向量表、swi</a></li>
<li><a href="https://ty-chen.github.io/linux-kernel-interrupt/">Linux操作系统学习笔记（十五）中断</a></li>
<li><a href="https://blog.csdn.net/lqx4_3/article/details/6373081">移植linux内核平台相关之 中断</a></li>
<li>Linux内核设计与实现（第三版）</li>
</ul>
]]></content>
      <categories>
        <category>OperatingSystem</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>interrrupt</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC进程间通讯</title>
    <url>/2024/02/28/OperatingSystem/Linux/IPC%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>IPC：Inter-Process Communication，进程间通信。描述的是运行在某个操作系统之上的不同进程间各个消息传递的方式，进程间通信类型通常包含以下几种：无名管道、有名管道、信号、共享内存、消息队列、信号量、套接字等</p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><ul>
<li>数据传输。一个进程数据传输给另外一个进程</li>
<li>共享数据。一个进程对共享区的数据进行更改，其它进程可以看到</li>
<li>通知事件。一个进程向另一个进程发送消息，通知某个事件（进程终止通知父进程）</li>
<li>资源共享。多个进程间共享同样的资源，需要内核提供锁和同步机制</li>
<li>进程控制。有些进程希望完全控制另一个进程的执行（Debug进程），此时控制进程希望能够拦截另一个进程的所有的Trap陷入和Exception异常，并能够及时知道状态e</li>
</ul>
<h1 id="无名管道pipe"><a href="#无名管道pipe" class="headerlink" title="无名管道pipe"></a>无名管道pipe</h1><p>当输入输出数据量比较大的时候，管道这种IPC机制非常有用。但是管道这种通讯方式有两种限制，第一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用，进程的亲缘关系通常是指父子进程关系。</p>
<p>要想创建一个简单的管道，可以使用系统调用pipe()函数。这个函数将返回两个文件描述符，一个读端、一个写端。如果使用pipe进行双方的通信，需要建立两个通道。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parent_process</span><span class="params">(<span class="type">int</span> pipe_fd[<span class="number">2</span>])</span> {</span><br><span class="line">    <span class="comment">// 关闭管道的写入端，因为父进程将从管道中读取数据</span></span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 从管道中读取数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    read(pipe_fd[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Parent received: %s\n"</span>, buffer);</span><br><span class="line">    <span class="comment">// 关闭读取端</span></span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child_process</span><span class="params">(<span class="type">int</span> pipe_fd[<span class="number">2</span>])</span> {</span><br><span class="line">    <span class="comment">// 关闭管道的读取端，因为子进程将向管道中写入数据</span></span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 向管道中写入数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">"Hello from child"</span>;</span><br><span class="line">    write(pipe_fd[<span class="number">1</span>], message, <span class="built_in">strlen</span>(message) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 关闭写入端</span></span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipe_fd) == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 子进程执行的代码</span></span><br><span class="line">        child_process(pipe_fd);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 父进程执行的代码</span></span><br><span class="line">        parent_process(pipe_fd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="命名管道FIFO"><a href="#命名管道FIFO" class="headerlink" title="命名管道FIFO"></a>命名管道FIFO</h1><p>命名管道是一种具有持久性的管道，允许无关的进程之间进行通信。命名管道是建立在实际的磁盘介质上有自己名字的文件，任何进程可以在任何时间通过文件名或路径名与该文件建立联系。<br>实现一个命名管道实际上就是实现一个FIFO文件。命名管道一旦建立，之后它的读、写以及关闭操作都与普通管道完全相同。虽然FIFO文件的inode节点在磁盘上，但是仅是一个节点而已，文件的数据还是存在于内存缓冲页面中，和普通管道相同。</p>
<p>使用<code>mkfifo</code>命令或<code>mkfifo</code>系统调用创建有名管道，它会在文件系统中生成一个特殊的文件。进程1通过打开这个文件获取写入文件描述符，进程2通过打开同一个文件获取读取文件描述符。数据通过管道的缓冲区传递，和无名管道类似，当缓冲区满或为空时，写入或读取进程可能会被阻塞</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">"myfifo"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_to_fifo</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 打开FIFO文件，如果不存在则创建</span></span><br><span class="line">    mkfifo(FIFO_FILE, <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// 以只写方式打开FIFO文件</span></span><br><span class="line">    fd = open(FIFO_FILE, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 向FIFO写入数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">"Hello from writer"</span>;</span><br><span class="line">    write(fd, message, <span class="built_in">strlen</span>(message) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_from_fifo</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// 以只读方式打开FIFO文件</span></span><br><span class="line">    fd = open(FIFO_FILE, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从FIFO读取数据</span></span><br><span class="line">    read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Reader received: %s\n"</span>, buffer);</span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 子进程执行写入操作</span></span><br><span class="line">        write_to_fifo();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 父进程执行读取操作</span></span><br><span class="line">        read_from_fifo();</span><br><span class="line">        <span class="comment">// 删除FIFO文件</span></span><br><span class="line">        unlink(FIFO_FILE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>信号是一种异步通信方式，用于通知进程发生了某个事件。可以用于处理外部事件、错误等。常见的信号包括SIGINT（中断）、SIGTERM（终止）等。</p>
<p>信号同时又是一种软中断，当某进程接收到信号时会终止当前程序的执行去处理信号的注册函数，然后回到断点程序继续往下执行<br>。信号事件的发生通常由两类原因引起，一种是硬件原因引起，比如敲击键盘等；另外一种是软件原因引起，比如调用kill、alarm函数等，同时系统异常（除0）等问题也会引发信号的产生。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Signal handler function</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> signum)</span> {</span><br><span class="line">    <span class="keyword">if</span> (signum == SIGUSR1) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Received SIGUSR1 signal\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// Register signal handler for SIGUSR1</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGUSR1, signal_handler) == SIG_ERR) {</span><br><span class="line">        perror(<span class="string">"signal"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Waiting for SIGUSR1 signal...\n"</span>);</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    kill(pid, SIGUSR1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Exiting the program\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_KEY 1234</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 创建共享内存段</span></span><br><span class="line">    <span class="type">int</span> shmid = shmget(SHM_KEY, SHM_SIZE, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 将共享内存段附加到进程的地址空间</span></span><br><span class="line">    <span class="type">char</span> *shared_memory = (<span class="type">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shared_memory == (<span class="type">char</span> *)(<span class="number">-1</span>)) {</span><br><span class="line">        perror(<span class="string">"shmat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 写入数据到共享内存</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">"Hello from writer"</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(shared_memory, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="comment">// 分离共享内存段</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(shared_memory) == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"shmdt"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建另一个进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 子进程执行的代码</span></span><br><span class="line">        <span class="comment">// 将共享内存段附加到子进程的地址空间</span></span><br><span class="line">        <span class="type">char</span> *child_shared_memory = (<span class="type">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (child_shared_memory == (<span class="type">char</span> *)(<span class="number">-1</span>)) {</span><br><span class="line">            perror(<span class="string">"shmat in child process"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从共享内存读取数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Reader received: %s\n"</span>, child_shared_memory);</span><br><span class="line">        <span class="comment">// 分离共享内存段</span></span><br><span class="line">        <span class="keyword">if</span> (shmdt(child_shared_memory) == <span class="number">-1</span>) {</span><br><span class="line">            perror(<span class="string">"shmdt in child process"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 删除共享内存段</span></span><br><span class="line">        <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>) {</span><br><span class="line">            perror(<span class="string">"shmctl"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 父进程执行的代码</span></span><br><span class="line">        <span class="comment">// 等待子进程执行完毕</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="消息队列-message-queue"><a href="#消息队列-message-queue" class="headerlink" title="消息队列( message queue )"></a>消息队列( message queue )</h1><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>消息队列是消息的链接表，包括 Posix 消息队列 system V 消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<h1 id="信号量-semophore"><a href="#信号量-semophore" class="headerlink" title="信号量( semophore )"></a>信号量( semophore )</h1><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 编译 gcc your_program.c -o your_program -pthread</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，作为信号量</span></span><br><span class="line"><span class="type">sem_t</span> semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，用于等待并增加信号量的值</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread is waiting...\n"</span>);</span><br><span class="line">    <span class="comment">// 等待信号量</span></span><br><span class="line">    sem_wait(&amp;semaphore);</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread is in the critical section\n"</span>);</span><br><span class="line">    <span class="comment">// 离开临界区后增加信号量的值</span></span><br><span class="line">    sem_post(&amp;semaphore);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="keyword">if</span> (sem_init(&amp;semaphore, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"sem_init"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>) != <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main thread is waiting...\n"</span>);</span><br><span class="line">    <span class="comment">// 等待信号量</span></span><br><span class="line">    sem_wait(&amp;semaphore);</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main thread is in the critical section\n"</span>);</span><br><span class="line">    <span class="comment">// 离开临界区后增加信号量的值</span></span><br><span class="line">    sem_post(&amp;semaphore);</span><br><span class="line">    <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(thread, <span class="literal">NULL</span>) != <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"pthread_join"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="keyword">if</span> (sem_destroy(&amp;semaphore) == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"sem_destroy"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字( socket )"></a>套接字( socket )</h1><p>Socket（套接字）是一种提供不同进程间通信的接口，通常用于网络编程。它是一个抽象层，通过它，程序可以通过网络进行数据交换，也可以在同一台计算机内的不同进程之间进行通信。Socket 提供了一种通用的编程模型，允许两个不同的进程在网络上或本地进行通信。通信可以是单向的（单工）、双向的（全双工或半双工）。</p>
<ul>
<li><p>服务器端</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> server_socket, client_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>, <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = {<span class="number">0</span>};</span><br><span class="line">    <span class="comment">// 创建服务器套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置服务器地址结构</span></span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_address.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">// 绑定服务器套接字到指定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span> (bind(server_socket, (<span class="keyword">struct</span> sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"bind failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 监听客户端连接</span></span><br><span class="line">    <span class="keyword">if</span> (listen(server_socket, <span class="number">3</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"listen failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Server listening on port %d...\n"</span>, PORT);</span><br><span class="line">    <span class="comment">// 接受客户端连接</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">    <span class="keyword">if</span> ((client_socket = accept(server_socket, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, (<span class="type">socklen_t</span>*)&amp;addrlen)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"accept failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 从客户端接收消息</span></span><br><span class="line">    read(client_socket, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Server received: %s\n"</span>, buffer);</span><br><span class="line">    <span class="comment">// 发送回复给客户端</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *reply_message = <span class="string">"Hello from server"</span>;</span><br><span class="line">    send(client_socket, reply_message, <span class="built_in">strlen</span>(reply_message), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Server sent: %s\n"</span>, reply_message);</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(server_socket);</span><br><span class="line">    close(client_socket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>客户端</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> client_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE] = {<span class="number">0</span>};</span><br><span class="line">    <span class="comment">// 创建客户端套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((client_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 设置服务器地址结构</span></span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    server_address.sin_port = htons(PORT);</span><br><span class="line">    <span class="comment">// 将IPv4地址从文本转换为二进制</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;server_address.sin_addr) &lt;= <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"inet_pton failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (connect(client_socket, (<span class="keyword">struct</span> sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"connect failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 发送消息给服务器</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">"Hello from client"</span>;</span><br><span class="line">    send(client_socket, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client sent: %s\n"</span>, message);</span><br><span class="line">    <span class="comment">// 接收服务器的回复</span></span><br><span class="line">    read(client_socket, buffer, BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client received: %s\n"</span>, buffer);</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(client_socket);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OperatingSystem</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>页中断机制详解</title>
    <url>/2023/09/01/OperatingSystem/Linux/%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>“页中断”（Page Fault）是指在虚拟内存系统中，当程序试图访问当前未分配物理内存的虚拟内存页面时所引发的一种中断。这种中断是由硬件或操作系统内核生成的，它们使得操作系统能够进行必要的操作以满足页面的访问需求。</p>
<p>与普通中断一样，当发生页中断的时候也会进入到相应的中断处理流程中，进而实现某些操作系统的赋予用户的功能。我们知道对于虚拟空间的内存，其共会经历三个阶段：未映射未分配、已映射未分配、已映射已分配。而页中断的中断处理过程将实现虚拟内存状态从已映射未分配转向已映射已分配。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li><p>虚拟内存支持</p>
<p>页中断机制是支持虚拟内存的关键机制。当程序访问虚拟内存中的某一页，而该页当前未加载到物理内存中时，会触发页中断。操作系统通过这个机制，能够将虚拟内存页面从磁盘加载到物理内存，从而满足程序的内存需求。</p>
</li>
<li><p>内存管理</p>
<p>有效的管理内存的换入换出，提高内存的使用效率</p>
</li>
<li><p>内存保护</p>
<p>如果程序试图访问没有权限的虚拟页则会触发缺页中断，操作系统可以检测并处理这种情况，防止程序访问无权限的内存区域。</p>
</li>
<li><p>内存分配</p>
<p>对于用户申请内存空间以及相关功能（mmap、fork、execve）底层都是通过页中断机制实现的</p>
</li>
</ul>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><ul>
<li><p>缺页中断（Page Fault on Demand）</p>
<p>当程序访问一个虚拟内存页面，但该页面当前未加载到物理内存中时，会触发缺页中断。操作系统会根据需要将缺失的页面从磁盘加载到物理内存，以满足程序的访问需求。</p>
</li>
<li><p>写保护中断（Page Fault for Write）</p>
<p>当程序试图写入一个只读的虚拟内存页面时，会触发写保护中断。操作系统可以通过将页面标记为可写，或者进行写时复制（Copy-On-Write）操作来处理这种情况。</p>
</li>
<li><p>非法访问中断（Page Fault for Non-Existent Memory）</p>
<p>当程序试图访问虚拟地址空间中未分配的部分时，会引发非法访问中断。操作系统通常会响应这种中断并处理访问错误。</p>
</li>
<li><p>页面大小中断（Page Size Fault）</p>
<p>在一些体系结构中，不同的虚拟内存页面可以有不同的大小。如果程序试图访问不匹配页面大小的地址，会触发页面大小中断。</p>
</li>
</ul>
<p>在操作系统中最重要且最常用的中断类型就是缺页中断和写保护中断，这两个中断支撑起了需要系统的调用的核心原理</p>
<h1 id="结构体说明"><a href="#结构体说明" class="headerlink" title="结构体说明"></a>结构体说明</h1><h2 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">398</span> <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> {</span></span><br><span class="line">  <span class="number">399</span>   <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>     <span class="comment">// 虚拟地址空间结构体，双向链表包含红黑树节点访问到不能访问的区域。</span></span><br><span class="line">  <span class="number">400</span>   <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>             <span class="comment">// 红黑树的根节点</span></span><br><span class="line">  <span class="number">401</span>   <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span>   <span class="comment">// mmap的高速缓冲器，指的是mmap最后指向的一个虚拟地址区间</span></span><br><span class="line">  <span class="number">402</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU                                                                                                              </span></span><br><span class="line">  <span class="number">403</span>   <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">  <span class="number">404</span>         <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">  <span class="number">405</span>         <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line">  <span class="number">406</span>   <span class="type">void</span> (*unmap_area) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr);</span><br><span class="line">  <span class="number">407</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="number">408</span>   <span class="type">unsigned</span> <span class="type">long</span> mmap_base;             <span class="comment">// mmap区域的基地址</span></span><br><span class="line">  <span class="number">409</span>   <span class="type">unsigned</span> <span class="type">long</span> mmap_legacy_base;      <span class="comment">// 自底向上的配置</span></span><br><span class="line">  <span class="number">410</span>   <span class="type">unsigned</span> <span class="type">long</span> task_size;             <span class="comment">// 进程的虚拟地址空间大小</span></span><br><span class="line">  <span class="number">411</span>   <span class="type">unsigned</span> <span class="type">long</span> cached_hole_size;      <span class="comment">// 缓冲器的最大的大小</span></span><br><span class="line">  <span class="number">412</span>   <span class="type">unsigned</span> <span class="type">long</span> free_area_cache;       <span class="comment">// 不受约束的空间大小</span></span><br><span class="line">  <span class="number">413</span>   <span class="type">unsigned</span> <span class="type">long</span> highest_vm_end;        <span class="comment">// 虚拟地址空间最大结尾地址</span></span><br><span class="line">  <span class="number">414</span>   <span class="type">pgd_t</span> * pgd;                         <span class="comment">// 页表的全局目录</span></span><br><span class="line">  <span class="number">415</span>   <span class="type">atomic_t</span> mm_users;        			 <span class="comment">// 用户数量</span></span><br><span class="line">  <span class="number">416</span>   <span class="type">atomic_t</span> mm_count;      			 <span class="comment">// 有多少用户引用mm_struct</span></span><br><span class="line">  <span class="number">417</span>   <span class="type">atomic_long_t</span> nr_ptes;  			 <span class="comment">// 页表</span></span><br><span class="line">  <span class="number">418</span>   <span class="type">int</span> map_count;        			     <span class="comment">// 虚拟地址空间的个数</span></span><br><span class="line">  <span class="number">419</span> </span><br><span class="line">  <span class="number">420</span>   <span class="type">spinlock_t</span> page_table_lock;   		 <span class="comment">// 保护页表和用户</span></span><br><span class="line">  <span class="number">421</span>   <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span>        <span class="comment">// 读写信号</span></span><br><span class="line">  <span class="number">422</span> </span><br><span class="line">  <span class="number">423</span>   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>    <span class="comment">/* List of maybe swapped mm's.  These are globally strung</span></span><br><span class="line"><span class="comment">  424              * together off init_mm.mmlist, and are protected</span></span><br><span class="line"><span class="comment">  425              * by mmlist_lock</span></span><br><span class="line"><span class="comment">  426              */</span></span><br><span class="line">  <span class="number">428</span> </span><br><span class="line">  <span class="number">429</span>   <span class="type">unsigned</span> <span class="type">long</span> hiwater_rss;  		<span class="comment">/* High-watermark of RSS usage */</span> </span><br><span class="line">  <span class="number">430</span>   <span class="type">unsigned</span> <span class="type">long</span> hiwater_vm; 			<span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line">  <span class="number">431</span> </span><br><span class="line">  <span class="number">432</span>   <span class="type">unsigned</span> <span class="type">long</span> total_vm;   				<span class="comment">// 映射的总页数</span></span><br><span class="line">  <span class="number">433</span>   <span class="type">unsigned</span> <span class="type">long</span> locked_vm;  				<span class="comment">// 已设置PG_mlocked的页面</span></span><br><span class="line">  <span class="number">434</span>   <span class="type">unsigned</span> <span class="type">long</span> pinned_vm;  				<span class="comment">// 重新计数永久增加</span></span><br><span class="line">  <span class="number">435</span>   <span class="type">unsigned</span> <span class="type">long</span> shared_vm;  				<span class="comment">// 共享页面</span></span><br><span class="line">  <span class="number">436</span>   <span class="type">unsigned</span> <span class="type">long</span> exec_vm;    				<span class="comment">// 可执行可写页面</span></span><br><span class="line">  <span class="number">437</span>   <span class="type">unsigned</span> <span class="type">long</span> stack_vm; </span><br><span class="line">  <span class="number">438</span>   <span class="type">unsigned</span> <span class="type">long</span> def_flags;</span><br><span class="line">  <span class="number">439</span>   <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;               <span class="comment">//开始代码段，结束代码。开始数据，结束数据</span></span><br><span class="line">  <span class="number">440</span>   <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;                              <span class="comment">//堆的开始和结束。</span></span><br><span class="line">  <span class="number">441</span>   <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;                   <span class="comment">//参数的起始和结束，环境变量的起始和终点</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="vm-area-struct"><a href="#vm-area-struct" class="headerlink" title="vm_area_struct"></a>vm_area_struct</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>    <span class="comment">// 指向进程的 mm_struct 结构</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;      <span class="comment">// 虚拟内存区域的起始地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;        <span class="comment">// 虚拟内存区域的结束地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span>  <span class="comment">// 指向下一个 vm_area_struct 结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_prev</span>;</span>  <span class="comment">// 指向前一个 vm_area_struct 结构</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;       <span class="comment">// 页面保护属性</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags;      <span class="comment">// 虚拟内存区域的标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是一些在内核中进行内部管理的字段，用于将 vm_area_struct 插入红黑树等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb_subtree_last</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><blockquote>
<p>本节相关的源码取自Linux-4.4（MIPS）只保留了关键段落代码</p>
</blockquote>
<h2 id="整体调用流程"><a href="#整体调用流程" class="headerlink" title="整体调用流程"></a>整体调用流程</h2><ol>
<li><p>在 Linux 系统上，页中断服务程序的名称是 do_page_fault</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// fault.c</span></span><br><span class="line">asmlinkage <span class="type">void</span> __kprobes <span class="title function_">do_page_fault</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">long</span> write, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ctx_state</span> <span class="title">prev_state</span>;</span></span><br><span class="line">    prev_state = exception_enter();</span><br><span class="line">    __do_page_fault(regs, write, address);</span><br><span class="line">    exception_exit(prev_state);                          </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>内核态用户态上下文切换</p>
<ul>
<li>对于exception_enter函数，其流程为：检查上下文跟踪是否启用；如果启用，读取先前上下文状态；如果先前状态是内核态直接返回，如果不是内核态则调用context_tracking_exit通知上下文跟踪子系统处理器正在退出用户模式并进入内核模式。</li>
<li>对于exception_exit函数，基本流程与上述一致。只是最后context_tracking_enter函数将通知上下文跟踪子系统处理器将从内核模式退出并进入非内核模式即先前的上下文模式（用户模式）</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// context_tracking.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">enum</span> ctx_state <span class="title function_">exception_enter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{       </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ctx_state</span> <span class="title">prev_ctx</span>;</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> (!context_tracking_is_enabled())		<span class="comment">// 判断上下文跟踪是否启用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    prev_ctx = this_cpu_read(context_tracking.state);	<span class="comment">// 读取先前上下文状态，内核态/用户态？</span></span><br><span class="line">    <span class="keyword">if</span> (prev_ctx != CONTEXT_KERNEL)						<span class="comment">// 不是内核态直接退出上一状态</span></span><br><span class="line">        context_tracking_exit(prev_ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev_ctx;</span><br><span class="line">}                                                                                                                                                                                         </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">exception_exit</span><span class="params">(<span class="keyword">enum</span> ctx_state prev_ctx)</span></span><br><span class="line">{   </span><br><span class="line">    <span class="keyword">if</span> (context_tracking_is_enabled()) {</span><br><span class="line">        <span class="keyword">if</span> (prev_ctx != CONTEXT_KERNEL)</span><br><span class="line">            context_tracking_enter(prev_ctx);</span><br><span class="line">    }</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">// context_tracking_state.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ctx_state</span> {</span>                                          </span><br><span class="line">    CONTEXT_DISABLED = <span class="number">-1</span>,  <span class="comment">/* returned by ct_state() if unknown */</span></span><br><span class="line">    CONTEXT_KERNEL = <span class="number">0</span>,</span><br><span class="line">    CONTEXT_USER,</span><br><span class="line">    CONTEXT_GUEST,</span><br><span class="line">} state; </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>页中断的下层封装__do_page_fault</p>
<ul>
<li>find_vma通过失效地址addr来查找vma，如果没有找到vma，说明addr地址还没有在进程地址空间中分配任何一个VMA的线性区，这将是一种严重的错误，返回VM_FAULT_BADMAP错误，内核将会杀掉该进程</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/latest/source/arch/mips/mm/fault.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __do_page_fault(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">long</span> write, <span class="type">unsigned</span> <span class="type">long</span> address)</span><br><span class="line">{</span><br><span class="line"><span class="comment">// 为了获得有关内核恐慌、内核oops、不可屏蔽中断或其他事件的通知，调用者需要将其自身插入到链中</span></span><br><span class="line">    <span class="keyword">if</span> (notify_die(DIE_PAGE_FAULT, <span class="string">"page fault"</span>, regs, <span class="number">-1</span>, current-&gt;thread.trap_nr, SIGSEGV) == NOTIFY_STOP)                              <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 查找VMA</span></span><br><span class="line">    vma = find_vma(mm, address);</span><br><span class="line"><span class="comment">// 判断VMA是否有写权限</span></span><br><span class="line">     <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">         xxx;</span><br><span class="line"><span class="comment">// 页中断的核心处理函数</span></span><br><span class="line">    fault = handle_mm_fault(mm, vma, address, flags);</span><br><span class="line"><span class="comment">// 相关goto处理函数</span></span><br><span class="line">    xxx</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>核心函数handle_pte_fault</p>
<p>对于虚拟地址的映射过程，首先检查表项中P位（PRESENT），该项表示物理页面是否存在在内存中。如果P=0那么其他各个字段都毫无意义，并且pte_none检查页表项也为空说明页表项未建立，如果pte_none非空说明映射已经建立，只是物理页面不在内存中。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// mm/memory.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_pte_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pte_t</span> *pte, <span class="type">pmd_t</span> *pmd, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 内存屏障</span></span><br><span class="line">    barrier();</span><br><span class="line">    <span class="comment">//pte页表项PRESENT未置位，说明PTE还没有映射物理页面（没有页面或页面被交换出去）</span></span><br><span class="line">    <span class="keyword">if</span> (!pte_present(entry)) {</span><br><span class="line">         <span class="comment">// 判断页表项是否为空（映射）</span></span><br><span class="line">        <span class="keyword">if</span> (pte_none(entry)) {</span><br><span class="line">            <span class="comment">// 判断VMA是否是匿名映射</span></span><br><span class="line">            <span class="keyword">if</span> (vma_is_anonymous(vma))</span><br><span class="line">                <span class="comment">// vma是匿名映射线性区，匿名映射</span></span><br><span class="line">                <span class="keyword">return</span> do_anonymous_page(mm, vma, address,  pte, pmd, flags);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// vma是文件映射线性区，文件映射</span></span><br><span class="line">                <span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd, flags, entry);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//PTE非空，从swap分区读回页面</span></span><br><span class="line">        <span class="keyword">return</span> do_swap_page(mm, vma, address,  pte, pmd, flags, entry);</span><br><span class="line">    } </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pte_protnone(entry))</span><br><span class="line">        <span class="comment">//非一致性内存访问（NUMA）下的页表映射操作</span></span><br><span class="line">        <span class="keyword">return</span> do_numa_page(mm, vma, address, entry, pte, pmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) {</span><br><span class="line">        <span class="keyword">if</span> (!pte_write(entry))	<span class="comment">// PTE只读</span></span><br><span class="line">            <span class="keyword">return</span> do_wp_page(mm, vma, address, pte, pmd, ptl, entry); <span class="comment">//写时复制，fork父子进程</span></span><br><span class="line">        entry = pte_mkdirty(entry);		<span class="comment">// pte可写时，标记为脏，</span></span><br><span class="line">    }    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// /标记pte项刚刚被访问过，以免页面被换出</span></span><br><span class="line">    entry = pte_mkyoung(entry);</span><br><span class="line">    <span class="keyword">if</span> (ptep_set_access_flags(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)) {</span><br><span class="line">        update_mmu_cache(vma, address, pte);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE)</span><br><span class="line">            flush_tlb_fix_spurious_fault(vma, address);         <span class="comment">// flush tlb cache                  </span></span><br><span class="line">    }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="匿名映射-do-anonymous-page"><a href="#匿名映射-do-anonymous-page" class="headerlink" title="匿名映射(do_anonymous_page)"></a>匿名映射(do_anonymous_page)</h2><ul>
<li><p>调用时机：PTE不存在且Flags是匿名映射</p>
</li>
<li><p>处理逻辑：</p>
<ul>
<li><p>读操作</p>
<p>使用 零页（BSS段） 进行映射，并且设置为只读。因为这里已经是缺页异常的请求调页的处理，所以肯定是本进程第一次访问这个页，分配全零即可。</p>
</li>
<li><p>写操作</p>
<p>申请一块新的物理内存页，然后根据物理内存页的地址生成映射关系，再对页表项进行映射，增加进程匿名页面的计数，把匿名页面添加到RMAP系统和LRU对应链表里，以用于后续进行内存回收。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_anonymous_page</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pte_t</span> *page_table, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// //如果page_table之前用来建立了临时内核映射，则释放该映射</span></span><br><span class="line">    pte_unmap(page_table);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断映射虚拟内存vma是否在不同进程间共享</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_SHARED)</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Use the zero-page for reads, VMA只读情况 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE) &amp;&amp; !mm_forbids_zeropage(mm)) {</span><br><span class="line">        <span class="comment">// 创建页表项（使用全0页，并设置属性标记）</span></span><br><span class="line">        entry = pte_mkspecial(pfn_pte(my_zero_pfn(address), vma-&gt;vm_page_prot));</span><br><span class="line">        <span class="comment">// 在给定的进程地址空间中，找到虚拟地址 address 对应的页表项，并返回一个指向该页表项的指针</span></span><br><span class="line">        page_table = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line">        <span class="keyword">if</span> (!pte_none(*page_table))</span><br><span class="line">            <span class="keyword">goto</span> unlock;</span><br><span class="line">        <span class="comment">/* Deliver the page fault to userland, check inside PT lock，传递page fault到用户空间 */</span></span><br><span class="line">        <span class="keyword">if</span> (userfaultfd_missing(vma)) {</span><br><span class="line">            pte_unmap_unlock(page_table, ptl);</span><br><span class="line">            <span class="keyword">return</span> handle_userfault(vma, address, flags,  VM_UFFD_MISSING);</span><br><span class="line">        }    </span><br><span class="line">        <span class="keyword">goto</span> setpte;</span><br><span class="line">    }    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 以下是VMA可写的情况 */</span></span><br><span class="line">    <span class="comment">// 为进程地址空间中的VMA准备struct anon_vma结构</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">        <span class="keyword">goto</span> oom; </span><br><span class="line">    <span class="comment">// 分配可移动的匿名页面，底层通过alloc_page</span></span><br><span class="line">    page = alloc_zeroed_user_highpage_movable(vma, address);</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">goto</span> oom; </span><br><span class="line">	<span class="comment">// 请求的内存分配进行资源计数，以检查是否有足够的内存资源可供使用</span></span><br><span class="line">    <span class="keyword">if</span> (mem_cgroup_try_charge(page, mm, GFP_KERNEL, &amp;memcg))</span><br><span class="line">        <span class="keyword">goto</span> oom_free_page;</span><br><span class="line">   <span class="comment">// 内核宏，用于设置页表项中的 "uptodate" 标志位，表示页面已经更新并且包含了有效数据。在页缓存和文件系统操作中，这个标志用于跟踪页面的有效性状态。</span></span><br><span class="line">    __SetPageUptodate(page);</span><br><span class="line">    <span class="comment">// 创建页表项 PTE</span></span><br><span class="line">    entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE)</span><br><span class="line">        <span class="comment">// 设置页表项可写</span></span><br><span class="line">        entry = pte_mkwrite(pte_mkdirty(entry))</span><br><span class="line">    <span class="comment">// 获取 PTE 地址</span></span><br><span class="line">    page_table = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line">    <span class="keyword">if</span> (!pte_none(*page_table))</span><br><span class="line">        <span class="keyword">goto</span> release;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Deliver the page fault to userland, check inside PT lock，传递page fault到用户空间*/</span></span><br><span class="line">    <span class="keyword">if</span> (userfaultfd_missing(vma)) {</span><br><span class="line">        pte_unmap_unlock(page_table, ptl);</span><br><span class="line">        mem_cgroup_cancel_charge(page, memcg);</span><br><span class="line">        page_cache_release(page);</span><br><span class="line">        <span class="keyword">return</span> handle_userfault(vma, address, flags,</span><br><span class="line">                    VM_UFFD_MISSING);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 增加mm的rss成员加一，用于记录分配给本进程的物理页总数</span></span><br><span class="line">    inc_mm_counter_fast(mm, MM_ANONPAGES);</span><br><span class="line">    <span class="comment">// 建立线性区和匿名页的反向映射</span></span><br><span class="line">    page_add_new_anon_rmap(page, vma, address);</span><br><span class="line">    mem_cgroup_commit_charge(page, memcg, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 将一个页面添加到 LRU（Least Recently Used）缓存中的不活跃链表或不可驱逐链表</span></span><br><span class="line">    lru_cache_add_active_or_unevictable(page, vma);</span><br><span class="line">setpte:</span><br><span class="line">    <span class="comment">// /将pte页表项值entry设置到硬件page_table页表项</span></span><br><span class="line">    set_pte_at(mm, address, page_table, entry);</span><br><span class="line">    <span class="comment">/* No need to invalidate - it was non-present before，更新MMU Cache */</span></span><br><span class="line">    update_mmu_cache(vma, address, page_table);</span><br><span class="line">unlock:</span><br><span class="line">    pte_unmap_unlock(page_table, ptl);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">release:</span><br><span class="line">    mem_cgroup_cancel_charge(page, memcg);</span><br><span class="line">    page_cache_release(page);</span><br><span class="line">    <span class="keyword">goto</span> unlock;</span><br><span class="line">oom_free_page:</span><br><span class="line">    page_cache_release(page);</span><br><span class="line">oom:</span><br><span class="line">    <span class="keyword">return</span> VM_FAULT_OOM;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="文件映射-do-fault"><a href="#文件映射-do-fault" class="headerlink" title="文件映射(do_fault)"></a>文件映射(do_fault)</h2><ul>
<li>调用条件：PTE不存在，该vma里的页是文件页或者共享匿名页</li>
<li>调用流程：<ul>
<li>把文件页从存储设备上的文件系统读到文件的缓存 （Page Cache）</li>
<li>设置进程的页表项PTE，把虚拟页映射到文件的页缓存物理页（Page Cache）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pte_t</span> *page_table, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 缺页由读内存导致</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE))</span><br><span class="line">        <span class="keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);</span><br><span class="line">    <span class="comment">// 缺页由写内存导致，且是非共享映射</span></span><br><span class="line">    <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED))</span><br><span class="line">        <span class="keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);</span><br><span class="line">    <span class="comment">// 缺页由写内存导致，且是共享映射</span></span><br><span class="line">    <span class="keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);</span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<h3 id="do-read-fault"><a href="#do-read-fault" class="headerlink" title="do_read_fault"></a>do_read_fault</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_read_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">        <span class="type">pgoff_t</span> pgoff, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// do_fault_around函数 建立映射关系，而不会创建页面高速缓存</span></span><br><span class="line">    <span class="comment">// 提前建立进程地址空间与页面高速缓存的映射关系有利于减小因为发生缺页的次数，提高了效率</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops-&gt;map_pages &amp;&amp; fault_around_bytes &gt;&gt; PAGE_SHIFT &gt; <span class="number">1</span>) {</span><br><span class="line">        do_fault_around(vma, address, pte, pgoff, flags);</span><br><span class="line">        <span class="keyword">if</span> (!pte_same(*pte, orig_pte))</span><br><span class="line">            <span class="keyword">goto</span> unlock_out;</span><br><span class="line">        pte_unmap_unlock(pte, ptl);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// do_fault是真正为异常地址分配物理页面                                               </span></span><br><span class="line">    ret = __do_fault(vma, address, pgoff, flags, <span class="literal">NULL</span>, &amp;fault_page);</span><br><span class="line">    <span class="comment">//为物理页面和缺页异常发生的虚拟地址建立映射关系，即使用这个物理页面来创建一个PTE，然后设置PTE，然后释放页锁，并且唤醒等待这个页锁的进程</span></span><br><span class="line">    do_set_pte(vma, address, fault_page, pte, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="do-cow-fault"><a href="#do-cow-fault" class="headerlink" title="do_cow_fault"></a>do_cow_fault</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_cow_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">        <span class="type">pgoff_t</span> pgoff, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 准备 anon_vma 结构体</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">	<span class="comment">// 申请页</span></span><br><span class="line">    new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);</span><br><span class="line">	<span class="comment">// 将内容读取到页上</span></span><br><span class="line">    ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page);</span><br><span class="line">	<span class="comment">// 如果fault页面存在，将其拷贝到new页面上</span></span><br><span class="line">    <span class="keyword">if</span> (fault_page)</span><br><span class="line">        copy_user_highpage(new_page, fault_page, address, vma);</span><br><span class="line">    <span class="comment">// 设置页表项中的 "uptodate" 标志位，表示页面已经更新并且包含了有效数据</span></span><br><span class="line">    __SetPageUptodate(new_page);</span><br><span class="line">	<span class="comment">// 设置PTE</span></span><br><span class="line">    do_set_pte(vma, address, new_page, pte, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="do-share-fault"><a href="#do-share-fault" class="headerlink" title="do_share_fault"></a>do_share_fault</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_shared_fault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">        <span class="type">pgoff_t</span> pgoff, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 通过vma-&gt;vm_ops-&gt;fault回调函数来读取文件内容到vmf-&gt;page里</span></span><br><span class="line">    ret = __do_fault(vma, address, pgoff, flags, <span class="literal">NULL</span>, &amp;fault_page);</span><br><span class="line">    <span class="comment">// 通知进程地址空间，页面将变成可写的。如果一个页面变成可写的，那么进程可能需要等待这个页面的内容回写成功</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops-&gt;page_mkwrite) {</span><br><span class="line">        unlock_page(fault_page);</span><br><span class="line">        tmp = do_page_mkwrite(vma, fault_page, address);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!tmp ||</span><br><span class="line">                (tmp &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE)))) {</span><br><span class="line">            page_cache_release(fault_page);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 将新生成的PTE entry设置到硬件页表中</span></span><br><span class="line">    do_set_pte(vma, address, fault_page, pte, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 将page标记为dirty</span></span><br><span class="line">    <span class="keyword">if</span> (set_page_dirty(fault_page))</span><br><span class="line">        dirtied = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 通过balance_dirty_pages_ratelimited()来平衡并回写一部分脏页</span></span><br><span class="line">    <span class="keyword">if</span> ((dirtied || vma-&gt;vm_ops-&gt;page_mkwrite) &amp;&amp; mapping)</span><br><span class="line">        balance_dirty_pages_ratelimited(mapping);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="公共函数-do-fault"><a href="#公共函数-do-fault" class="headerlink" title="公共函数(_do_fault)"></a>公共函数(_do_fault)</h3><p>主要完成缺页对应文件页缓存（file cache）的获取</p>
<p>对于回调函数filemap_fault() ，会判断内存中有没有以前访问后留下的文件页缓存（file cache），如果还有，则直接把留存的 file cache 赋给 vmf—&gt;page。如果没有，则需要先新申请页作为 file cache，再从磁盘中读取文件的数据到 file cache。file cache 的存在使得第二次映射同一个文件时，读取会比第一次快很多</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __do_fault(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address,</span><br><span class="line">            <span class="type">pgoff_t</span> pgoff, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">            <span class="keyword">struct</span> page *cow_page, <span class="keyword">struct</span> page **page)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 调用文件映射页的虚拟地址区域的 fault 钩子函数</span></span><br><span class="line">    <span class="comment">// 一般文件系统对应 filemap_fault() 函数，也就是说 vm_ops 一般定义为 generic_file_vm_ops</span></span><br><span class="line">    ret = vma-&gt;vm_ops-&gt;fault(vma, &amp;vmf);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="写时复制-do-wp-page"><a href="#写时复制-do-wp-page" class="headerlink" title="写时复制(do_wp_page)"></a>写时复制(do_wp_page)</h2><ul>
<li><p>调用条件：PTE页表项存在且PRESENT已置位；此次操作为写操作且PTE没有写权限</p>
</li>
<li><p>处理逻辑</p>
<p>对线性地址对应的物理页面进行检验，首先判断是否存在共享，如果没有，直接设置pte为可读可写，然后刷新页缓冲之后返回；如果有共享，则通过get_free_page函数取得一页新的物理页面，然后取消共享，将新的页表项设置为这个新页的地址，刷新缓冲，然后将旧页面的内容复制到新页面。</p>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_wp_page</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">pte_t</span> *page_table, <span class="type">pmd_t</span> *pmd,</span></span><br><span class="line"><span class="params">        <span class="type">spinlock_t</span> *ptl, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">    __<span class="title function_">releases</span><span class="params">(ptl)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">old_page</span>;</span></span><br><span class="line"></span><br><span class="line">    old_page = vm_normal_page(vma, address, orig_pte);</span><br><span class="line">    <span class="keyword">if</span> (!old_page) {</span><br><span class="line">		<span class="comment">// 处理可写并且共享的特殊映射页面（包括VM_MIXEDMAP或VM_PFNMAP页面），并调用wp_page_reuse函数来复用缺页异常页面</span></span><br><span class="line">        <span class="keyword">if</span> ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) == (VM_WRITE|VM_SHARED))</span><br><span class="line">            <span class="keyword">return</span> wp_pfn_shared(mm, vma, address, page_table, ptl, orig_pte, pmd);</span><br><span class="line">        pte_unmap_unlock(page_table, ptl);</span><br><span class="line">        <span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd, orig_pte, old_page);</span><br><span class="line">    }                                                                                                                             </span><br><span class="line">    <span class="keyword">if</span> (PageAnon(old_page) &amp;&amp; !PageKsm(old_page)) {</span><br><span class="line">        <span class="keyword">if</span> (reuse_swap_page(old_page)) {</span><br><span class="line">            <span class="comment">// wp_page_reuse：处理可以复用的页面</span></span><br><span class="line">            <span class="keyword">return</span> wp_page_reuse(mm, vma, address, page_table, ptl, orig_pte, old_page, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) == (VM_WRITE|VM_SHARED))) {</span><br><span class="line">        <span class="keyword">return</span> wp_page_shared(mm, vma, address, page_table, pmd, ptl, orig_pte, old_page);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//处理写时复制，分配新的page，拷贝旧页面到新页面，并根据vm_page_prot生成新的pte，添加到硬件页表</span></span><br><span class="line">    <span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd, orig_pte, old_page);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="do-numa-page"><a href="#do-numa-page" class="headerlink" title="do_numa_page"></a>do_numa_page</h2><p>非一致性内存访问（NUMA）下的页表映射操作</p>
<h2 id="do-swap-page"><a href="#do-swap-page" class="headerlink" title="do_swap_page"></a>do_swap_page</h2><p>此时pte的内容所对应的页面在swap空间中，那么就需要由pte得到swap entry，再由swap entry得到page，再由pte以及pte entry添加到pte页表</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th>异常来源</th>
<th>相关函数调用</th>
<th>中断动作</th>
</tr>
</thead>
<tbody><tr>
<td>页面未映射</td>
<td>do_anonymous_page</td>
<td>分配物理页面并在页表中设置从虚拟地址到物理地址的映射</td>
</tr>
<tr>
<td>写只读页面</td>
<td>do_wp_page</td>
<td>如果写时复制就复制一页并标记可写返回进程；如果异常发送SIGSEGV</td>
</tr>
<tr>
<td>页面在磁盘中</td>
<td></td>
<td>从磁盘按需加载</td>
</tr>
<tr>
<td>没有访问权限</td>
<td></td>
<td>发送SIGSEGV信号</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cntofu.com/book/114/Interrupts/interrupts-5.md">Interrupts and Interrupt Handling Part 5</a></li>
<li><a href="https://www.cnblogs.com/jikexianfeng/articles/5647994.html">缺页异常详解</a></li>
<li><a href="https://blog.csdn.net/jasonactions/article/details/114886549">缺页中断处理 - handle_pte_fault</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/607537244">异常处理流程2-page fault</a></li>
</ul>
]]></content>
      <categories>
        <category>OperatingSystem</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>interrupt</tag>
      </tags>
  </entry>
  <entry>
    <title>豆瓣电影Top250数据爬取、数据分析及数据可视化</title>
    <url>/2022/12/03/SoftwareDevelopment/Item/doubanTop250Spider/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在爬虫学习中，一套完整的项目实战对于代码和计算机思维能力有很大的提升。本文基于B站视频<a href="https://www.bilibili.com/video/BV12E411A7ZQ?from=search&amp;seid=4741588992451392787">《Python爬虫基础5天速成（2021全新合集）Python入门+数据可视化》</a>关于 “豆瓣电影Top250” 项目做出的总结、拓展与分享。<br>在本文中，只展示数据爬取到数据保存的工作，数据可视化部分只做部分分析和结果展示。具体关于库的操作我选择了一些官方文档做链接，知识点比较全面请参考下列表。如果想要项目源代码，请评论或私信。</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.7/library/urllib.html?highlight=urllib">URL处理系统模块：urllib</a></li>
<li><a href="https://requests.readthedocs.io/zh_CN/latest/">URL处理第三方模块：requests</a></li>
<li><a href="https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/">数据提取bs4模块：BeautifulSoup</a></li>
<li><a href="https://docs.python.org/zh-cn/3.7/library/re.html">数据提取正则表达式模块：re</a></li>
<li><a href="https://www.jianshu.com/p/9135d7833d6d">数据提取模块 ：lxml</a></li>
<li><a href="https://docs.python.org/zh-cn/3.7/library/sqlite3.html">数据库保存模块：sqlite3</a></li>
<li><a href="https://www.cnblogs.com/python-robot/p/9958352.html">本地文件保存模块：xlwt</a></li>
</ul>
<h1 id="数据爬取与解析"><a href="#数据爬取与解析" class="headerlink" title="数据爬取与解析"></a>数据爬取与解析</h1><h2 id="数据爬取"><a href="#数据爬取" class="headerlink" title="数据爬取"></a>数据爬取</h2><p>数据爬取工作是整个工程的第一步，这一阶段所要做的工作是将网页上带有我们需要的信息的网页源码抓取下来。<strong>建议在此步骤时，如果数据量不大全部抓取保存到本地；如果数据量很大，则先保存一组到多组数据到本地</strong>。在接下的数据解析时通过本地文件解析，这样做会避免后面多次访问网站而被封ip，当然针对被封ip有相应的解决办法，但是这些内容涉及到网络知识，建议后面再学。</p>
<h3 id="urllib方法"><a href="#urllib方法" class="headerlink" title="urllib方法"></a>urllib方法</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">base_url = <span class="string">"https://movie.douban.com/top250?start="</span></span><br><span class="line">header = {</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">#构建请求</span></span><br><span class="line">req = urllib.request.Request(url=base_url,headers=header)</span><br><span class="line"><span class="comment">#得到响应</span></span><br><span class="line">response = urllib.request.urlopen(req)</span><br><span class="line">html = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="requests方法"><a href="#requests方法" class="headerlink" title="requests方法"></a>requests方法</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">base_url = <span class="string">"https://movie.douban.com/top250?start="</span></span><br><span class="line">header = {</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"</span></span><br><span class="line">}</span><br><span class="line">response = requests.get(url=base_url,headers=header)</span><br><span class="line">data = response.content.decode()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"w"</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h2><p>数据解析作为第二步是整个工程的核心，这一步直接决定了 我们是否能够在海量的数据中只得到我们想要的数据。爬虫中三种重要的数据解析的方法分别是：BeautifulSoup、re正则表达式和xpath，三种方法没有优劣好坏，按照我前面给出的文档，自己用好一种即可满足需求，当然三种方法根据场景使用是最高效的，如果你是大佬的话👍。<br>我自己常用的是xpath方法。第一，xpath路径可以直接在网页上进行复制；第二，可以通过<a href="https://blog.csdn.net/heartbeat196/article/details/113790232">XPath Helper工具</a>进行更好的测试，我在之前的博客有提到可以<a href="https://blog.csdn.net/heartbeat196/article/details/113790232">点击</a>查看。下面我用三种不同的方法对保存到本地的一页上的数据进行了解析。</p>
<h3 id="BeaufifulSoup"><a href="#BeaufifulSoup" class="headerlink" title="BeaufifulSoup"></a>BeaufifulSoup</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#将要解析的网站打开</span></span><br><span class="line">html = <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"rb"</span>)</span><br><span class="line"><span class="comment">#构建BeautifulSoup对象</span></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">"html.parser"</span>)</span><br><span class="line"><span class="comment">#得到每一块的内容</span></span><br><span class="line">blocks = soup.select(<span class="string">".grid_view .item"</span>)</span><br><span class="line"><span class="comment">#构建电影列表</span></span><br><span class="line">movie_list = []</span><br><span class="line"><span class="comment">#电影链接和电影图片链接</span></span><br><span class="line"><span class="keyword">for</span> index,block <span class="keyword">in</span> <span class="built_in">enumerate</span>(blocks):</span><br><span class="line">    movie_dict = {}</span><br><span class="line">    movie_dict[<span class="string">"movie_href"</span>] = block.select(<span class="string">"a"</span>)[<span class="number">0</span>].get(<span class="string">"href"</span>)       <span class="comment">#电影详情页链接</span></span><br><span class="line">    movie_dict[<span class="string">"pic_href"</span>] = block.select(<span class="string">"img"</span>)[<span class="number">0</span>].get(<span class="string">"src"</span>)        <span class="comment">#电影链接</span></span><br><span class="line">    title = block.select(<span class="string">".title"</span>)                      <span class="comment">#电影名字</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(title)==<span class="number">2</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = block.select(<span class="string">".title"</span>)[<span class="number">0</span>].text            <span class="comment">#电影中文名字</span></span><br><span class="line">        o_title = block.select(<span class="string">".title"</span>)[<span class="number">1</span>].text            <span class="comment"># 电影中文名字</span></span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = o_title.replace(<span class="string">"/"</span>,<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = block.select(<span class="string">".title"</span>)[<span class="number">0</span>].text            <span class="comment">#电影中文名字</span></span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = <span class="string">" "</span>                                       <span class="comment">#电影外文名字</span></span><br><span class="line">    movie_dict[<span class="string">"rate"</span>] = block.select(<span class="string">".star .rating_num"</span>)[<span class="number">0</span>].text        <span class="comment">#电影评分</span></span><br><span class="line">    movie_dict[<span class="string">"judge"</span>] = block.select(<span class="string">".star span"</span>)[<span class="number">3</span>].text[:-<span class="number">3</span>]         <span class="comment">#评分人数</span></span><br><span class="line">    bd = block.select(<span class="string">".bd p"</span>)[<span class="number">0</span>].text</span><br><span class="line">    movie_dict[<span class="string">"bd"</span>] = re.sub(<span class="string">" "</span>,<span class="string">""</span>,bd)</span><br><span class="line">    movie_dict[<span class="string">"inq"</span>] = block.select(<span class="string">".quote .inq"</span>)[<span class="number">0</span>].text.replace(<span class="string">"。"</span>,<span class="string">""</span>)</span><br><span class="line">    movie_list.append(movie_dict)</span><br><span class="line"><span class="comment">#打印测试</span></span><br><span class="line"><span class="built_in">print</span>(movie_list)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#将要解析的网站打开</span></span><br><span class="line">html = <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"rb"</span>)</span><br><span class="line">content = html.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment">#构建etree对象</span></span><br><span class="line">data = etree.HTML(content)</span><br><span class="line"><span class="comment">#获取多个电影信息列表</span></span><br><span class="line">divs = data.xpath(<span class="string">'//div[@class="item"]'</span>)</span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    movie_dict = { }</span><br><span class="line">    movie_dict[<span class="string">"movie_href"</span>] = div.xpath(<span class="string">'div[@class="pic"]/a/@href'</span>)</span><br><span class="line">    <span class="comment">#print(movie_href)          #测试</span></span><br><span class="line">    movie_dict[<span class="string">"pic_href"</span>] = div.xpath(<span class="string">'div[@class="pic"]//img/@src'</span>)</span><br><span class="line">    <span class="comment">#print(pic_href)           #测试</span></span><br><span class="line">    title = div.xpath(<span class="string">'div[@class="info"]//a/span[@class="title"]/text()'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(title)==<span class="number">2</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = title[<span class="number">0</span>]</span><br><span class="line">        o_title = title[<span class="number">1</span>].replace(<span class="string">"/"</span>,<span class="string">""</span>)</span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = <span class="string">""</span>.join(o_title.split())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        movie_dict[<span class="string">"c_title"</span>] = title[<span class="number">0</span>]</span><br><span class="line">        movie_dict[<span class="string">"o_title"</span>] = <span class="string">" "</span></span><br><span class="line">    <span class="comment">#print(c_title,o_title)      #测试</span></span><br><span class="line">    movie_dict[<span class="string">"rate"</span>] = div.xpath(<span class="string">'div//div[2]/div/span[2]/text()'</span>)</span><br><span class="line">    <span class="comment">#print(rate)                #测试</span></span><br><span class="line">    judge = div.xpath(<span class="string">'div//div[2]/div/span[4]/text()'</span>)</span><br><span class="line">    movie_dict[<span class="string">"judge"</span>] = (<span class="built_in">str</span>(judge))[<span class="number">2</span>:-<span class="number">5</span>]</span><br><span class="line">    <span class="comment">#print(judge)                #测试</span></span><br><span class="line">    bd = <span class="built_in">str</span>(div.xpath(<span class="string">'div//div[@class="bd"]/p[1]/text()'</span>))</span><br><span class="line">    movie_dict[<span class="string">"bd"</span>] = bd.replace(<span class="string">" "</span>,<span class="string">""</span>).replace(<span class="string">r"\xa0"</span>,<span class="string">""</span>).replace(<span class="string">r"\r"</span>,<span class="string">""</span>).replace(<span class="string">r"\n"</span>,<span class="string">""</span>)</span><br><span class="line">    <span class="comment">#print(bd)                   #测试</span></span><br><span class="line">    <span class="built_in">print</span>(movie_dict)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="re正则表达式"><a href="#re正则表达式" class="headerlink" title="re正则表达式"></a>re正则表达式</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment">#影片详情链接规则</span></span><br><span class="line">findLink = re.<span class="built_in">compile</span>(<span class="string">r'&lt;a href="(.*?)"&gt;'</span>)        <span class="comment">#创建正则表达式对象，表示规则（字符串的模式）</span></span><br><span class="line"><span class="comment">#影片图片规则</span></span><br><span class="line">findSrclink = re.<span class="built_in">compile</span>(<span class="string">r'&lt;img.*src="(.*?)"'</span>,re.S)</span><br><span class="line"><span class="comment">#影片片名规则</span></span><br><span class="line">findTitle = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span class="title"&gt;(.*)&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#影片的评分规则</span></span><br><span class="line">findGrade = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span class="rating_num" property="v:average"&gt;(.*)&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#评价人数规则</span></span><br><span class="line">findJud = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span&gt;(.*)人评价&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#找到概况</span></span><br><span class="line">findInq = re.<span class="built_in">compile</span>(<span class="string">r'&lt;span class="inq"&gt;(.*)&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">#影片相关内容</span></span><br><span class="line">findBd = re.<span class="built_in">compile</span>(<span class="string">r'&lt;p class=""&gt;(.*?)&lt;/p&gt;'</span>,re.S)</span><br><span class="line"><span class="comment">#将要解析的网站打开</span></span><br><span class="line">html = <span class="built_in">open</span>(<span class="string">"top250_first_page.html"</span>,<span class="string">"rb"</span>)</span><br><span class="line">content = html.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">datalist = []</span><br><span class="line">soup = BeautifulSoup(content, <span class="string">"html.parser"</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> soup.find_all(<span class="string">"div"</span>,class_ = <span class="string">"item"</span>):</span><br><span class="line">    item = <span class="built_in">str</span>(item)</span><br><span class="line">    <span class="comment">#print(html)                                             #测试电影信息的一小段有没有内解析拿到</span></span><br><span class="line">    data = [ ]</span><br><span class="line">    title = re.findall(findTitle,item)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(title)==<span class="number">2</span>):</span><br><span class="line">        Ctitle = title[<span class="number">0</span>]</span><br><span class="line">        data.append(Ctitle)</span><br><span class="line">        Ftitle = title[<span class="number">1</span>]</span><br><span class="line">        Ftitle = title[<span class="number">1</span>].replace(<span class="string">"/"</span>, <span class="string">""</span>)</span><br><span class="line">        Ftitle = <span class="string">""</span>.join(Ftitle.split())</span><br><span class="line">        data.append(Ftitle)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Ctitle = title[<span class="number">0</span>]</span><br><span class="line">        data.append(Ctitle)</span><br><span class="line">        Ftitle = <span class="string">" "</span></span><br><span class="line">        data.append(Ftitle)</span><br><span class="line">    link = re.findall(findLink,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(link)</span><br><span class="line">    srclink = re.findall(findSrclink,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(srclink)</span><br><span class="line">    grade = re.findall(findGrade,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(grade)</span><br><span class="line">    judge = re.findall(findJud,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(judge)</span><br><span class="line">    inq = re.findall(findInq,item)[<span class="number">0</span>]</span><br><span class="line">    data.append(inq)</span><br><span class="line">    bd = re.findall(findBd,item)[<span class="number">0</span>]</span><br><span class="line">    bd = re.sub(<span class="string">'&lt;br(\s+)?/&gt;(\s+)?'</span>,<span class="string">" "</span>,bd)</span><br><span class="line">    bd = re.sub(<span class="string">"/"</span>,<span class="string">" "</span>,bd)</span><br><span class="line">    bd = <span class="string">""</span>.join(bd.split())</span><br><span class="line">    data.append(bd)</span><br><span class="line">    datalist.append(data)</span><br><span class="line"><span class="built_in">print</span>(datalist)            <span class="comment">#测试所有列表是否被打印</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="本地excel保存"><a href="#本地excel保存" class="headerlink" title="本地excel保存"></a>本地excel保存</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line">workbook = xlwt.Workbook(encoding=<span class="string">"utf-8"</span>, style_compression=<span class="number">0</span>)</span><br><span class="line">worksheet = workbook.add_sheet(<span class="string">"豆瓣电影250"</span>)</span><br><span class="line">col = [<span class="string">"中文名"</span>, <span class="string">"外文名"</span>, <span class="string">"电影链接"</span>, <span class="string">"图片链接"</span>, <span class="string">"评分"</span>, <span class="string">"评价人数"</span>, <span class="string">"概评"</span>, <span class="string">"概述"</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">    worksheet.write(<span class="number">0</span>, i, col[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(datalist)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">        worksheet.write(i + <span class="number">1</span>, j, datalist[i][j])</span><br><span class="line">workbook.save(<span class="string">"豆瓣top250_firstPage.xls"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="sqlite数据库保存"><a href="#sqlite数据库保存" class="headerlink" title="sqlite数据库保存"></a>sqlite数据库保存</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_db</span>(<span class="params">dbpath</span>):</span><br><span class="line">    sql = <span class="string">'''</span></span><br><span class="line"><span class="string">        create table movie250 </span></span><br><span class="line"><span class="string">        (</span></span><br><span class="line"><span class="string">        id integer primary key autoincrement,</span></span><br><span class="line"><span class="string">        info_link text,</span></span><br><span class="line"><span class="string">        pic_link text,</span></span><br><span class="line"><span class="string">        cname varchar,</span></span><br><span class="line"><span class="string">        ename varchar,</span></span><br><span class="line"><span class="string">        score numeric ,</span></span><br><span class="line"><span class="string">        rated numeric ,</span></span><br><span class="line"><span class="string">        instroduction text,</span></span><br><span class="line"><span class="string">        info text</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    '''</span>  <span class="comment"># 创建数据表</span></span><br><span class="line">    conn = sqlite3.connect(dbpath)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    conn.commit()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">saveData2DB</span>(<span class="params">datalist, dbpath</span>):</span><br><span class="line">    <span class="comment">#init_db(dbpath)</span></span><br><span class="line">    conn = sqlite3.connect(dbpath)</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datalist:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        	data[index] = <span class="string">'"'</span> + data[index] + <span class="string">'"'</span></span><br><span class="line">        sql = <span class="string">'''</span></span><br><span class="line"><span class="string">                insert into movie250 (</span></span><br><span class="line"><span class="string">                info_link,pic_link,cname,ename,score,rated,instroduction,info) </span></span><br><span class="line"><span class="string">                values(%s)'''</span> % <span class="string">","</span>.join(data)</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        conn.commit()</span><br><span class="line">    cur.close()</span><br><span class="line">    conn.close()</span><br><span class="line">saveData2DB(datalist,<span class="string">"movie.db"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="/images/SoftwareDevelopment/Item/douban-1.png" alt="在这里插入图片描述"><br><img src="/images/SoftwareDevelopment/Item/douban-2.png" alt="在这里插入图片描述"></p>
<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a><a href="https://dormousehole.readthedocs.io/en/latest/">Flask</a></h2><p>Flask 是一个微型的 Python 开发的 Web 框架，基于Werkzeug WSGI工具箱和Jinja2 模板引擎。 Flask使用BSD授权。 Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数据库、窗体验证工具。<br>简单来说在此项目中，Flask框架给我们提供了一个本地网页平台展示数据。我们根据不同的路由地址进行到不同的页面访问。如下图是首界面，通过不同的链接地址可以实现页面跳转，当然只是本地！<br><img src="/images/SoftwareDevelopment/Item/douban-3.png" alt="在这里插入图片描述"></p>
<h2 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a><a href="https://echarts.apache.org/en/index.html">Echarts</a></h2><p>Echarts是一个纯基于js的图表库，可以流畅的运行在 PC 和移动设备上。在本项目中可以将数据进行统计分类从而用不同的展示方法进行展现。在Echarts中可以支持的图表类型有很多，同时其有一个很好的点在于它能满足我们实时修改查看，最终形成自己想要的图，便将js代码复制粘贴到我们所需要的网页代码的地方。<br>由于在页面内有动态显示，所以不在进行展示。</p>
<h2 id="WordCloud"><a href="#WordCloud" class="headerlink" title="WordCloud"></a>WordCloud</h2><p>词云展示方法是近些年来较为常用的数据可视化方法。其主要是通过分词技术将一篇文章或者一段话分成若干单词，然后统计这些词出现的频率，我们根据自定义化设置画布和这些词出现的颜色大小等等来得到某个词云。词云中重要的是画布的配置、自己所要定义的形式是什么样子，其他更多的是某些固定的方法。下图为我通过爬取毛不易的歌词内容获得毛不易的歌词词云图，如果需要此项目源码或者方法请私信。<br><img src="/images/SoftwareDevelopment/Item/douban-4.png" alt="在这里插入图片描述"></p>
<h1 id="新手问题总结与解决方法"><a href="#新手问题总结与解决方法" class="headerlink" title="新手问题总结与解决方法"></a>新手问题总结与解决方法</h1><h2 id="ip被封"><a href="#ip被封" class="headerlink" title="ip被封"></a>ip被封</h2><p>ip被封可能是新手在爬虫学习阶段遇到的最大的问题。首先如果是初学想要尽快实现一些成果时，建议在合理范围内减少爬取次数，如果我们能获得网页内容了首先将其存到本地文件夹下进行后续的测试和解析。俗话说：上有政策下有对策，面对ip被封：基础阶段我们可以添加请求头，尽可能的进行伪装像一个浏览器在访问；再进一步我们可以自己构建代理ip函数，仿照源码添加免费ip，构建handler处理器使用opener方法也可以；如果有能力的话，可以学习代理ip池的方法来解决该问题。<br>当然，爬虫我们是要在合法范围内进行抓取，如果某些数据是机密或者不能访问的，我们还一直访问可能就很快有自己的小手镯子了🔓。我们只爬取我们可以访问到的，爬虫只是提高效率，不是翻过禁墙。</p>
<h2 id="查看网页源码和”F12-Elements”后不一致"><a href="#查看网页源码和”F12-Elements”后不一致" class="headerlink" title="查看网页源码和”F12 Elements”后不一致"></a>查看网页源码和”F12 Elements”后不一致</h2><p>该问题可以总结为用一般方法有些需要的元素抓取不到。在本次项目中我们爬取的页面是静态网页所以可以直接抓取，但是对于动态网页就会无能为力。<br>查看网页源码：最原始的代码，指的是服务器直接发送到浏览器的代码。<br>F12检查元素：js渲染后的代码。而确实的部分就是js所渲染的。<br>如果我们想要抓取这部分代码可以采取以下两种方法：</p>
<ol>
<li>在页面上进行抓包，获取表单的元素和js链接提交请求</li>
<li>通过selenium技术，模拟用户打开网页，进行自动化的抓取。</li>
</ol>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>以上两个问题是我在这个项目中所遇到的，当然在面对更复杂的爬虫工作时，会有更加繁琐的问题出现。还有一些其他问题，我将其总结为基础知识问题。在很多初学的时候，我们获得的数据往往以不同的格式进行存储，但是某些方法只能针对某些固定数据格式，这些需要我们提起注意；还有就是我们不可避免的马虎问题，关键词拼写错误，变量书写错误等等，这些最好的解决办法就是孰能生巧。<br>最后就是建议大家在完成一个项目时选择分块按照不同的模块去练习测试，最终完成项目。</p>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Item</category>
      </categories>
  </entry>
  <entry>
    <title>智能家居模型设计</title>
    <url>/2022/12/03/SoftwareDevelopment/Item/smartHome/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>伴随着通信技术的不断发展和社会环境的进步，人们对更智能化的生活有了更高的追求。物联网智能家居已经不能算是新鲜的名词了，其单品及互联应用也都已经非常广泛了。本设计基于STM32单片机，通过ESP8266无线通信模块以及连接相应的传感器及外设对智能家居的场景进行模拟。本文最初写于今年6月，现在从事嵌入式工作一段时间后现在再次将我的毕业设计重新进行整理和思考，希望能对读者有所帮助！</p>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>对于任何一个项目或者工程的开始第一步永远是先明确需求，知道自己做成什么样子的东西。在我参考了一些资料并阅读了几篇文献后，对其有了初认识。我理解的智能家居就是从感知层出发对环境进行监测，通过传输层遵从一定的网络协议对数据进行传输同时通过软件对数据进行整理分析，并在应用层（家具状态）做出相应的动作。最终我将该流程整理成下图所示的实物模拟，进而对其进行模块的抽象。基于此，进行下面的硬件设计选型及软件实现等等。<br><img src="/images/SoftwareDevelopment/Item/smarthome-1.png"></p>
<h1 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h1><h2 id="硬件选型原则"><a href="#硬件选型原则" class="headerlink" title="硬件选型原则"></a>硬件选型原则</h2><p>由于该项目是模型设计，对于硬件的选型整体上是以==低成本、低功耗、高集成、高仿真度==为原则的。</p>
<ul>
<li>满足功能及性能需求。本设计的侧重点不在于数据的精确和控制的灵敏，故没有严格参数要求。</li>
<li>易上手的“大众”产品。对于这些元件我们可以很容易的找到相关资料，而且避免踩坑。</li>
<li>兼容性。由于是模块化设计，对于部分模块的兼容性是要有一定的要求的。</li>
</ul>
<h2 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h2><p>如下是对于硬件的选型及相关介绍，最后附有一张所有用到的硬件的图片。</p>
<p><em><strong>1. 主控模块—-STM32F103C8T6</strong></em></p>
<p>   我相信51应该是大部分电子同学入手的第一款单片机。诚然，51有其灵活轻巧之处，但是stm32具有强大外设接口和较高的运行速度（STM32F103的CPU最高速度达72 MHz，具有16KB ~ 1MB Flash、多种控制外设、USB全速接口和CAN；多达112个快速I/O口、11个定时器和13个通信接口） 此外STM32还提供了三种省电模式和两种调试方式。其灵活的调试方法、多样的功能特点和较优的性能参数同样也是选择STM32作为主控芯片的原因。  </p>
<p><em><strong>2. 无线通信模块—-ESP01S无线通信模块</strong></em></p>
<p>   基于此模块首先考虑的是通信方式，如果不谈应用场景，比较传输速度、传输距离和安全性，zigbee和蓝牙会是更好的选择。但是在智能家居的场景下，wifi无疑会是更优选，因为当下wifi已经基本普及到了每个家庭，模拟还原度会更高。接下来是具体芯片的选择，安信可的ESP8266模组很多都可以在该场景下应用，其具体的区分主要体现在封装方式、硬件配置、资源引脚等等方面。具体的区分可以参考安信可官网给出的文档说明，<a href="https://www.ai-thinker.com/product/esp8266">please click</a>！</p>
<p><em><strong>3. 环境监测模块</strong></em></p>
<ul>
<li><p>温湿度监测—-DHT11</p>
<blockquote>
<p>  DHT11是一款有已校准数字信号输出的温湿度传感器。此传感器使用起来简单，精度和性能参数足够满足环境监测的场景。其遵从单总线协议，有严格的时序要求。主机先要发送一个至少18ms的低电平，在这个过程中，DHT11内部完成AD转换等操作，当主机拉高后，有20-40us时间，这个时间用于主机做输入输出切换，当主机释放总线控制权（此时主机为输入状态，总线被上拉电阻拉高），DHT11尝试将总线拉低，成功拉低后就开始准备发送数据了，再拉高一次就开始传输数据了。</p>
</blockquote>
</li>
<li><p>空气质量监测—-MQ135<br> &gt; MQ系列传感器是监测空气环境最常用的传感器，大概十几个都是针对不同污染物进行检测的，本次实验我们采用的是MQ135，主要针对氨气、苯、酒精、烟雾颗粒进行空气质量检测，同样根据自己的需求可以选择其他型号的传感器吧，比如烟雾、酒精、一氧化碳等等。</p>
</li>
<li><p>光照监测—-BH1750</p>
<blockquote>
<p> BH1750传感器有接近视觉灵敏度的光谱灵敏度特性，它支持I2CBUS接口，支持1.8v逻辑输入接口。传感器有两种可选的I2Cslave地址，无需其他外部件。光源依赖性弱，受红外线影响很小。传感器通过降低功率功能，实现低电流化。</p>
</blockquote>
</li>
</ul>
<p><em><strong>4. 数据展示模块—-OLED</strong></em></p>
<p>   数据显示无非就是OLED、LCD、TFT屏幕等等。该模块的作用是对监测到的环境数据及家具的状态进行实时显示。OLED相较于LCD屏幕则不需要背光层，同样也不需要发出光亮的液晶层；而相较于TFT有更高的性价比，最终选择了0.96寸OLED屏幕。</p>
<p><em><strong>5. 家具模拟模块</strong></em></p>
<p>   家具模拟模块主要是模拟到了门、窗、灯和风扇。具体是通过步进电机、舵机、LED灯和风扇模块实现的。而应用也很简单，配置IO口的工作模式，控制GPIO口输出的高低电平即可。<br>   <img src="/images/SoftwareDevelopment/Item/smarthome-2.png"></p>
<h2 id="PCB设计"><a href="#PCB设计" class="headerlink" title="PCB设计"></a>PCB设计</h2><p>对于以上众多元件和模块，如果用导线直接连接起来的话，我只能想到一个词形容：一团乱麻！因此设计PCB板就成了解决该问题的最好方法。可能有的同学在大学期间学习过如何画板打板，有些同学没有接触过，以我自己的经验来讲，学习一两周时间对于绘制该项目PCB已经绰绰有余。该项目并不需要在板子上有各个电路的设计（有能力的同学可以设计一个电源电路），因此只需要布局布线即可还是比较简单的，以下是我所设计的板子 。</p>
<p>该部分的设计让自己对于整个硬件资源的了解及使用有一个新的认识。在主控芯片有限的硬件资源、有限空间的电路板上，如何能充分利用每个元件的形状大小和性能特点来做到彼此之间的交互是该部分的重难点。<br>==Tips：阅读每根pin的功能，分配好主控芯片的各个管脚资源==</p>
<p><img src="/images/SoftwareDevelopment/Item/smarthome-3.png"></p>
<h1 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h1><p>整个代码工程内容相对较大，在此就不进行详细的展示了如果有需要可以私信我。在此只展示部分主函数代码和相关头文件等，除此之外，数据上云格式定义、命令下发、各个模块的驱动函数同样重要！</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"math.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"string.h"</span>	</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"dht11.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"BH1750.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"adc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"OLED_I2C.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"usart.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"timer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"exti.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"door_bsp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"fan.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"esp8266.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MqttKit.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"onenet.h"</span></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span>					<span class="comment">//定义结构体</span></span><br><span class="line">	<span class="type">uint8_t</span> temp;				<span class="comment">//温度</span></span><br><span class="line">	<span class="type">uint8_t</span> humi;				<span class="comment">//湿度</span></span><br><span class="line">	<span class="type">float</span> mq;					<span class="comment">//MQ135传感器</span></span><br><span class="line">	<span class="type">float</span> sun;					<span class="comment">//光照强度传感器</span></span><br><span class="line">	<span class="type">uint8_t</span> LED_FLAG;			<span class="comment">//LED</span></span><br><span class="line">	<span class="type">uint8_t</span> FAN_FLAG;			<span class="comment">//风扇</span></span><br><span class="line">	<span class="type">uint8_t</span> DOOR_FLAG;			<span class="comment">//步进电机</span></span><br><span class="line">	<span class="type">uint8_t</span> WARNING_FLAG;		<span class="comment">//步进电机</span></span><br><span class="line">}SendData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> SendData send_data;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> cmd_rev_flag;</span><br><span class="line">SendData send_data = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> ,<span class="number">0</span>};	<span class="comment">//初始化</span></span><br><span class="line"><span class="type">uint8_t</span> cmd_rev_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *data_ptr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> timeCount = <span class="number">0</span>;	<span class="comment">//发送间隔变量</span></span><br><span class="line">	Hardware_Init();</span><br><span class="line">	Net_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{  		</span><br><span class="line">		<span class="keyword">if</span>(++timeCount &gt;= <span class="number">200</span> || (cmd_rev_flag == <span class="number">1</span>))	</span><br><span class="line">{	</span><br><span class="line">			DHT11_Read_Data(&amp;send_data.temp,&amp;send_data.humi);</span><br><span class="line">			send_data.mq=(<span class="type">float</span>)(Get_Adc_Average(ADC_Channel_1,<span class="number">10</span>))*(<span class="number">3.3</span>/<span class="number">4096</span>);	</span><br><span class="line">			send_data.sun = LIght_Intensity();										 </span><br><span class="line">			OneNet_SendData();	<span class="comment">//发送数据</span></span><br><span class="line">			timeCount = <span class="number">0</span>;</span><br><span class="line">			cmd_rev_flag=<span class="number">0</span>;</span><br><span class="line">			ESP8266_Clear();</span><br><span class="line">		}</span><br><span class="line">		data_ptr = ESP8266_GetIPD(<span class="number">0</span>);		<span class="comment">//检查是否有下发指定</span></span><br><span class="line">		<span class="keyword">if</span>(data_ptr != <span class="literal">NULL</span>)</span><br><span class="line">			OneNet_RevPro(data_ptr);</span><br><span class="line">		delay_ms(<span class="number">10</span>);</span><br><span class="line">	}		 </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="硬件初始化"><a href="#硬件初始化" class="headerlink" title="硬件初始化"></a>硬件初始化</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Hardware_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	delay_init();	    		<span class="comment">//延时函数初始化</span></span><br><span class="line">	TIM2_Int_Init(<span class="number">4999</span>,<span class="number">7199</span>);  	<span class="comment">//用于OLED显示</span></span><br><span class="line">	Usart1_Init(<span class="number">115200</span>);		<span class="comment">//串口调试</span></span><br><span class="line">	Usart2_Init(<span class="number">115200</span>);		<span class="comment">//esp8266--stm32通信</span></span><br><span class="line">	OLED_Init();				<span class="comment">//OLED初始化</span></span><br><span class="line">	OLED_CLS();</span><br><span class="line">	KEY_Init();					<span class="comment">//按键初始化</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">								<span class="comment">//设置中断优先级分组2，为后面外部中断做基础</span></span><br><span class="line">	EXTIX_Init();				<span class="comment">//判断键值执行操作</span></span><br><span class="line">	DHT11_Init();				<span class="comment">//温湿度传感器初始化</span></span><br><span class="line">	Adc_Init();					<span class="comment">//空气检测初始化</span></span><br><span class="line">	BH1750_Init();				<span class="comment">//光照</span></span><br><span class="line">	TIM3_Int_Init(<span class="number">4999</span>,<span class="number">7199</span>);  	<span class="comment">//报警显示</span></span><br><span class="line">	ESP8266_Init();				<span class="comment">//初始化ESP8266</span></span><br><span class="line">	<span class="keyword">while</span>(OneNet_DevLink())		<span class="comment">//接入OneNET</span></span><br><span class="line">	delay_ms(<span class="number">500</span>);</span><br><span class="line">}	</span><br></pre></td></tr></tbody></table></figure>

<h1 id="云平台选择"><a href="#云平台选择" class="headerlink" title="云平台选择"></a>云平台选择</h1><p>本设计还有一个重要的部分就是对于云平台的选择，本项目选择的是中国移动物联网云平台OneNET。当然，如果有能力的同学自己做个app更好。</p>
<p>目前很多云平台厂商都支持了对于个人开发者的物联网应用的需求，我见到用到最多的包括阿里云、腾讯云、机智云、OneNET等等。这些平台对对于个人开发者还是很有好的，有着比较完善的流程。我个人使用过机智云和OneNET，对此做出以下建议。</p>
<ul>
<li>OneNET：更适合已有工程文件，在此基础之上进行通信部分的开发。其对于最终的界面设计很开放，可以自行设计图标及显示方式等；</li>
<li>机智云：适合没有工程文件，从刚开始就选择使用该物联网云平台。可以在平台上生成代码包进行开发；</li>
</ul>
<h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><h2 id="实物图与手机界面"><a href="#实物图与手机界面" class="headerlink" title="实物图与手机界面"></a>实物图与手机界面</h2><p><img src="/images/SoftwareDevelopment/Item/smarthome-4.png"></p>
<h2 id="云平台数据可视化界面"><a href="#云平台数据可视化界面" class="headerlink" title="云平台数据可视化界面"></a>云平台数据可视化界面</h2><p><img src="/images/SoftwareDevelopment/Item/smarthome-5.png"></p>
<h2 id="云平台控制界面"><a href="#云平台控制界面" class="headerlink" title="云平台控制界面"></a>云平台控制界面</h2><p><img src="/images/SoftwareDevelopment/Item/smarthome-6.png"></p>
<h1 id="实现功能及扩展"><a href="#实现功能及扩展" class="headerlink" title="实现功能及扩展"></a>实现功能及扩展</h1><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ul>
<li><p>监测：空气中温度、湿度、光照和空气质量等环境因素；</p>
</li>
<li><p>控制：模拟的“家居”：门、灯、窗帘、风扇；</p>
</li>
<li><p>显示：OLED显示、手机显示、电脑显示；</p>
</li>
<li><p>控制方式：按键控制、手机控制、电脑控制；</p>
</li>
<li><p>报警：设置环境因素阈值，超标开发板的灯亮起（可改成蜂鸣器）</p>
</li>
<li><p>以上所有环境及家具状态都可以可视化显示</p>
</li>
</ul>
<h2 id="可扩展功能"><a href="#可扩展功能" class="headerlink" title="可扩展功能"></a>可扩展功能</h2><p>该系统具有很高的扩展性，做出基础模型之后可以进行二次开发。需要注意的是将硬件资源分配好。</p>
<ul>
<li>语音模块。语音控制智能家居的状态。</li>
<li>安防系统。添加指纹、RFID、面部识别等开门方式。</li>
<li>告警系统。目前只是遇到告警平台自动提醒，可以添加短信通知功能。</li>
<li>模式选择。居家多种模式自动切换，娱乐模式、休息模式、离家模式等等，家具可以对应着不同状态。</li>
<li>……</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本设计对于智能家居控制系统的模拟从传统到智能、从前端到后端，覆盖面、还原度还是比较高的；其次，系统的兼容性和可扩展移植性较高，基于此可以进行二次开发，可以扩展的内容我在上面也有总结。我认为相对容易上手的就是对于监测到的数据进行进一步分析应用。最后就是其应用性，当自己设计好电源模块可以独立供电后就可以直接应用到生活中，即使不做毕设diy一个环境监测的系统也是不错的。整体来说，本设计实现的功能是：四测三显两控一平台，基本实现了智能家居模拟的基本的要求。同样该项目还可以应用到环境监测等方面的，但是其侧重点更要偏向数据的分析和处理。</p>
<p>行文至此就结束啦，如果有不足之处或者更好的想法可以一起交流 ~</p>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Item</category>
      </categories>
      <tags>
        <tag>毕业设计</tag>
      </tags>
  </entry>
  <entry>
    <title>ALSA</title>
    <url>/2023/04/11/SoftwareDevelopment/Media/Audio-Alsa/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>官网：<a href="https://www.alsa-project.org/wiki/Main_Page">https://www.alsa-project.org/wiki/Main_Page</a></p>
</blockquote>
<p>ALSA：Advanced Linux Sound Architecture，高级linux声音体系，它在Linux操作系统上提供了音频和MIDI（Musical Instrument Digital Interface，音乐设备数字化接口）的支持。</p>
<h1 id="ALSA设备文件结构"><a href="#ALSA设备文件结构" class="headerlink" title="ALSA设备文件结构"></a>ALSA设备文件结构</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># cd /dev/snd; ls -l;</span></span><br><span class="line"></span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">8</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">38</span> controlC0	 用于声卡的控制,例如通道选择,混音,麦克风的控制等 </span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">4</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">38</span> midiC0D0	 用于播放midi音频 </span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">7</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">39</span> pcmC0D0c	 用于录音的pcm设备 </span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">6</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">56</span> pcmC0D0p	 用于播放的pcm设备 </span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">3</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">38</span> seq		 音序器 </span><br><span class="line">crw-rw----+ <span class="number">1</span> root audio <span class="number">116</span>, <span class="number">2</span> <span class="number">2011</span><span class="number">-02</span><span class="number">-23</span> <span class="number">21</span>:<span class="number">38</span> timer	     定时器</span><br></pre></td></tr></tbody></table></figure>

<p>其中,C0D0代表的是声卡0中的设备0 ; pcmC0D0c最后一个c代表capture ; pcmC0D0p最后一个p代表playback。</p>
<h2 id="alsa相关函数及文件"><a href="#alsa相关函数及文件" class="headerlink" title="alsa相关函数及文件"></a>alsa相关函数及文件</h2><h3 id="函数及结构体"><a href="#函数及结构体" class="headerlink" title="函数及结构体"></a>函数及结构体</h3><ul>
<li>AVFrame    iFrame           存储非压缩的数据，输入</li>
<li>AVFrame    swapFrame   存储非压缩的数据，重采样</li>
<li>AVPack       oPacket          压缩即编码后的输入，输出</li>
</ul>
<ol>
<li><p>snd_pcm_hw_params_get_rate( )</p>
</li>
<li><p>snd_pcm_open( )</p>
<ul>
<li><p>snd_config_update_ref</p>
<p>这个函数作用是检查alsa配置文件是否发生了变化，包括文件名字和各个配置文件的内容是否修改，如果有修改，就重新加载配置文件树，刷新全局变量snd_config并增加一个snd_config的引用计数，调用snd_config_update_ref传入的top就是指向snd_config的指针，这个top当作参数传入snd_pcm_open_noupdate函数中。snd_config_unref接下来会减去snd_config的引用计数。</p>
<p>首先创建顶层配置节点，然后打开/usr/share/alsa/alsa.conf，加载文件内容到顶层配置节点上，然后遍历所有的hooks，调用snd_config_hooks加载所有hooks，并调用相关的hooks函数打开对应的plugin动态库</p>
</li>
<li><p>snd_pcm_open_noupdate</p>
</li>
</ul>
</li>
<li><p>avcodec_open2( )</p>
<ul>
<li><p>检测指定的codec和context里面的codec是否匹配。</p>
</li>
<li><p>分配空间。</p>
</li>
<li><p>检测codec各个参数合法性，并给某些字段赋初值。</p>
</li>
<li><p>调用codec的init初始化codec。</p>
</li>
<li><p>释放资源，返回。</p>
</li>
</ul>
</li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ol>
<li><p>参考网址 : <a href="https://www.cnblogs.com/lihaiping/p/alsaconfig.html">https://www.cnblogs.com/lihaiping/p/alsaconfig.html</a></p>
</li>
<li><p>配置文件的调用过程</p>
<p>alsa-lib库  :  alsa-lib-1.2.1.2/src/pcm/pcm.c</p>
<p>snd_pcm_open( ) 函数作为打开一个pcm的接口.  具体的调用过程是 :  static snd_pcm_open_noupdate —-&gt;  static snd_pcm_open_conf( )</p>
<p>解析asound.conf过程 : <a href="https://www.xuebuyuan.com/1043778.html">https://www.xuebuyuan.com/1043778.html</a></p>
</li>
<li><p>snd_pcm_open内部直接解析的是usr/share/alsa/alsa.conf, 在这个文件中决定了etc/asound.conf和/.asoundrc这两个文件要不要调用</p>
</li>
</ol>
<h3 id="3-3-音频设备的定义"><a href="#3-3-音频设备的定义" class="headerlink" title="3.3 音频设备的定义"></a>3.3 音频设备的定义</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#  文件定义位置 : /system/core/include/system/audio.h</span><br><span class="line">enum {</span><br><span class="line">    AUDIO_DEVICE_NONE                          = 0x0,</span><br><span class="line">    /* reserved bits */</span><br><span class="line">    AUDIO_DEVICE_BIT_IN                        = 0x80000000,</span><br><span class="line">    AUDIO_DEVICE_BIT_DEFAULT                   = 0x40000000,</span><br><span class="line">    /* output devices */</span><br><span class="line">    AUDIO_DEVICE_OUT_EARPIECE                  = 0x1,    // 听筒</span><br><span class="line">    AUDIO_DEVICE_OUT_SPEAKER                   = 0x2,    // 扬声器</span><br><span class="line">    AUDIO_DEVICE_OUT_WIRED_HEADSET             = 0x4,    // 线控耳机，可以通过耳机控制远端播放、暂停、音量调节等功能的耳机</span><br><span class="line">    AUDIO_DEVICE_OUT_WIRED_HEADPHONE           = 0x8,    // 普通耳机，只能听，不能操控播放</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_SCO             = 0x10,   // 单声道蓝牙耳机，十进制32</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET     = 0x20,   // 车载免提蓝牙设备，十进制64</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT      = 0x40,   // 立体声蓝牙耳机</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP            = 0x80,   // 十进制128</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES = 0x100,  // 十进制256</span><br><span class="line">    AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER    = 0x200,  // 十进制512</span><br><span class="line">    AUDIO_DEVICE_OUT_AUX_DIGITAL               = 0x400,  // 十进制1024</span><br><span class="line">    AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET         = 0x800,  // 十进制2048</span><br><span class="line">    AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET         = 0x1000, // 十进制4096</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="alsa插件"><a href="#alsa插件" class="headerlink" title="alsa插件"></a>alsa插件</h1><blockquote>
<p>asound.conf配置 <a href="https://www.alsa-project.org/main/index.php/Asoundrc">https://www.alsa-project.org/main/index.php/Asoundrc</a></p>
<p>插件详解官网  <a href="https://www.alsa-project.org/alsa-doc/alsa-lib/pcm_plugins.html">https://www.alsa-project.org/alsa-doc/alsa-lib/pcm_plugins.html</a></p>
</blockquote>
<ol>
<li>生成alsa配置文件 : alsactl store -f a.conf</li>
<li>对于耳机的controls需要指定-c 1,默认走的是card 0</li>
<li>播放音频的命令 arecord -D usbheadsetC -d 5 -f cd -r 48000 -c 2 -t wav test.wav</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//查看控件</span></span><br><span class="line"><span class="meta"># amixer -c 1 controls </span></span><br><span class="line">numid=<span class="number">3</span>,iface=MIXER,name=<span class="string">'PCM Playback Switch'</span></span><br><span class="line">numid=<span class="number">4</span>,iface=MIXER,name=<span class="string">'PCM Playback Volume'</span></span><br><span class="line">numid=<span class="number">6</span>,iface=MIXER,name=<span class="string">'usbCapture_vol'</span></span><br><span class="line">numid=<span class="number">5</span>,iface=MIXER,name=<span class="string">'usbPlay_vol'</span></span><br><span class="line">numid=<span class="number">1</span>,iface=PCM,name=<span class="string">'Capture Channel Map'</span></span><br><span class="line">numid=<span class="number">2</span>,iface=PCM,name=<span class="string">'Playback Channel Map'</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//对控件进行配置</span></span><br><span class="line"><span class="meta"># amixer -c 1 sget usbCapture_vol </span></span><br><span class="line">Simple mixer control <span class="string">'usbCapture_vol'</span>,<span class="number">0</span></span><br><span class="line">  Capabilities: volume</span><br><span class="line">  Playback channels: Front Left - Front Right</span><br><span class="line">  Capture channels: Front Left - Front Right</span><br><span class="line">  Limits: <span class="number">0</span> - <span class="number">255</span></span><br><span class="line">  Front Left: <span class="number">100</span> [<span class="number">39</span>%]</span><br><span class="line">  Front Right: <span class="number">100</span> [<span class="number">39</span>%]</span><br><span class="line"><span class="meta"># amixer -c 1 cget numid=5,iface=MIXER,name=<span class="string">'usbCapture_vol'</span></span></span><br><span class="line">numid=<span class="number">5</span>,iface=MIXER,name=<span class="string">'usbCapture_vol'</span></span><br><span class="line">  ; type=INTEGER,access=rw---RW-,values=<span class="number">2</span>,min=<span class="number">0</span>,max=<span class="number">255</span>,step=<span class="number">0</span></span><br><span class="line">  : values=<span class="number">100</span>,<span class="number">100</span></span><br><span class="line">  | dBscale-min=<span class="number">-20.00</span>dB,step=<span class="number">0.20</span>dB,mute=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># arecord -l</span></span><br><span class="line">**** List of CAPTURE Hardware Devices ****</span><br><span class="line">card <span class="number">0</span>: smartpenknot [smartpen_knot], device <span class="number">0</span>: i2s-ecodec nau8822-hifi<span class="number">-0</span> []</span><br><span class="line">  Subdevices: <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line">card <span class="number">0</span>: smartpenknot [smartpen_knot], device <span class="number">1</span>: dmic dmic-codec-hifi<span class="number">-1</span> []</span><br><span class="line">  Subdevices: <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line">card <span class="number">0</span>: smartpenknot [smartpen_knot], device <span class="number">2</span>: i2s-tloop pcm-dump<span class="number">-2</span> []</span><br><span class="line">  Subdevices: <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line">card <span class="number">1</span>: EP3C [Meizu EP3C], device <span class="number">0</span>: USB Audio [USB Audio]</span><br><span class="line">  Subdevices: <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line"># </span><br><span class="line"><span class="meta"># aplay -l</span></span><br><span class="line">**** List of PLAYBACK Hardware Devices ****</span><br><span class="line">card <span class="number">0</span>: smartpenknot [smartpen_knot], device <span class="number">0</span>: i2s-ecodec nau8822-hifi<span class="number">-0</span> []</span><br><span class="line">  Subdevices: <span class="number">1</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line">card <span class="number">1</span>: EP3C [Meizu EP3C], device <span class="number">0</span>: USB Audio [USB Audio]</span><br><span class="line">  Subdevices: <span class="number">0</span>/<span class="number">1</span></span><br><span class="line">  Subdevice #<span class="number">0</span>: subdevice #<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h1 id="ALSA音频工具"><a href="#ALSA音频工具" class="headerlink" title="ALSA音频工具"></a>ALSA音频工具</h1><p>对于以下工具的使用，都可以直接输入“工具名”或“工具名 –help” 获得详细使用方法</p>
<h2 id="arecode-录音"><a href="#arecode-录音" class="headerlink" title="arecode 录音"></a>arecode 录音</h2><ol>
<li>查看录音设备 : arecode -l</li>
<li>命令实例 :  arecord -D hw:0,1 -d 10 -f cd -r 44100 -c 2 -t wav test.wav</li>
<li>参数解析 : <ul>
<li>-D 指定了录音设备，0,1 是card 0 device 1</li>
<li>-d 指定录音的时长，单位 : 秒</li>
<li>-f 指定采样格式，通过上面的信息知道只支持 cd cdr dat </li>
<li>-r 指定了采样率，单位 : Hz</li>
<li>-c 指定channel 个数</li>
<li>-t 指定生成的文件格式</li>
</ul>
</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">lee@lee-virtual-machine:~$ arecord -l</span><br><span class="line">**** CAPTURE 硬體裝置清單 ****</span><br><span class="line">card 0: AudioPCI [Ensoniq AudioPCI], device 0: ES1371/1 [ES1371 DAC2/ADC]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 #0: subdevice #0</span><br><span class="line">lee@lee-virtual-machine:~$ arecord -D hw:0,0 -d 10 -f cd -r 44100 -c 2 -t wav test.wav</span><br><span class="line">正在录音 WAVE 'test.wav' : Signed 16 bit Little Endian, 频率44100Hz， Stereo</span><br><span class="line">lee@lee-virtual-machine:~$ </span><br></pre></td></tr></tbody></table></figure>



<h2 id="aplay-放音"><a href="#aplay-放音" class="headerlink" title="aplay 放音"></a>aplay 放音</h2><ol>
<li><p>查看放音设备 : aplay -l</p>
</li>
<li><p>命令实例 : aplay test.wav</p>
<blockquote>
<p>如果是直接播放pcm数据，则需要指定pcm格式 、采样率、channel个数等。</p>
</blockquote>
</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">lee@lee-virtual-machine:~$ aplay -l</span><br><span class="line">**** PLAYBACK 硬體裝置清單 ****</span><br><span class="line">card 0: AudioPCI [Ensoniq AudioPCI], device 0: ES1371/1 [ES1371 DAC2/ADC]</span><br><span class="line">  子设备: 0/1</span><br><span class="line">  子设备 #0: subdevice #0</span><br><span class="line">card 0: AudioPCI [Ensoniq AudioPCI], device 1: ES1371/2 [ES1371 DAC1]</span><br><span class="line">  子设备: 1/1</span><br><span class="line">  子设备 #0: subdevice #0</span><br><span class="line">lee@lee-virtual-machine:~$ aplay test.wav </span><br><span class="line">正在播放 WAVE 'test.wav' : Signed 16 bit Little Endian, 频率44100Hz， Stereo</span><br><span class="line">lee@lee-virtual-machine:~$ </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h2 id="amixer-配参"><a href="#amixer-配参" class="headerlink" title="amixer 配参"></a>amixer 配参</h2><p>amixer，是alsamixer的文本模式（命令行模式）用于配置音频的各个参数</p>
<ol>
<li><p>使用方法 :</p>
<ol>
<li><p>用 # amixer controls 列出所有控制项。( 显示接口函数 )</p>
</li>
<li><p>如果对控制项不熟悉或者想查看当前的所有配置可以使用 # amixer contents 命令。(显示当前配置)</p>
</li>
<li><p>查看获取某个设置项的值用 # amixer cget + 控制参数 命令。 这里控制参数直接复制 # amixer controls 打印出来的数据就可以</p>
</li>
<li><p>根据控制参数类型设置控制参数使用 # amixer cset + 控制参数 + 设置参数 命令。</p>
</li>
<li><p>values 表示数值对于 volume 之类的是具体的数字，在上下文菜单中有显示数值的范围，对于 switch 之类的表示开关一般是 on 或 off。</p>
<p>另外一sget/sset系列的命令, 与cget/cset的使用相同</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//使用例子:</span></span><br><span class="line"><span class="comment">//给的参数看value需要几个 需要什么类型进行相应的配置即可</span></span><br><span class="line">/ <span class="meta"># amixer cget numid=43,iface=MIXER,name=<span class="string">'Speaker Playback Volum'</span></span></span><br><span class="line">numid=<span class="number">43</span>,iface=MIXER,name=<span class="string">'Speaker Playback Volume'</span></span><br><span class="line">  ; type=INTEGER,access=rw---R--,values=<span class="number">2</span>,min=<span class="number">0</span>,max=<span class="number">63</span>,step=<span class="number">0</span></span><br><span class="line">  : values=<span class="number">63</span>,<span class="number">63</span></span><br><span class="line">  | dBscale-min=<span class="number">-57.00</span>dB,step=<span class="number">1.00</span>dB,mute=<span class="number">0</span></span><br><span class="line">/ # </span><br><span class="line">/ # </span><br><span class="line">/ # </span><br><span class="line">/ <span class="meta"># amixer cset numid=43,iface=MIXER,name=<span class="string">'Speaker Playback Volum'</span> 30 30 </span></span><br><span class="line">numid=<span class="number">43</span>,iface=MIXER,name=<span class="string">'Speaker Playback Volume'</span></span><br><span class="line">  ; type=INTEGER,access=rw---R--,values=<span class="number">2</span>,min=<span class="number">0</span>,max=<span class="number">63</span>,step=<span class="number">0</span></span><br><span class="line">  : values=<span class="number">30</span>,<span class="number">30</span></span><br><span class="line">  | dBscale-min=<span class="number">-57.00</span>dB,step=<span class="number">1.00</span>dB,mute=<span class="number">0</span></span><br><span class="line">/ # </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li><p>保存及恢复方法</p>
<p>对声卡信息状态进行保存 : alsactl store -f /var/lib/alsa/asound.state </p>
<p>声卡状态恢复命令 : alsactl restore -f /var/lib/alsa/asound.state</p>
</li>
</ol>
<h2 id="Linux音频分析工具"><a href="#Linux音频分析工具" class="headerlink" title="Linux音频分析工具"></a>Linux音频分析工具</h2><ol>
<li><p>audacity</p>
<ul>
<li><p>功能：查看各种格式音频的波形，并有裁剪、转换格式、生成特定音频数据等诸多功能</p>
</li>
<li><p>下载方法 : sudo apt install audacity -o Acquire::http::proxy=”<a href="http://192.168.4.15:8080/&quot;">http://192.168.4.15:8080/"</a>( -o 参数指定代理)</p>
</li>
<li><p>使用方法：命令行输入audacity，添加音频文件即可</p>
</li>
</ul>
</li>
<li><p>play</p>
<ul>
<li>由于aplay播放数据格式有限，play对于音频数据格式进行了较多的支持</li>
<li>play播放裸数据命令 : play -t raw -r 16000 -e signed-integer -b 16 -c 1 test.wav</li>
</ul>
</li>
</ol>
<h1 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h1><p>代码链接：<a href="https://github.com/yangLieee/audioplayer">https://github.com/yangLieee/audioplayer</a></p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：数据存储出来只有78字节，但是写函数已经执行完毕？</p>
<p>A：这只是写了一个文件头，而最终文件没有写入。原因是：avio_open之后没有关闭，调用closep函数之后数据正常写入;</p>
<p>​		调试流程：首先定位问题位置。在alsa录音完成之后将数据写入buffer中存储来看是否是alsa部分的录音问题。之后根据流程进行检查。一定要注意open close / new delete / 等配套的使用</p>
</li>
<li><p>数据已经写结束 但是还是会再次执行一次其上面的程序</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fmtContext)                                                                    </span><br><span class="line">       av_write_trailer(fmtContext);</span><br><span class="line"><span class="keyword">if</span>(fmtContext != <span class="literal">NULL</span>){   </span><br><span class="line">   <span class="keyword">if</span>( avio_closep(&amp;fmtContext-&gt;pb) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"avio_closep error!"</span>);</span><br><span class="line">   avformat_free_context(fmtContext);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">av_write_trailer的作用</span></span><br><span class="line"><span class="comment">	1. 循环调用interleave_packet()以及write_packet()，将还未输出的AVPacket输出出来。</span></span><br><span class="line"><span class="comment">	2. 调用AVOutputFormat的write_trailer()，输出文件尾。</span></span><br><span class="line"><span class="comment">avio_closep的作用</span></span><br><span class="line"><span class="comment">	关闭输出文件的上下文,与avio_open相对应使用</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">这两个的使用需要保证av_write_trailer函数调用早于avio_closep</span></span><br><span class="line"><span class="comment">如果不调用这两个函数会导致最终文件不能写出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>Q：重采样时 channel 可以正常转换, sample_rate采样率变化不能转换?</p>
<p>A：在做采样率的重采样时, 对输出的context配置需要将采样点也做一下转换,否则已经转换成功但是生成的文件大小还是按照以前的输出进行.<br>  采样点转换函数 : av_rescale_rnd(iFrame-&gt;nb_samples, oSampleRate, iSampleRate, AV_ROUND_UP);</p>
</li>
<li><p>Q : 录音之后声音太小, 甚至有时候听不到, 需要如何调整? </p>
<p>A : 通过amixer参数进行相应的配置</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">/storage/recode <span class="meta"># amixer cset numid=53,iface=MIXER,name=<span class="string">'DMIC GAIN'</span> 15</span></span><br><span class="line">numid=<span class="number">53</span>,iface=MIXER,name=<span class="string">'DMIC GAIN'</span></span><br><span class="line">  ; type=INTEGER,access=rw---R--,values=<span class="number">1</span>,min=<span class="number">0</span>,max=<span class="number">31</span>,step=<span class="number">0</span></span><br><span class="line">  : values=<span class="number">15</span></span><br><span class="line">  | dBscale-min=<span class="number">0.00</span>dB,step=<span class="number">3.00</span>dB,mute=<span class="number">0</span></span><br><span class="line"><span class="comment">//这个步骤的作用是, 将dmic的增益调整为15 </span></span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>Q:  耳机音量小但是amixer没有相关可以配置的参数?</p>
<p>A : 通过asound.conf配置新的插件, </p>
<p><a href="https://alsa.opensrc.org/How_to_use_softvol_to_control_the_master_volume">https://alsa.opensrc.org/How_to_use_softvol_to_control_the_master_volume</a></p>
</li>
</ol>
<h1 id="参考资料（包含FFmpeg）"><a href="#参考资料（包含FFmpeg）" class="headerlink" title="参考资料（包含FFmpeg）"></a>参考资料（包含FFmpeg）</h1><blockquote>
<p>注：如果后续如涉及到FFmpeg文章，再将该部分内容移除，以下文章是在工作的开发中有帮助到自己</p>
</blockquote>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/1TJQc3Ktdw_Qz576iLjB1Q">ALSA（高级Linux声音架构）浅析</a></p>
</li>
<li><p><a href="https://wenku.baidu.com/view/dacb0922af45b307e87197a2.html">ALSA框架介绍——音频通路</a></p>
</li>
<li><p><a href="https://magodo.github.io/alsa-pcm/#0-pcm">ALSA - PCM接口</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/jason-lu/archive/2013/06/07/3123750.html">Linux ALSA框架之三:PCM设备的创建 </a></p>
</li>
<li><p><a href="https://blog.csdn.net/leixiaohua1020/article/details/44116215">FFmpeg源代码简单分析</a></p>
</li>
<li><p><a href="https://blog.csdn.net/BrookIcv/article/details/53490799">FFmpeg 中AVPacket的使用</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Media</category>
      </categories>
      <tags>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>Libmad详解</title>
    <url>/2022/11/05/SoftwareDevelopment/Media/Audio-libmad/</url>
    <content><![CDATA[<p>简单来讲，libmad就是一个MP3文件的解码库。如果想要深入理解其中的实现需要对MP3文件格式有详细的了解，关于MP3文件格式的内容在这里我不赘述，之前的文章当中有过详细的讲解 <a href="https://yanglieee.com/2022/09/05/Audio-meet-1/">click here</a></p>
<h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><blockquote>
<p>Libmad 详解：<a href="https://www.underbit.com/products/mad/">https://www.underbit.com/products/mad/</a></p>
</blockquote>
<p> libmad 是一个高质量的 MPEG 音频解码器。目前支持  MPEG-1 和 MPEG-2 对较低采样频率的扩展，以及所谓的 MPEG 2.5 格式，三个音频层都在代码上做了实现。优势：</p>
<ul>
<li>24 位 PCM 输出</li>
<li>100% 定点（整数）计算</li>
<li>基于 ISO/IEC 标准的全新实施</li>
<li>根据 GNU 通用公共许可证 (GPL) 的条款分发</li>
</ul>
<h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p><a href="https://sourceforge.net/projects/mad/files/">https://sourceforge.net/projects/mad/files/</a></p>
<p><a href="https://www.linuxfromscratch.org/blfs/view/svn/multimedia/libmad.html">https://www.linuxfromscratch.org/blfs/view/svn/multimedia/libmad.html</a></p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>&lt; 基于 libmad-0.15.1b 版本&gt;</p>
<table>
<thead>
<tr>
<th>源文件</th>
<th>bit.c</th>
<th>decoder.c</th>
<th>fixed.c</th>
<th>frame.c</th>
<th>huffman.c</th>
<th>layer12.c</th>
<th>layer3.c</th>
<th>stream.c</th>
<th>synth.c</th>
<th>timer.c</th>
<th>version.c</th>
<th>minimad.c(demo)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>头文件</td>
<td>bit.h</td>
<td>decoder.h</td>
<td>fixed.h</td>
<td>frame.h</td>
<td>huffman.h</td>
<td>layer12.h</td>
<td>layer3.h</td>
<td>stream.h</td>
<td>synth.h</td>
<td>timer.h</td>
<td>version.h</td>
<td>global.h</td>
<td>mad.h（API）</td>
</tr>
<tr>
<td>dat文件</td>
<td>sf_table.dat</td>
<td>imdct_s.dat</td>
<td>qc_table.dat</td>
<td>D.dat</td>
<td>rq_table.dat</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>其他文件</td>
<td>Makefile</td>
<td>config</td>
<td>……</td>
<td></td>
<td>大部分内容不参与编译</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>具体使用方法可以参考minimad.c文件，这里面对api的使用有进一步的说明</p>
<p>同时也可以参考我基于Linux libmad写出来的一个音频播放器，源码链接 <a href="https://github.com/yangLieee/audioplayer">click here</a></p>
<h1 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h1><p>&lt; 仅介绍linux环境下编译方法 &gt; </p>
<ol>
<li>手写Makefile / CMakeLists.txt</li>
<li>系统提供的config<ul>
<li>执行 <strong>sed -i ‘/-fforce-mem/d’ configure</strong> ， 这条命令是为了适配高版本的gcc，因为高版本的gcc已经将-fforce-mem去除了</li>
<li>执行 <strong>./configure ,</strong> 文件夹下会生成Makefile</li>
<li>执行 <strong>sudo make; sudo install;</strong> </li>
<li>至此静态库和动态库已经生成，目录在/usr/local/lib</li>
</ul>
</li>
</ol>
<h1 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h1><ol>
<li><p>mad_decoder_init( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mad_decoder_init</span><span class="params">(<span class="keyword">struct</span> mad_decoder *, <span class="type">void</span> *,   </span></span><br><span class="line"><span class="params">           <span class="comment">/* input func  */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* header func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_header <span class="type">const</span> *),                   </span></span><br><span class="line"><span class="params">           <span class="comment">/* filter func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream <span class="type">const</span> *, <span class="keyword">struct</span> mad_frame *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* output func */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_header <span class="type">const</span> *, <span class="keyword">struct</span> mad_pcm *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* error func  */</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="keyword">struct</span> mad_stream *, <span class="keyword">struct</span> mad_frame *), </span></span><br><span class="line"><span class="params">           <span class="comment">/* message func*/</span>  <span class="keyword">enum</span> mad_flow (*)(<span class="type">void</span> *, <span class="type">void</span> *, <span class="type">unsigned</span> <span class="type">int</span> *))</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>mad_decoder_init( )是libmad中最终重要的函数之一，其作用是将line3~line8的六个回调函数注册到mad_decoder实例出来的decoder中。</p>
<ul>
<li><p><strong>必须自定义的参数：</strong>参数1：用户自己实例的一个解码器结构体；参数2：用户自定义的结构体指针，这个指针将用于整个解码的过程在回调函数之间进行数据的传输；参数3：输入的回调函数，该回调用于用户自定义将数据输入编码器的逻辑；参数6：输出的回调函数，同input callback func。自定义输出的分辨率吧：24bit / 16bit，可以存成文件亦可以直接通过pcm接口播放。Output回调函数在madlib每解码完成一个帧后被调用，直到全部解码完成或出错。参数8（异步工作模式下必选）：输出信息。</p>
</li>
<li><p><strong>选择性定义参数：</strong>其他参数属于自定义参数比如进行头解析、过滤筛选的回调函数等等，如果自己没有需求置0即可。</p>
</li>
</ul>
</li>
<li><p>mad_decoder_run( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mad_decoder_run</span><span class="params">(<span class="keyword">struct</span> mad_decoder *, <span class="keyword">enum</span> mad_decoder_mode)</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>该函数是解码的主流程函数，即解码器的入口函数，如果要追代码可以从此处开始进行剖析。</p>
<ul>
<li>参数1：用户自定义实例化并初始化的解码器decoder；</li>
<li>参数2：选择解码模式（SYNC / ASYNC）深入代码可以发现这个选择使得解码器进入不同的函数进行工作。</li>
</ul>
<p>所谓同步方式是指解码函数在解码完一帧后才返回并带回出错信息，异步方式是指解码函数在调用后立即返回，通过消息传递解码状态信息。(故异步方式必须定义message回调函数)</p>
</li>
<li><p>mad_decoder_finish( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mad_decoder_finish</span><span class="params">(<span class="keyword">struct</span> mad_decoder *)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>解码结束，用于清理工作，释放与流相关的任何动态内存。</p>
</li>
<li><p>mad_stream_buffer( )</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mad_stream_buffer</span><span class="params">(<span class="keyword">struct</span> mad_stream *, <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *, <span class="type">unsigned</span> <span class="type">long</span>)</span>; </span><br></pre></td></tr></tbody></table></figure>

<p>该函数是input回调函数中最重要的函数，其作用是按照参数2、参数3即MP3文件在内存映像的起始地址和本次要传递的文件长度与mad_stream进行关联，形成libmad可识别的stream流</p>
<p>需要注意，这里传递多少数据完全是自定义的。如果一次性送入则整个解码过程调用一次input；如果一次性传递若干，output根据传递的数据进行解码，如果没有数据可解继续调用input。所以自己定义好输入逻辑即可。</p>
</li>
</ol>
<h1 id="重点数据结构"><a href="#重点数据结构" class="headerlink" title="重点数据结构"></a>重点数据结构</h1><ol>
<li><p>mad_stream</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//mad.h &amp;&amp; stream.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_stream</span> {</span>           </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *buffer;          <span class="comment">/* input bitstream buffer */</span>                                       <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *bufend;          <span class="comment">/* end of buffer */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> skiplen;                <span class="comment">/* bytes to skip before next frame */</span></span><br><span class="line">  <span class="type">int</span> sync;                             <span class="comment">/* stream sync found */</span>        </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> freerate;               <span class="comment">/* free bitrate (fixed) */</span>     </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *this_frame;      <span class="comment">/* start of current frame */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span> *next_frame;      <span class="comment">/* start of next frame */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mad_bitptr</span> <span class="title">ptr</span>;</span>                <span class="comment">/* current processing bit pointer */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mad_bitptr</span> <span class="title">anc_ptr</span>;</span>            <span class="comment">/* ancillary bits pointer */</span>   </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> anc_bitlen;              <span class="comment">/* number of ancillary bits */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="title function_">char</span> <span class="params">(*main_data)</span>[MAD_BUFFER_MDLEN];                  <span class="comment">/* Layer III main_data() */</span>    </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> md_len;                  <span class="comment">/* bytes in main_data */</span>  </span><br><span class="line">  <span class="type">int</span> options;                          <span class="comment">/* decoding options (see below) */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_error</span> <span class="title">error</span>;</span>                 <span class="comment">/* error code (see above) */</span>   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>该结构体记录了文件的地址、当前所处理的位置和解码前的Bitstream数据</p>
<p>mad_stream.bufend – mad_stream.next_frame就是剩余的未被解码的 MPEG 帧的数据的字节数量（假设此帧在缓冲区中不完整)</p>
</li>
<li><p>mad_header</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_header</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_layer</span> <span class="title">layer</span>;</span>             <span class="comment">/* audio layer (1, 2, or 3) */</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">mad_mode</span> <span class="title">mode</span>;</span>               <span class="comment">/* channel mode (see above) */</span></span><br><span class="line">  <span class="type">int</span> mode_extension;               <span class="comment">/* additional mode info */</span>                                             <span class="class"><span class="keyword">enum</span> <span class="title">mad_emphasis</span> <span class="title">emphasis</span>;</span>       <span class="comment">/* de-emphasis to use (see above) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bitrate;            <span class="comment">/* stream bitrate (bps) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> samplerate;          <span class="comment">/* sampling frequency (Hz) */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> crc_check;         <span class="comment">/* frame CRC accumulator */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> crc_target;        <span class="comment">/* final target CRC checksum */</span></span><br><span class="line">  <span class="type">int</span> flags;                        <span class="comment">/* flags (see below) */</span></span><br><span class="line">  <span class="type">int</span> private_bits;                 <span class="comment">/* private bits (see below) */</span></span><br><span class="line">  <span class="type">mad_timer_t</span> duration;             <span class="comment">/* audio playing time of frame */</span></span><br><span class="line">};    </span><br></pre></td></tr></tbody></table></figure>

<p>通过注释很容易看出，该结构体记录了MPEG 帧的基本信息，比如MPEG 层数、声道模式、流比特率、采样率、比特率以及某些校验位等等。</p>
<blockquote>
<p>Tips：（bitrate % 32） 如果是整数说明该文件格式是CBR（constant bitrate，恒定比特率），否则是VBR（variable bitrate，可变比特率），这对文件播放时长是有影响的。</p>
</blockquote>
</li>
<li><p>mad_pcm</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mad_pcm</span> {</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> samplerate;          <span class="comment">/* sampling frequency (Hz) */</span>                                           <span class="type">unsigned</span> <span class="type">short</span> channels;          <span class="comment">/* number of channels */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> length;            <span class="comment">/* number of samples per channel */</span></span><br><span class="line">  <span class="type">mad_fixed_t</span> samples[<span class="number">2</span>][<span class="number">1152</span>];     <span class="comment">/* PCM output samples [ch][sample] */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>madlib解码器是以帧为单位进行解码的，mad_pcm每次最多解码出（1152 * channels）个PCM数据，每个采样点用int（32bit）表征但是只用了其中的24bit，至此可以直接输出数据保存文件或者直接调用音频播放的API进行播放。但目前大多数codec支持的是16bit量化分辨率，所以在输出时将数据饱和到16bit进行输出。</p>
</li>
<li><p>mad_flow</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">mad_flow</span> {</span></span><br><span class="line">  MAD_FLOW_CONTINUE = <span class="number">0x0000</span>,   <span class="comment">/* continue normally */</span>                                                     MAD_FLOW_STOP     = <span class="number">0x0010</span>,   <span class="comment">/* stop decoding normally */</span></span><br><span class="line">  MAD_FLOW_BREAK    = <span class="number">0x0011</span>,   <span class="comment">/* stop decoding and signal an error */</span></span><br><span class="line">  MAD_FLOW_IGNORE   = <span class="number">0x0020</span>    <span class="comment">/* ignore the current frame */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>所有回调函数的返回值均为该枚举类型，在解码的主流程中会通过不断判断解码器所调用的回调函数的状态来确认下一步的动作</p>
</li>
</ol>
<h1 id="相关调试经验"><a href="#相关调试经验" class="headerlink" title="相关调试经验"></a>相关调试经验</h1><ol>
<li><p>配置参数未选择</p>
<p>Q：编译正常通过，流程正确，但是输出的声音能听出是所需要的音频但是整体数据并不正确？</p>
<p>A：在mad.h中有若干的函数是根据平台的不同有不同的实现，由于编译过程中没有注意警告直接将其注释导致没有选择正确函数实现，导致最终的数据都是错误的。编译时添加相应的平台的参数即可，如果手动写cmake，参考给出的Makefile做参数选择！</p>
</li>
<li><p>线程栈空间大小分配不足</p>
<p>Q：在PC上测试正常播放，但是移植到小系统中经常出现stack overflow？</p>
<p>A：由于MP3一帧数据的采样点数为1152，使用 int 类型进行存储，所以核心函数 “ Ⅲ_decode” 至少需要6k的栈空间，如果是单独一个线程的话再加上其他的局部变量、函数跳转等等可能就超过8k。</p>
<p>​	  当时使用c++ 的thread进行的线程创建并不能配置栈空间大小，经过两天左右的debug查到是核心函数栈空间的溢出，最终使用pthread加大栈空间的大小运行即可。</p>
</li>
<li><p>动态解码的实现</p>
<p>Q：刚开始百度libmad的库，很多博客说只能调用一次input回调函数即一次加载所有的源数据，这对于实时控制造成不便？</p>
<p>A： 深入源码可以看出输入的的数据解码完成只要不返回STOP是可以继续填充数据的，这样临时的buffer就小一些并且可以试试控制完成播放器的功能。（需要注意如果一次输入的数据是几帧多一点，而多出来的需要放保存下次再此进行解码）</p>
</li>
<li><p>获得音频参数</p>
<p>Q：能够很快的获得音频信息？</p>
<p>A： 对于wav头很容易的可以找到音频的参数，但是MP3文件的信息保存在帧头中，所以可以进行一步预解码。即读入若干（512即可）byte数据解一帧的头就可以获得全部信息，包括：采样率、比特率、声道、音频时长等等。</p>
</li>
<li><p>获得播放进度 / 时长出现异常</p>
<p>Q：使用公式：当前文件位置 / 文件大小 × 文件总时长，获得当前播放时间出现异常？</p>
<p>A： 对于duration 和 fpos是用int的数据类型进行保存的，但是对于wav文件一般比较大在计算的时候超出了数据类型所能存储的最大长度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Media</category>
      </categories>
      <tags>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>Audio-再遇</title>
    <url>/2022/09/05/SoftwareDevelopment/Media/Audio-meet-1/</url>
    <content><![CDATA[<p>本篇内容对一节提到的编码进行扩展，将重点对PCM格式、WAVE格式、MP3格式进行详细解析。</p>
<h1 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h1><p>PCM : Pulse-Code Modulation 脉冲调制编码</p>
<p>PCM 本是一种调制方法的名称，进而通过该方法得到的音频数据也称作PCM数据，即裸数据。该数据是我们通过codec得到的最原始的数据！</p>
<p>​    <img src="/images/SoftwareDevelopment/Media/Audio-remeet-1.png" alt="pic"></p>
<h1 id="WAVE"><a href="#WAVE" class="headerlink" title="WAVE"></a>WAVE</h1><p>WAVE : Waveform Audio File Format 波形音频文件格式, 即我们平时所说的wave文件</p>
<p>很简单，WAV文件格式结构体通常是用来保存PCM格式的原始数据，基于此添加一个文件头构成了WAV文件，即wave = wave头 + PCM数据。因此它通常也被称为无损音频，但是严格意义上来讲，WAV也可以存储其它压缩格式的音频数据。</p>
<h2 id="wav头"><a href="#wav头" class="headerlink" title="wav头"></a>wav头</h2><table>
<thead>
<tr>
<th><strong>偏移地址</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>大小</strong></th>
<th><strong>名称</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td>00H~03H</td>
<td>char</td>
<td>4</td>
<td>资源交换文件标志 ( RIFF )</td>
<td>52 49 46 46 固定写法</td>
</tr>
<tr>
<td>04H~07H</td>
<td>long int （4）</td>
<td>1</td>
<td>文件大小size</td>
<td>从下个地址 (08) 开始到 WAV 文件结尾的总字节数整个 WAV 文件的大小就是该数值 + 8</td>
</tr>
<tr>
<td>08H~0BH</td>
<td>char</td>
<td>4</td>
<td>WAV文件标志 WAVE</td>
<td>57 41 56 45 , 是 WAVE 四个字母的 ASCII 码，固定写法</td>
</tr>
<tr>
<td>0CH~0FH</td>
<td>char</td>
<td>4</td>
<td>波形格式标志（fmt ）</td>
<td>最后一位0x20 对应的字符是空格</td>
</tr>
<tr>
<td>10H~13H</td>
<td>int</td>
<td>1</td>
<td>过滤字节</td>
<td>一般为00000010H</td>
</tr>
<tr>
<td>14H~15H</td>
<td>short int （2）</td>
<td>1</td>
<td><strong>格式种类audioformat</strong></td>
<td>值为1时，表示数据为线性PCM编码</td>
</tr>
<tr>
<td>16H~17H</td>
<td>short int</td>
<td>1</td>
<td><strong>通道数 channnels</strong></td>
<td>1 表示单声道 , 2 表示立体声</td>
</tr>
<tr>
<td>18H~1BH</td>
<td>long int</td>
<td>1</td>
<td><strong>采样频率 sampleRate</strong></td>
<td>80 BB 00 00 – &gt; 48000 Hz ;</td>
</tr>
<tr>
<td>1CH~1FH</td>
<td>long int</td>
<td>1</td>
<td>波形数据传输速率（每秒平均字节数）</td>
<td>采样率×通道数×采样位数 / 8</td>
</tr>
<tr>
<td>20H~21H</td>
<td>short int</td>
<td>1</td>
<td>DATA数据块调整长度，字节。</td>
<td>通道数×样本数据位数 / 8</td>
</tr>
<tr>
<td>22H~23H</td>
<td>short int</td>
<td>1</td>
<td>PCM位宽</td>
<td>10 00 —-&gt; 16 位, 2 字节</td>
</tr>
<tr>
<td>24H~27H</td>
<td>char</td>
<td>4</td>
<td>数据标记</td>
<td>64 61 74 61 data的ASCII的值</td>
</tr>
<tr>
<td>28H~2BH</td>
<td>long int</td>
<td>1</td>
<td>PCM 数据总长度</td>
<td></td>
</tr>
</tbody></table>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>Q：wave文件的文件头一定是44Bytes吗？</p>
<p>A：不一定！以上格式只是wave文件的标准，属于通用标准。但是将其他格式文件通过ffmpeg转码之后的wav文件头会大于44个字节（115Bytes），在文件头和数据块之间添加了一些ffmpeg的信息，部分表征的意义不同！网上很多格式转换工具都是调用的ffmpeg转码的，导致文件头大小不完全相同。</p>
<blockquote>
<p>​     -map_metadata -1 -fflags +bitexact 可以去除标注信息，使文件头符合标准</p>
<p>​     ffmpeg -y -i music.mp3 -map_metadata -1 -fflags +bitexact -f wav -ac 1 -ar 16000 -ab 16k music.wav</p>
</blockquote>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Ffmpeg不去标准信息转码wave之后的文件格式：</p>
<table>
<thead>
<tr>
<th>偏移地址</th>
<th>字节数</th>
<th>数据类型</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>00H ~ 23H</td>
<td>36</td>
<td>同上表的00H~23H一致</td>
<td></td>
</tr>
<tr>
<td>24H ~ 27H</td>
<td>4</td>
<td>char</td>
<td>“LIST”, LIST块标志，固定不变</td>
</tr>
<tr>
<td>28H ~ 2BH</td>
<td>4</td>
<td>long</td>
<td>LIST块占用的字节数，在这里为26字节</td>
</tr>
<tr>
<td>2CH ~ 45H</td>
<td>26</td>
<td>char</td>
<td>LIST块内容</td>
</tr>
<tr>
<td>46H ~ 49H</td>
<td>4</td>
<td>char</td>
<td>“data”, data数据块标志，固定不变</td>
</tr>
<tr>
<td>4AH ~ 4DH</td>
<td>4</td>
<td>long</td>
<td>wav文件音频数据所占大小</td>
</tr>
</tbody></table>
<h1 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MP3：Moving Picture Experts Group Audio Layer III, 动态影像专家压缩标准音频层面3</p>
<p>首先科普下部分概念：MPEG（Moving Pictures Experts Group ，动态图像专家组），简单理解就是一些研究音视频的专家发布的相关标准，其命名为MPEG-*（其中*代表数字或字母），例如MPEG-1、MPEG-2.5、MPEG-E等等。</p>
<p>可能有人会想MPEG-3是不是就是MP3呢？MPEG是针对音视频及系统测试的一整套的标准规范，其中对于MPEG1来讲，其part3音频部分规定了3个独立分层的音频编码格式，分别为layer Ⅰ、layer Ⅱ、layer Ⅲ，而layer Ⅲ也就是我们所说的MP3（MEPEG1 Layer Ⅲ），这三层的区别主要在于编码的算法及输出速率的区别。同样纵向来看，MPEG2、MPEG2.5同样有三个独立的layer，区别在于它们所使用的采样率更低了。</p>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>目前大多数标准MP3文件都支持ID3V2标准。具体组成格式为：ID3V2.3标签帧（1个）+ 数据帧（若干）+ ID3V1帧（1个），其中ID3V2.3 = 标签头（1个，必须） + 标签帧（若干，不必须） + 扩展标签头（不必须）</p>
<p>组成部分我画了一张示意图可以参考，每一部分下面将做详细解析</p>
<p>​    <img src="/images/SoftwareDevelopment/Media/Audio-remeet-2.png" alt="pic"></p>
<h2 id="ID3标准"><a href="#ID3标准" class="headerlink" title="ID3标准"></a>ID3标准</h2><p>MP3帧头中除了存储一些象private、copyright、original的简单音乐说明信息以外，没有考虑存放歌名、作者、专辑名、年份 等复杂信息，而这些信息在MP3应用中非常必要。1996年，FricKemp在“Studio 3”项目中提出了在MP3文件尾增加一块用于存放歌曲的说明信息，形成了ID3标准</p>
<h2 id="标签头"><a href="#标签头" class="headerlink" title="标签头"></a>标签头</h2><p>标签头是由10Byte组成的，具体含义如下</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char Header[3];</td>
<td>必须为”ID3”否则认为标签不存在，如上图地址00—02部分为”49 44 33”，文本为“ID3”</td>
</tr>
<tr>
<td>char Ver;</td>
<td>版本号 ID3V2.3 就记录 3，如上图地址03处记录为”03”</td>
</tr>
<tr>
<td>char Revision;</td>
<td>副版本号此版本记录为 0</td>
</tr>
<tr>
<td>char Flag;</td>
<td>放标志的字节，一般为00abc00000a – 表示是否使用 Unsynchronisationb – 表示是否有扩展头部,一般没有(至少 Winamp 没有记录),所以一般也不设置c – 表示是否为测试标签(99.99%的标签都不是测试用的，所以一般也不设置)</td>
</tr>
<tr>
<td>char Size[4];</td>
<td>标签大小,包括标签头的 10 个字节和所有的标签帧的大小</td>
</tr>
</tbody></table>
<p>整个标签大小 :</p>
<p>ID3V2_frame_size = (int)(Size[0] &amp; 0x7F) &lt;&lt; 21 | (int)(Size[1] &amp; 0x7F) &lt;&lt; 14 | (int)(Size[2] &amp; 0x7F) &lt;&lt; 7 | (int)(Size[3] &amp; 0x7F) + 10;</p>
<h2 id="标签帧"><a href="#标签帧" class="headerlink" title="标签帧"></a>标签帧</h2><p>每个标签帧都有一个 10 个字节的帧头（虽然都是10字节，但是与标签头不是一个东西。标签头有且只有一个，而标签头每一个标签帧都有一个帧头）和至少一个字节的不固定长度的内容组成。</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char FrameID[4]</td>
<td>用四个字符标识一个帧，说明其内容</td>
</tr>
<tr>
<td>char Size[4]</td>
<td>帧内容的大小，不包括帧头，不得小于1</td>
</tr>
<tr>
<td>char Flags[2]</td>
<td>存放标志，只定义了6 位，此处不再说明</td>
</tr>
</tbody></table>
<p>常用帧标识：</p>
<p>TIT2：标题<br>TPE1：作者<br>TALB：专辑<br>TRCK： 音轨，格式：N/M，N表示专辑中第几首，M为专辑中歌曲总数<br>TYER：年份<br>TCON：类型<br>COMM：备注，格式：“eng\0备注内容”，其中eng表示所使用的语言<br>帧大小为四个字节所表示的整数大小。</p>
<h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p>数据帧由帧头和数据帧组成，对于每一帧数据都有一个帧头。</p>
<p>帧头长4字节，对于固定位率的MP3文件，所有帧的帧头格式一样其数据结构如下</p>
<p>typedef struct frameHeader<br>{<br>unsigned int sync1:8; //同步信息 1<br>unsigned int error_protection:1; //CRC 校验<br>unsigned int layer:2; //层<br>unsigned int version:2; //版本<br>unsigned int sync2:3; //同步信息 2<br>unsigned int extension:1; //版权<br>unsigned int padding:1; //填充空白字<br>unsigned int sample_rate_index:2; //采样率索引<br>unsigned int bit_rate_index:4; //位率索引<br>unsigned int emphasis:2; //强调方式<br>unsigned int original:1; //原始媒体<br>unsigned int copyright:1; //版权标志<br>unsigned int mode_extension:2; //扩展模式,仅用于联合立体声<br>unsigned int channel_mode:2; //声道模式<br>}FHEADER;</p>
<p>比特率为32的整数倍一般就是恒定编码，否则就是可变编码；可变编码帧头一般会有不同</p>
<h2 id="ID3V1标签帧"><a href="#ID3V1标签帧" class="headerlink" title="ID3V1标签帧"></a>ID3V1标签帧</h2><p>标签头是由128Byte组成的，具体含义如下</p>
<table>
<thead>
<tr>
<th>定义</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>char Header[3]</td>
<td>标签头必须是”TAG”否则认为没有标签</td>
</tr>
<tr>
<td>char Title[30]</td>
<td>标题</td>
</tr>
<tr>
<td>char Artist[30]</td>
<td>作者</td>
</tr>
<tr>
<td>char Album[30]</td>
<td>专集</td>
</tr>
<tr>
<td>char Year[4]</td>
<td>出品年代</td>
</tr>
<tr>
<td>char Comment[28]</td>
<td>备注</td>
</tr>
<tr>
<td>char reserve</td>
<td>保留</td>
</tr>
<tr>
<td>char track</td>
<td>音轨</td>
</tr>
<tr>
<td>char Genre;</td>
<td>类型</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Media</category>
      </categories>
      <tags>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>OTA</title>
    <url>/2023/07/08/SoftwareDevelopment/SystemFunction/ota/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OTA（Over-the-Air）直译来讲就是空中下载，是指通过网络将设备固件更新到最新版本，而无需物理连接。对于不同厂家的不同的产品有着不同的OTA升级策略，但是在OTA升级中关键步骤几乎都是一致的。</p>
<p>相应的，通过有线方式进行升级，叫本地升级，比如通过UART，USB或者SPI通信接口来升级设备固件</p>
<h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><ol>
<li>如何将固件下载到本地？</li>
<li>如何保证下载到的固件是正确且完整的？</li>
<li>如何烧录新的固件且过程中出现问题可以正常恢复？</li>
</ol>
<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><ol>
<li>服务器端制作升级包</li>
<li>设备端下载升级包<ul>
<li>建立与服务器的网络连接</li>
<li>从服务器下载新的固件版本，确认是否需要升级</li>
<li>下载升级包</li>
</ul>
</li>
<li>设备端检验升级包<ul>
<li>解压升级包</li>
<li>校验固件版本的完整性、准确性、安全性</li>
</ul>
</li>
<li>升级<ul>
<li>将固件写入设备的存储介质</li>
<li>升级成功写入新的版本号</li>
</ul>
</li>
<li>设备重启</li>
</ol>
<h1 id="OTA升级策略"><a href="#OTA升级策略" class="headerlink" title="OTA升级策略"></a>OTA升级策略</h1><h2 id="固件完整性"><a href="#固件完整性" class="headerlink" title="固件完整性"></a>固件完整性</h2><h3 id="全包升级"><a href="#全包升级" class="headerlink" title="全包升级"></a>全包升级</h3><p>全包升级（Full Update）：全包升级是指将完整的固件包发送给设备进行升级。这意味着设备需要下载整个固件包并进行完全的替换，无论设备当前运行的是哪个版本。全包升级适用于较小的固件更新或在设备上进行了较大的改动。</p>
<h3 id="差分升级"><a href="#差分升级" class="headerlink" title="差分升级"></a>差分升级</h3><p>差分升级（Differential Update）：差分升级是指只发送变更部分的固件包给设备进行升级。这样，设备只需要下载和应用固件的变化部分，而不是整个固件包。差分升级适用于较大的固件更新，尤其是当设备已经处于较新的版本上时。</p>
<p>这种方式可以大大减少升级所需的时间和数据量，提高升级的效率。但是，差分升级可能需要额外的计算资源来处理固件的合并和应用，因为设备需要将变更部分与当前的固件进行合并，并且可能会出现不兼容的情况。</p>
<h2 id="固件覆盖模式"><a href="#固件覆盖模式" class="headerlink" title="固件覆盖模式"></a>固件覆盖模式</h2><h3 id="单区模式"><a href="#单区模式" class="headerlink" title="单区模式"></a>单区模式</h3><p>在单区覆盖模式下，设备固件的存储空间被分成一个单一的区域。当进行OTA固件升级时，新的固件包会完全替换原有的固件，覆盖在同一个存储区域上。这意味着在升级过程中，设备的固件会被擦除并用新的固件替代。但是由于程序执行的代码已经从flash拷贝到ram中进行执行了，所以OTA的流程还是可以进行完成的，当新的固件覆写到旧固件的存储区域完成重启设备即可进入新版本</p>
<p>单区覆盖模式的优点是实现简单，固件更新相对直接，但缺点是如果升级失败，可能需要进行完全的固件恢复，而且升级过程中无法回滚到原有固件版本，甚至最后变成“板砖”</p>
<h3 id="双区模式"><a href="#双区模式" class="headerlink" title="双区模式"></a>双区模式</h3><p>在双区覆盖模式下，设备固件的存储空间被分为两个独立的区域，假设称为”A区”和”B区”。设备当前运行的固件版本存储在其中一个区域（例如A区），而进行OTA固件升级时，新的固件包将被下载并写入另一个区域（例如B区）。</p>
<p>在升级过程中，设备将保持运行在当前固件版本所在的区域（例如A区），而新的固件被下载到另一个区域（例如B区）。下载完成后，设备会进行固件切换，将运行环境从当前区域切换到新的固件所在的区域。这样，如果升级失败，设备可以回滚到原有的固件版本，通过切换回之前的区域。</p>
<p>双区覆盖模式的优点是在升级过程中提供了冗余和回滚的能力，减少了升级失败的风险。然而，相对于单区覆盖模式，双区覆盖模式需要更多的存储空间来维护两个固件区域。</p>
<h1 id="其它策略"><a href="#其它策略" class="headerlink" title="其它策略"></a>其它策略</h1><h2 id="解压策略"><a href="#解压策略" class="headerlink" title="解压策略"></a>解压策略</h2><p>在工作的一个项目中（freertos系统、8M nor flash），由于flash存储空间有限，不能将升级包下载解压到flash文件系统上。</p>
<p>此时可以使用<code>边解压变升级</code>的方式，使用minizip、zlib等开源库的API将升级包的zip包解压到RAM当中，无论是使用堆空间还是栈空间都是可以的，按照固定大小解压到buffer，将buffer内容升级或者是烧录进flash即可。</p>
<p>这样做的好处很明显：节省flash空间、减少了一次数据的写flash和读flash，理论上按照同样大小的块烧录，速度更快</p>
<h2 id="完整性策略"><a href="#完整性策略" class="headerlink" title="完整性策略"></a>完整性策略</h2><p>完整性指的是：我们下载download下来的数据包与网络服务器端的数据包是一致的</p>
<p>这个相对简单，我们对升级包做hash或者md5值，将这个值写入文件放到服务器上。当我们下载压缩包的时候，将这个hash/md5一起下载，在本地对压缩包做hash/md5，再与下载下来的值比较。这样对于数据包是否正确是否完整我们就有了准确的判断依据。</p>
<h2 id="合法性策略"><a href="#合法性策略" class="headerlink" title="合法性策略"></a>合法性策略</h2><p>合法性策略指的是：对于服务器来讲，它所存放的升级包不能给规定产品以外的设备来获取到压缩包，或者说即使客户端下载下来了也不能正常解压压缩包拿到数据。</p>
<p>工作中我所涉及的加密的方法是使用非对称加密RSA算法，这里可能涉及到密码学的相关知识，后面我也需要再进一步学习整理出专门的文章来做解释。在OTA的场景下，可以概括成如下一些步骤：</p>
<ul>
<li>生成RSA密钥对（公钥+私钥）</li>
<li>将公钥提供给设备端。可以将公钥作为固件的一部分或单独提供给设备。</li>
<li>将私钥提供给服务端。在OTA服务器端，使用私钥对固件文件进行数字签名。</li>
<li>OTA下载流程。将固件通过HTTP/HTTP等协议传输到设备端。</li>
<li>设备端验签。OTA设备接收到加密的固件后，使用嵌入在设备中的公钥对固件进行解密和验证。</li>
<li>验证成功进入固件升级流程</li>
</ul>
<h1 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">download_firmware</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">verify_firmware</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">write_firmware</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">update_firmware_version</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">restart_device</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">  <span class="keyword">if</span>(download_firmware() &amp;&amp;</span><br><span class="line">     verify_firmware() &amp;&amp;</span><br><span class="line">     write_firmware() &amp;&amp;</span><br><span class="line">     update_firmware_version()) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"OTA upgrade succeeded.\n"</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"OTA upgrade failed.\n"</span>);</span><br><span class="line">  }</span><br><span class="line">    reboot();		<span class="comment">// 设备重启</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">download_firmware</span><span class="params">()</span> {</span><br><span class="line">	<span class="comment">// 从服务器端下载固件</span></span><br><span class="line">    <span class="comment">// 工具：wget、curl</span></span><br><span class="line">    <span class="comment">// 在lwip工程中提供了代码http_client_download_to_disk接口来下载文件</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">verify_firmware</span><span class="params">()</span> {</span><br><span class="line">  <span class="comment">// 校验固件（完整性、安全性、准确性）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">write_firmware</span><span class="params">()</span> {</span><br><span class="line">  <span class="comment">// 将固件写入非易失性存储器当中（write to flash）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">update_firmware_version</span><span class="params">()</span> {</span><br><span class="line">  <span class="comment">// 将系统的版本号进行更新</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/usstmiracle/article/details/123200234">OTA实现原理</a></li>
</ul>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>SystemFunction</category>
      </categories>
  </entry>
  <entry>
    <title>功耗管理</title>
    <url>/2023/07/19/SoftwareDevelopment/SystemFunction/%E5%8A%9F%E8%80%97%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="功耗管理"><a href="#功耗管理" class="headerlink" title="功耗管理"></a>功耗管理</h1><ul>
<li>系统时钟（系统时钟、外设时钟）</li>
<li>电源模式（IDLE、DEEP、LIGHT、STANDBY）</li>
<li>引脚处理（普通引脚、总线引脚、中断引脚）</li>
<li>定时器（系统定时器、软件定时器、低功耗定时器）</li>
<li>电池（充电、放电曲线）</li>
<li>电量（库仑计、电池电压估算）</li>
<li>PM框架（睡眠管理、变频管理）</li>
</ul>
<h1 id="休眠唤醒流程"><a href="#休眠唤醒流程" class="headerlink" title="休眠唤醒流程"></a>休眠唤醒流程</h1><ul>
<li><p>休眠准备</p>
<ol>
<li>正常退出应用程序并保存数据。将此时应用程序的状态及数据进行保存；</li>
<li>关闭外设、GPIO及时钟等。这里是对系统功耗做优化的核心部分；</li>
<li>配置唤醒源。将我们所关心的事件作为唤醒源</li>
</ol>
</li>
<li><p>进入休眠</p>
<p>通过执行软件命令，进入休眠状态。</p>
</li>
<li><p>等待唤醒</p>
<p>在此状态下，主处理器和大部分系统模块会停止运行。当系统检测到唤醒时间发生，比如触屏事件、按键事件、定时器事件等等，系统将进入唤醒流程。（唤醒事件一定是要在休眠前进行配置的）</p>
</li>
<li><p>唤醒恢复</p>
<p>恢复保存的状态和数据，重新启动必要的外设和时钟，并使系统回到正常工作状态。</p>
</li>
</ul>
<h1 id="休眠唤醒原则"><a href="#休眠唤醒原则" class="headerlink" title="休眠唤醒原则"></a>休眠唤醒原则</h1><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>休眠：</p>
<ul>
<li>时钟状态保存：保存关键的时钟状态和寄存器信息。包括处理器时钟频率、外设时钟配置、中断控制器状态等。</li>
<li>禁用时钟源：例如处理器主时钟、外设时钟等。禁用这些时钟源有助于降低系统功耗并减少电流消耗。</li>
<li>RTC定时器。通常RTC是有独立电源域的，RTC将以低功耗模式供电</li>
</ul>
<p>唤醒</p>
<ul>
<li>恢复时钟源：将禁用的时钟源将被重新启用，处理器主时钟和外设时钟会重新配置。</li>
<li>时钟状态恢复：包括处理器时钟频率、外设时钟配置、中断控制器状态等。</li>
<li>时钟系统稳定：在唤醒后，系统会等待一段时间以确保时钟系统稳定（对应时钟控制器的stable标志位置位即可）。</li>
</ul>
<h2 id="CPU-Core"><a href="#CPU-Core" class="headerlink" title="CPU Core"></a>CPU Core</h2><p>不同的处理器架构和硬件设计可能会有不同的掉电级别和功耗管理策略，在特定的应用中，需要查阅相关的处理器手册、硬件规格和操作系统文档，以了解详细的掉电行为和配置方法。</p>
<p>对于较高级别的处理器将存在以下级别的状态：Normal、Idle、Sleep、Stand By、Power Down，在不同的等级下将执行不同等级的休眠操作。在该章节下，对于cpu core最大节省功耗的点在于<code>掉电</code>。Suspend-to-RAM，系统的状态会保存到内存中，CPU核心将被禁用并进入低功耗状态，当系统唤醒时，CPU核心重新上电并恢复正常运行。</p>
<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>休眠：</p>
<ul>
<li><p>尽量对所有pin都进行设置</p>
</li>
<li><p>GPIO内部PULL状态与外部PULL状态一致的管脚：输入PULL状态（GPIO_INPUT | GPIO_PULL_UP/DOWN）</p>
<p>例如：IO内部只有上拉电阻，查看原理图外设对应管脚上拉，则可以设置为输入上拉</p>
<p>或者可以遵循另一种原则：</p>
<ul>
<li>如果该IO口带上拉，请设置为高电平输出或者高阻态输入（GPIO_OUTPUT_HIGH| GPIO_PULL_HIZ）</li>
<li>如果该IO口带下拉，请设置为低电平输出或者高阻态输入（GPIO_OUTPUT_LOW | GPIO_PULL_HIZ）</li>
</ul>
</li>
<li><p>外部接上下拉电阻或接电源接地，并且与内部上下拉状态不一致的管脚：输入NO PULL状态（GPIO_INPUT | GPIO_PULL_HIZ）</p>
<p>具体需要根据设备的原理图来判断</p>
</li>
<li><p>悬空管脚：输出低电平并且 NO PULL 状态（GPIO_OUTPUT_LOW | GPIO_PULL_HIZ）</p>
</li>
<li><p>中断引脚除唤醒中断源保留外其他需要失能（关中断）</p>
</li>
</ul>
<p>唤醒：</p>
<ul>
<li>普通引脚：正常输入输出状态，据情况判断</li>
<li>总线引脚：可以在休眠前通过相关函数记录状态，唤醒时恢复即可（该部分基本是配置为FUNC功能）</li>
<li>中断引脚：使能中断</li>
</ul>
<h2 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h2><p>外设的休眠唤醒取决于具体的产品。但是一般存在于嵌入式设备产品的外设包括：LCD、Camera、WIFI、BT、CODEC或其它传感器。通常外设时钟关闭、掉电外设将不会工作，功耗也随之降低</p>
<h1 id="功耗测量"><a href="#功耗测量" class="headerlink" title="功耗测量"></a>功耗测量</h1><h2 id="测量条件"><a href="#测量条件" class="headerlink" title="测量条件"></a>测量条件</h2><p>对功耗进行测量的时候，需要将usb断开，使用电池供电</p>
<h2 id="测量指标"><a href="#测量指标" class="headerlink" title="测量指标"></a>测量指标</h2><p>功耗测量的时候需要对系统在不同阶段进行测量，主要包括：</p>
<ol>
<li>静态功耗：指设备处于空闲或低负载状态时的功耗。它是设备在没有进行任何操作或执行任务时的最小功耗水平。</li>
<li>动态功耗：指设备在执行各种任务和工作负载时的功耗。它取决于设备的工作负载、处理器使用率、外设活动等。</li>
<li>休眠功耗：指设备进入休眠模式时的功耗。</li>
<li>唤醒功耗：指设备从休眠状态唤醒时的功耗。唤醒时可能会有一些额外的功耗，例如重新启动CPU核心、恢复外设等。</li>
<li>峰值功耗：指设备在执行高负载或特定任务时的最大功耗水平。</li>
</ol>
<h1 id="Linux电源管理"><a href="#Linux电源管理" class="headerlink" title="Linux电源管理"></a>Linux电源管理</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># cat /sys/power/state  <span class="comment">//查看内核支持哪几种休眠方式</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># echo standby &gt; /sys/power/state  <span class="comment">// 命令系统进入standby休眠</span></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>freeze</code>:  冻结I/O设备，将它们置于低功耗状态，使处理器进入空闲状态。唤醒最快，耗电比其它standby， mem，disk方式高。</p>
</li>
<li><p><code>standby</code>：请求系统进入 Suspend-to-Idle状态。在该状态下，系统仅关闭 CPU 核心并保持其他硬件运行，以实现更低的功耗。</p>
</li>
<li><p><code>mem</code>：请求系统进入 Suspend-to-RAM状态。在该状态下，系统的状态会保存到内存中，并关闭不必要的硬件设备。进入等待模式，唤醒较慢，耗电比disk方式高。</p>
</li>
<li><p><code>disk</code>：请求系统进入 Suspend-to-Disk状态。在该状态下，系统的状态会保存到磁盘上，并完全关闭系统。</p>
</li>
</ul>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：时钟与功耗的关系？</p>
<p>A：Soc中各个设备在工作时，时钟频率越高功耗越大、发热越大、越容易不稳定，需要散热条件越苛刻；<br>Soc内部有很多外设，这些外设不使用的时候最好关掉</p>
</li>
<li><p>Q：休眠之后没有按键、没有触屏中断触发，也没有rtc唤醒，但是刚刚休眠之后就被唤醒？</p>
<p>A：wifi-irq中断在休眠时需要配置成下拉或者输出低，不让其唤醒即可</p>
</li>
<li><p>Q：唤醒之后某个功能不能正常使用？</p>
<p>A：唤醒之后相关IO的状态设置可能出现错误，在休眠前通过<code>get_gpio_func</code>获取到并记录保证一致；如果还是不成功可以考虑休眠时IO状态的设置，是否是休眠时某些IO状态组合对外设产生了非法的命令导致错误，IO状态设置原则只是一般规则</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.eefocus.com/article/491902.html">MCU低功耗设计的5点注意要点</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/568050822">一文搞懂linux系统休眠唤醒</a></li>
</ul>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>SystemFunction</category>
      </categories>
  </entry>
  <entry>
    <title>Audio-初识</title>
    <url>/2022/08/31/SoftwareDevelopment/Media/Audio-meet/</url>
    <content><![CDATA[<p>跳动的音符，婉转的节奏，悠扬的歌声……</p>
<p>音乐无疑是最能愉悦身心的方式之一，那么歌手的音调、音色是如何存储到手机中，又是如何通过喇叭播放出来的呢？</p>
<p>下面我将通过几篇博客阐述我对音频的理解及部分调试经验，本章主要介绍音频的的基础知识</p>
<h1 id="信号分类"><a href="#信号分类" class="headerlink" title="信号分类"></a>信号分类</h1><p>声音严格意义来讲应该被叫做声音信号，而在维基百科中对于<strong>信号</strong>的定义是<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E9%87%8F/9984692">表示消息的物理量</a>，这样就很好理解了声音信号就是以声音为载体的一个物理量。而自然界中信号可以有如下的分类</p>
<p><img src="/images/SoftwareDevelopment/Media/Audio-meet-1.png" alt="signal"></p>
<p>因此，按照信号变化分类声音信号属于随机信号；按照信号特征分类声音信号属于模拟信号</p>
<h1 id="模数转换"><a href="#模数转换" class="headerlink" title="模数转换"></a>模数转换</h1><p>上一部分了解到声音是模拟信号，而对于计算机来讲其只能处理数字信号即0和1，所以必须需要将声音模拟信号转换成数字信号，而这个过程叫做模数转换（Analog Digital Conversion），相应的完成该功能的硬件单元就叫做模数转换器(ADC)</p>
<p>完成该过程需要三部曲分别是：采样、量化、编码，整体过程如下图：</p>
<p><img src="/images/SoftwareDevelopment/Media/Audio-meet-2.png" alt="ADC"></p>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p><em>重要参数：采样率</em></p>
<ul>
<li>定义：在时间轴上对信号进行离散化</li>
<li>原理：按照一定的频率对模拟信号的瞬时时刻进行样本采集</li>
</ul>
<p>其实采样作用通俗理解就是是采集样本。由于模拟信号是连续的，理论上我们需要采集无数个点才能完整的还原该信号，但是一来无穷的概念是不可能满足的，二来我们其实并不需要这么高的采样率。我们听觉是有延迟的就和视频帧不停的刷新欺骗我们的眼睛是画面连续的是一个道理。</p>
<p>所以采样率越高，声音的还原就越真实越自然，人对频率的识别范围是 20HZ - 22000HZ, 如果每秒钟能对声音做 22000 个采样, 回放时就足可以满足人耳的需求. 所以 22050 的采样频率是常用的, 44100已是CD音质, 超过48000的采样对人耳已经没有意义。这和电影的每秒 24 帧图片的道理差不多。</p>
<h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p><em>相关参数：采样位数</em></p>
<ul>
<li><p>定义：在幅度轴上对信号进行数字化</p>
</li>
<li><p>原理：对采样点的幅度赋予具体的数值，该数值由n位二进制表征（n = 8 / 16 / 32）</p>
</li>
</ul>
<p>采样位数越高说明划分的等级越精细。较低的采样位数损失精度，较高的采样位数可能造成软硬件资源的浪费</p>
<blockquote>
<p>小常识：标准CD音乐的质量就是16bit、44.1KHz采样</p>
</blockquote>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>定义：按照一定的格式记录 采样 和 量化 后的数据。后续会对部分格式的存储格式进行分析</p>
<h3 id="编码分类"><a href="#编码分类" class="headerlink" title="编码分类"></a>编码分类</h3><blockquote>
<p> 该部分内容转自 <a href="https://www.jianshu.com/p/28d3f108ef63">https://www.jianshu.com/p/28d3f108ef63</a></p>
</blockquote>
<h4 id="波形编码"><a href="#波形编码" class="headerlink" title="波形编码"></a>波形编码</h4><ul>
<li>定义：不利用生成音频信号的任何参数，直接将 <strong>时间域信号</strong> 变换为 <strong>数字代码</strong>，使重构的语音波形尽可能地与原始语音信号的 波形形状 保持一致。</li>
<li>原理：在 <strong>时间轴</strong> 上对模拟语音信号按一定的速率抽样，然后将幅度样本分层量化，并用代码表示。</li>
</ul>
<h4 id="参数编码"><a href="#参数编码" class="headerlink" title="参数编码"></a>参数编码</h4><p>从语音 <strong>波形信号</strong> 中提取生成语音的参数，使用这些参数通过语音生成模型重构出语音，使重构的语音信号尽可能地保持原始语音信号的语意。也就是说，参数编码是把语音信号产生的数字模型作为基础，然后求出数字模型的模型参数，再按照这些参数还原数字模型，进而合成语音。</p>
<h4 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h4><p>混合编码是指同时使用两种或两种以上的编码方法进行编码。这种编码方法克服了波形编码和参数编码的弱点，并结合了波形编码高质量和参数编码的低编码率，能够取得比较好的效果。</p>
<ul>
<li><p>WAV编码（波形编码）</p>
<p>WAV是编码的一种实现方式（其实它有非常多实现方式，但都是不会进行压缩操作）。就是在源 <strong>PCM</strong> 数据格式的前面加上44个字节。分别用来描述 <strong>PCM</strong> 的采样率、声道数、数据格式等信息。</p>
</li>
<li><p>MP3编码</p>
<p>MP3编码具有不错的压缩比，而且听感也接近于WAV文件，当然在不同的环境下，应该调整合适的参数来达到更好的效果。</p>
</li>
<li><p>AAC编码</p>
</li>
</ul>
<p>  AAC是目前比较热门的有损压缩编码技术，并且衍生了LC-AAC、HE-AAC、HE-AAC v2 三种主要编码格式。</p>
<p>  <strong>LC-AAC：</strong>是比较传统的AAC,主要应用于中高码率的场景编码(&gt;= 80Kbit/s)<br>   <strong>HE-AAC：</strong> 主要应用于低码率场景的编码(&lt;= 48Kbit/s)</p>
<ul>
<li><p>Ogg编码（有损）</p>
<p>Ogg编码是一种非常有潜力的编码，在各种码率下都有比较优秀的表现。尤其在低码率场景下。Ogg除了音质好之外，Ogg的编码算法也是非常出色。可以用更小的码率达到更好的音质。128Kbit/s的Ogg比192Kbit/s甚至更高码率的MP3更优质.但目前由软件还是硬件支持问题,都没法达到与MP3的使用广度.</p>
</li>
</ul>
<h1 id="音频参数"><a href="#音频参数" class="headerlink" title="音频参数"></a>音频参数</h1><p>一段悠扬的音乐经过采样、量化、编码就保存数字信号文件，而我们最终的目的一定不是只存成文件而是通过文件形式传播让更多人听到该音乐，因此一定存在DA转换，即还原数字信号为模拟信号的过程。那么在整个过程中有哪些参数表征了音频重要的信息呢？</p>
<p>不仅限于webrtc、ffmpeg、libmad等等音频编解码库，对于所有编解码器和codec来讲，音频源数据的三个参数至关重要：<strong>声道channel、采样率sampleRate、采样位数sampleBit</strong>。这三个参数之所以重要是因为有这几个参数就可以准确的知道一个裸的音频数据（PCM）的全部信息了。</p>
<h2 id="声道"><a href="#声道" class="headerlink" title="声道"></a>声道</h2><p>声道是指音频文件在录制时音源的数量位置和播放时相应的扬声器的数量（百度百科）。所以可想而知，其他参数相同的情况下，声道数越多定位越精准，同样所需扬声器和功放组件越多。</p>
<ul>
<li>单声道（mono）</li>
<li>双声道（stereo 立体声）：左声道 + 右声道，低音不分离，应用于音乐播放较多</li>
<li>2.1声道 ：左声道 + 右声道， 低音分离</li>
<li>5.1声道 ：左声道 + 右声道 + 低音声道 + 中央声道 + 左环绕 + 右环绕，应用于类传统影院和家庭影院中</li>
<li>7.1声道 ：左声道 + 右声道 + 低音声道 + 中央声道 + 左环绕 + 右环绕 + 左后环 + 右后环，常见的包括：Dolby Surround 7.1杜比7.1环绕声</li>
</ul>
<h2 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h2><p>采样率可以理解为采集样本的速率（故也可以称为采样速度或者采样频率），它定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。</p>
<p>例如：采样率为44100，意味着每秒钟对连续的声音信号采集44100次，同样对应得到的数字信号每秒的样本数量（具体可以参考采样过程）</p>
<h2 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h2><p>采样位数就是指某一瞬时时刻，量化声音大小（精细程度）的计量单位</p>
<ul>
<li>8bit ( 1Byte ) 对应0~255，将振幅划分为256个等级</li>
<li>16bit (2Byte) 对应0~65535，将振幅划分为65536个等级</li>
</ul>
<h2 id="样本格式"><a href="#样本格式" class="headerlink" title="样本格式"></a>样本格式</h2><h3 id="样本组合形式"><a href="#样本组合形式" class="headerlink" title="样本组合形式"></a>样本组合形式</h3><ul>
<li>交错模式：每个声道的样本数据交错存储排布</li>
<li>平面模式：每个声道的样本数据分开存储</li>
</ul>
<p>下面以stereo模式进行图示解释（C代表Channel）：</p>
<p>​    <img src="/images/SoftwareDevelopment/Media/Audio-meet-3.png" alt="sample"></p>
<h3 id="FFmpeg-样本组织形式介绍"><a href="#FFmpeg-样本组织形式介绍" class="headerlink" title="FFmpeg 样本组织形式介绍"></a>FFmpeg 样本组织形式介绍</h3><ul>
<li>Packed格式，frame.data[0]包含所有的音频数据。</li>
<li>Planar格式，frame.data[i]表示第i个声道的数据（假设声道0是第一个）</li>
</ul>
<h3 id="FFmpeg-主要样本格式"><a href="#FFmpeg-主要样本格式" class="headerlink" title="FFmpeg 主要样本格式"></a>FFmpeg 主要样本格式</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AVSampleFormat</span> {</span></span><br><span class="line">    AV_SAMPLE_FMT_NONE = <span class="number">-1</span>,</span><br><span class="line">    AV_SAMPLE_FMT_U8,          <span class="comment">///&lt; unsigned 8 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S16,         <span class="comment">///&lt; signed 16 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S32,         <span class="comment">///&lt; signed 32 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_FLT,         <span class="comment">///&lt; float</span></span><br><span class="line">    AV_SAMPLE_FMT_DBL,         <span class="comment">///&lt; double</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_U8P,         <span class="comment">///&lt; unsigned 8 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S16P,        <span class="comment">///&lt; signed 16 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S32P,        <span class="comment">///&lt; signed 32 bits, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_FLTP,        <span class="comment">///&lt; float, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_DBLP,        <span class="comment">///&lt; double, planar</span></span><br><span class="line">    AV_SAMPLE_FMT_S64,         <span class="comment">///&lt; signed 64 bits</span></span><br><span class="line">    AV_SAMPLE_FMT_S64P,        <span class="comment">///&lt; signed 64 bits, planar</span></span><br><span class="line"> </span><br><span class="line">    AV_SAMPLE_FMT_NB           <span class="comment">///&lt; Number of sample formats. DO NOT USE if linking dynamically</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>说明：以P为结尾的是planar结构；Planar模式是FFmpeg内部存储模式，我们实际使用的音频文件都是Packed模式的。</p>
<h2 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h2><p>比特率指的是单位时间播放连续的媒体如压缩后的音频或视频的比特数量，在这个意义上讲，它相当于术语数字带宽消耗量，或吞吐量。单位bps / Kbps（bit per second）这里是bit而不是Byte（1Byte = 8bit）</p>
<p>虽然经常作为“速度”的参考，比特率并不测量“‘距离’/时间”，而是被传输或者被处理的“‘二进制码数量’/时间”，所以应该把它和传播速度区分开来，传播速度依赖于传输的介质并且有通常的物理意义。（来自维基百科）</p>
<h2 id="参数关系"><a href="#参数关系" class="headerlink" title="参数关系"></a>参数关系</h2><p>对于PCM裸数据： 文件时长 ≈（文件总大小 - 头信息）/ (采样率 * 采样位数 * 通道数 / 8) [也就是比特率]</p>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Media</category>
      </categories>
      <tags>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>音频POP音解析</title>
    <url>/2023/08/15/SoftwareDevelopment/Media/Audio-musicPop/</url>
    <content><![CDATA[<h1 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h1><p>“POP”噪声是指音频器件在上电、断电瞬间以及上电稳定后，各种操作带来的瞬态冲击所产生的爆破声</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ol>
<li>电容充电/放电： 在音频设备状态切换时，电容可能会进行充电或放电，导致电压跳变</li>
<li>控制音频PA使能引脚的GPIO口下拉能力弱，或其他地方有上拉，导致长时间未关断</li>
<li>耳机插入</li>
</ol>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ol>
<li>CODEC、PA上电掉电时序控制不正确</li>
<li>CODEC内部音频通路切换</li>
<li>操作CODEC相关寄存器（设置Bias Level）的时候MCLK动了</li>
<li>对于比较差的模拟功放，在操作其mute管脚可能出现问题</li>
</ol>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol>
<li><p>音源本身存在问题，数据本身不连续有跳变</p>
</li>
<li><p>非线性放大。音频信号在放大过程中可能引起非线性失真，导致 “pop” 音</p>
</li>
</ol>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><p>对于POP音的产生有很多原因，确认具体产生原因对症下药</p>
<ol>
<li>确认MCLK是否稳定。连接示波器，录放音查看MCLK是否稳定，在关键BIAS ON / BIAS OFF等关键节点加入延时保证可以正常查看</li>
<li>确认功放CODEC上电时序。查看代码或者相关打印log保证功放时序</li>
<li>确认CODEC寄存器影响。二分法依次注释掉操作寄存器相关代码并确认是否存在POP音，定位是哪些寄存器影响。</li>
<li>确认硬件电容是否影响</li>
</ol>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol>
<li><p>硬件Layout</p>
<p>减小 POP 音就必须抑制 IC 的偏置电压bias的瞬变，Layout上的体现方法就是增大bias的滤波电容。偏置电容变得过大会导致 IC 的建立时间变长，另外电容过大还会导致 THD+N 变差。</p>
</li>
<li><p>时序控制</p>
<ul>
<li>上电时序：打开codec输出；PA拉高使能；延时一小段后送入相应音源</li>
<li>下电时序：闭相应音源；PA 拉低；延时一小段以后关闭codec输出</li>
</ul>
</li>
<li><p>CODEC寄存器支持</p>
<p>现在有些CODEC在软件上有一个寄存器可以设置这个直流电平的上升时间，让它在一定时间内跳变到1/2VDD，而不是很陡的一个上升沿，这样可以在一定程度改善这个POP音。</p>
</li>
<li><p>配置CODEC内部音频通路</p>
<p>在录放音开始或者结束的时候，CODEC内部通常需要使能相关通路的寄存器。这些寄存器的打开的先后顺序也可能产生影响，可以进行调整试试看</p>
</li>
<li><p>软件淡入淡出效果。 在音频切换时实现软件淡入淡出效果，平滑切换音频信号（淡入淡出音频信号/电压/振幅）</p>
</li>
<li><p>保证MCLK稳定</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.bilibili.com/video/BV1Cv411e79Z">常见的音频问题</a></li>
<li><a href="https://cloud.tencent.com/developer/article/2206040">pop音排查</a></li>
<li><a href="https://blog.csdn.net/dahailinan/article/details/109129653">音频常见问题总结</a></li>
<li><a href="https://www.likecs.com/show-727583.html">杂音 &amp; pop 音的解决方法</a></li>
</ol>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Media</category>
      </categories>
      <tags>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>Opus Ogg详解</title>
    <url>/2023/01/04/SoftwareDevelopment/Media/Audio-opus/</url>
    <content><![CDATA[<h1 id="opus是什么"><a href="#opus是什么" class="headerlink" title="opus是什么"></a>opus是什么</h1><blockquote>
<p>以下内容取自opus官网：<a href="https://www.opus-codec.org/">https://www.opus-codec.org</a></p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Opus 是一种完全开放、免版税、用途广泛的音频编解码器。 Opus 在 Internet 上的交互式语音和音乐传输方面无与伦比，但也适用于存储和流媒体应用。它被互联网工程任务组 (IETF) 标准化为 RFC 6716，它结合了 Skype 的 SILK 编解码器和 Xiph.Org 的 CELT 编解码器的技术。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Opus 可以处理范围广泛的音频应用，包括 IP 语音、视频会议、游戏内聊天，甚至远程现场音乐表演。它可以从低比特率窄带语音扩展到非常高质量的立体声音乐。支持的功能有：</p>
<ul>
<li>比特率从 6 kb/s 到 510 kb/s</li>
<li>采样率从 8 kHz（窄带）到 48 kHz（全带）</li>
<li>帧大小从 2.5 ms 到 60 ms</li>
<li>支持恒定比特率 (CBR) 和可变比特率 (VBR)</li>
<li>从窄带到全带的音频带宽</li>
<li>支持语音和音乐</li>
<li>支持单声道和立体声</li>
<li>支持多达 255 个通道（多流帧）</li>
<li>动态可调比特率、音频带宽和帧大小</li>
<li>良好的丢包鲁棒性和丢包隐藏 (PLC)</li>
<li>浮点和定点实现</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>音频带宽。Opus编码器覆盖了低频段到高频段的全带音频</p>
</li>
<li><p>低延迟。延迟依赖于帧规格，Opus最低帧规格2.5ms，非常适合实时音视频场景</p>
</li>
</ul>
<h1 id="opus库"><a href="#opus库" class="headerlink" title="opus库"></a>opus库</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>编解码器libopus: <a href="https://www.opus-codec.org/docs/opus_api-1.2/index.html">https://www.opus-codec.org/docs/opus_api-1.2/index.html</a></p>
<p>封装器opusfile：<a href="https://www.opus-codec.org/docs/opusfile_api-0.7/index.html">https://www.opus-codec.org/docs/opusfile_api-0.7/index.html</a></p>
</blockquote>
<p>opus库包括三部分：libopus、opus-tools、opusfile</p>
<ul>
<li>libopus：opus编解码的源码和可执行文件（注意：这里编码出来的opus文件是播放不了的，并且解码也必须用那种播放不了的opus文件,后面解释为什么）</li>
<li>opus-tools：工具包，其中包含了libogg（.wav2.opus  /  .opus2.wav）</li>
<li>opusfile：将可播放的opus文件解码成wav的工具，可分析出这个可播放的opus文件的信息，其中包含了libogg</li>
</ul>
<h2 id="可播放opus与不可播放opus文件"><a href="#可播放opus与不可播放opus文件" class="headerlink" title="可播放opus与不可播放opus文件"></a>可播放opus与不可播放opus文件</h2><p>ogg文件里面包含了opus编码的音频，相当于MP4文件中包含了aac</p>
<ul>
<li>不可播放opus：只有编码层opus数据的音频（没有ogg的封装只经过libopus编码），后缀名是.opus</li>
<li>可播放的opus：opus编码的音频外部套用了一层ogg的封装（经过ogg的封装，opus-tools编码的文件），后缀名可以是.opus也可以是.ogg</li>
</ul>
<h1 id="opus结构"><a href="#opus结构" class="headerlink" title="opus结构"></a>opus结构</h1><p>每个 Opus 包以一个 TOC （Table of Contents）字节开头</p>
<table>
<thead>
<tr>
<th>配置数（config）</th>
<th>编码模式</th>
<th>音频带宽</th>
<th>帧长度</th>
</tr>
</thead>
<tbody><tr>
<td>0…3</td>
<td>SILK-only</td>
<td>NB</td>
<td>10, 20, 40, 60 ms</td>
</tr>
<tr>
<td>4…7</td>
<td>SILK-only</td>
<td>MB</td>
<td>10, 20, 40, 60 ms</td>
</tr>
<tr>
<td>8…11</td>
<td>SILK-only</td>
<td>WB</td>
<td>10, 20, 40, 60 ms</td>
</tr>
<tr>
<td>12…13</td>
<td>Hybrid</td>
<td>SWB</td>
<td>10, 20 ms</td>
</tr>
<tr>
<td>14…15</td>
<td>Hybrid</td>
<td>FB</td>
<td>10, 20 ms</td>
</tr>
<tr>
<td>16…19</td>
<td>CELT-only</td>
<td>NB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
<tr>
<td>20…23</td>
<td>CELT-only</td>
<td>WB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
<tr>
<td>24…27</td>
<td>CELT-only</td>
<td>SWB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
<tr>
<td>28…31</td>
<td>CELT-only</td>
<td>FB</td>
<td>2.5, 5, 10, 20 ms</td>
</tr>
</tbody></table>
<p>立体声标志位（s）取值 0 表示单声道，1 表示多声道立体声。</p>
<p>TOC 中最后两位（c）表示：</p>
<ul>
<li>0：一个包中只有一帧音频。</li>
<li>1：一个包中有两帧音频，并且大小相同。</li>
<li>2：一个包中有两帧音频，但是大小不同。</li>
</ul>
<h1 id="opusfile-API"><a href="#opusfile-API" class="headerlink" title="opusfile API"></a>opusfile API</h1><blockquote>
<p>opusfile高级API官方文档：<a href="https://opus-codec.org/docs/opusfile_api-0.12/">https://opus-codec.org/docs/opusfile_api-0.12/</a></p>
<p>参考文档：</p>
<p>​	<a href="https://juejin.cn/post/6844903998831460360">https://juejin.cn/post/6844903998831460360</a></p>
<p>​	<a href="https://chenliang.org/2020/04/17/ogg-encapsulation-for-opus/">https://chenliang.org/2020/04/17/ogg-encapsulation-for-opus/</a></p>
</blockquote>
<ol>
<li><p><strong>op_open_file() / op_free()</strong></p>
<p>打开/关闭一个解码器</p>
</li>
<li><p><strong>op_head() / op_tags()</strong></p>
</li>
</ol>
<ul>
<li><p>op_head函数可用于获取channels、samplerate等参数</p>
</li>
<li><p>op_tags函数可获得用户自定义参数，例如：标题、歌手、编码方式标准等等，其中tags-&gt;user_comments[i]可获取用户自定义的信息</p>
</li>
</ul>
<ol start="3">
<li><strong>op_pcm_total() / op_pcm_tell() / op_pcm_seek()</strong></li>
</ol>
<ul>
<li>op_pcm_total 可以返回该opus文件转换成pcm文件后的总的pcm长度</li>
<li>op_pcm_tell 可以放回目前文件已经播放的pcm的长度</li>
<li>op_pcm_seek 可以通过参数指定让音频进行跳转播放</li>
</ul>
<ol start="4">
<li><strong>op_pcm_read()</strong></li>
</ol>
<p>   从op_open_file打开的文件流中读取pcm数据进行播放。注意解码的数量并不等于传入buffer的大小，需要使用到该函数的返回值</p>
<h1 id="Ogg"><a href="#Ogg" class="headerlink" title="Ogg"></a>Ogg</h1><blockquote>
<p> 参考 : <a href="https://juejin.cn/post/6844904016254599175">https://juejin.cn/post/6844904016254599175</a></p>
</blockquote>
<p>全称：OGGVobis(oggVorbis) 一个自由且开放标准的容器格式，“.ogg”结尾命名</p>
<p>OGG是以页（page）为单位将逻辑流组织链接起来，每个页都有pageheader和pagedata。</p>
<ol>
<li>capture_pattern页标识：ASCII字符，0x4f ‘O’ 0x67 ‘g’ 0x67 ‘g’ 0x53 ‘S’，4个字节大小，它标识着一个页的开始。</li>
<li>stream_structure_version版本id：一般当前版本默认为0，1个字节。</li>
<li>header_type_flag类型标识：标识当前的页的类型，1个字节， - 0x01：本页媒体编码数据与前一页属于同一个逻辑流的同一个packet，若此位没有设，表示本页是以一个新的packet开始的； - 0x02：表示该页为逻辑流的第一页，bos标识，如果此位未设置，那表示不是第一页； - 0x04：表示该页位逻辑流的最后一页，eos标识，如果此位未设置，那表示本页不是最后一页。</li>
<li>granule_position：媒体编码相关的参数信息，8个字节，对于音频流来说，它存储着到本页为止逻辑流在PCM输出中采样码的数目，可以由它来算得时间戳。对于视频流来说，它存储着到本页为止视频帧编码的数目。若此值为-1，那表示截止到本页，逻辑流的packet未结束。(小端)</li>
<li>serial_number：当前页中的流的id，4个字节，它是区分本页所属逻辑流与其他逻辑流的序号，我们可以通过这个值来划分流。(小端)</li>
<li>page_seguence_number：本页在逻辑流的序号，4个字节。</li>
<li>CRC_cbecksum：循环冗余效验码效验，4个字节，用来效验每页的有效性。</li>
<li>number_page_segments：给定本页在segment_table域中出现的segement个数，1个字节。</li>
<li>segment_table：从字面看它就是一个表，表示着每个segment的长度，取值范围是0~255。由segment（1个segment就是1个字节）可以得到packet的值，每个packet的大小是以最后一个不等于255的segment结束的，从页头中的segment_table可以得到每个packet长度，举例：如果一组segment依次顺序为FF 45 FF FF FF 40FF 05FF FF FF 66（共4个packet，含12个segment，每个packet的长度是：FF 45【324】；FF FF FF 40【829】；FF 05【260】；FF FF FF 66【847】），那么第一个packet的长度为255+69 = 324,第二个packet大小829，同理。</li>
</ol>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Media</category>
      </categories>
      <tags>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>m3u8视频流基础</title>
    <url>/2023/11/05/SoftwareDevelopment/Media/m3u8Reserch/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>文件格式与编码格式区别：</p>
<ul>
<li><p>文件格式</p>
<p>文件格式是指数字媒体文件的结构和组织方式，通常用于存储和传输媒体数据，例如音频、视频或图像。文件格式决定了媒体文件的扩展名（例如，.mp3、.mp4、.jpg、.png、.avi、.mkv 等），而不同的文件格式可能支持不同的编码格式和特性，例如MP4 文件格式通常可以包含 H.264 编码的视频和 AAC 编码的音频</p>
</li>
<li><p>编码格式</p>
<p>编码格式是指数字媒体数据的压缩和编码方式，以减小文件大小并在媒体传输和播放时提供高质量的媒体内容。不同的编码格式采用不同的算法来压缩和编码媒体数据，并最终影响到文件的质量、大小以及兼容性。对于视频，常见的编码格式包括 H.264（AVC）、H.265（HEVC）、VP9 等；对于音频，常见的编码格式包括 AAC、MP3、Opus 等。</p>
</li>
</ul>
<h1 id="M3U8"><a href="#M3U8" class="headerlink" title="M3U8"></a>M3U8</h1><blockquote>
<p><a href="https://m3u8-player.com/">m3u8在线播放器</a></p>
<p><a href="http://blog.luckly-mjw.cn/tool-show/m3u8-downloader/index.html">m3u8视频在线提取工具</a></p>
</blockquote>
<p>M3U（Moving Picture Experts Group Audio Layer 3 Uniform Resource Locator）本质上说不是音频文件，而是一个记录索引的纯文本文件，一个音频文件的列表文件。它并不能在离线模式下读取网络资源音频，而是根据它的索引找到对应的音视频文件的网络地址进行在线播放。</p>
<p>M3U8 文件是指 UTF-8 编码格式的 M3U 文件(M3U 使用 Latin-1 字符集编码)，是一种常用的直播和点播视频格式。M3U8文件中的内容主要由标签（TAG）、属性列表（Attribute Lists）、播放地址（URI）构成。</p>
<h2 id="TAG"><a href="#TAG" class="headerlink" title="TAG"></a>TAG</h2><ul>
<li>Basic Tags，基本标签：该类标签必须出现在每个M3U8文件中；</li>
<li>Media Segment Tags，媒体片段标签：该类标签和其跟随的URI一起指定一个媒体片段。有些媒体片段标签仅作用于其下一行的片段，而其他的媒体片段标签作用于所有子序列片段，直到另外一个相同标签实例出现。一个媒体片段标签一定不能出现在主播放列表中；</li>
<li>Media Playlist Tags，媒体播放列表标签：该类标签是描述媒体播放列表的全局参数。一个媒体播放列表中，每种类型的媒体播放列表标签只能出现一次。媒体播放列表标签不能出现在主播放列表中；</li>
<li>Master Playlist Tags，主播放列表标签：主播放标签定义了Variant Stream、Rendition和其他显示的全局参数，主播放列表标签不能出现在媒体播放列表中</li>
</ul>
<ol>
<li>EXTM3U<br>EXTM3U标记指示文件是扩展M3U [ M3U ]播放列表文件。它必须是每个媒体播放列表的第一行，每个主播放列表。其格式为：＃EXTM3U</li>
<li>EXT-X-VERSION<br>EXT-X-VERSION标记指示兼容版本播放列表文件，其关联的媒体及其服务器。 EXT-X-VERSION标签适用于整个播放列表文件。它的格式为：＃EXT-X-VERSION：</li>
<li>EXTINF<br>EXTINF标签指定媒体段的持续时间。适用仅到下一个媒体段。每个媒体都需要此标签分割。其格式为：#EXTINF：<ol start="4">
<li></li>
</ol>
</li>
</ol>
<h2 id="Attribute-Lists"><a href="#Attribute-Lists" class="headerlink" title="Attribute Lists"></a>Attribute Lists</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">属性名=属性值</span><br></pre></td></tr></tbody></table></figure>

<p>在一些标签后面跟随的是属性列表，属性列表是用逗号分割开来的键值对列表。如下面的语法格式所示，属性列表中的属性名、’=’、属性值之间不能有空格，属性名可以是由数字[0,9]、大写字母[A,Z]、和’-‘这些字符构成。</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>播放地址比较简单，一般单独占用一行。其中播放地址是比较简单的，其一般单独占用一行。该地址一般由.m3u8、.m3u、.ts结尾（实际应用中这些后缀后面还可能会带着由问号(?)分割的其他应用参数），前两种结尾的播放地址代表当前是一个一级M3U8文件，这些地址指向的是一个个二级M3U8文件；而以.ts结尾的播放地址代表当前是一个二级M3U8文件，这些地址指向的是一个个具体的ts分片下载地址。</p>
<h1 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h1><p>HLS（HTTP Live Streaming）是一种用于实时流媒体传输的协议，最初由苹果公司开发并推广。它被广泛用于在互联网上实时传输音频和视频内容，并在多种设备和平台上播放。</p>
<p>HLS主要内容由HTTP + M3U8 + TS这三个部分共同组成，其中HTTP是最常见的应用层协议了，我们日常基本的浏览器上网就是基于HTTP协议；而TS是音视频编码标准MPEG-2中定义的一种媒体流封装复用格式，TS相关的详情可以参考文章<a href="https://zhuanlan.zhihu.com/p/571531960">《MPEG-2 TS流结构浅析》</a>；HTTP和TS都是其他协议或标准中规定的内容，那么HLS的核心就是这个M3U8了</p>
<p>优点：</p>
<ul>
<li>跨平台兼容性：HLS 协议在多个平台上广泛支持，包括iOS设备、Android设备、桌面计算机、智能电视等。这意味着内容提供商可以使用单一的 HLS 流来覆盖多个设备，而无需定制多个传输协议。</li>
<li>分段传输：HLS 将媒体内容分成小的媒体片段，并以连续的方式传输。这有助于减少缓冲延迟并提高播放的稳定性。</li>
<li>自适应码率支持：HLS 允许内容提供商提供多个不同质量和分辨率的媒体流，以适应观众的设备和带宽。</li>
<li>安全性：HLS 支持内容加密，以确保内容的安全性，并防止未经授权的访问。</li>
</ul>
<p>缺点：</p>
<ul>
<li>延迟：HLS 在某些情况下可能引入较长的播放延迟，特别是在实时直播场景中。这个延迟对于需要低延迟的应用可能不太适用，如在线游戏或实时互动。</li>
</ul>
<h1 id="视频I-x2F-P-x2F-B帧"><a href="#视频I-x2F-P-x2F-B帧" class="headerlink" title="视频I/P/B帧"></a>视频I/P/B帧</h1><ul>
<li>I 帧 (Intra-coded frame)：<strong>关键帧</strong>，它是独立的帧，不依赖其他帧的信息。I 帧包含完整的图像信息，因此它的压缩效果相对较差，但是它可以独立地被解码。</li>
<li>P 帧 (Predicted frame)：<strong>预测帧</strong>。它依赖于前面的 I 帧或者 P 帧，P 帧在存储图像信息的同时，还记录了图像的变化量，因此它的压缩效果比 I 帧更好。</li>
<li>B 帧 (Bidirectional frame)：<strong>双向预测帧</strong>。它依赖于前面和后面的 I 帧或者 P 帧，B 帧可以从多个方向预测图像，因此其压缩效果比 P 帧更好，但是不能独立地被解码，必须和相邻的 I 帧或者 P 帧配合使用。</li>
</ul>
<h1 id="播放示例"><a href="#播放示例" class="headerlink" title="播放示例"></a>播放示例</h1><h2 id="mp4转m3u8"><a href="#mp4转m3u8" class="headerlink" title="mp4转m3u8"></a>mp4转m3u8</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> ffmpeg -i inupt.mp4 -c:v libx264 -c:a aac -strict -2 -f hls -hls_list_size 2 -hls_time 15 output.m3u8</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i: 		指定输入文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c:v   	指定视频编码的视频编解码器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c:a   	指定音频编码的音频编解码器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-strict   用于启用或禁用编码器的严格性。-2 表示禁用所有警告和错误，以便 FFmpeg 可以自动进行最佳设置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f        指定了输出格式，即要生成的流媒体格式是 HLS</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-hls_list_size 	指定 HLS 播放列表文件（M3U8 文件）的最大条目数。在这个例子中，最多会有 2 个 M3U8 文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-hls_time 		指定 HLS 分段的持续时间（以秒为单位）。在这个例子中，每个分段的持续时间为 15 秒</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后是输出文件名</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="测试地址"><a href="#测试地址" class="headerlink" title="测试地址"></a>测试地址</h2><ul>
<li><p><a href="https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8">https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8</a></p>
</li>
<li><p><a href="http://playertest.longtailvideo.com/adaptive/bipbop/gear4/prog_index.m3u8">http://playertest.longtailvideo.com/adaptive/bipbop/gear4/prog_index.m3u8</a></p>
</li>
<li><p>广西卫视：<a href="https://mobilelive.gxtv.cn/live/nn_live1004/playlist.m3u8">https://mobilelive.gxtv.cn/live/nn_live1004/playlist.m3u8</a></p>
</li>
<li><p>综艺旅游频道：<a href="https://mobilelive.gxtv.cn/live/nn_live1005/playlist.m3u8">https://mobilelive.gxtv.cn/live/nn_live1005/playlist.m3u8</a></p>
</li>
<li><p>都市频道：<a href="https://mobilelive.gxtv.cn/live/nn_live1006/playlist.m3u8">https://mobilelive.gxtv.cn/live/nn_live1006/playlist.m3u8</a></p>
</li>
</ul>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>ffplay播放m3u8网络流错误？</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[tcp @ 0x561907287000] Connection to tcp://192.168.4.16:8082 failed: Connection timed out</span><br><span class="line">https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8: Connection timed out</span><br></pre></td></tr></tbody></table></figure>

<p>如上所示即为报错内容，这个ip及端口明显是我的本机之前所配置的代理，而ffplay在网络拉流的时候使用了错误的代理。最终在/etc/environment文件中找到这个ip并修改成目前正在使用的代理。source /etc/environment 刷新环境变量，并使用export查看，再次播放即可。</p>
</li>
<li><p>mplayer播放https的网络直播数据流出错？</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">    $ mplayer  https:<span class="comment">//mobilelive.gxtv.cn/live/nn_live1006/playlist.m3u8 </span></span><br><span class="line">    MPlayer <span class="number">1.5</span><span class="number">-9</span> (C) <span class="number">2000</span><span class="number">-2022</span> MPlayer Team</span><br><span class="line">    </span><br><span class="line">    Playing https:<span class="comment">//mobilelive.gxtv.cn/live/nn_live1006/playlist.m3u8.</span></span><br><span class="line">    libavformat version <span class="number">59.17</span><span class="number">.102</span> (internal)</span><br><span class="line">    Cannot seek backward in linear streams!</span><br><span class="line">    Cannot seek backward in linear streams!</span><br><span class="line">    Cannot seek backward in linear streams!</span><br><span class="line">    Cannot seek backward in linear streams!</span><br><span class="line">    Cannot seek backward in linear streams!</span><br><span class="line">    Cannot seek backward in linear streams!</span><br><span class="line">    Cannot seek backward in linear streams!</span><br><span class="line">    Cannot seek backward in linear streams!</span><br><span class="line">    Cannot seek backward in linear streams!</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 解决方案</span></span><br><span class="line">    在命令行的位置添加一个选项    -cache <span class="number">4096</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>  m3u8视频流不能跳转</span><br><span class="line"></span><br><span class="line">    ```shell</span><br><span class="line">    *** ftime=<span class="number">0.040</span> ***</span><br><span class="line">    delay=<span class="number">0.371519</span></span><br><span class="line">    seekTime : <span class="number">60.000000</span> </span><br><span class="line">    A:  <span class="number">13.6</span> V:  <span class="number">13.6</span> A-V: <span class="number">-0.006</span> ct: <span class="number">-0.016</span>   <span class="number">0</span>/  <span class="number">0</span>  <span class="number">7</span>% <span class="number">32</span>%  <span class="number">7.1</span>% <span class="number">25</span> <span class="number">0</span> <span class="number">0</span>%          </span><br><span class="line">    demux_seek_lavf(<span class="number">0x854a00</span>, <span class="number">60.000000</span>, <span class="number">0.000000</span>, <span class="number">1</span>)</span><br><span class="line">    [AVIOContext @ <span class="number">0x77192444</span>]Statistics: <span class="number">1019312</span> bytes read, <span class="number">0</span> seeks</span><br><span class="line">    ds_fill_buffer(d_audio) called</span><br><span class="line">    demux_lavf_fill_buffer()</span><br><span class="line">    [mpegts @ <span class="number">0x77190bc8</span>]Skipping after seek</span><br><span class="line">    [hls @ <span class="number">0x77190bc8</span>]HLS request <span class="keyword">for</span> url <span class="string">'http://video.english163.com/uploadfile/vieo/xindongfang/xindongfangd01j01/500kb/hls/index5.ts'</span>, offset <span class="number">0</span>, playlist <span class="number">0</span></span><br><span class="line">    [hls @ <span class="number">0x77190bc8</span>]Opening <span class="string">'crypto+http://video.english163.com/uploadfile/vieo/xindongfang/xindongfangd01j01/500kb/hls/index5.ts'</span> <span class="keyword">for</span> reading</span><br></pre></td></tr></tbody></table></figure>

<p>定位问题的方法：如果可以将所有的config都打开，这样子确认是否能够支持。随后通过二分法，定位到具体是哪一个配置文件起作用。</p>
</li>
<li><p>mplayer没有详细的打印?</p>
<p>mplayer -msglevel all=9可以将所有打印显示出来，其中all可以替换成network、xxx等等</p>
</li>
<li><p>m3u8使用本地key进行解密？</p>
<p>首先需要把播放文件下载到本地m3u8文件，该文件将包含EXTM3U信息头和ts切片链接。接下来，将解密key写成文件的形式存放在本地。最后，修改m3u8本地文件，修改字段为 EXT-X-KEY: METHOD=AES-128,URI=”file//home/user/key.m3u8”,IV=xxxxxxxx。</p>
<p>这里需要注意的是，对于密钥文件的名字扩展名一定是.m3u8。因为新版本ffmpeg出于安全限制了文件扩展名，只有白名单里的才能被读取，而.key文件不在白名单里，.m3u8一定在白名单中。如果一定要使用其它的扩展名，对于ffplay需要添加 -allowed_extensions ALL 字段才可以正常播放。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 以下扩展名是允许的</span><br><span class="line">.str = "3gp,aac,avi,ac3,eac3,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav"</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/574836942">H264编码格式–图文解释</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/571599256">HLS协议剖析</a></li>
<li><a href="https://ossrs.net/lts/zh-cn/assets/files/hls-m3u8-draft-pantos-http-live-streaming-12-1e1670aa99771fd9759768d524d5fa2a.pdf">HTTP Live Streaming  draft-pantos-http-live-streaming-12</a></li>
<li><a href="https://www.cnblogs.com/chentiao/p/17085240.html">视频的I、P、B帧通俗解释</a></li>
</ol>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Media</category>
      </categories>
      <tags>
        <tag>Video</tag>
      </tags>
  </entry>
  <entry>
    <title>Git&amp;&amp;Repo</title>
    <url>/2023/12/09/SoftwareDevelopment/Tools/GIT/</url>
    <content><![CDATA[<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><p>Git 是一种分布式版本控制系统，每个开发者都拥有完整的仓库副本。这使得可以在本地进行大部分操作，而不需要网络连接。分布式系统允许离线工作、更灵活的分支管理和更高效的协作。Git 支持多种工作流程，包括集中式工作流、功能分支工作流、Gitflow 等。开发者可以选择适合他们团队和项目的工作流。</p>
<h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><h2 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h2><h3 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/init.png"></p>
<h3 id="远程获取已有仓库"><a href="#远程获取已有仓库" class="headerlink" title="远程获取已有仓库"></a>远程获取已有仓库</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone https://github.com/yangLieee/Git_Test.git</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/clone.png"></p>
<h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/status.png"></p>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/remote.png"></p>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/log.png"></p>
<h3 id="查看文件改动"><a href="#查看文件改动" class="headerlink" title="查看文件改动"></a>查看文件改动</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git diff [filename]</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/diff.png"></p>
<h3 id="查看本地提交记录"><a href="#查看本地提交记录" class="headerlink" title="查看本地提交记录"></a>查看本地提交记录</h3><p>可以叫做显示可引用的历史版本记录。HEAD值越小，表示版本越新，越大表示版本生成时间越久。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></tbody></table></figure>

<h2 id="文件提交流程"><a href="#文件提交流程" class="headerlink" title="文件提交流程"></a>文件提交流程</h2><h3 id="获取最新版本文件"><a href="#获取最新版本文件" class="headerlink" title="获取最新版本文件"></a>获取最新版本文件</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git pull [remote] [branch]</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/pull.png"></p>
<h3 id="将文件提交至暂存区"><a href="#将文件提交至暂存区" class="headerlink" title="将文件提交至暂存区"></a>将文件提交至暂存区</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git add [filename]</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/add.png"></p>
<h3 id="提交文件并写log信息"><a href="#提交文件并写log信息" class="headerlink" title="提交文件并写log信息"></a>提交文件并写log信息</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交文件LOG单行显示</span></span><br><span class="line">git commit -m "[Log]"</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交文件LOG多行</span></span><br><span class="line">git commit -m '</span><br><span class="line">[log] xxx</span><br><span class="line"> - add</span><br><span class="line"> - delete xxx</span><br><span class="line"> '</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">使用-a参数可以不用 git add，直接提交</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/commit.png"></p>
<p><img src="/images/SoftwareDevelopment/Tools/GIT/commit_1.png"></p>
<h3 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">git push origin HEAD:refs/for/refs/heads/master</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/push.png"></p>
<p><img src="/images/SoftwareDevelopment/Tools/GIT/push1.png"></p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/branch.png"></p>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git checkout [branch-name]</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/checkout_branch.png"></p>
<h3 id="创建本地新分支"><a href="#创建本地新分支" class="headerlink" title="创建本地新分支"></a>创建本地新分支</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git branch [branch-name]</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/create_branch.png"></p>
<h2 id="更改文件状态"><a href="#更改文件状态" class="headerlink" title="更改文件状态"></a>更改文件状态</h2><h3 id="撤销add"><a href="#撤销add" class="headerlink" title="撤销add"></a>撤销add</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git reset [filename]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="撤销commit"><a href="#撤销commit" class="headerlink" title="撤销commit"></a>撤销commit</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">commit-ID是指上一个版本的版本号的commit-ID</span></span><br><span class="line">git reset [commit-ID]</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/images/SoftwareDevelopment/Tools/GIT/reset.png"></p>
<h3 id="恢复文件的改动至库里状态"><a href="#恢复文件的改动至库里状态" class="headerlink" title="恢复文件的改动至库里状态"></a>恢复文件的改动至库里状态</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git checkout [filename]</span><br></pre></td></tr></tbody></table></figure>

<h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><p>命令可以将当前分支的 HEAD 指针指向指定的提交，从而回退代码到指定版本。</p>
<ul>
<li>–mixed （默认）：将 HEAD 指针和暂存区都回退到指定提交，但不改变工作区的内容。</li>
<li>–soft 仅将 HEAD 指针回退到指定提交，不改变暂存区和工作区的内容。</li>
<li>–hard 将 HEAD 指针、暂存区和工作区都回退到指定提交，会丢失最新的代码修改，慎用。</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git reset --soft [commit-ID] [filename]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="图像界面"><a href="#图像界面" class="headerlink" title="图像界面"></a>图像界面</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">gitk </span><br></pre></td></tr></tbody></table></figure>



<h1 id="Git命令取别名"><a href="#Git命令取别名" class="headerlink" title="Git命令取别名"></a>Git命令取别名</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"># 在.gitconfig文件中添加以下内容</span><br><span class="line"></span><br><span class="line">[alias]</span><br><span class="line">    br=branch</span><br><span class="line">    st=status</span><br><span class="line">    last=<span class="built_in">log</span> <span class="number">-1</span></span><br><span class="line">    # 取消暂存文件，取消git add的内容</span><br><span class="line">    unstage=reset HEAD</span><br></pre></td></tr></tbody></table></figure>



<h1 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> repo 是对分布式版本控制系统 Git 中部分命令的封装，是一个命令行工具。它可以管理多个 git 项目。</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">repo init -u url [OPTIONS]</span><br><span class="line">#repo init -u ssh://192.168.1.26:29418/manifest -b master -m example.xml</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>-u :指定一个URL，其链接到一个清单仓</li>
<li>-m : 指定要下载哪个xml文件的内容，默认执行manifest下面的default.xml</li>
<li>-b : 选在一个清单库中的一个分支</li>
</ul>
<h3 id="下载具体内容"><a href="#下载具体内容" class="headerlink" title="下载具体内容"></a>下载具体内容</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></tbody></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cloud.tencent.com/developer/article/1355182">Git使用教程：最详细、最傻瓜、最浅显、真正手把手教！</a></li>
<li><a href="https://blog.csdn.net/Sugar_wolf/article/details/127860237">repo使用指南</a></li>
</ul>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>Xrun的解决方案</title>
    <url>/2023/10/17/SoftwareDevelopment/Media/Audio-underrun/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="数据流框图"><a href="#数据流框图" class="headerlink" title="数据流框图"></a>数据流框图</h2><p><img src="/images/SoftwareDevelopment/Media/Audio-xrun.png" alt="xrun"></p>
<h2 id="xrun概念"><a href="#xrun概念" class="headerlink" title="xrun概念"></a>xrun概念</h2><p>xrun是 “underrun”（欠速）和 “overrun”（溢出）的一种特殊情况，主要出现在数字音频工作站或音频处理应用程序中。但是underrun和overrun不只是音频领域的专业术语，在计算机网络、视频处理等领域也都有这个含义。本篇重点对音频领域的xrun做说明。</p>
<ul>
<li><p>Underrun</p>
<p>Underrun 通常发生在数据发送端无法及时提供足够的数据以满足接收端的需求时（==供小于求==），放音出现。</p>
</li>
<li><p>Overrun</p>
<p>Overrun 通常发生在数据接收端无法及时处理所接收到的数据时（==供大于求==），录音出现。</p>
</li>
</ul>
<h2 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h2><p>放音流程：</p>
<ol>
<li>将音频文件从Flash读到DDR上。此时数据存储在堆栈空间buffer中</li>
<li>处理原始数据。此时可能会对原始数据进行处理包括重采样、增益等等</li>
<li>传输音频数据。将处理完成的数据通过DMA通道传输到音频控制器上，进而通过I2S或者其它总线传输到CODEC上最终通过喇叭放音</li>
</ol>
<p>如上条目所示是放音的基本流程。分析以上步骤可以发现如果该流程是同步串行执行的话将十分耗费处理器的性能，所以在实际中，第一步和第三步通常是异步执行的，因此这就涉及到数据同步的问题。假设软硬件初始化完毕，本次的数据已经传输完毕而新的数据没有及时供应，也就是第一步的数据没有到位，此时就会导致underrun的发生</p>
<p>同理，对于录音来讲，就是放音的逆过程。</p>
<h2 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h2><p>在alsa中发生xrun最直接的表现就是调用snd_pcm_writei或者snd_pcm_readi时，返回值返回-EPIPE。这是因为 ALSA 驱动 buffer 没有数据可以丢给 codec 或者codec数据太多ALSA驱动接收不过来所导致的。而导致这种情况发生的原因包括：</p>
<ul>
<li><p>生产者与消费者线程的优先级不一致导致的系统调度</p>
</li>
<li><p>DDR的buffer大小申请不合理</p>
</li>
<li><p>中断频繁</p>
</li>
<li><p>DMA配置策略导致没有及时将数据搬到FIFO</p>
</li>
<li><p>硬件播放格式与源数据格式不一致</p>
</li>
</ul>
<h1 id="Linux-xrun调试方法"><a href="#Linux-xrun调试方法" class="headerlink" title="Linux xrun调试方法"></a>Linux xrun调试方法</h1><ol>
<li><p>内核配置选中 CONFIG_SND_DEBUG、CONFIG_SND_PCM_XRUN_DEBUG和CONFIG_SND_VERBOSE_PROCFS</p>
</li>
<li><p>重新编译内核并烧录</p>
</li>
<li><p>配置调试参数 <code>echo xxx &gt; /proc/asound/card#/pcm0p/xrun_debug</code>(“＃”替换为声卡号 0 / 1 / 2 …)</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">1   Basic debugging - show xruns in ksyslog interface</span><br><span class="line">2   Dump stack - dump stack for basic debugging</span><br><span class="line">4   Jiffies check - compare the position with kernel jiffies (a sort of in-kernel monotonic clock),</span><br><span class="line">    show what's changed when basic debugging is enabled</span><br><span class="line">8   Dump positions on each period update call</span><br><span class="line">16  Dump positions on each hardware pointer update call</span><br><span class="line">32  Enable logging of last 10 ring buffer positions</span><br><span class="line">64  Show the last 10 ring buffer position only once (when first error situation occured)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>推荐使用的参数组合数字：53、11、29</p>
</li>
<li><p>播放音乐，当发生underrun的时候会有如下打印</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">audiocodec soc@xxxxxxxx：sound@0：XRUN：pcmC0D0p：0</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="xrun解决方案"><a href="#xrun解决方案" class="headerlink" title="xrun解决方案"></a>xrun解决方案</h1><ol>
<li><p>通常对于函数返回值的判断需要进行一定处理</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rc == -EPIPE) {</span><br><span class="line">  <span class="comment">/* EPIPE means underrun */</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"underrun occurred\n"</span>);</span><br><span class="line">  snd_pcm_prepare(handle);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


</li>
<li><p>调整生产者线程（将音频数据填充至buffer）和消费者线程（将buffer的数据写入硬件snd_pcm_writei）的优先级</p>
</li>
<li><p>调整period_size和period_count。 period_size：每次传输的数据长度。值越小，时延越小，cpu占用就越高；period_count：缓冲区period的个数，缓冲区越大发生XRUN的机会就越少。</p>
</li>
<li><p>配置软件参数：silence_threshold和stop_threshold</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="comment">// snd_pcm_uframes_t buf_size = MINIMUM_SAMPLE_SET_SIZE;</span></span><br><span class="line">    <span class="comment">// snd_pcm_hw_params_set_buffer_size_near(alsa_handle, params, &amp;buf_size);   </span></span><br><span class="line">    <span class="type">snd_pcm_uframes_t</span> boundary = <span class="number">0</span>;</span><br><span class="line">    <span class="type">snd_pcm_sw_params_t</span>  *sw_params;</span><br><span class="line">    snd_pcm_sw_params_alloca(&amp;sw_params);</span><br><span class="line">    <span class="comment">/* Get current software configuration */</span></span><br><span class="line">    snd_pcm_sw_params_current(alsa_handle, sw_params);</span><br><span class="line">    <span class="comment">/* Get boundary for ring pointers from a software configuration container */</span></span><br><span class="line">    snd_pcm_sw_params_get_boundary(sw_params, &amp;boundary);</span><br><span class="line">    <span class="comment">/* Set stop threshold inside a software configuration container */</span></span><br><span class="line">    <span class="comment">/* 这里的2倍可以通过writei的次数与发生underrun的次数来判断 */</span></span><br><span class="line">    snd_pcm_sw_params_set_stop_threshold(alsa_handle, sw_params, buf_size * <span class="number">2</span>);</span><br><span class="line">    <span class="comment">/* Set silence size inside a software configuration container */</span></span><br><span class="line">    snd_pcm_sw_params_set_silence_size(alsa_handle, sw_params, boundary);</span><br><span class="line">    <span class="comment">/* Write sw parameters to the driver */</span></span><br><span class="line">    snd_pcm_sw_params(alsa_handle, sw_params);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://blog.csdn.net/Guet_Kite/article/details/110818400">xrun排查</a></li>
<li><a href="https://cloud.tencent.com/developer/article/2206033">ALSA子系统 | ALSA Buffer的更新</a></li>
<li><a href="https://blog.csdn.net/whshiyun/article/details/80889838">高通msm8996平台的ASOC音频路径分析（基于androidN及linux3.1x）</a></li>
<li><a href="https://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html">ALSA project</a></li>
</ol>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Media</category>
      </categories>
      <tags>
        <tag>Audio</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake &amp;&amp; Makefile</title>
    <url>/2022/08/25/SoftwareDevelopment/Tools/cmake/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>官网 : <a href="https://cmake.org/cmake/help/v3.15/">https://cmake.org/cmake/help/v3.15/</a></p>
</blockquote>
<p>CMake是跨平台的 免费和开源软件，用于使用独立于编译器的方法构建自动化、测试、打包和安装软件。CMake 本身并不是一个构建系统；它生成另一个系统的构建文件。它支持目录层次结构和依赖于多个库的应用程序。它与原生构建环境结合使用，例如Make、Qt Creator、Ninja、Android Studio、Apple 的Xcode和Microsoft Visual Studio。（摘自Wiki）</p>
<h1 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><p>cmake要求最低版本(选择性添加)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.0</span><span class="number">.0</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>编译工程名</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">project(xxx)</span><br><span class="line"><span class="comment">//会自动创建两个变量，PROJECT_SOURCE_DIR和PROJECT_NAME</span></span><br><span class="line"><span class="comment">//${PROJECT_SOURCE_DIR}：本CMakeLists.txt所在的文件夹路径</span></span><br><span class="line"><span class="comment">//${PROJECT_NAME}：本CMakeLists.txt的project名称</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>给部分文件或路径组合起别名, 通过${变量}获取变量内容</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(变量 文件名/路径/...)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置c / c++ 编译编译参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> (CMAKE_C_FLAGS <span class="string">"-Wall -O2"</span>)</span><br><span class="line"><span class="built_in">set</span> (CMAKE_CXX_FLAGS <span class="string">"-Wall -std=C++11"</span>)</span><br><span class="line">add_compile_options( -Wall )				<span class="comment">//该命令译选项是针对所有编译器的(包括c和c++编译器)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>为当前路径以及子目录的源文件加入由-D引入的define flag</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_definitions(-DFOO -DDEBUG ...)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>对子文件夹进行cmake编译</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_subdirectory(子文件夹名) </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>打印信息</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">message() 			<span class="comment">//直接添加打印的内容和变量即可,不需要双引号</span></span><br><span class="line">message(<span class="string">"PROJECT_SOURCE_DIR = ${PROJECT_SOURCE_DIR}"</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>帮助信息 </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 查看cmake默认变量		cmake --help-variable-<span class="built_in">list</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>用法：根据某个宏确定编译内容。比较字符串，相同返回true</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CPU_PLATFORM_BIT STREQUAL <span class="string">"64"</span>)</span><br><span class="line">    add_library(mylib generic_64bit.c)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    add_library(mylib generic_32bit.c)</span><br><span class="line">endif()  </span><br></pre></td></tr></tbody></table></figure>

<h2 id="编译目标"><a href="#编译目标" class="headerlink" title="编译目标"></a>编译目标</h2><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_executable(目标文件名字xxx 源文件)</span><br><span class="line"><span class="comment">//example: add_executable(${PROJECT_NAME} example_person.cpp)</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="动态-x2F-静态库"><a href="#动态-x2F-静态库" class="headerlink" title="动态 / 静态库"></a>动态 / 静态库</h3><p>将指定的源文件生成链接文件，然后添加到工程中去</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">add_library(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">[EXCLUDE_FROM_ALL]</span><br><span class="line">[source1] [source2] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;name&gt;表示库文件的名字，该库文件会根据命令里列出的源文件来创建。生成的库自动补全,如libxxx.so </span></span><br><span class="line"><span class="comment">//STATIC、SHARED和MODULE的作用是指定生成的库文件的类型。STATIC库是目标文件的归档文件，在链接其它目标的时候使用。SHARED库会被	动态链接（动态链接库），在运行时会被加载。MODULE库是一种不会被链接到其它目标中的插件，但是可能会在运行时使用dlopen-系列的函数	。默认状态下，库文件将会在于源文件目录树的构建目录树的位置被创建，该命令也会在这里被调用。</span></span><br><span class="line"><span class="comment">//source1 source2分别表示各个源文件</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="链接-x2F-路径"><a href="#链接-x2F-路径" class="headerlink" title="链接/路径"></a>链接/路径</h2><h3 id="头文件路径"><a href="#头文件路径" class="headerlink" title="头文件路径"></a>头文件路径</h3><p>添加头文件的查找路径, 相当于命令行的  <em><strong>-l</strong></em> 参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">include_directories(../thirdparty/comm/include)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="链接库路径"><a href="#链接库路径" class="headerlink" title="链接库路径"></a>链接库路径</h3><p>添加需要链接的库文件目录, 相当于命令行 <em><strong>-L</strong></em> 参数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">link_directories(<span class="string">"/home/server/third/lib"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a>链接库</h3><p> 将目标文件与库文件进行链接</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">target_link_libraries(&lt;target&gt; [item1] [item2] [...] [[debug|optimized|general] &lt;item&gt;] ...)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//&lt;target&gt;是指通过add_executable()和add_library()指令生成已经创建的目标文件</span></span><br><span class="line"><span class="comment">//[item]表示库文件没有后缀的名字。默认情况下，库依赖项是传递的。当这个目标链接到另一个目标时，链接到这个目标的库也会出现在另一个目标的连接线上。这个传递的接口存储在interface_link_libraries的目标属性中，可以通过设置该属性直接重写传递接口。</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="安装（Install）"><a href="#安装（Install）" class="headerlink" title="安装（Install）"></a>安装（Install）</h2><ul>
<li>详情参考：<a href="https://cmake.org/cmake/help/v3.22/command/install.html">https://cmake.org/cmake/help/v3.22/command/install.html</a></li>
<li>作用：用于定义安装规则，安装内容包括可执行文件，静态库，动态库以及文件，目录，脚本等</li>
<li>使用方法：make install</li>
<li>目标安装路径：${CMAKE_INSTALL_PREFIX}指定，默认/usr/local</li>
</ul>
<h3 id="目标文件安装"><a href="#目标文件安装" class="headerlink" title="目标文件安装"></a>目标文件安装</h3><p>目标文件指的是我们通过 add_executable / add_library 得到的二进制文件或者库，只有这些文件才可以通过该命令装载到相应的位置</p>
<ul>
<li>可执行文件：RUNTIME</li>
<li>动态库：LIBRARY</li>
<li>静态库：ARCHIVE</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(TARGETS targets... [EXPORT &lt;export-name&gt;]</span><br><span class="line">        [RUNTIME_DEPENDENCIES args...|RUNTIME_DEPENDENCY_SET &lt;<span class="built_in">set</span>-name&gt;]</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|BUNDLE|</span><br><span class="line">          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]</span><br><span class="line">         [DESTINATION &lt;dir&gt;]</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">         [OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">         [NAMELINK_ONLY|NAMELINK_SKIP]</span><br><span class="line">        ] [...]</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line"><span class="comment">// example:</span></span><br><span class="line">install(TARGETS mybin mystaiclib mydynamiclib</span><br><span class="line">        RUNTIME DESTINATION bin</span><br><span class="line">        ARCHIVE DESTINATION lib</span><br><span class="line">        LIBRARY DESTINATION lib)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="普通文件安装"><a href="#普通文件安装" class="headerlink" title="普通文件安装"></a>普通文件安装</h3><p>普通文件即需要导出的头文件、依赖的三方库等等，该命令同时可以指定导出文件的权限（默认644）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(&lt;FILES|PROGRAMS&gt; files...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [PERMISSIONS permissions...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [RENAME &lt;name&gt;] [OPTIONAL] [EXCLUDE_FROM_ALL])</span><br><span class="line">        </span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">install(FILES mylib.h DESTINATION include)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="目录安装"><a href="#目录安装" class="headerlink" title="目录安装"></a>目录安装</h3><p>参数介绍：</p>
<ul>
<li>DIRECTORY：后面连接的是所在Source目录的相对路径（结尾是否是”/“对拷贝结果有一定影响）</li>
<li>PATTERN：使用正则表达式进行过滤</li>
<li>PERMISSIONS：指定PATTERN过滤后的文件权限。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">install(DIRECTORY dirs...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [FILE_PERMISSIONS permissions...]</span><br><span class="line">        [DIRECTORY_PERMISSIONS permissions...]</span><br><span class="line">        [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL]</span><br><span class="line">        [FILES_MATCHING]</span><br><span class="line">        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">         [EXCLUDE] [PERMISSIONS permissions...]] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">install(DIRECTORY src/ DESTINATION include/myproj  FILES_MATCHING PATTERN <span class="string">"*.h"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>Q: 编译参数添加了-lpthread 参数, 但是还是报undefined reference to `pthread_create’ </p>
<p>A : 需要使用target_link_libraries( target thread) 在这里链接thread库</p>
</li>
<li><p>Q: 如果在多级的目录下编译, 始终找不到问题报 undefine的问题 ?</p>
<p>A : 看一下是不是链接的库或目标文件格式不同, 一个c 一个c++ , 这样就会导致找不到符号错误</p>
</li>
<li><p>Q: undefined reference to `typeinfo for xxxBase_class’ ?</p>
<p>A: 基类的构造和析构函数需要加{ };  否则就会报这个问题</p>
</li>
</ol>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="PHYON"><a href="#PHYON" class="headerlink" title="PHYON"></a>PHYON</h3><p>.PHONY 在 makefile 中表示定义伪目标。所谓伪目标，就是它不代表一个真正的文件名，在执行 make 时可以指定这个目标来执行其所在规则定义的命令</p>
<h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><ul>
<li><p>=</p>
<p>最基本的赋值方式，语句与在文中的位置无关，系统自动推导将最终的赋值作为变量的值</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">str=123</span><br><span class="line"><span class="section">target:</span></span><br><span class="line">	@echo  <span class="variable">$(str)</span></span><br><span class="line">str=456</span><br><span class="line"><span class="comment"># 最终结果：456</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>：=</p>
<p>覆盖式赋值。如果变量在之前定义赋值过，本次的值将更新变量。该符号赋值只能推导该符号位置之前的值</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">str:=<span class="variable">$(str1)</span>123</span><br><span class="line">str1=456</span><br><span class="line"><span class="section">target:</span></span><br><span class="line">	@echo  <span class="variable">$(str)</span></span><br><span class="line"><span class="comment"># 最终结果：123（将str默认为空字符）</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>？=</p>
<p>如果当前变量在之前被赋值过，则此次赋值不执行，否则执行</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">str=123</span><br><span class="line">str?=456</span><br><span class="line"><span class="section">target:</span></span><br><span class="line">	@echo  <span class="variable">$(str)</span></span><br><span class="line"><span class="comment"># 最终结果 123</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>+=</p>
<p>追加赋值。旧值保持不变，将新值黏贴到旧值后面</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line">str=123</span><br><span class="line">str+=456</span><br><span class="line"><span class="section">target:</span></span><br><span class="line">	@echo  <span class="variable">$(str)</span></span><br><span class="line"><span class="comment"># 最终结果：123 456</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table>
<thead>
<tr>
<th>通配符</th>
<th>使用说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配0个或者是任意个字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td>[]</td>
<td>我们可以指定匹配的字符放在 “[]” 中</td>
</tr>
<tr>
<td>%</td>
<td>匹配任意个字符</td>
</tr>
</tbody></table>
<h2 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h2><table>
<thead>
<tr>
<th>自动化变量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>$@</td>
<td align="center">表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</td>
</tr>
<tr>
<td>$%</td>
<td align="center">当目标文件是一个静态库文件时，代表静态库的一个成员名。</td>
</tr>
<tr>
<td>$&lt;</td>
<td align="center">规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</td>
</tr>
<tr>
<td>$?</td>
<td align="center">所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</td>
</tr>
<tr>
<td>$^</td>
<td align="center">代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量  $ 只记录它的第一次引用的情况。就是说变量 $ 会去掉重复的依赖文件。</td>
</tr>
<tr>
<td>$+</td>
<td align="center">类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td>
</tr>
<tr>
<td>$*</td>
<td align="center">在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。</td>
</tr>
</tbody></table>
<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><h3 id="添加前缀"><a href="#添加前缀" class="headerlink" title="添加前缀"></a>添加前缀</h3><ul>
<li>函数名：addprefix( )</li>
<li>语法：$(addprefix PREFIX/,${NAME…})</li>
<li>函数功能：为“NAMES…”中的每一个文件名添加前缀“PREFIX”。参数“NAMES…”是空格分割的文件名序列，将“PREFIX”添加到此序列的每一个文件名之前。</li>
<li>返回值：以单空格分割的添加了前缀“PREFIX”的文件名序列。</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">$(addprefix src/,foo bar)</span><br><span class="line"><span class="comment">//返回值为“src/foo src/bar”</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ul>
<li>函数名：filter( )</li>
<li>语法：$(filter SUFFIX…,$(SOURCES))</li>
<li>作用：保留字串 “ $(SOURCES)” 中所有符合模式 “ SUFFIX ” 的单词</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sources := main.c AT.txt</span><br><span class="line">foo : $(sources)</span><br><span class="line">    cc $(filter %.c,%.s,$(sources)) -o foo</span><br></pre></td></tr></tbody></table></figure>



<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p>用于Makefile的Debug，打印分为三个等级：info、warning、error</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">$(info SRC = $(SRC))</span><br><span class="line">$(warning INC = $(INC))</span><br><span class="line"><span class="comment">//注意：执行到error会直接stop退出</span></span><br><span class="line">$(error INC = $(INC))</span><br></pre></td></tr></tbody></table></figure>



]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>编译规则</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2023/04/19/SoftwareDevelopment/Tools/docker/</url>
    <content><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看正在运行的容器</span></span><br><span class="line">sudo docker ps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有容器的ID</span></span><br><span class="line">sudo docker ps -aq</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker的镜像</span></span><br><span class="line">sudo docker images</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 CONTAINER ID或 NAMES 停止一个/多个容器(ID或NAME通过docker ps查看)</span></span><br><span class="line">sudo docker stop ID1 ID2 ID3</span><br><span class="line">sudo dokcer stop NAME1 NAME2 NAME3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止所有（正在运行/退出...）容器</span></span><br><span class="line">sudo docker stop $(sudo docker ps -aq)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 CONTAINER ID或 NAMES 取出一个/多个容器(ID或NAME通过docker ps查看)</span></span><br><span class="line">sudo docker rm ID1 ID2 ID3</span><br><span class="line">sudo dokcer rm NAME1 NAME2 NAME3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取出所有（正在运行/退出...）容器</span></span><br><span class="line">sudo docker rm $(sudo docker ps -aq)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="搭建Http服务器"><a href="#搭建Http服务器" class="headerlink" title="搭建Http服务器"></a>搭建Http服务器</h1><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载docker</span></span><br><span class="line">sudo apt-get install docker;</span><br><span class="line">sudo apt-get install docker.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 导入环境变量，最终作为服务器根目录的文件夹</span></span><br><span class="line">export DOCK_SERVER_PATH=/home/user/docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 创建容器，在创建容器的过程中，需要用到nginx的镜像文件，镜像文件的下载时自动完成的，如果没有指定的版本号，默认时最新版本。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">	-d表示  容器在后台运行（不产生输出到Shell）并显示容器的ID；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">	-p表示  映射容器的端口到宿主机的端口；</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	-v表示  将本地目录复制到服务器的目录，中间冒号隔开；映射的目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">	--<span class="built_in">rm</span>   容器停止后自动删除容器，例如通过docker container stop mynginx以后，容器就没有了；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">	-name  后面的mynginx就是自定义容器的名字</span></span><br><span class="line">sudo docker container run -d -p 80:80 --rm -v $DOCK_SERVER_PATH/:/usr/share/nginx/html --name mynginx nginx </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 进入容器</span></span><br><span class="line">sudo docker exec -it 576ff9b465d0 /bin/bash</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>XPath Helper安装及使用</title>
    <url>/2022/12/03/SoftwareDevelopment/Tools/xpath/</url>
    <content><![CDATA[<h1 id="引语"><a href="#引语" class="headerlink" title="引语"></a>引语</h1><p><em>在爬虫各个应用场景下，数据解析为其中重要的一环。而在数据解析中，BeautifulSoup、Xpath以及正则表达式等多种方法均为利器，在实际应用中根据不同场景选择不同的方法是最高效的，但是对各个方法的掌握程度要求很高。事实上，精通一种方法就已经满足需要了，再此基础之上，用辅助工具帮助理解提高效率。<br>本文将提供给“爬虫大师们”使用xpath方法的辅助工具XPath Helper插件。</em></p>
<h1 id="XPath-Helper简介"><a href="#XPath-Helper简介" class="headerlink" title="XPath Helper简介"></a>XPath Helper简介</h1><p>XPath即为XML路径语言，它是一种用来确定XML(标准通用标记语言的子集)文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。起初XPath的提出的初衷是将其作为一个通用的、介于XPointer与XSL间的语法模型。<br>XPath Helper是一款专用于chrome内核浏览器的实用型爬虫网页解析工具。XPath Helper插件功能强劲，支持进行XPath查询功能。XPath Help插件可以帮助用户在各类网站上通过按shift键选择想要查看的页面元素来提取查询其代码，同时还支持用户对查询出来的代码进行编辑，而编辑出的结果将立即显示在旁边的结果框中。</p>
<h1 id="XPath-Helper安装方法"><a href="#XPath-Helper安装方法" class="headerlink" title="XPath Helper安装方法"></a>XPath Helper安装方法</h1><ol>
<li>根据下面的链接将文件下载到本地。<br>链接：<a href="https://pan.baidu.com/s/18_Ws5qjHW9skhE1cb1jtYA">https://pan.baidu.com/s/18_Ws5qjHW9skhE1cb1jtYA</a><br>提取码：x0no</li>
<li>下载完成后，将文件的后缀名改为“.zip”，并进行解压。</li>
<li>解压之后有两个文件，将文件名为“2.0.2_0.crx”后缀名改为“.zip”，并对其进行二次解压。<br>==至此，所有弹出的提示语句全部选择  是==</li>
<li>二次解压完成，获得如下图所示的文件夹。如果红色框内文件夹如图所示，将“_metadata”改为“metadata”。如果默认就是“metadata”则不需要做任何操作。<br><img src="/images/SoftwareDevelopment/Tools/xpath-1.png"></li>
<li>进入自己对应的浏览器。在此，我以Google浏览器为基础操作。</li>
</ol>
<pre><code>**点击谷歌右上角的三个点的按钮
选择更多工具——&gt;选择扩展程序
进入，打开开发者模式，加载已解压的扩展程序，选择相应的已解压的文件，确认！
重启浏览器，确认可以正常使用**
</code></pre>
<ol start="6">
<li>如下图表示创建成功。<img src="/images/SoftwareDevelopment/Tools/xpath-2.png" alt="在这里插入图片描述"></li>
</ol>
<h1 id="XPath-Helper简单使用方法"><a href="#XPath-Helper简单使用方法" class="headerlink" title="XPath Helper简单使用方法"></a>XPath Helper简单使用方法</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>获取页面元素的xpath地址。</li>
<li>验证用户自己写的xpath地址是否正确。</li>
</ol>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>打开/关闭XPath Helper快捷键：Ctrl+Shift+x</li>
<li>打开Xpath Helper后的结果如下图所示<br> <img src="/images/SoftwareDevelopment/Tools/xpath-3.png" alt="在这里插入图片描述"></li>
<li>打开该插件的情况下，按住Shift在页面内进行移动，鼠标所经过之处会有黄色方框显示，下图为在CSDN首页，选中标题引导框的结果。左侧的query框内即为选中内容的xpath地址。<br><img src="/images/SoftwareDevelopment/Tools/xpath-4.png" alt="在这里插入图片描述"></li>
<li>如果作为验证的方法，在query框内写入自己写入xpath地址，看result框内是否是自己想要抓取的元素，如果不正确，可以实时在query内进行修改，直至获得正确xpath地址。<br><img src="/images/SoftwareDevelopment/Tools/xpath-5.png" alt="在这里插入图片描述"></li>
</ul>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>gdb &amp;&amp; coredump</title>
    <url>/2023/05/06/SoftwareDevelopment/Tools/gdb/</url>
    <content><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul>
<li>内存访问越界</li>
<li>多线程程序使用了线程不安全的函数</li>
<li>多线程读写的数据未加锁保护</li>
<li>非法指针</li>
<li>堆栈溢出</li>
</ul>
<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><ol>
<li><p>通过添加”-g”的参数对程序文件进行编译</p>
<blockquote>
<p>回溯跟踪指的是监视程序在运行过程中的函数调用历史，堆栈转储则是一种以原始的十六进制格式保存程序执行环境的方法.</p>
</blockquote>
<ul>
<li>-g1		不包含局部变量和与行号有关的调试信息，只能用于回溯跟踪和堆栈转储之用。</li>
<li>-g2         此时调试信息包括扩展的符号表、行号、局部或外部变量信息**(默认level)**</li>
<li>-g3         包含级别2中的调试信息和源代码中定义的宏</li>
</ul>
</li>
<li><p>配置设备端的core文件大小<br>   ulimit -a        查看当前的各种用户进程限制<br>   ulimit -c unlimited     开启Coredump,并且不限制文件的大小</p>
</li>
<li><p>执行可执行程序, 生成core文件</p>
</li>
<li><p>将core文件取出, 执行 “gdb  ./test  core”进行分析</p>
</li>
</ol>
<h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>gdb 进入环境</li>
<li>file a.out(可执行文件名)    加载可执行文件</li>
<li>set args argv[1] argv[2] ……	加载a.out所需要的参数</li>
</ol>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>简写</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>run</td>
<td></td>
<td>重新开始运行文件</td>
</tr>
<tr>
<td>start</td>
<td></td>
<td>单步执行,运行程序,停在第一执行语句</td>
</tr>
<tr>
<td>list</td>
<td>l</td>
<td>查看源代码</td>
</tr>
<tr>
<td>set</td>
<td></td>
<td>设置变量的值</td>
</tr>
<tr>
<td>next</td>
<td>n</td>
<td>单步调试( 逐过程, 函数直接执行)</td>
</tr>
<tr>
<td>step</td>
<td>s</td>
<td>单步调试( 逐语句, 跳入自定义函数内部执行)</td>
</tr>
<tr>
<td>backtrace</td>
<td>bt</td>
<td>查看函数的调用栈帧和层级关系</td>
</tr>
<tr>
<td>frame</td>
<td>f</td>
<td>切换栈帧, 直接使用frame + &lt;bt前面的数字&gt;</td>
</tr>
<tr>
<td>info</td>
<td>i</td>
<td>查看函数内部局部变量的数值</td>
</tr>
<tr>
<td>finish</td>
<td></td>
<td>结束当前函数, 返回到函数调用的点</td>
</tr>
<tr>
<td>continue</td>
<td>c</td>
<td>继续运行</td>
</tr>
<tr>
<td>print</td>
<td>p</td>
<td>打印值及地址</td>
</tr>
<tr>
<td>break</td>
<td>b</td>
<td>设置断点</td>
</tr>
<tr>
<td>disable</td>
<td></td>
<td>失能断点</td>
</tr>
<tr>
<td>delete</td>
<td>d</td>
<td>删除断点</td>
</tr>
<tr>
<td>watch</td>
<td>w</td>
<td>设置观察点</td>
</tr>
<tr>
<td>quit</td>
<td>q</td>
<td>退出gdb</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令</th>
<th>简写</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>info args</td>
<td></td>
<td>查看参数</td>
</tr>
<tr>
<td>info locals</td>
<td></td>
<td>查看本地变量</td>
</tr>
<tr>
<td>info sharedlibrary</td>
<td></td>
<td>显示共享链接库的信息</td>
</tr>
<tr>
<td>info breakpoints</td>
<td>info b</td>
<td>显示断点</td>
</tr>
</tbody></table>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：没有生成core文件?<br>A：kernel没有选择coredump功能，make kernel-menuconfig配置选项中选择coredump(第一个即可)</p>
</li>
<li><p>Q：gdb无法显示so动态库的信息或者显示信息有误时</p>
<p>A：通常是由于库搜索路径错误导致的 ;  使用set sysroot / , 然后再次tb可以看到库中的函数</p>
</li>
<li><p>Q：无法清屏？</p>
<p>A：gdb中没有专门的清屏命令, 但是可以执行shell的命令进行清屏（shell clear）</p>
</li>
</ol>
<h1 id="拓展资料"><a href="#拓展资料" class="headerlink" title="拓展资料"></a>拓展资料</h1><ul>
<li><a href="https://blog.csdn.net/rheostat/article/details/8523598">在C/C++程序中打印当前函数调用栈</a></li>
</ul>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>硬件随机数测试方法</title>
    <url>/2022/11/26/SoftwareDevelopment/ThirdParty/DTRNG_Test/</url>
    <content><![CDATA[<h1 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h1><p>配置芯片DTRNG硬件单元寄存器生成一定数量的数据，保存成二进制文件，使用NIST测试套件进行验证得到是否随机的结论。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol>
<li>DTRNG：Digital True Random Number Generator，数字真随机数发生器</li>
<li>NIST：National Institude of Standards and Technology，国家标准技术研究所</li>
<li>NIST-sts (Statistical Test Suite)，统计测试套件：</li>
</ol>
<ul>
<li><p>源码链接：<a href="https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software%EF%BC%88Download%E5%8D%B3%E5%8F%AF%EF%BC%89">https://csrc.nist.gov/projects/random-bit-generation/documentation-and-software（Download即可）</a></p>
</li>
<li><p>文档链接：<a href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf">https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf</a></p>
</li>
<li><p>windows安装</p>
<p>官网的软件包是Linux系统下开发的，Windows系统需要先下一个<a href="https://cygwin.com/install.html">cygwin软件</a>来辅助使用</p>
<p>可以参考博客：<a href="https://blog.csdn.net/weixin_39928192/article/details/89256576">https://blog.csdn.net/weixin_39928192/article/details/89256576</a>?</p>
</li>
<li><p>Linux安装</p>
<p>进入工程文件夹sts-2.1.2直接make即可，得到 assess 可执行程序</p>
</li>
</ul>
<h1 id="随机测试项"><a href="#随机测试项" class="headerlink" title="随机测试项"></a><strong>随机测试项</strong></h1><p>每一个测试项的解读：<a href="https://blog.csdn.net/lafu5137/article/details/79593845">https://blog.csdn.net/lafu5137/article/details/79593845</a></p>
<ol>
<li>The Frequency (Monobit) Test，频率检测。该检验主要是看0和1在整个序列中所占的比例（基础检测）</li>
<li>Frequency Test within a Block，块内频率检测</li>
<li>The Runs Test，游程检测。游程指的是一个没有间断的相同数序列</li>
<li>Tests for the Longest-Run-of-Ones in a Block，块内最长游程检测</li>
<li>The Binary Matrix Rank Test，二元矩阵秩检测</li>
<li>The Discrete Fourier Transform (Spectral) Test，离散傅立叶变换检测</li>
<li>The Non-overlapping Template Matching Test，非重叠模块匹配检测</li>
<li>The Overlapping Template Matching Test，重叠模块匹配检测</li>
<li>Maurer’s “Universal Statistical” Test，Maurer的通用检测统计</li>
<li>The Linear Complexity Test，线性复杂度检测</li>
<li>The Serial Test，序列检测</li>
<li>The Approximate Entropy Test，近似熵检测</li>
<li>The Cumulative Sums (Cusums) Test，累加和检验</li>
<li>The Random Excursions Test，随机游动检测</li>
<li>The Random Excursions Variant Test.，随机游动状态频率检测</li>
</ol>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h1><p>该流程是基于Linux系统进行操作的，使用的数据：sts-2.1.2/data/data.pi</p>
<ol>
<li>启动程序。**./assess ，**stream length译为流的长度。</li>
<li>输入待测文件路径。根据菜单，键入0并输入文件的路径（相对路径和绝对路径都可以）</li>
<li>选择测试项。键入1表示应用全部测试项；输入0表示部分测试项，随后输入一个16位二进制序列选择测试项。</li>
<li>参数调整。可以根据菜单及选项微调部分参数的值，基本选择默认即可。</li>
<li>输入比特流的个数。表示有多少个stream</li>
<li>选择输入文件类型。该类型对应于第二步输入文件的类型，两种类型供选择：ASCII / Binary</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h1><ol>
<li>每一项测试所需的序列的stream length是不一样的，经测试如果选择全部测试项至少保证stream length &gt;= 10000bits，否则会出现错误。而如果单项测试查阅文档满足参数范围即可，比如选择1频率测试只需保证stream length&gt;100bits即可。</li>
<li>必须保证：流长度 × 流个数 &lt;= 文件大小</li>
<li>如果输入的文件是ACSII格式的话，启动程序时所输入的bitstream的单位是byte；而输入文件为Binary的话bitstream单位为bit。例如：第一步键入./assess 10000；第五步键入10 ；此时第六步选择0代表输入了10000×10×8（bits），输入1代表输入了10000×10（bits）。实际输入过程是要反着理解，先确定输入文件类型，进而确认bitstream、number，保证第一个公式</li>
</ol>
<h1 id="检测标准"><a href="#检测标准" class="headerlink" title="检测标准"></a><strong>检测标准</strong></h1><p>测试成功结束则会在 <strong>sts-2.1.2/experiments/AlgorithmTesting/</strong> 目录下生成测试报告，而针对每一个项目的结果会在其子目录下生成测试报告。</p>
<p>最终测试报告finalAnalysisReport.txt中P-value都大于等于0.01即可认为通过了NIST检验，这个数据越大越好。如果该数据为0，可能是由于数据量的问题则可以去每个子项目结果中去查看，会有SUCCESS字样！</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a><strong>Q&amp;A</strong></h1><ol>
<li><p>Q：Segment fault</p>
<p>A： bitstream*num &gt; fileSize即流的长度乘以流的个数超过了文件的大小通常会有error信息</p>
</li>
<li><p>Q：igamc: UNDERFLOW？</p>
<p>A：数据下溢，可能是数据格式的原因或者数据过于不随机</p>
</li>
<li><p>Q：P-value全部是0？</p>
<p>A：导致 <strong>igamc: UNDERFLOW</strong> 的原因都是有可能的，同时也可能是因为数据量不够所导致的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>ThirdParty</category>
      </categories>
  </entry>
  <entry>
    <title>LwIP+websocket</title>
    <url>/2023/04/19/SoftwareDevelopment/ThirdParty/lwip+websocket/</url>
    <content><![CDATA[<h1 id="WebSocket流程"><a href="#WebSocket流程" class="headerlink" title="WebSocket流程"></a>WebSocket流程</h1><blockquote>
<p>websocket <a href="https://github.com/dhbaird/easywsclient">https://github.com/dhbaird/easywsclient</a></p>
</blockquote>
<h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><ol>
<li>socket()</li>
<li>bind()</li>
<li>listen()</li>
<li>accept()</li>
<li>recv()</li>
</ol>
<h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><ol>
<li>socket()</li>
<li>connect()</li>
<li>send()</li>
</ol>
<h1 id="Lwip-API"><a href="#Lwip-API" class="headerlink" title="Lwip-API"></a>Lwip-API</h1><h2 id="lwip-socket"><a href="#lwip-socket" class="headerlink" title="lwip_socket"></a>lwip_socket</h2><ul>
<li><p>功能：用于根据指定的地址族、数据类型和协议来分配一个套接口的描述字及其所用的资源的函数</p>
</li>
<li><p>函数原型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> socket(domain,type,protocol)	  lwip_socket(domain,type,protocol)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>参数选项</p>
<ul>
<li><p>domain：地址族AF_INET（IP_V4）、AF_INET6(IP_V6)</p>
</li>
<li><p>type：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_STREAM     1 <span class="comment">//流式套接字提供可靠的、面向连接的通信流；它使用TCP 协议，从而保证了数据传输的正确性和顺序性。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_DGRAM      2<span class="comment">// 数据报套接字定义了一种无连接的服 ，数据通过相互独立的报文进行传输，是无序的，并且不保证是可靠、无差错的。它使用数据报协议UDP。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCK_RAW        3<span class="comment">// 原始套接字允许对底层协议如IP或ICMP进行直接访问，功能强大但使用较为不便，主要用于一些协议的开发。</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>ptotocol</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IP      0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_ICMP    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_TCP     6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_UDP     17</span></span><br><span class="line"><span class="comment">// 一般自动设置为0, 系统自动设置合适的协议</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="lwip-connect"><a href="#lwip-connect" class="headerlink" title="lwip_connect"></a>lwip_connect</h2><ul>
<li><p>函数功能：用于建立与指定socket的连接。一般用于客户端，</p>
</li>
<li><p>函数原型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> connect (s,	name, namelen)	   lwip_connect(s,name,namelen)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>s ：socket()返回文件描述符代表的套接字</li>
<li>const struct sockaddr *name：存放了服务端用于通信的地址和端口。</li>
<li>socklen_t namelen：name参数结构体的长度。</li>
</ul>
</li>
</ul>
<h2 id="lwip-setsockopt"><a href="#lwip-setsockopt" class="headerlink" title="lwip_setsockopt"></a>lwip_setsockopt</h2><ul>
<li><p>功能：设置与某个套接字关联的选项，当操作套接字选项时，选项位于的层和选项的名称必须给出</p>
</li>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level,<span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>参数选项</p>
<ul>
<li><p>sock：将要被设置选项的套接字</p>
</li>
<li><p>optname：需要访问的选项名</p>
</li>
<li><p>optval：指向包含新选项值得缓冲</p>
</li>
<li><p>optlen：现选项的长度</p>
</li>
<li><p>level：参数（level）详细说明：level是指定控制套接字的层次，可以取如下三种值</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">选项名称(optname)　　　说明　　　　　          　　　　数据类型</span><br><span class="line">========================================================================</span><br><span class="line">SO_BROADCAST　　　　　 允许发送广播数据　　　　　　　　 <span class="type">int</span></span><br><span class="line">SO_DEBUG　　　　　　　  允许调试　　　　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_DONTROUTE　　　　　　不查找　　　　　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_ERROR　　　　　　　　获得套接字错误　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_KEEPALIVE　　　　　　保持连接　　　　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_LINGER　　　　　　　 延迟关闭连接　　　　　　　　　　<span class="keyword">struct</span> linger</span><br><span class="line">SO_OOBINLINE　　　　　　带外数据放入正常数据流　　　　　<span class="type">int</span></span><br><span class="line">SO_RCVBUF　　　　　　　 接收缓冲区大小　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_SNDBUF　　　　　　　 发送缓冲区大小　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_RCVLOWAT　　　　　　 接收缓冲区下限　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_SNDLOWAT　　　　　　 发送缓冲区下限　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_RCVTIMEO　　　　　　 接收超时　　　　　　　　　　　　<span class="keyword">struct</span> timeval</span><br><span class="line">SO_SNDTIMEO　　　　　　 发送超时　　　　　　　　　　　　<span class="keyword">struct</span> timeval</span><br><span class="line">SO_REUSERADDR　　　　　 允许重用本地地址和端口　　　　　<span class="type">int</span></span><br><span class="line">SO_TYPE　　　　　　　　 获得套接字类型　　　　　　　　　<span class="type">int</span></span><br><span class="line">SO_BSDCOMPAT　　　　　　与BSD系统兼容　　　　　　　　　 <span class="type">int</span></span><br><span class="line">========================================================================</span><br><span class="line"><span class="comment">// SOL_SOCKET：通用套接字选项</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">选项名称(optname)　　　说明　　　　　          　　　　数据类型</span><br><span class="line">========================================================================</span><br><span class="line">IP_HDRINCL　　　　　　　在数据包中包含IP首部　　　　　　<span class="type">int</span></span><br><span class="line">IP_OPTINOS　　　　　　　IP首部选项　　　　　　　　　　　<span class="type">int</span></span><br><span class="line">IP_TOS　　　　　　　　　类型</span><br><span class="line">IP_TTL　　　　　　　　　生存时间　　　　　　　　　　　　 <span class="type">int</span></span><br><span class="line">========================================================================</span><br><span class="line"><span class="comment">//IPPROTO_IP：IP选项</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">选项名称(optname)　　　说明　　　　　          　　　　数据类型</span><br><span class="line">========================================================================</span><br><span class="line">TCP_MAXSEG　　　　　　TCP最大数据段的大小　　　　　　　 <span class="type">int</span></span><br><span class="line">TCP_NODELAY　　　　　 不使用Nagle算法　　　　　　　　　 <span class="type">int</span></span><br><span class="line">========================================================================</span><br><span class="line"><span class="comment">// IPPROTO_TCP：TCP选项  </span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="lwip-fcntl"><a href="#lwip-fcntl" class="headerlink" title="lwip_fcntl"></a>lwip_fcntl</h2><ul>
<li>功能：fcntl 的最小实现。 目前仅实现了命令 F_GETFL 和 F_SETFL。 只有标志 O_NONBLOCK 被实现。</li>
</ul>
<h2 id="lwip-send-x2F-lwip-sendto-x2F-lwip-write"><a href="#lwip-send-x2F-lwip-sendto-x2F-lwip-write" class="headerlink" title="lwip_send / lwip_sendto / lwip_write"></a>lwip_send / lwip_sendto / lwip_write</h2><ul>
<li><p>功能：发送数据</p>
</li>
<li><p>区别：</p>
<ul>
<li>lwip_send：核心， 最终的调用</li>
<li>lwip_write：直接调用lwip_send</li>
<li>Lwip_sendto：相较于lwip_to多了远程主机的ip地址和端口号相关的参数，处理中多了netconn_connect的调用（lwip_connect + lwip_send）</li>
</ul>
</li>
<li><p>函数原型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sendmsg	(s,	message，flags )	   lwip_sendmsg(s,message,flags)</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="lwip-select"><a href="#lwip-select" class="headerlink" title="lwip_select"></a>lwip_select</h2><ul>
<li><p>功能：用于I/O多路复用的API，使用select可以同时监听多个socket的状态，以便读写数据</p>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> select	(maxfdp1,readset,writeset,exceptset,timeout)</span></span><br><span class="line">		lwip_select(maxfdp1,readset,writeset,exceptset,timeout)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>参数含义</p>
<ul>
<li><p>maxfdp1：要检查的最大文件描述符的数目，一般是最大dp+1</p>
</li>
<li><p>readset/writeset/exceptset：</p>
<p>fd_set类型，指向需要监听的可读、可写和异常事件的文件描述符集合</p>
</li>
</ul>
</li>
</ul>
<h2 id="lwip-recv"><a href="#lwip-recv" class="headerlink" title="lwip_recv"></a>lwip_recv</h2><ul>
<li><p>函数功能：接受数据</p>
</li>
<li><p>函数原型</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> recv(s,	mem,len,flags)	   lwip_recv(s,mem,len,flags)</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：调用lwip_send / lwip_recv时出现WSAEWOULDBLOCK / WSAEINPROGRESS</p>
<p>A：本质上以上两个错误码不是错误，而是一种警告，接收方告诉发送方它现在处于busy状态</p>
<p>​		WSAEWOULDBLOCK的意思是output buffer已经满了，无法再写入数据。按照网上博主的说法，在绝大多数情况下其实不会出现buffer满的情况，而是		处于busy状态。我理解的这与overrun的意思差不多，只不过这里不会对数据正确性、完整性造成影响，接收方告诉我它的缓冲区满了或者数据已经处理		不过来了，它不再接受数据了，所以给我们一个异常。</p>
<p>​		WSAEINPROGRESS:一个阻塞的WINDOWS套接口调用正在运行中。</p>
<p>解决：当出现 WSAEWOULDBLOCK 异常后直到空出 Output Buffer 时，系统会发送一个 FD_WRITE 给发送方。我们完全可以在等收到 FD_WRITE 消息后再重新发送从出现异常开始的数据包即可（该包需要全部重新发送）。</p>
<blockquote>
<p><a href="https://bbs.csdn.net/topics/70198557">参考链接</a></p>
</blockquote>
</li>
<li></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://blog.csdn.net/wwwyue1985/article/details/113789192">Lwip之API接口与原理</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_39854159/article/details/120693512">LWIP学习之Socket （API篇）</a></p>
</li>
<li><p><a href="https://www.nongnu.org/lwip/2_0_x/group__socket.html#gae3d13671f622e17c17317c9a16dfd0ee">Lwip API</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>ThirdParty</category>
      </categories>
      <tags>
        <tag>lwip</tag>
      </tags>
  </entry>
  <entry>
    <title>Mplayer编译及使用说明</title>
    <url>/2023/03/07/SoftwareDevelopment/ThirdParty/mplayer/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>官网：<a href="http://www.mplayerhq.hu/design7/news.html">http://www.mplayerhq.hu/design7/news.html</a></p>
</blockquote>
<p><strong>MPlayer</strong>是一款开源的多媒体播放器，以GNU通用公共许可证发布。此款软件可在各主流操作系统使用，例如Linux和其他类Unix操作系统、微软Windows系统及苹果电脑的Mac OS 系统。MPlayer是建基于命令行界面，在各操作系统可选择安装不同的图形界面。</p>
<h1 id="ubuntu下编译过程"><a href="#ubuntu下编译过程" class="headerlink" title="ubuntu下编译过程"></a>ubuntu下编译过程</h1><ol>
<li><p>下载并解压源码文件<a href="http://www.mplayerhq.hu/design7/news.html">click here</a></p>
</li>
<li><p>生成配置文件（目前直接走默认参数选项）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接执行./configure错误，--yasm=<span class="string">''</span>参数是根据提示没有找到yasm，可通过该命令直接执行</span></span><br><span class="line">./configure --yasm=''</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make完成既可看到文件夹下存在mplayer可执行文件</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>安装</p>
</li>
</ol>
   <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将mplayer及依赖的库文件进行安装, 不安装也可以进行使用</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure>

<h1 id="源码文件"><a href="#源码文件" class="headerlink" title="源码文件"></a>源码文件</h1><ul>
<li><p>vd__*	</p>
<p><strong>video decode</strong>  与解码相关的,解码器只是负责把解码完成的帧传输给vo，如何显示是vo的函数实现;</p>
</li>
<li><p>vf__*  </p>
<p><strong>video filter</strong>  所有过滤器的定义，当命令行输入-vf的参数，规则会去相应的filter函数解析。例如： -vf rotate=2,vf_rotate.c的函数进行进行rotate函数的解析。</p>
</li>
<li><p>vo_*</p>
<p><strong>video output</strong>   输出的函数定义，每一个函数对应实现一种或几种的功能。例如：vo_md5sum.c得到md5的一个值</p>
</li>
<li><p>DOCS 文档</p>
</li>
</ul>
<h1 id="mplayer流程"><a href="#mplayer流程" class="headerlink" title="mplayer流程"></a>mplayer流程</h1><ol>
<li><p>调用 AddExcept（）注册异常处理函数</p>
</li>
<li><p>initmplayer();   //初始化，创建快进和暂停的信号量</p>
</li>
<li><p>InitTimer();初始化计时器</p>
</li>
<li><p>mp_msg_init();初始化消息系统</p>
</li>
<li><p>set_path_env();设置路径、环境</p>
</li>
<li><p>ipu_image_start();ipu初始化</p>
</li>
<li><p>mplayer_showmode(1);设置显示模式</p>
</li>
<li><p>parse_codec_cfg(NULL);解析codec配置寄存器</p>
</li>
<li><p>打开数据流</p>
</li>
<li><p>分析播放树</p>
</li>
<li><p>添加播放树列表</p>
</li>
<li><p>初始化预填充缓存</p>
</li>
<li><p>打开播放的文件</p>
</li>
<li><p>创建buffer</p>
</li>
<li><p>打开数据流</p>
</li>
<li><p>检测数据流类型（音频格式和视频格式）</p>
</li>
<li><p>分析音频流视频流的信息（原始视频尺寸、分辨率、帧频率、码流大小）</p>
</li>
<li><p>启动相应的分离器</p>
</li>
<li><p>分析剪辑信息</p>
</li>
<li><p>初始化codec（多媒体数字信号编解码器）</p>
</li>
<li><p>选择打开相应的视频解码器</p>
</li>
<li><p>初始化视频解码器，分析视频流信息</p>
</li>
<li><p>选择打开相应的音频解码器</p>
</li>
<li><p>初始化音频解码器、PCM，分析音频信息</p>
</li>
<li><p>同步音频视频输出</p>
</li>
<li><p>开始播放</p>
</li>
</ol>
<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><ul>
<li><p>-list-options 打 印 所有 可 用 的 选 项</p>
</li>
<li><p>-vf   选择视频相关参数</p>
<ul>
<li><p>format 选择解码之后的格式输出</p>
</li>
<li><ul>
<li>NV12  /  NV21</li>
<li>BGRA</li>
<li>RGB</li>
</ul>
</li>
<li><p>rotate  选择旋转的角度输出</p>
</li>
<li><ul>
<li>1  顺时针旋转90</li>
<li>2  顺时针旋转270</li>
<li>4  旋转0度</li>
</ul>
</li>
</ul>
</li>
<li><p>-slave  从模式，mplayer会从标准输入读一个换行符（/n）分隔开的命令。</p>
</li>
<li><p>-quiet   去除杂项信息, 使 控制屏幕输出简略；尤其是阻止显示状态行（即 A: 0.7 V: 0.6 A-V: 0.068 …）</p>
</li>
<li><p>-speed &lt;0.01 - 100&gt;选择播放速率</p>
</li>
<li><p>-vo 指定视频输出驱动的优先级列表</p>
</li>
<li><p>-vc  选择编解码器，  -vc help 可以列出所有视频解码器，其中中括号里面是.dll的是我们无法使用的</p>
</li>
<li><ul>
<li>ffm264   264软解码</li>
<li>ffh264v4l2m2m  264硬解码</li>
</ul>
</li>
<li><p>-ao 指定音频输出驱动的优先级列表</p>
</li>
<li><p>-ac 指定音频解码器优先级列表</p>
</li>
<li><p>-zoom -x 800 -y 400 指令播放窗体的大小</p>
</li>
<li><p>-input  输入</p>
</li>
<li><ul>
<li>cmdlist  列出所有可绑定按键的命令</li>
<li>file 命令输入通道。制定输入fifo的名字，写入控制命令，与slave参数一起使用</li>
</ul>
</li>
</ul>
<h1 id="slave模式"><a href="#slave模式" class="headerlink" title="slave模式"></a>slave模式</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>MPlayer为后台运行其他程序，不再截获键盘事件，MPlayer会从标准输入读一个换行符（/n）分隔开的命令。</p>
<p>大多数slave模式命令相当于命令行选项。</p>
<ul>
<li><p>命令行播放通过 -input file= 参数监听某个管道</p>
</li>
<li><p>另起一个线程，创建同名管道并输入6.2所示控制参数即可达到控制mplayer的效果</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkfifo</span> /tmp/fifofile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mplayer -slave -input file=/tmp/fifofile &lt;movie&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>具体使用说明可以参考源文件下DOCS/tech/slave.txt</p>
<h2 id="控制参数"><a href="#控制参数" class="headerlink" title="控制参数"></a>控制参数</h2><p><strong>mplayer -input cmdlist</strong> 命令可以打印出一份可以输入清单</p>
<ul>
<li>get_file_name  打印当前文件名</li>
<li>get_percent_pos   打印出文件中的当前位置为整数百分比(0-100）</li>
<li>get_time_length   打印当前文件长度用秒表示</li>
<li>get_time_pos   打印文件当前位置用秒表示</li>
<li>seek  定位电影的某些地方<ul>
<li>0 是一个相对定位+/- （默认值）</li>
<li>1 是定位％在电影里</li>
<li>2 是寻求一个绝对位置的秒。</li>
</ul>
</li>
<li>quit   推出mplayer进程</li>
<li>stop   停止播放</li>
<li>exit   从OSD菜单退出控制台。不像’quit’，不退出MPlayer的</li>
</ul>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>针对slave使用方法，简单写了几个函数作为参考示例</p>
<p>github仓库（mplayerInterface文件夹）：<a href="https://github.com/yangLieee/codebackup.git">click here</a></p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>MPlayer interrupted by signal 13 in module: key_events ？</p>
<p>因为Mplayer是通过换行符(“\n”)来分隔不同的命令，所以我们在编程中不管是写入到管道文件还是写入到QT的进程中在命令后面一定要加入换行符(“\n”),这样Mplayer才能辨别。</p>
</li>
<li><p>只有在串口有输出，adb shell没有输出 </p>
<p>错误信息：Cannot find HOME directory.</p>
<p>解决方法：setenv(“HOME”，“/”，“1”)</p>
</li>
<li><p>在vo部分添加 rotate功能 之后, 只有一个方向可以正常显示?</p>
</li>
</ol>
<p>   对于nv12格式的图片和数据, uv_stride和stride这两个参数影响LCD最终显示的效果. 在旋转之后需要将对应的宽高对应到相应的stride中, 最终可以正常显示</p>
<ol start="4">
<li><p>mpi被mplayer用来存储解码之后的图像（mp_image.h中定义），得到mpi之后，vf被调用，整个filter链上钉filter都被调用了一遍包括最后的vo; 在vo的put_image里把图像输出到显示器上。这个时候需要考虑图像的存储方法，即用哪种颜色空间。</p>
</li>
<li><p><a href="https://blog.csdn.net/willand1981/article/details/5783107">https://blog.csdn.net/willand1981/article/details/5783107</a></p>
</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><a href="http://www.mplayerhq.hu/DOCS/man/zh_CN/mplayer.1.html">Mplayer和mencoder使用文档简介</a></p>
</li>
<li><p><a href="http://www.mplayerhq.hu/DOCS/HTML/zh_CN/index.html">Mplayer使用文档</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qizheguang/article/details/50552810">mplayer流程及相关函数说明</a></p>
</li>
<li><p><a href="https://blog.csdn.net/liangkaiming/article/details/5790893">slave 模式文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>ThirdParty</category>
      </categories>
  </entry>
  <entry>
    <title>LwIP协议栈</title>
    <url>/2022/11/30/SoftwareDevelopment/ThirdParty/lwip/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>Lwip官网：<a href="https://savannah.nongnu.org/projects/lwip/">https://savannah.nongnu.org/projects/lwip/</a></p>
</blockquote>
<p>LWIP（light weight ip）轻型IP协议，有无操作系统的支持都可以运行。LwIP实现的重点是在保持TCP协议主要功能的基础上减少对RAM 的占用，它只需十几KB的RAM和40K左右的ROM就可以运行，这使LwIP协议栈适合在低端的嵌入式系统中使用。</p>
<p>LWIP支持的协议种类：</p>
<ul>
<li>DNS，域名解析；</li>
<li>SNMP，简单网络管理协议；</li>
<li>DHCP，动态主机配置协议；</li>
<li>UDP 协议，用户数据报协议；</li>
<li>TCP 协议，支持 TCP 拥塞控制， RTT 估计，快速恢复与重传等；</li>
<li>IP 协议，包括 IPv4 和 IPv6，支持 IP 分片与重装，支持多网络接口下数据转发；</li>
<li>AUTOIP， IP 地址自动配置；</li>
<li>ICMP 协议，用于网络调试与维护；</li>
<li>IGMP 协议，用于网络组管理，可以实现多播数据的接收；</li>
<li>ARP 协议，以太网地址解析协议；</li>
<li>PPP，点对点协议，支持 PPPoE</li>
</ul>
<h1 id="LwIP架构"><a href="#LwIP架构" class="headerlink" title="LwIP架构"></a>LwIP架构</h1><p>LwIP 符合 TCP/IP 模型架构，规定了数据的格式、传输、路由和接收，以实现端到端的通信。 此模型包括四个抽象层，用于根据涉及的网络范围，对所有相关协议排序。这几 层从低到高依次为：</p>
<ul>
<li><p>链路层包含了局域网的单网段 （链路）通信技术</p>
</li>
<li><p>网际层 （IP）将独立的网络连接起来，建立互联</p>
</li>
<li><p>传输层处理主机端口到主机端口的通信</p>
</li>
<li><p>应用层在实现多个应用进程相互通信的同时，完成应用所需的服务 （例如：数据处理）</p>
<p><img src="/images/SoftwareDevelopment/ThirdParty/lwip.png"></p>
</li>
</ul>
<h1 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h1><h2 id="RAW-API"><a href="#RAW-API" class="headerlink" title="RAW API"></a>RAW API</h2><p>内核回调型API，当初始化应用时，用户需要为不同内核事件注册所需的回调函数 （例如 TCP_Sent、 TCP_error…）。当相应事件发生时， LwIP 会自发地调用相关的回调函数。<em>没有操作系统支持中，只能使用RAW API开发</em></p>
<table>
<thead>
<tr>
<th></th>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TCP连接建立</td>
<td>tcp_new</td>
<td>建立一个新的 TCP PCB （协议控制块）。</td>
</tr>
<tr>
<td></td>
<td>tcp_bind</td>
<td>将 TCP PCB 绑定到本地 IP 地址和端口。</td>
</tr>
<tr>
<td></td>
<td>tcp_listen</td>
<td>启动 TCP PCB 上的监听进程。</td>
</tr>
<tr>
<td></td>
<td>tcp_accept</td>
<td>注册回调函数，连接成功建立后调用。</td>
</tr>
<tr>
<td></td>
<td>tcp_connect</td>
<td>发送连接建立请求。</td>
</tr>
<tr>
<td>发送TCP数据</td>
<td>tcp_write</td>
<td>将发送数据写入 TCP 缓冲区中。</td>
</tr>
<tr>
<td></td>
<td>tcp_sent</td>
<td>注册回调函数，数据发送成功后调用。</td>
</tr>
<tr>
<td></td>
<td>tcp_output</td>
<td>发送 TCP 缓冲区中的数据</td>
</tr>
<tr>
<td>接收TCP数据</td>
<td>tcp_recv</td>
<td>注册回调函数， TCP 接收到数据后调用</td>
</tr>
<tr>
<td>应用轮询</td>
<td>tcp_poll</td>
<td>注册回调函数，TCP慢定时器调用（500ms一次）。</td>
</tr>
<tr>
<td>关闭并终止连接</td>
<td>tcp_close</td>
<td>主动关闭。</td>
</tr>
<tr>
<td></td>
<td>tcp_err</td>
<td>注册回调函数，出错时调用。</td>
</tr>
<tr>
<td></td>
<td>tcp_abort</td>
<td>中止连接，向远程主机发送 RST。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>udp_new</td>
<td>创建新的 UDP PCB。</td>
</tr>
<tr>
<td></td>
<td>udp_remove</td>
<td>移除 UDP PCB 并释放相关资源。</td>
</tr>
<tr>
<td></td>
<td>udp_bind</td>
<td>将 UDP PCB 与本地 IP 地址和端口绑定。</td>
</tr>
<tr>
<td></td>
<td>udp_connect</td>
<td>建立 UDP PCB 远程 IP 地址和端口。</td>
</tr>
<tr>
<td></td>
<td>udp_disconnect</td>
<td>移除 UDP PCB 远程 IP 和端口。</td>
</tr>
<tr>
<td></td>
<td>udp_send</td>
<td>发送 UDP 数据</td>
</tr>
<tr>
<td></td>
<td>udp_recv</td>
<td>注册回调函数，当收到新数据报时即对其调用。</td>
</tr>
</tbody></table>
<h2 id="Netconn-API"><a href="#Netconn-API" class="headerlink" title="Netconn API"></a>Netconn API</h2><p>Netconn API 为高层有序 API，其执行模型基于典型的阻塞式打开 - 读 - 写 - 关闭机制。 若要正常工作，此 API 必须处于多线程工作模式，该模式需为 LwIP TCP/IP 栈实现专用线程， 并 / 或为应用实现多个线程。</p>
<p>基于操作系统的IPC机制（即信号量和邮箱机制）实现的，将LWIP内核代码和网络应用程序分离成了独立的线程，因此LWIP内核线程就只负责数据包的TCP/IP封装和拆封，而不用进行数据的应用层处理，大大提高了系统对网络数据包的处理效率</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>netconn_new</td>
<td>创建一个新连接。</td>
</tr>
<tr>
<td>netconn_delete</td>
<td>删除一个已有连接。</td>
</tr>
<tr>
<td>netconn_bind</td>
<td>将连接绑定到本地 IP 地址和端口。</td>
</tr>
<tr>
<td>netconn_connect</td>
<td>连接远程 IP 地址和端口。</td>
</tr>
<tr>
<td>netconn_send</td>
<td>通过 UDP 发送数据。</td>
</tr>
<tr>
<td>netconn_recv</td>
<td>接收数据。</td>
</tr>
<tr>
<td>netconn_listen</td>
<td>置 TCP netconn 处于监听模式。</td>
</tr>
<tr>
<td>netconn_accept</td>
<td>接受正在监听状态的 TCP 连接上的传入连接。</td>
</tr>
<tr>
<td>netconn_write</td>
<td>通过 TCP 数据 （将数据写入 TCP 缓冲区）。</td>
</tr>
<tr>
<td>netconn_close</td>
<td>主动关闭 TCP netconn。</td>
</tr>
</tbody></table>
<h2 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h2><p>了标准 BSD 套接字 API。它是有序 API，在内部构建于 Netconn API 之上，对网络连接进行了高级的抽象，使得用户可以像操作文件一样操作网络连接	</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>socket</td>
<td>创建一个新套接字。</td>
</tr>
<tr>
<td>bind</td>
<td>将套接字绑定到 IP 地址和端口。</td>
</tr>
<tr>
<td>listen</td>
<td>监听套接字连接。</td>
</tr>
<tr>
<td>connect</td>
<td>将套接字连接到远程主机 IP 地址和端口。</td>
</tr>
<tr>
<td>accept</td>
<td>在套接字上接受新连接。</td>
</tr>
<tr>
<td>read</td>
<td>从套接字读取数据。</td>
</tr>
<tr>
<td>write</td>
<td>向套接字写入数据。</td>
</tr>
<tr>
<td>close</td>
<td>关闭套接字 （删除套接字）。</td>
</tr>
</tbody></table>
<h1 id="LwIP配置"><a href="#LwIP配置" class="headerlink" title="LwIP配置"></a>LwIP配置</h1><p>lwipopts.h 文件允许用户充分配置栈及其所有模块。用户不需要定义 所有 LwIP 选项：如果未定义某选项，则使用 opt.h 文件中定义的默认值。因此， lwipopts.h 提供了覆盖许多 lwIP 行为的方法。</p>
<table>
<thead>
<tr>
<th><strong>Lwip 内存选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MEM_SIZE</td>
<td>LwIP 堆内存大小：用于所有 LwIP 动态内存分配</td>
</tr>
<tr>
<td>MEMP_NUM_PBUF</td>
<td>MEM_REF 和 MEM_ROM pbuf 总数</td>
</tr>
<tr>
<td>MEMP_NUM_UDP_PCB</td>
<td>UDP PCB 结构体的总数</td>
</tr>
<tr>
<td>MEMP_NUM_TCP_PCB</td>
<td>TCP PCB 结构体的总数</td>
</tr>
<tr>
<td>MEMP_NUM_TCP_PCB_LISTEN</td>
<td>处于监听状态的 TCP PCB 总数</td>
</tr>
<tr>
<td>MEMP_NUM_TCP_SEG</td>
<td>最多同时在 TCP 缓冲队列中的报文段数量</td>
</tr>
<tr>
<td>PBUF_POOL_SIZE</td>
<td>PBUF_POOL 类型的 pbuf 总数</td>
</tr>
<tr>
<td>PBUF_POOL_BUFSIZE</td>
<td>PBUF_POOL 类型 pbuf 的大小</td>
</tr>
<tr>
<td>TCP_MSS</td>
<td>最大 TCP 报文段 （MTU - IP 报头大小 - TCP 报头大小）</td>
</tr>
<tr>
<td>TCP_SND_BUF</td>
<td>对于一个连接， TCP 的发送缓冲空间</td>
</tr>
<tr>
<td>TCP_SND_QUEUELEN</td>
<td>TCP 发送队列中 pbuf 的最大数</td>
</tr>
<tr>
<td>TCP_WND</td>
<td>TCP 接收窗大小</td>
</tr>
</tbody></table>
<h1 id="LwIP内存管理"><a href="#LwIP内存管理" class="headerlink" title="LwIP内存管理"></a>LwIP内存管理</h1><p>LwIP有两种内存管理方式：内存池、内存堆</p>
<p>参考链接：<a href="https://blog.csdn.net/jiangjunjie_2005/article/details/26051399#t9">https://blog.csdn.net/jiangjunjie_2005/article/details/26051399#t9</a></p>
<h1 id="实现TCP服务器"><a href="#实现TCP服务器" class="headerlink" title="实现TCP服务器"></a>实现TCP服务器</h1><blockquote>
<p>echoserver实现：<a href="https://github.com/yangLieee/codebackup/tree/master/iperf">https://github.com/yangLieee/codebackup/tree/master/iperf</a></p>
</blockquote>
<ol>
<li><p>新建控制块 </p>
<p>使用tcp_new()函数建立一个TCP控制块。</p>
</li>
<li><p>绑定控制块</p>
<p>对于服务器来说，新建一个控制快后，需要在控制块上绑定本地IP和端口，以方便客户端的连接。</p>
</li>
<li><p>控制块侦听</p>
<p>使用tcp_listen函数，对于服务器来说，需要显性调用tcp_listen函数以使控制块进入监听状态，等待客户端的连接请求。</p>
</li>
<li><p>建立连接</p>
<p>在tcp_listen函数进入服务器监听状态后，需要马上使用tcp_accept函数来注册一个接收处理函数，因为一旦有客户端连接请求被成功建立后，服务器就会调用这个处理函数。</p>
</li>
<li><p>接受并处理数据</p>
<p>一旦连接成功，accept回调函数会调用tcp_recv函数注册一个接收完成的处理函数。对于服务器来说，接收到了客户端的数据或操作要求，就会调用这一回调函数进行处理。这其实是一个复杂的过程：接收到数据后，首先通知更新接受窗口（使用tcp_recved函数），处理并发送数据（使用tcp_write函数），数据发送成功则清除已发送的数据（使用tcp_sent函数），最后关闭连接（使用函数tcp_close）。</p>
</li>
</ol>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>Q：<a href="https://blog.csdn.net/tanmx219/article/details/105930028">tcp_recvd正确调用方法</a>？</p>
<p>A：很多源码是在tcp_server_sent发送函数中调tcp_recvd，如果用户不是用来echo（立即发回相同的报文），而是真正要处理事务的时候，这种用法是错误的：此时，接收窗口大小由发送窗口决定，如果没有发送新数据，接收窗口就会越来越小，直到最后无法接收数据。<strong>正确的用法是：在收到数据后，应用层调用tcp_recved函数恢复原来的窗口大小；而在发送函数中，不用管窗口的事！</strong></p>
</li>
<li><p>Q：调用lwip iperf接口，无法关闭server?</p>
<p>A：lwip iperf只是实现当client断开连接删除掉其相关pcb结构体，而没有断开tcp连接没有释放监听端口，仿照lwiperf_tcp_close函数实现一个新的针对server关闭的接口即可</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.kancloud.cn/jiejietop/tcpip/988613">LwIP应用开发指南</a></li>
<li><a href="https://blog.csdn.net/weixin_54217950/article/details/121344759">网络基础之协议栈</a></li>
<li><a href="https://www.st.com/resource/zh/user_manual/um1713-developing-applications-on-stm32cube-with-lwip-tcpip-stack-stmicroelectronics.pdf">使用 LwIP TCP/IP 栈在 STM32Cube 上开发应用</a></li>
<li><a href="https://blog.51cto.com/u_15262460/2883223">LwIP使用经验</a></li>
<li><a href="https://blog.csdn.net/zhzht19861011/article/details/125322654">TCP回调函数是何时调用的</a></li>
<li><a href="https://blog.csdn.net/zhzht19861011/article/details/125278742">协议栈什么情况下发送 RST 标志</a></li>
</ol>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>ThirdParty</category>
      </categories>
      <tags>
        <tag>lwip</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite</title>
    <url>/2023/04/11/SoftwareDevelopment/ThirdParty/sqlite3/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>sqlite中文网站：<a href="https://www.sqlite.net.cn/">https://www.sqlite.net.cn/</a></p>
</blockquote>
<p>SQLite是一种C语言库，它实现了一个&nbsp;小型、快速、自包含、高可靠性，&nbsp;功能齐全的SQL数据库引擎。SQLite是世界上最常用的数据库引擎，广泛应用于嵌入式领域。</p>
<p>与大多数其他SQL数据库不同，SQLite没有单独的服务器进程。SQLite直接读取和写入普通磁盘文件。具有多个表，索引，触发器和视图的完整SQL数据库包含在单个磁盘文件中。</p>
<h1 id="Shell命令"><a href="#Shell命令" class="headerlink" title="Shell命令"></a>Shell命令</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建数据库</span></span><br><span class="line"># sqlite3 test.db</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据库</span></span><br><span class="line"># .database</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建表格</span></span><br><span class="line"># CREATE TABLE <span class="title function_">user</span><span class="params">(Id integer PRIMARY KEY, name text)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询表格</span></span><br><span class="line"># .tables</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">#  INSERT INTO user <span class="title function_">VALUES</span><span class="params">(<span class="number">1</span>, <span class="string">'小张'</span>)</span>;</span><br><span class="line">#  INSERT INTO user <span class="title function_">VALUES</span><span class="params">(<span class="number">2</span>, <span class="string">'小陈'</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据(一定要有分号)</span></span><br><span class="line"><span class="meta"># select * from user;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出命令行环境</span></span><br><span class="line"># .quit / .<span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示数据库结构</span></span><br><span class="line"># .schema</span><br></pre></td></tr></tbody></table></figure>

<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>约束就是用来进一步描述每一列数据属性的。</p>
<h2 id="非空-NOT-NULL"><a href="#非空-NOT-NULL" class="headerlink" title="非空 NOT NULL"></a>非空 NOT NULL</h2><p>有一些字段我们可能一时不知到该填些什么，同时它也没设定默认值， 当添加数据时，我们把这样的字段空着不填，系统认为他是 NULL 值。但是还有另外一类字段，必须被填上数据，如果不填，系统就会报错。 这样的字段被称为 NOT NULL 非空字段,需要在定义表的时候事先声明。</p>
<h2 id="唯一-UNIQUE"><a href="#唯一-UNIQUE" class="headerlink" title="唯一 UNIQUE"></a>唯一 UNIQUE</h2><p>除了主列以外，还有一些列也不能有重复值。</p>
<h2 id="主键-PRIMARY-KEY"><a href="#主键-PRIMARY-KEY" class="headerlink" title="主键 PRIMARY KEY"></a>主键 PRIMARY KEY</h2><p>一般是整数或者字符串，只要保证唯一就行。 在 SQLite 中，主键如果是整数类型，该列的值可以自动增长。</p>
<h2 id="外键-FOREIGN-KEY"><a href="#外键-FOREIGN-KEY" class="headerlink" title="外键 FOREIGN KEY"></a>外键 FOREIGN KEY</h2><p>我们的数据库中已经有 Teachers 表了，假如我们再建立一个 Students 表， 要求 Students 表中的每一个学生都对应一个 Teachers 表中的教师。 很简单，只需要在 Students 表中建立一个 TeacherId 字段，保存对应教师的 Id 号， 这样，学生和教师之间就建立了关系。 问题是：我们有可能给学生存入一个不在 Teachers 表中的 TeacherId 值， 而且发现不了这个错误。 这种情况下，可以把 Students 表中 TeacherId 字段声明为一个外键， 让它的值对应到 Teachers 表中的 Id 字段上。 这样，一旦在 Students 表中存入一个不存在的教师 Id ，系统就会报错。</p>
<h2 id="默认值-DEFAULT"><a href="#默认值-DEFAULT" class="headerlink" title="默认值 DEFAULT"></a>默认值 DEFAULT</h2><p>有一些特别的字段列，在每一条记录中，他的值基本上都是一样的。只是在个别情况下才改为别的值，这样的字段列我们可以给他设一个默认值。</p>
<h2 id="条件检查-CHECK"><a href="#条件检查-CHECK" class="headerlink" title="条件检查 CHECK"></a>条件检查 CHECK</h2><p>某些值必须符合一定的条件才允许存入，这是就需要用到这个 CHECK 约束。</p>
<h1 id="VFS在linux下架构图"><a href="#VFS在linux下架构图" class="headerlink" title="VFS在linux下架构图"></a>VFS在linux下架构图</h1><p>Linux系统的User使用GLIBC（POSIX标准、GUN C运行时库）作为应用程序的运行时库，然后通过操作系统，将其转换为系统调用SCI（system-call interface），SCI是操作系统内核定义的系统调用接口，这层抽象允许用户程序的I/O操作转换为内核的接口调用。VFS提供了一个抽象层，将POSIX API接口与不同存储设备的具体接口实现进行了分离，使得底层的文件系统类型、设备类型对上层应用程序透明。</p>
<p><img src="/images/SoftwareDevelopment/ThirdParty/sqlite.png" alt="在这里插入图片描述"></p>
<h1 id="sqlite3-vfs"><a href="#sqlite3-vfs" class="headerlink" title="sqlite3 vfs"></a>sqlite3 vfs</h1><p>API：<a href="https://www.sqlite.net.cn/cintro.html">https://www.sqlite.net.cn/cintro.html</a></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 注册一个VFS系统，支持多个创建通过第二个参数使能</span></span><br><span class="line"># sqlite3_vfs_register(sqlite3_vfs *pVfs, <span class="type">int</span> makeDflt)</span><br><span class="line"><span class="comment">// 使用demo vfs替换默认的vfs</span></span><br><span class="line"># sqlite3_open_v2(<span class="string">"demo.db"</span>, &amp;db, SQLITE_OPEN_READWRITE, <span class="string">"demo"</span>);</span><br></pre></td></tr></tbody></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.51cto.com/u_15169172/2710683">一文搞懂嵌入式数据库sqlite3</a></p>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>ThirdParty</category>
      </categories>
  </entry>
  <entry>
    <title>Wpa_supplicant &amp; Hostapd</title>
    <url>/2024/01/13/SoftwareDevelopment/ThirdParty/wpa_supplicant/</url>
    <content><![CDATA[<h1 id="WIFI基础"><a href="#WIFI基础" class="headerlink" title="WIFI基础"></a>WIFI基础</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a><a href="https://www.freecodecamp.org/chinese/news/osi-model-networking-layers/">OSI七层模型</a></h2><blockquote>
<p><em>请不要把暗号告诉任何人（Please Do Not Tell the Secret Password to Anyone）。</em></p>
</blockquote>
<ul>
<li>Application Layer（应用层）。应用层能与应用程序界面沟通以达到向用户展示的目的。常见的协议有HTTP、HTTPS、FTP、SMTP等。其数据单位为APDU（Application Protocol Data Unit）。</li>
<li>Presentation Layer（表示层）。表示层能为不同客户端提供数据和信息的语法转换，使系统能解读成正确的数据，同时它还能提供压缩解压、加密解密等服务。例如不同格式图像（如GIF、JPEG、TIFF等）的显示就是由位于表示层的协议来支持的。其数据单位为PPDU（Presentation Protocol Data Unit）。</li>
<li>Session Layer（会话层）。会话层用于为通信双方制定通信方式，创建和注销会话（双方通信）等。其数据单位为-SPDU（Session Protocol Data Unit）。常见的协议有ZIP、AppleTalk、SCP等。</li>
<li>Transport Layer（传输层）。传输层用于控制数据流量，同时能进行调试及错误处理，以确保通信顺利。发送端的传输层会为数据分组加上序号，以方便接收端把分组重组为有用的数据或文件。传输层的常见协议有TCP、UDP等。于 TCP 而言，数据单元是<code>数据包</code>。对于 UDP 而言，包被称为<code>数据报（datagram）</code></li>
<li>Network Layer（网络层）。网络层为数据传送的目的地寻址，然后再选择一个传送数据的最佳路线。网络层数据的单位为Packet或Datagram。常见的设备有路由器等。常见协议有IP、IPv6。第三层的数据单元是&nbsp;<code>数据包（data packet）/负载（payload）</code>。通常，每个数据包都包含一个帧&nbsp;<strong>加上</strong>&nbsp;一个 IP 地址信息的包装。换句话说，帧被第三层的地址信息封装了。</li>
<li>Data Link Layer（数据链路层）。在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。通过差错控制提供数据帧（Frame）在信道上无差错的传输。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。数据链路层数据的单位为<code>Frame（帧）</code>。常见的设备有二层交换机、网桥等。<ul>
<li><strong>介质访问控制（MAC，Media Access Control）。</strong>MAC 子层负责分配硬件标识号，这个标识号被称为 MAC 地址，它能够唯一标识网络上的各个设备。两个设备不应该有相同的 MAC 地址。MAC 地址在硬件制造时就分配好了，位于网卡当中，大多数网络都会自动对其进行识别。交换机会跟踪网络上所有的 MAC 地址。在<a href="https://www.pcmag.com/encyclopedia/term/mac-address">这里</a>和<a href="https://people.richland.edu/dkirby/141macaddress.htm">这里</a>了解更多有关 MAC 地址的信息，在<a href="https://www.networkworld.com/article/3584876/what-is-a-network-switch-and-how-does-it-work.html">这里</a>进一步了解网络交换机。</li>
<li><strong>逻辑链路控制（LLC，Logical Link Control）。</strong>&nbsp;LLC 子层处理帧的寻址以及流量控制。速度取决于两个节点之间的链路，例如以太网或 Wifi。</li>
</ul>
</li>
<li>Physical Layer（物理层）。物理层定义了通信设备机械、电气、功能和过程等方面的特性，用以建立、维护和拆除物理链路连接。物理层数据的单位为<code>bit</code>。</li>
</ul>
<h1 id="STA模式"><a href="#STA模式" class="headerlink" title="STA模式"></a>STA模式</h1><p>STA客户端模式用到了wpa_supplicant和轻量级的udhcpd客户端</p>
<h2 id="wpa-supplicant介绍"><a href="#wpa-supplicant介绍" class="headerlink" title="wpa_supplicant介绍"></a><strong>wpa_supplicant</strong>介绍</h2><p><a href="https://wiki.archlinux.org/title/wpa_supplicant">wpa_supplicant - ArchWiki</a></p>
<p><a href="https://hostap.epitest.fi/wpa_supplicant/devel/index.html">wpa_supplicant: Developers’ documentation for wpa_supplicant</a></p>
<p>WPA代表Wi-Fi Protected Access（Wi-Fi受保护访问），是一种用于无线网络的安全协议。它的目的是提供比WEP（Wired Equivalent Privacy，有线等效隐私）更强大的安全性，以保护无线网络免受未经授权的访问和数据截取。</p>
<p>wpa_supplicant是一个用于实现 WPA（Wi-Fi Protected Access）和 WPA2（Wi-Fi Protected Access 2）协议的开源软件客户端。它的主要功能是处理 Wi-Fi 网络的扫描、关联、认证和加密等任务，使得计算机或设备能够安全地连接到受保护的 Wi-Fi 网络。</p>
<p>wpa_supplicant是一个 独立运行的 守护进程，其核心是一个消息循环，在消息循环中处理WPA状态机、控制命令、驱动事件、配置信息等。经过编译后 的 wpa_supplicant源程序可以看到两个主要的可执行工具：wpa_supplicant 和 wpa_cli。wpa_supplicant是核心程序，它和wpa_cli的关系就是服务和客户端的关系：后台运行wpa_supplicant，使用 wpa_cli来搜索、设置、和连接网络。</p>
<h2 id="WPA命令行参数"><a href="#WPA命令行参数" class="headerlink" title="WPA命令行参数"></a>WPA命令行参数</h2><blockquote>
<p>使用WPAS和WPSC的命令之前，可以通过ifconfig命令查看wlan驱动是否成功加载，wlan成功加载是必要的前提</p>
</blockquote>
<ol>
<li><p>启动WPAS</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">/usr/sbin/wpa_supplicant -Dnl80211 -iwlan0 -c/usr/resource/wpa_supplicant.conf -B -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># -D : driver 可选指定的驱动程序，nl80211是当前的标准，但并非所有无线芯片的模块都支持它；</span></span><br><span class="line"><span class="comment"># -i ：interface 网络接口名称 wlan0</span></span><br><span class="line"><span class="comment"># -c : configure files 读取配置文件/etc/wpa_supplicant.conf </span></span><br><span class="line"><span class="comment"># -B : background 后台执行</span></span><br><span class="line"><span class="comment"># -d : debug 调试信息</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><a href="https://man.archlinux.org/man/wpa_cli.8">wpa_cli常用参数含义</a></p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -p:  path, Change the path where control sockets should be found,更改应找到控制套接字的路径。</span></span><br><span class="line"><span class="comment"># -i:  ifname, Specify the interface that is being configured. By default, choose the first interface found with a control socket in the socket path</span></span><br><span class="line"><span class="comment">#         指定正在配置的接口。 默认情况下，选择在套接字路径中找到的第一个带有控制套接字的接口</span></span><br><span class="line"><span class="comment"># -B： Run as a daemon in the background，在后台作为守护进程运行。</span></span><br><span class="line"><span class="comment"># command ：运行命令，包括：status、scan、scan_result等等命令</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>搜索附近网络（显示OK/NO）</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 使用默认参数</span></span><br><span class="line">$ wpa_cli scan </span><br><span class="line"><span class="comment"># 指定参数</span></span><br><span class="line">$ wpa_cli scan -i wlan0 -p /var/run/wpa_supplicant</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>搜索附近网络,并列出结果</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wpa_cli scan_results</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>查看当前设备已连接的网络配置列表</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wpa_cli list_networks</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>连接网络（wpa_supplicant.conf配置文件没有配置，即首次连接）</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 获取一个存储wifi结构的ID (基于wpa_supplicant.conf配置递增)，ID值将以返回值或者打印的形式显示</span></span><br><span class="line">$ wpa_cli -i wlan0 add_network</span><br><span class="line"><span class="comment"># 设置ID=2的热点的SSID</span></span><br><span class="line">$ wpa_cli -i wlan0 set_network 2 ssid <span class="string">'"Jz_Staff"'</span></span><br><span class="line"><span class="comment"># 设置ID=2的热点的PSK</span></span><br><span class="line">$ wpa_cli -i wlan0 set_network 2 psk <span class="string">'"mAkEZnZWPk"'</span></span><br><span class="line"><span class="comment"># 启动ID=2的网络</span></span><br><span class="line">$ wpa_cli -i wlan0 enable_network 2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置网络信息（选填项）</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 基于以上连接信息，设置ID=2的热点的加密方式</span></span><br><span class="line">$ wpa_cli -i wlan0 set_network 2 key_mgmt WPA2-PSK</span><br><span class="line">$ wpa_cli -i wlan0 set_network 0 key_mgmt SAE</span><br><span class="line"><span class="comment">#设置ID=2的网络优先级,默认为2</span></span><br><span class="line">wpa_cli -i wlan0 set_network 2 priority 2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>获取当前网络状态</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wpa_cli status</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>保存刚刚填写的wifi账号密码</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wpa_cli -i wlan0 save_config</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>将ID=2的网络断开</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wpa_cli -i wlan0 disable_network 2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>将ID=2的网络移除，移除的前提一定是该网络需要断开（DISABLE）</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wpa_cli -i wlan0 remove_network 2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>切换使用ID=2的网络</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wpa_cli -i wlan0 select_network 2</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>断开/重启网络连接</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ wpa_cli -i wlan0 disconnect</span><br><span class="line">$ wpa_cli -i wlan0 reconnect</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="WPA配置文件"><a href="#WPA配置文件" class="headerlink" title="WPA配置文件"></a>WPA配置文件</h2><p>文件名称：wpa_supplicant.conf<br>该配置文件用于指定 Wi-Fi 网络的连接参数、安全设置和其他相关配置。同时包含了连接到一个或多个 Wi-Fi 网络所需的信息，wpa_supplicant 在启动时会读取这个文件，并根据其中的配置信息进行相应的连接。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 指定本地socket路径，用于wpa_cli与wpas的通信</span></span><br><span class="line">ctrl_interface=/var/run/wpa_supplicant</span><br><span class="line"><span class="comment"># 这个配置项通常用于确定是否要将成功连接到的网络的配置信息写入到配置文件中。如果网络连接成功，会把信息写入该文件</span></span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network={</span><br><span class="line">				<span class="comment"># ssid ： 指定无线网络的服务集标识符（SSID），是网络的名称。</span></span><br><span class="line">        ssid=<span class="string">"xiaomiCivi"</span></span><br><span class="line">				<span class="comment"># 表示允许扫描隐藏的网络。当设置为1时，wpa_supplicant 会尝试主动发起对隐藏网络的扫描，并连接到匹配的隐藏网络</span></span><br><span class="line">        scan_ssid=1</span><br><span class="line">				<span class="comment"># 密码</span></span><br><span class="line">        psk=<span class="string">"12345678"</span></span><br><span class="line">				<span class="comment"># 通过配置网络块的优先级，影响最终要连接的网络</span></span><br><span class="line">        priority=1</span><br><span class="line">				<span class="comment"># 指定使用的密钥管理方式，例如 WPA-PSK（预共享密钥）或 WPA-EAP（扩展认证协议）。</span></span><br><span class="line">				key_mgmt=WPA-PSK</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="AP模式"><a href="#AP模式" class="headerlink" title="AP模式"></a>AP模式</h1><p>AP热点模式使用到了hostapd和轻量级的udhcpd服务端</p>
<h2 id="Hostapd介绍"><a href="#Hostapd介绍" class="headerlink" title="Hostapd介绍"></a>Hostapd介绍</h2><p><a href="https://wireless.wiki.kernel.org/en/users/documentation/hostapd">en:users:documentation:hostapd [Linux Wireless]</a></p>
<p><a href="https://hostap.epitest.fi/hostapd/">hostapd: IEEE 802.11 AP, IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator</a></p>
<ol>
<li>hostapd 是一种用于无线局域网（WLAN）访问点的软件，可通过 Linux 系统将一台计算机转化为 WLAN 的访问点。</li>
<li>特点<ol>
<li><strong>WLAN访问点（WLAN Access Point）</strong>：hostapd 允许将一台计算机配置为无线局域网访问点，以便允许其他无线设备（如手机、笔记本电脑）连接到计算机并访问网络资源。</li>
<li><strong>支持多种认证协议：</strong> hostapd 支持多种认证协议，包括WPA（Wi-Fi Protected Access）和WPA2，以提供更高级别的无线网络安全性。</li>
<li><strong>支持多种加密算法：</strong> 它支持多种加密算法，如WEP（Wired Equivalent Privacy）、TKIP（Temporal Key Integrity Protocol）和CCMP（Counter Cipher Mode with Block Chaining Message Authentication Code Protocol），提供灵活的加密选项。</li>
<li><strong>支持802.1X认证：</strong> hostapd 支持使用IEEE 802.1X认证协议，这是一种提供对网络用户进行身份验证的标准化方法。</li>
<li><strong>灵活的配置选项：</strong> 用户可以通过配置文件对 hostapd 进行灵活的设置，以满足特定网络环境和需求。</li>
<li><strong>实时监控和日志记录：</strong> hostapd 提供实时监控功能，可以记录无线客户端的连接和断开情况，同时生成详细的系统日志以便故障排查和性能监测</li>
</ol>
</li>
</ol>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote>
<p>配置说明</p>
<p><a href="https://wireless.wiki.kernel.org/en/users/documentation/hostapd#wireless_interface">en:users:documentation:hostapd [Linux Wireless]</a></p>
</blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 告诉hostapd 使用什么无线接口</span></span><br><span class="line">interface=wlan0</span><br><span class="line"><span class="comment"># 使用hostapd_cli的命令需要指定这个控制接口</span></span><br><span class="line">ctrl_interface=/var/run/hostapd</span><br><span class="line"><span class="comment"># 驱动程序的选择，始终是nl80211</span></span><br><span class="line">driver=nl80211</span><br><span class="line"><span class="comment"># 设置网络接口名称(SSID = service set identifier)</span></span><br><span class="line">ssid=MyNetwork</span><br><span class="line"><span class="comment"># 设置接口的工作模式和允许的通道。有效值取决于硬件，但始终是 a（5G频段）、b（2.4G）、g(2.4G) 的子集。</span></span><br><span class="line">hw_mode=g</span><br><span class="line"><span class="comment"># 设置hostapd 操作的通道。必须是 hw_mode 中设置的模式支持的通道，以及您所在国家/地区的无线监管规则允许的通道。</span></span><br><span class="line">channel=1</span><br><span class="line"><span class="comment"># 控制 MAC 地址过滤。MAC 地址很容易被欺骗，因此仅考虑使用它来增强您现有的其他安全措施。</span></span><br><span class="line">macaddr_acl=0</span><br><span class="line"><span class="comment"># 身份验证算法，位字段。1=用于开放身份验证，2=用于共享密钥身份验证 (WEP)，3=两者</span></span><br><span class="line">auth_algs=1</span><br><span class="line"><span class="comment"># 是否广播，0 广播SSID，1 不广播SSID（发送空SSID，即长度为0的SSID），2 忽略广播 SSID 的探测请求，跟1类似，但是兼容某些不支持空SSID的设备</span></span><br><span class="line">ignore_broadcast_ssid=0</span><br><span class="line"><span class="comment"># 类似于auth_algs。1 wpa，2 wpa2, 3 两者。 新的设备可以设置为2，仅使用wpa2版本。</span></span><br><span class="line">wpa=3</span><br><span class="line"><span class="comment"># 确定用于 WPA 身份验证的预共享密钥</span></span><br><span class="line">wpa_passphrase=YourPassPhrase</span><br><span class="line"><span class="comment"># 控制客户端可以使用哪些密钥管理算法进行身份验证</span></span><br><span class="line">wpa_key_mgmt=WPA-PSK</span><br><span class="line"><span class="comment"># 设置加密算法，CCMP就是AES，不推荐使用TKIP，除非设备不支持。wpa控制 WPA 的数据加密，rsn控制 WPA2 的数据加密。</span></span><br><span class="line">wpa_pairwise=TKIP</span><br><span class="line">rsn_pairwise=CCMP</span><br></pre></td></tr></tbody></table></figure>

<h2 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h2><ol>
<li><p>启动hostapd server</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hostapd /etc/hostapd.conf -B -d</span><br><span class="line"></span><br><span class="line">-h   显示帮助信息</span><br><span class="line">-d   显示更多的debug信息 (-<span class="built_in">dd</span> 获取更多)</span><br><span class="line">-B   将hostapd程序运行在后台</span><br><span class="line">-g   全局控制接口路径，这个工hostapd_cli使用，一般为/var/run/hostapd</span><br><span class="line">-G   控制接口组</span><br><span class="line">-P   PID 文件</span><br><span class="line">-K   调试信息中包含关键数据</span><br><span class="line">-t   调试信息中包含时间戳</span><br><span class="line">-v   显示hostapd的版本</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>修改无线热点的名称</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hostapd_cli <span class="built_in">set</span> ssid myNetWorkAP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对端没有连接成功，reload不生效，新的SSID不显示; 对端连接成功，reload断开连接，但无法连接。</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>修改无线热点密码（reload生效）</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hostapd_cli <span class="built_in">set</span> wpa_passphrase 87654321</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置无线热点信道（reload不生效）</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hostapd_cli <span class="built_in">set</span> channel 11</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>隐藏无线热点（reload不生效）</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hostapd_cli <span class="built_in">set</span> ignore_broadcast_ssid 1</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>显示接口状态信息，包括接入点命令，当前连接客户端数量</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hostapd_cli status</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>显示当前配置信息</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hostapd_cli get_config</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p><code>**注意事项**</code></p>
<ol>
<li><p>使用 set 命令进行修改时，修改的内容是对应的内存里变量的内容，并不是修改 hostapd 配置文件的内容，因此在使用 set 命令完成所有的配置修改后，需要使用 reload 命令将这些配置重新加载。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hostapd_cli reload</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>有些配置内容即使按照 set 、reload 配置后，也是无法更新的。此时需要再 set 命令配置完成后，先使用 disable 命令，再使用 enable ，从而实现配置更新。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 禁用hostapd</span></span><br><span class="line">$ hostapd_cli <span class="built_in">disable</span></span><br><span class="line"><span class="comment">#启用hostapd</span></span><br><span class="line">$ hostapd_cli <span class="built_in">enable</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="启动AP流程"><a href="#启动AP流程" class="headerlink" title="启动AP流程"></a>启动AP流程</h2><ol>
<li><p>启动hostapd server</p>
</li>
<li><p>为wlan0分配IP地址，默认为网关地址（可省略，直接使用udhcpd加 -I 参数）</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ifconfig wlan0 192.168.1.1</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>启动udhcpd服务</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">udhcpd /etc/udhcpd.conf &amp;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h1><h2 id="udhcp"><a href="#udhcp" class="headerlink" title="udhcp"></a>udhcp</h2><blockquote>
<p>官网</p>
<p><a href="https://udhcp.busybox.net/">udhcp Server/Client Package</a></p>
</blockquote>
<p>u 可能是 “micro” 的缩写，表示 “微型”。udhcp 是一个小型 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）客户端和服务器的工具集。这个工具集包括 udhcpc 客户端和 udhcpd 服务器(d 通常表示 “daemon”，指的是守护进程)。udhcpc是用来获取IP地址的，而udhcpd则是用来为设备分配IP地址的。如果使用的是静态IP则不需DHCP服务的。</p>
<h3 id="udhcpd"><a href="#udhcpd" class="headerlink" title="udhcpd"></a>udhcpd</h3><ul>
<li><p>配置文件：udhcpd.conf</p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># IP租用块的开始和结束</span></span><br><span class="line">start 192.168.0.150   <span class="comment">#default: 192.168.0.20</span></span><br><span class="line">end 192.168.0.240     <span class="comment">#default: 192.168.0.254</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># udhcpd使用的接口</span></span><br><span class="line">interface wlan0       <span class="comment">#default: eth0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大租约数（包括 OFFER、DECLINE 和 ARP 冲突保留的地址）</span></span><br><span class="line">max_leases  21      <span class="comment">#default: 254</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其它DHCP选项</span></span><br><span class="line">opt dns 116.116.116.116</span><br><span class="line">option  subnet  255.255.255.0</span><br><span class="line">opt router  192.168.0.1</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>功能：</p>
<ul>
<li><strong>IP地址分配：</strong> 提供动态分配 IP 地址的功能。当设备首次连接到网络时，udhcpd 可以为其分配一个可用的IP地址。</li>
<li><strong>子网掩码分配：</strong> 配置子网掩码，定义设备在网络上的地址范围。</li>
<li><strong>默认网关分配：</strong> 分配默认网关的IP地址，允许设备访问其他网络。</li>
<li><strong>DNS服务器分配：</strong> 提供DNS服务器的IP地址，用于域名解析。</li>
<li><strong>租约管理：</strong> 管理IP地址的租约，包括租约的分配、更新和释放。</li>
</ul>
</li>
<li><p>启动udhcpd进程</p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 执行下面命令自动在对应的目录下生成一个内容为该进程pid的文件，默认/var/run/udhcpd.pid</span></span><br><span class="line">udhcpd /etc/udhcpd.conf -I [addr]</span><br><span class="line"></span><br><span class="line"><span class="comment"># -f   在前台运行</span></span><br><span class="line"><span class="comment"># -S   也记录到系统日志</span></span><br><span class="line"><span class="comment"># -I   本地地址，如果已经使用ifconfig工具配置了addrsess，就不需要这个悬念</span></span><br><span class="line"><span class="comment"># -a   ARP ping 的 MSEC 超时 (默认 2000)</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="udhcpc"><a href="#udhcpc" class="headerlink" title="udhcpc"></a>udhcpc</h3><p>udhcpc 是一个用于从 DHCP 服务器获取 IP 地址的小型 DHCP 客户端程序。通常，udhcpc 用于嵌入式系统或资源受限的环境，因为它相对轻量且占用资源少。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 获取DHCP地址</span></span><br><span class="line">$ udhcpc -i &lt;interface&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#-b: 在后台运行udhcpc，以守护进程的方式工作。</span></span><br><span class="line"><span class="comment">#-i  指定接口,默认eth0</span></span><br><span class="line"><span class="comment">#-t  设置 DHCP 超时时间，即等待 DHCP 服务器响应的最长时间。单位是秒。（默认3）</span></span><br><span class="line"><span class="comment">#-T  设置 DHCP 重试时间，即在未收到 DHCP 服务器响应时，客户端将尝试重新发送 DHCP 请求的时间间隔。单位是秒。（默认3）</span></span><br><span class="line"><span class="comment">#-R: 在关闭udhcpc时，可以向dhcpserver发送release取消租约。</span></span><br><span class="line"><span class="comment">#-H  选项用于指定客户端主机名（Hostname）。主机名是在网络中用于标识设备的名称。</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>-<strong>b</strong>: 后台执行udhcpc命令</li>
<li>-<strong>s</strong>: 指定脚本文件，在DHCP成功获取地址后执行该脚本文件</li>
<li>-<strong>H</strong>: 指定客户端主机名，会在DHCP消息中发送</li>
<li>-<strong>p</strong>: 指定pid文件，记录udhcpc进程的id</li>
<li>-<strong>t</strong>: 指定超时时间，单位为秒</li>
</ul>
<h2 id="netd"><a href="#netd" class="headerlink" title="netd"></a>netd</h2><p>Netd是Android系统中专门负责网络管理和控制的后台daemon程序。Netd位于Framework层和Kernel层之间，它是Android系统中网络相关消息和命令转发及处理的中枢模块。</p>
<ol>
<li>异步非阻塞：netd采用异步非阻塞的编程模型，这意味着它可以同时处理多个并发的网络连接，而无需为每个连接创建一个线程。这种模型可以极大地减少线程切换和资源消耗，提高应用程序的性能和可扩展性。</li>
<li>Reactor模式：netd使用Reactor模式来处理并发网络操作。它通过一个主事件循环来监听所有的网络事件，一旦有事件发生，就会通知相应的处理程序进行处理。这种事件驱动的模式可以更有效地管理并发连接和事件处理。</li>
<li>内存池：netd使用内存池来管理网络连接的内存分配和释放。通过预先分配一块连续的内存空间，可以避免频繁的内存申请和释放，提高内存的利用率和性能。</li>
<li>可扩展性：netd具有良好的可扩展性，可以根据应用程序的需求进行灵活的配置。它支持多线程的并发处理，可以通过增加线程数来提高处理能力。同时，它还支持基于事件的任务调度，可以将复杂的任务拆分为多个小任务，并根据情况动态地调整和分配资源。</li>
</ol>
<h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><p>ifconfig（接口配置）是一个网络管理工具，它用于配置和查看 Linux 操作系统中网络接口的状态，使用ifconfig，您可以分配 IP 地址、启用或禁用接口、管理 ARP 缓存、路由等。自从 Linux 内核版本 2.2 开始，推荐使用 <strong><code>ip</code></strong> 命令来替代 **<code>ifconfig</code>**，因为ip 命令提供了更强大和灵活的网络管理功能。</p>
<p>使用该ifconfig命令设置的配置<code>不是持久</code>的。系统重新启动后，所有更改都将丢失。要使更改永久生效，您需要编辑特定于发行版的配置文件或将命令添加到启动脚本。</p>
<ol>
<li><p>显示网络接口信息</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 输出包括有关所有活动和非活动网络接口的信息</span></span><br><span class="line">$ ifconfig -a</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>启用/禁用网络接口</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 启用接口，interface: eth0、wlan0等</span></span><br><span class="line">$ ifconfig &lt;interface&gt; up </span><br><span class="line"><span class="comment"># 禁用接口</span></span><br><span class="line">$ ifconfig &lt;interface&gt; down</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>设置IP地址和掩码</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 例：ifconfig eth0 192.168.0.101 netmask 255.255.0.0</span></span><br><span class="line">$ ifconfig &lt;interface&gt; [ip-address] netmask [subnet-mask]</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>更改网络接口的MTU</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># MTU “最大传输单元”允许您限制在接口上传输的数据包的大小。</span></span><br><span class="line">$ ifconfig &lt;interface&gt; mtu [mtu-value]</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>ip 命令是一个强大的网络工具，用于配置网络接口、路由表、策略路由等。</p>
<ol>
<li><p>查看网络接口信息</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ip address show</span><br><span class="line">$ ip a</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>启用/禁用网络接口</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> &lt;interface&gt; up    <span class="comment"># 启用接口</span></span><br><span class="line">$ ip <span class="built_in">link</span> <span class="built_in">set</span> &lt;interface&gt; down  <span class="comment"># 禁用接口</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>配置/删除IP地址</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ ip address add    &lt;ip_address/mask&gt; dev &lt;interface&gt;  <span class="comment"># 添加 IP 地址</span></span><br><span class="line">$ ip address delete &lt;ip_address/mask&gt; dev &lt;interface&gt;  <span class="comment"># 删除 IP 地址</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用详情：<a href="https://blog.51cto.com/u_11738327/3883798">click</a></p>
</li>
</ol>
<h2 id="iw"><a href="#iw" class="headerlink" title="iw"></a>iw</h2><p>iw 是一个全新的基于 nl80211 的用于配置无线设备的命令行界面（CLI）实用程序。它支持最近添加到内核中的所有新驱动程序。与已废弃的 iwconfig 工具相比，采用无线扩展接口的 iw 更为先进和强大。因此，我们强烈建议您切换到 iw 和 nl80211，以便更好地配置和管理您的无线设备。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># iw help    # 帮助</span></span><br><span class="line"><span class="comment"># iw list    # 获得所有设备的功能，如带宽信息（2.4GHz，和5GHz），和802.11n的信息</span></span><br><span class="line"><span class="comment"># iw dev wlan0 scan    # 扫描</span></span><br><span class="line"><span class="comment"># iw event    # 监听事件 </span></span><br><span class="line"><span class="comment"># iw dev wlan0 link    # 获得链路状态 </span></span><br><span class="line"><span class="comment"># iw wlan0 connect foo    # 连接到已禁用加密的AP，这里它的SSID是foo </span></span><br><span class="line"><span class="comment"># iw wlan0 connect foo 2432  # 假设你有两个AP SSID 都是 foo ，你知道你要连接的是在 2432 频道</span></span><br><span class="line"><span class="comment"># iw wlan0 connect foo keys 0:abcde d:1:0011223344    # 连接到使用WEP的AP</span></span><br><span class="line"><span class="comment"># iw dev wlan1 station dump    # 获取station 的统计信息</span></span><br><span class="line"><span class="comment"># iw dev wlan1 station get     # 获得station对应的peer统计信息</span></span><br><span class="line"><span class="comment"># iw dev wlan0 set power_save on  #设置省电模式</span></span><br><span class="line"><span class="comment"># iw dev wlan0 get power_save  #查询当前的节电设定</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li><p>使用wpa_cli执行scan命令出现 <code>Failed to connect to non-global ctrl_ifname: wlan0 error: No such file or directory</code>错误?<br> 可能是-p的参数指定socket的路径的时候出现错误，此时需要查看在wpa_supplicant.conf文件中ctrl_interface指定的socket路径是哪里</p>
</li>
<li><p>直接使用udhcpd可能出现一些错误，错误log以及解决方案如下</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># error, max_leases value (254) not sane, setting to 234 instead</span></span><br><span class="line">max_leases 字段的值设置不正确，改成234或者更小即可</span><br><span class="line"></span><br><span class="line"><span class="comment"># error, Unable to open /var/lib/misc/udhcpd.leases for reading</span></span><br><span class="line">系统中没有这个路径和文件。使用以下命令：***<span class="built_in">mkdir</span> -p /var/lib/misc/; <span class="built_in">touch</span> /var/lib/misc/udhcpd.leases***</span><br><span class="line"></span><br><span class="line"><span class="comment"># error, SIOCGIFADDR failed, is the interface up and configured?: No such device</span></span><br><span class="line">interface接口没有启动或者名称错误。可以使用ifconfig查看是否存在，不存在启动（ifconfig wlan0 up），并检查名字拼写</span><br><span class="line"></span><br><span class="line"><span class="comment"># udhcpd: is interface wlan0 up and configured?: Cannot assign requested address</span></span><br><span class="line">没有指定的地址，使用 ***udhcpd -I [addr]*** 或者 ***ifconfig wlan0 addr*** 命令指定</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.kancloud.cn/alex_wsc/android-wifi-nfc-gps/413626">第4章 深入理解wpa_supplicant · 深入理解Android：Wi-Fi、NFC和GPS卷（完整版） · 看云</a></p>
<p><a href="https://www.cnblogs.com/conscience-remain/p/17552340.html">linux下wifi的sta和ap操作 - 良知犹存 - 博客园</a></p>
<p><a href="https://www.cnblogs.com/cxt-janson/p/11542803.html">【转】wpa_supplicant和hostapd的定义和区别 - 陈晓涛 - 博客园</a></p>
]]></content>
      <categories>
        <category>SoftwareDevelopment</category>
        <category>ThirdParty</category>
      </categories>
  </entry>
</search>
